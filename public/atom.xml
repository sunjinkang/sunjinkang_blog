<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sun ...something</title>
  
  <subtitle>about what I have learned and some interesting things</subtitle>
  <link href="https://sunjinkang.github.io/atom.xml" rel="self"/>
  
  <link href="https://sunjinkang.github.io/"/>
  <updated>2022-07-19T09:39:22.172Z</updated>
  <id>https://sunjinkang.github.io/</id>
  
  <author>
    <name>Sun Jinkang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test-image</title>
    <link href="https://sunjinkang.github.io/2022/07/19/test-image/"/>
    <id>https://sunjinkang.github.io/2022/07/19/test-image/</id>
    <published>2022-07-19T09:39:22.000Z</published>
    <updated>2022-07-19T09:39:22.172Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>origin-type-and-reference-type</title>
    <link href="https://sunjinkang.github.io/2022/07/19/origin-type-and-reference-type/"/>
    <id>https://sunjinkang.github.io/2022/07/19/origin-type-and-reference-type/</id>
    <published>2022-07-19T08:23:28.000Z</published>
    <updated>2022-07-19T08:23:28.522Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>js-transform</title>
    <link href="https://sunjinkang.github.io/2022/07/19/js-transform/"/>
    <id>https://sunjinkang.github.io/2022/07/19/js-transform/</id>
    <published>2022-07-19T07:59:15.000Z</published>
    <updated>2022-07-21T07:46:18.785Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数学运算符中的类型转换"><a href="#数学运算符中的类型转换" class="headerlink" title="数学运算符中的类型转换"></a>数学运算符中的类型转换</h4><p>1、减、乘、除运算<br><strong>非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span> <span class="comment">// 0, true先转换乘1，然后执行 1 - 1</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">false</span> <span class="comment">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span> <span class="comment">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">undefined</span> <span class="comment">// NaN, undefined转换为数字为 NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">&#x27;5&#x27;</span>] <span class="comment">// 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5</span></span><br></pre></td></tr></table></figure><p>2、加运算<br><strong>js中的加法运算，还可以用来拼接字符串</strong></p><ul><li>加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型</li><li>加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li><li>加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接</li><li><em>以上三点，优先级从高到低</em>*</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">&#x27;123&#x27;</span> <span class="comment">// &#x27;123123&#x27; (规则1)</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span> <span class="comment">//  123 (规则2)</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span> <span class="comment">//  124 (规则2)</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;   <span class="comment">//  &#x27;123[object Object]&#x27; (规则3)</span></span><br></pre></td></tr></table></figure><h4 id="逻辑运算中的类型转换"><a href="#逻辑运算中的类型转换" class="headerlink" title="逻辑运算中的类型转换"></a>逻辑运算中的类型转换</h4><p>1、单个变量<br>先将变量转换为Boolean值<br><strong>只有null、undefined、’’、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]</strong></p><p>2、使用 == 比较中的5条规则<br><strong>建议使用 ===</strong></p><ul><li>规则1：NaN和其他任何类型比较永远返回false(包括和他自己)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">&#x27;2&#x27;</span> <span class="comment">// false,先将true转换为1，而不是把&#x27;2&#x27;变成true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>] <span class="comment">// true, 先将true转换为1，[&#x27;1&#x27;]拆箱成&#x27;1&#x27;,在参考规则3</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;2&#x27;</span>] <span class="comment">// false, 同上</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false, 首先false变成0，然后参考规则4</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false, 同上</span></span><br></pre></td></tr></table></figure></li><li>String和Number比较，先将String转换为Number类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">&#x27;123&#x27;</span> <span class="comment">// true, &#x27;123&#x27;会变成123</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true，&#x27;&#x27;会变成 0</span></span><br></pre></td></tr></table></figure></li><li>null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型</li><li><em>ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError</em>*<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class="comment">// true, 对象和字符串比较，对象通过toString 得到一个基本类型值</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// true, [1,2,3]通过toString得到一个基本类型</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类型转换表"><a href="#类型转换表" class="headerlink" title="类型转换表"></a>类型转换表</h4><p><img src="/2022/07/19/js-transform/convert-table.png" alt="类型转换对照表"></p><h4 id="类型转换对照网站"><a href="#类型转换对照网站" class="headerlink" title="类型转换对照网站"></a>类型转换对照网站</h4><p><a href="https://dorey.github.io/JavaScript-Equality-Table/">https://dorey.github.io/JavaScript-Equality-Table/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数学运算符中的类型转换&quot;&gt;&lt;a href=&quot;#数学运算符中的类型转换&quot; class=&quot;headerlink&quot; title=&quot;数学运算符中的类型转换&quot;&gt;&lt;/a&gt;数学运算符中的类型转换&lt;/h4&gt;&lt;p&gt;1、减、乘、除运算&lt;br&gt;&lt;strong&gt;非Number类型的使用减</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端概念相关-渐进增强与优雅降级</title>
    <link href="https://sunjinkang.github.io/2022/07/12/about-fe-theory/"/>
    <id>https://sunjinkang.github.io/2022/07/12/about-fe-theory/</id>
    <published>2022-07-12T02:37:56.000Z</published>
    <updated>2022-07-18T05:47:25.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="渐进增强-Progressive-Enhancement-相当于向上兼容"><a href="#渐进增强-Progressive-Enhancement-相当于向上兼容" class="headerlink" title="渐进增强(Progressive Enhancement)(相当于向上兼容)"></a>渐进增强(Progressive Enhancement)(相当于向上兼容)</h4><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验</p><h4 id="优雅降级-Graceful-Degradation-相当于向下兼容"><a href="#优雅降级-Graceful-Degradation-相当于向下兼容" class="headerlink" title="优雅降级(Graceful Degradation)(相当于向下兼容)"></a>优雅降级(Graceful Degradation)(相当于向下兼容)</h4><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览</p><p>向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少<br>大多数软件都是向下兼容的</p><h4 id="渐进增强与优雅降级的区别"><a href="#渐进增强与优雅降级的区别" class="headerlink" title="渐进增强与优雅降级的区别"></a>渐进增强与优雅降级的区别</h4><p>优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度<br>关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程</p><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p><p>渐进增强观点则认为应关注于内容本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.transition &#123; <span class="comment">/*渐进增强写法*/</span></span><br><span class="line">  -webkit-transition: all .5s;</span><br><span class="line">     -moz-transition: all .5s;</span><br><span class="line">       -o-transition: all .5s;</span><br><span class="line">          transition: all .5s;</span><br><span class="line">&#125;</span><br><span class="line">.transition &#123; <span class="comment">/*优雅降级写法*/</span></span><br><span class="line">          <span class="attr">transition</span>: all .5s;</span><br><span class="line">       -o-transition: all .5s;</span><br><span class="line">     -moz-transition: all .5s;</span><br><span class="line">  -webkit-transition: all .5s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：</p><p>1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；<br>2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；<br>3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；<br>4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p><p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;渐进增强-Progressive-Enhancement-相当于向上兼容&quot;&gt;&lt;a href=&quot;#渐进增强-Progressive-Enhancement-相当于向上兼容&quot; class=&quot;headerlink&quot; title=&quot;渐进增强(Progressive Enh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>document-location</title>
    <link href="https://sunjinkang.github.io/2022/07/05/document-location/"/>
    <id>https://sunjinkang.github.io/2022/07/05/document-location/</id>
    <published>2022-07-05T08:17:32.000Z</published>
    <updated>2022-07-19T03:09:43.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="code-spell-checker配置项说明"><a href="#code-spell-checker配置项说明" class="headerlink" title="code spell checker配置项说明"></a>code spell checker配置项说明</h4><p><a href="https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker">文档地址</a></p><h4 id="查看chrome各个版本功能变更"><a href="#查看chrome各个版本功能变更" class="headerlink" title="查看chrome各个版本功能变更"></a>查看chrome各个版本功能变更</h4><p><a href="https://chromestatus.com/features">chrome status</a></p><h4 id="查看-、-、if-在不同情况下的执行结果"><a href="#查看-、-、if-在不同情况下的执行结果" class="headerlink" title="查看== 、=== 、if()在不同情况下的执行结果"></a>查看== 、=== 、if()在不同情况下的执行结果</h4><p><a href="https://dorey.github.io/JavaScript-Equality-Table/">地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;code-spell-checker配置项说明&quot;&gt;&lt;a href=&quot;#code-spell-checker配置项说明&quot; class=&quot;headerlink&quot; title=&quot;code spell checker配置项说明&quot;&gt;&lt;/a&gt;code spell checke</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github生成令牌(Personal_access_tokens)操作步骤</title>
    <link href="https://sunjinkang.github.io/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/"/>
    <id>https://sunjinkang.github.io/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-06-30T03:23:56.000Z</published>
    <updated>2022-06-30T05:18:19.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="github生成令牌"><a href="#github生成令牌" class="headerlink" title="github生成令牌"></a>github生成令牌</h4><p>(1)登录<a href="https://github.com/">GitHub网站</a><br>(2)找到setting页面 -&gt; Developer setting<br>(3)选择 Personal access tokens ，点击 Generate new token 按钮<br>(4)需要填写token的权限范围<br>(5)<strong><font color="Red">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;github生成令牌&quot;&gt;&lt;a href=&quot;#github生成令牌&quot; class=&quot;headerlink&quot; title=&quot;github生成令牌&quot;&gt;&lt;/a&gt;github生成令牌&lt;/h4&gt;&lt;p&gt;(1)登录&lt;a href=&quot;https://github.com/&quot;&gt;Git</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github推送代码弹窗应该怎么输入？</title>
    <link href="https://sunjinkang.github.io/2022/06/30/github%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E5%BC%B9%E7%AA%97%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E8%BE%93%E5%85%A5%EF%BC%9F/"/>
    <id>https://sunjinkang.github.io/2022/06/30/github%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E5%BC%B9%E7%AA%97%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E8%BE%93%E5%85%A5%EF%BC%9F/</id>
    <published>2022-06-30T02:45:15.000Z</published>
    <updated>2022-06-30T05:22:12.389Z</updated>
    
    <content type="html"><![CDATA[<h4 id="github推送代码弹窗应该怎么输入"><a href="#github推送代码弹窗应该怎么输入" class="headerlink" title="github推送代码弹窗应该怎么输入?"></a>github推送代码弹窗应该怎么输入?</h4><p>当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，<br>鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。</p><p>(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>—- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line"><span class="attr">fatal</span>: unable to access <span class="string">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: Failed to connect to github.com port <span class="number">443</span>: Timed out</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line">$ git push</span><br><span class="line"><span class="attr">fatal</span>: unable to access <span class="string">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: OpenSSL SSL_read: Connection was aborted, errno <span class="number">10053</span></span><br></pre></td></tr></table></figure><p>(2)第一个GitHub登录弹窗<br><img src alt="github_login"><br>该弹窗中 <strong>username为github的登录邮箱，password为GitHub的登录密码</strong><br>—- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class="line"><span class="attr">remote</span>: Support <span class="keyword">for</span> password authentication was removed on August <span class="number">13</span>, <span class="number">2021.</span> Please use a personal access token instead.</span><br></pre></td></tr></table></figure><p>(3)第二个登录弹窗<br>![login_insert]<br>该弹窗会出现两次，第一次输入username，第二次输入password，<strong>username为GitHub的登录邮箱，<font color="Red">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章<a href="/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/">github生成令牌</a>)</font></strong><br>—- 注意：如果password输入错误，会导致无法提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class="line"><span class="attr">remote</span>: Support <span class="keyword">for</span> password authentication was removed on August <span class="number">13</span>, <span class="number">2021.</span> Please use a personal access token instead.</span><br><span class="line"><span class="attr">remote</span>: Please see https:<span class="comment">//github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span></span><br><span class="line">fatal: Authentication failed <span class="keyword">for</span> <span class="string">&#x27;https://github.com/xxxxxxx.git/&#x27;</span></span><br></pre></td></tr></table></figure><p>当username和password输入完成后，就可以正常push代码啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;github推送代码弹窗应该怎么输入&quot;&gt;&lt;a href=&quot;#github推送代码弹窗应该怎么输入&quot; class=&quot;headerlink&quot; title=&quot;github推送代码弹窗应该怎么输入?&quot;&gt;&lt;/a&gt;github推送代码弹窗应该怎么输入?&lt;/h4&gt;&lt;p&gt;当本地修</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>meta标签的使用</title>
    <link href="https://sunjinkang.github.io/2022/06/28/meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinkang.github.io/2022/06/28/meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-06-28T14:16:30.000Z</published>
    <updated>2022-07-21T07:48:28.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="meta标签的使用"><a href="#meta标签的使用" class="headerlink" title="meta标签的使用"></a>meta标签的使用</h4><h6 id="文档级元数据元素"><a href="#文档级元数据元素" class="headerlink" title="文档级元数据元素"></a><meta>文档级元数据元素</h6><p>meta标签一般放在HTML页面的head里面，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">MDN</a>定义：</p><blockquote><p>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。</p></blockquote><h6 id="meta定义的元数据类型"><a href="#meta定义的元数据类型" class="headerlink" title="meta定义的元数据类型"></a>meta定义的元数据类型</h6><p>(1)name属性：meta元素提供文档级别元数据，应用于整个页面<br>– name和content一起使用，name表示元数据名称，content表示元数据的值<br>—- name=”author”，表示网页作者的名字，例如某个组织或机构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mate name=&quot;author&quot; content=&quot;xxx@mail.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>—- name=”description”，是一段简短而精确的，对页面内容的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//淘宝网页的meta</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>—- name=”keywords”，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//淘宝网页的meta</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;keyword&quot;</span> content=<span class="string">&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>—- name=”viewport”，为viewport（视口）的初始大小提供指示，目前仅用于移动设备</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>width：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？<br>initial-scale：为设备宽度与viewport大小之间的缩放比例<br>maximum-scale：？？？？<br>minimum-scale：？？？？<br>user-scalable：？？？？<br>minimal-ui：？？？？</p><p>—- name=”robots”，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的<br>content类型：<br>all：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索<br>none：搜索引擎将忽略此网页<br>index：搜索引擎索引此网页<br>follow：搜索引擎继续通过此网页的链接索引搜索其它的网页</p><p>—- name=”renderer”，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;renderer&quot;</span> content=<span class="string">&quot;webkit&quot;</span>&gt; <span class="comment">//默认webkit内核</span></span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式</span><br></pre></td></tr></table></figure><p>content类型：<br>？？？？</p><p>—- name=”spm-id”，？？？？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 淘宝</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;spm-id&quot;</span> content=<span class="string">&quot;a21bo&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>—- name=”aplus-xplug”，？？？？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 淘宝网</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;aplus-xplug&quot;</span> content=<span class="string">&quot;NONE&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同<br>– http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值<br>– http-equiv所有允许的值都是特定http头部的名称<br>—- http-equiv=”X-UA-Compatible”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 淘宝网</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=10,chrome=1&quot;</span>&gt;<span class="comment">//IE浏览器适配</span></span><br></pre></td></tr></table></figure><p>IE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。<br>chrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。<br>两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。<br>另外，这个属性支持的范围是IE8-IE11<br>如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。</p><p>—- http-equiv=”content-type”，用来声明文档类型和字符集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;content-type&quot;</span> content=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>—- http-equiv=”x-dns-prefetch-control”<br>一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;x-dns-prefetch-control&quot;</span> content=<span class="string">&quot;on&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>—- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？</p><p>(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码<br>(4)itemprop属性：meta元素提供用户定义的元数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;meta标签的使用&quot;&gt;&lt;a href=&quot;#meta标签的使用&quot; class=&quot;headerlink&quot; title=&quot;meta标签的使用&quot;&gt;&lt;/a&gt;meta标签的使用&lt;/h4&gt;&lt;h6 id=&quot;文档级元数据元素&quot;&gt;&lt;a href=&quot;#文档级元数据元素&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>text-type-about-markdown</title>
    <link href="https://sunjinkang.github.io/2022/06/27/text-type-about-markdown/"/>
    <id>https://sunjinkang.github.io/2022/06/27/text-type-about-markdown/</id>
    <published>2022-06-27T02:43:07.000Z</published>
    <updated>2022-06-27T03:25:22.264Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MarkDown语法及示例"><a href="#MarkDown语法及示例" class="headerlink" title="MarkDown语法及示例"></a>MarkDown语法及示例</h4><h6 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h6><p>```javascript<br>const name = ‘eric’;<br>….<br>``` </p><h6 id="加粗字体"><a href="#加粗字体" class="headerlink" title="加粗字体"></a>加粗字体</h6><p>**文字**</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;MarkDown语法及示例&quot;&gt;&lt;a href=&quot;#MarkDown语法及示例&quot; class=&quot;headerlink&quot; title=&quot;MarkDown语法及示例&quot;&gt;&lt;/a&gt;MarkDown语法及示例&lt;/h4&gt;&lt;h6 id=&quot;代码块&quot;&gt;&lt;a href=&quot;#代码块&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>create-fixed-length-array</title>
    <link href="https://sunjinkang.github.io/2022/06/27/create-fixed-length-array/"/>
    <id>https://sunjinkang.github.io/2022/06/27/create-fixed-length-array/</id>
    <published>2022-06-27T02:20:46.000Z</published>
    <updated>2022-06-27T02:58:17.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="新建固定长度数组"><a href="#新建固定长度数组" class="headerlink" title="新建固定长度数组"></a>新建固定长度数组</h4><h6 id="使用primitives填充数组"><a href="#使用primitives填充数组" class="headerlink" title="使用primitives填充数组"></a>使用primitives填充数组</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [3, 3, 3]</span></span><br></pre></td></tr></table></figure><p>Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法</p><h6 id="使用对象填充数组"><a href="#使用对象填充数组" class="headerlink" title="使用对象填充数组"></a>使用对象填充数组</h6><p>(1)使用Array().fill()创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure><p>Array(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。<br>这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class="line">newArray[<span class="number">1</span>].value = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 2&#125;, &#123;value: 2&#125;, &#123;value: 2&#125;]</span></span><br></pre></td></tr></table></figure><p>(2)使用Array.from()创建数组<br>Array.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。<br>因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">3</span>), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure><p>如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">3</span>), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class="line">newArray[<span class="number">1</span>].value = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure><p>(3)使用Array.map()结合Array.fill()创建数组<br>注意：不要直接使用map新建数组，<strong>array.map()跳过 empty 元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>(<span class="number">3</span>).map(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [empty x 3]</span></span><br></pre></td></tr></table></figure><p>解决方法很简单，将 empty 数组 fill null 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">null</span>).map(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure><p>注意：使用这种方法创建的数组，修改某一项时不影响其他项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">null</span>).map(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class="line">newArray[<span class="number">1</span>].value = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArray);  <span class="comment">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;新建固定长度数组&quot;&gt;&lt;a href=&quot;#新建固定长度数组&quot; class=&quot;headerlink&quot; title=&quot;新建固定长度数组&quot;&gt;&lt;/a&gt;新建固定长度数组&lt;/h4&gt;&lt;h6 id=&quot;使用primitives填充数组&quot;&gt;&lt;a href=&quot;#使用primitives填</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>question-about-render</title>
    <link href="https://sunjinkang.github.io/2022/06/23/question-about-render/"/>
    <id>https://sunjinkang.github.io/2022/06/23/question-about-render/</id>
    <published>2022-06-23T05:21:12.000Z</published>
    <updated>2022-06-23T10:51:11.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="疑问点"><a href="#疑问点" class="headerlink" title="疑问点"></a>疑问点</h4><p>(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？<br>类似渲染的子节点？？？<br>(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？<br>没什么特别意义，团队规范规定<br>(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？<br>性能、更新<br>(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js<br>react-dom =》 渲染浏览器<br>vue可以搭配react-dom<br>(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？<br>可以，使用createElement<br>(6)hooks和函数的区别是什么？没区别<br>(7)vue3中element-plus组件函数的类型从哪里获取？<br>(8)如何将看到的东西和实际应用联系起来？<br>(9)怎么抓住重点？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;疑问点&quot;&gt;&lt;a href=&quot;#疑问点&quot; class=&quot;headerlink&quot; title=&quot;疑问点&quot;&gt;&lt;/a&gt;疑问点&lt;/h4&gt;&lt;p&gt;(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？&lt;br&gt;类似渲染的子节点？？？&lt;br&gt;(2)react中将调试</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue3-render</title>
    <link href="https://sunjinkang.github.io/2022/06/22/vue3-render/"/>
    <id>https://sunjinkang.github.io/2022/06/22/vue3-render/</id>
    <published>2022-06-22T14:12:51.000Z</published>
    <updated>2022-07-19T09:55:26.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p><img src="/2022/06/22/vue3-render/vue3_render.png" alt="vue3_render"><br>(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）<br>(2)调用beforeCreate<br>(3)初始化注入，包括data、method等添加到实例对象<br>(4)实例创建完成，调用created<br>(5)有el挂载，使用template替换；无挂载，使用mount自动挂载<br>(6)有template，进行编译，使其成为render函数<br>(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板<br>(8)调用beforeMount（vue实例挂载在虚拟DOM上）<br>(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）<br>(10)调用mounted<br>– （1）数据变更，即将重新渲染<br>– （2）调用beforeUpdate<br>– （3）进行虚拟DOM和真实DOM对比，进行patch<br>– （4）渲染完成，调用updated<br>(11)实例销毁之前调用beforeUnmount<br>(12)实例销毁，vm.$destroy<br>(13)销毁后调用unmounted</p><h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><p><img src="/2022/06/22/vue3-render/render.png" alt="render"><br>(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载<br>(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）<br>(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池<br>(4)最后更新容器上的Vnode<br>注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）</p><h2 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h2><p><img src="/2022/06/22/vue3-render/render_node1.png" alt="render_node1"><br><img src="/2022/06/22/vue3-render/render_node2.png" alt="render_node2"><br><img src="/2022/06/22/vue3-render/render_function.png" alt="render_function"><br>注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等<br>(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点<br>(2)container 是新节点的容器<br>(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物<br>(4)optimized 参数是是否开启优化模式的标识</p><h2 id="卸载组件"><a href="#卸载组件" class="headerlink" title="卸载组件"></a>卸载组件</h2><p>如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：<br>(1)如果存在ref，会首先重置ref<br>(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载<br>(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;渲染流程&quot;&gt;&lt;a href=&quot;#渲染流程&quot; class=&quot;headerlink&quot; title=&quot;渲染流程&quot;&gt;&lt;/a&gt;渲染流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2022/06/22/vue3-render/vue3_render.png&quot; alt=&quot;vue3_r</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>react-render</title>
    <link href="https://sunjinkang.github.io/2022/06/22/react-render/"/>
    <id>https://sunjinkang.github.io/2022/06/22/react-render/</id>
    <published>2022-06-22T14:12:37.000Z</published>
    <updated>2022-07-19T09:54:13.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><h4 id="React-createElement语法糖"><a href="#React-createElement语法糖" class="headerlink" title="React.createElement语法糖"></a>React.createElement语法糖</h4><p>(1)React.createElement(type, [props], […children]);<br>(2)type：元素类型<br>(3)props：属性值<br>(4)children：子元素</p><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系<br>(2)$$typeof：标识符，使用Symbol数据结构确保唯一性</p><h4 id="协调算法"><a href="#协调算法" class="headerlink" title="协调算法"></a>协调算法</h4><h4 id="filter图示"><a href="#filter图示" class="headerlink" title="filter图示"></a>filter图示</h4><p><img src="/2022/06/22/react-render/fiber_tree.png" alt="filter_tree"></p><h2 id="Element转化为Dom"><a href="#Element转化为Dom" class="headerlink" title="Element转化为Dom"></a>Element转化为Dom</h2><p>(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化<br>(2)ReactDOM.render(element, container[, callback])<br>(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function</p><h2 id="源码相关"><a href="#源码相关" class="headerlink" title="源码相关"></a>源码相关</h2><p>1、setState触发更新、父组件重新渲染时触发更新<br><img src="/2022/06/22/react-render/update_class.png" alt="update_class"><br>(1)static getDerivedStateFromProps()<br>(2)shouldComponentUpdate(nextProps,nextState)<br>(3)render()<br>(4)getSnapshotBeforeUpdate(prevProps,prevState)<br>(5)componentDidUpdate(prevProps,prevState,snapshot)<br>其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参<br>2、forceUpdate触发更新<br><img src="/2022/06/22/react-render/force_update.png" alt="force_update"><br>(1)static getDerivedStateFromProps()<br>(2)render()<br>(3)getSnapshotBeforeUpdate()<br>(4)componentDidUpdate()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主要步骤&quot;&gt;&lt;a href=&quot;#主要步骤&quot; class=&quot;headerlink&quot; title=&quot;主要步骤&quot;&gt;&lt;/a&gt;主要步骤&lt;/h2&gt;&lt;h4 id=&quot;React-createElement语法糖&quot;&gt;&lt;a href=&quot;#React-createElement语法糖&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>browser-render</title>
    <link href="https://sunjinkang.github.io/2022/05/23/browser-render/"/>
    <id>https://sunjinkang.github.io/2022/05/23/browser-render/</id>
    <published>2022-05-23T06:13:56.000Z</published>
    <updated>2022-06-23T01:58:33.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>(1)深度遍历解析HTML建立DOM树<br>(2)解析CSS建立CSSOM树<br>(3)依据DOM树和CSSOM树构造Render树<br>(4)计算各元素尺寸、位置<br>(5)绘制页面像素信息<br>(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)</p><h2 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h2><p>(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等<br>(2)重排/重绘<br>–1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。<br>–2、任何页面布局和几何属性的改变都会触发重排，比如：<br>页面渲染初始化；(无法避免)<br>添加或删除可见的DOM元素；<br>元素位置的改变；<br>改变元素尺寸（宽、高、内外边距、边框等）；<br>浏览器窗口尺寸的变化（resize事件发生时）；<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)<br>–3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。<br>–4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。</p><h2 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h2><p>(1)解析Javascript脚本，单线程执行<br>(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞</p><h2 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h2><p>(1)归属于浏览器而不是JS引擎，用来控制事件循环<br>(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理</p><h2 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h2><p>(1)setInterval与setTimeout所在线程<br>(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确<br>(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行</p><h2 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h2><p>(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p><h2 id="实现hover等鼠标操作"><a href="#实现hover等鼠标操作" class="headerlink" title="实现hover等鼠标操作"></a>实现hover等鼠标操作</h2><p><img src="/images/hover.png" alt="hover"></p><h2 id="使用performance分析页面性能"><a href="#使用performance分析页面性能" class="headerlink" title="使用performance分析页面性能"></a>使用performance分析页面性能</h2><p><img src="/images/performance.png" alt="performance"></p><h2 id="使用network调试"><a href="#使用network调试" class="headerlink" title="使用network调试"></a>使用network调试</h2><p><img src="/images/network.png" alt="network"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;渲染流程&quot;&gt;&lt;a href=&quot;#渲染流程&quot; class=&quot;headerlink&quot; title=&quot;渲染流程&quot;&gt;&lt;/a&gt;渲染流程&lt;/h2&gt;&lt;p&gt;(1)深度遍历解析HTML建立DOM树&lt;br&gt;(2)解析CSS建立CSSOM树&lt;br&gt;(3)依据DOM树和CSSOM树构造R</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>about-use-hexo</title>
    <link href="https://sunjinkang.github.io/2022/03/26/about-use-hexo/"/>
    <id>https://sunjinkang.github.io/2022/03/26/about-use-hexo/</id>
    <published>2022-03-26T13:14:29.000Z</published>
    <updated>2022-06-23T01:58:33.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些使用hexo搭建博客时遇到的问题"><a href="#一些使用hexo搭建博客时遇到的问题" class="headerlink" title="一些使用hexo搭建博客时遇到的问题"></a>一些使用hexo搭建博客时遇到的问题</h2><p>1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found<br>解决办法：重新运行命令：npm install hexo-cli -g</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些使用hexo搭建博客时遇到的问题&quot;&gt;&lt;a href=&quot;#一些使用hexo搭建博客时遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;一些使用hexo搭建博客时遇到的问题&quot;&gt;&lt;/a&gt;一些使用hexo搭建博客时遇到的问题&lt;/h2&gt;&lt;p&gt;1、一段时间</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>var-const-let</title>
    <link href="https://sunjinkang.github.io/2022/03/26/var-const-let/"/>
    <id>https://sunjinkang.github.io/2022/03/26/var-const-let/</id>
    <published>2022-03-26T13:04:12.000Z</published>
    <updated>2022-06-23T01:58:33.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会"><a href="#1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会" class="headerlink" title="1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会"></a>1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,<span class="built_in">window</span>.a);    <span class="comment">// 100 100</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b,<span class="built_in">window</span>.b);    <span class="comment">// 10 undefined</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c,<span class="built_in">window</span>.c);    <span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure><p>let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章<a href="https://zhuanlan.zhihu.com/p/114128108">let和const声明的变量到底去哪里了？</a></p><h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会&quot;&gt;&lt;a href=&quot;#1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会&quot; class=&quot;headerlink&quot; title=&quot;1、挂载</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sunjinkang.github.io/2022/01/05/hello-world/"/>
    <id>https://sunjinkang.github.io/2022/01/05/hello-world/</id>
    <published>2022-01-05T09:20:43.363Z</published>
    <updated>2022-06-23T01:58:33.679Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="deploy产生如下错误的解决方法"><a href="#deploy产生如下错误的解决方法" class="headerlink" title="deploy产生如下错误的解决方法"></a>deploy产生如下错误的解决方法</h3><p>(1)使用hexo部署报错Error: Spawn failed<br>解决办法：删除.deploy_git文件夹 -&gt; 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -&gt; 按顺序执行命令hexo clean、hexo generate、hexo deploy</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
