<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sun ...something</title>
  
  <subtitle>about what I have learned and some interesting things</subtitle>
  <link href="https://sunjinkang.github.io/atom.xml" rel="self"/>
  
  <link href="https://sunjinkang.github.io/"/>
  <updated>2022-10-08T08:35:54.983Z</updated>
  <id>https://sunjinkang.github.io/</id>
  
  <author>
    <name>Sun Jinkang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法阅读笔记(5)</title>
    <link href="https://sunjinkang.github.io/2022/10/08/data-structure5/"/>
    <id>https://sunjinkang.github.io/2022/10/08/data-structure5/</id>
    <published>2022-10-08T08:33:37.000Z</published>
    <updated>2022-10-08T08:35:54.983Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉堆和堆排序"><a href="#二叉堆和堆排序" class="headerlink" title="二叉堆和堆排序"></a>二叉堆和堆排序</h4><h6 id="二叉堆数据结构"><a href="#二叉堆数据结构" class="headerlink" title="二叉堆数据结构"></a>二叉堆数据结构</h6><p>(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。<br>(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉堆和堆排序&quot;&gt;&lt;a href=&quot;#二叉堆和堆排序&quot; class=&quot;headerlink&quot; title=&quot;二叉堆和堆排序&quot;&gt;&lt;/a&gt;二叉堆和堆排序&lt;/h4&gt;&lt;h6 id=&quot;二叉堆数据结构&quot;&gt;&lt;a href=&quot;#二叉堆数据结构&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法阅读笔记(4)</title>
    <link href="https://sunjinkang.github.io/2022/10/08/data-structure4/"/>
    <id>https://sunjinkang.github.io/2022/10/08/data-structure4/</id>
    <published>2022-10-08T05:25:18.000Z</published>
    <updated>2022-10-08T08:25:03.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。</p><p>每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">understandRecursion</span>(<span class="params">doIunderstandRecursion</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> recursionAnswer = confirm(<span class="string">&#x27;Do you understand recursion?&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (recursionAnswer === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 基线条件或停止点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  understandRecursion(recursionAnswer); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="计算一个数的阶乘"><a href="#计算一个数的阶乘" class="headerlink" title="计算一个数的阶乘"></a>计算一个数的阶乘</h6><p>数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。<br>5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120<br>(1)迭代阶乘<br>(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialIterative</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> n = number; n &gt; <span class="number">1</span>; n--) &#123;</span><br><span class="line">    total = total * n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorialIterative(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>(2)递归阶乘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 基线条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/data-structure4/factorial.png" alt="factorial"></p><p>如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）</p><p><strong>测试浏览器最大调用栈大小</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  recursiveFn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  recursiveFn();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i = &#x27;</span> + i + <span class="string">&#x27; error: &#x27;</span> + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。</strong><br>有关尾调用优化的更多相关信息，请访问 <a href="https://www.chromestatus.com/feature/">https://www.chromestatus.com/feature/</a><br>5516876633341952</p><h6 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h6><p>(1)位置 0 的斐波那契数是零<br>(2)1 和 2 的斐波那契数是 1<br>(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数</p><p><strong>迭代求斐波那契数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciIterative</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> fibNMinus2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fibNMinus1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> fibN = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// n &gt;= 2</span></span><br><span class="line">    fibN = fibNMinus1 + fibNMinus2; <span class="comment">// f(n-1) + f(n-2)</span></span><br><span class="line">    fibNMinus2 = fibNMinus1;</span><br><span class="line">    fibNMinus1 = fibN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br><span class="line">fibonacciIterative(<span class="number">9</span>); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p><strong>递归求斐波那契数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fibonacci(<span class="number">9</span>); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p><strong>记忆化斐波那契数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciMemoization</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memo = [<span class="number">0</span>, <span class="number">1</span>]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">const</span> fibonacci = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="literal">null</span>) <span class="keyword">return</span> memo[n]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (memo[n] = fibonacci(n - <span class="number">1</span>, memo) + fibonacci(n - <span class="number">2</span>, memo)); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n);</span><br><span class="line">&#125;</span><br><span class="line">fibonacciMemoization(<span class="number">9</span>); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p>迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除</p><h4 id="树数据结构"><a href="#树数据结构" class="headerlink" title="树数据结构"></a>树数据结构</h4><h6 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h6><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点</p><p>位于树顶部的节点叫作根节点。它没有父节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。</p><p>一个节点可以有祖先和后代。<br>一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。<br>一个节点的后代包括子节点、孙子节点、曾孙节点等。</p><p>子树：子树由节点和它的后代构成。</p><p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p><p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。<br><img src="/2022/10/08/data-structure4/tree.png" alt="tree"></p><h6 id="二叉树和二叉搜索树"><a href="#二叉树和二叉搜索树" class="headerlink" title="二叉树和二叉搜索树"></a>二叉树和二叉搜索树</h6><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p><p>二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。<br><img src="/2022/10/08/data-structure4/binary-search-tree.png" alt="binary-search-tree"></p><p>通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）<br>键是树相关的术语中对节点的称呼</p><p><strong>中序遍历</strong><br><img src="/2022/10/08/data-structure4/in-order-traverse.png" alt="in-order-traverse"><br><strong>先序遍历</strong><br><img src="/2022/10/08/data-structure4/pre-order-traverse.png" alt="pre-order-traverse"><br><strong>后序遍历</strong><br><img src="/2022/10/08/data-structure4/post-order-traverse.png" alt="post-order-traverse"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key; <span class="comment">// &#123;1&#125; 节点值</span></span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>; <span class="comment">// 左侧子节点引用</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>; <span class="comment">// 右侧子节点引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Compare, defaultCompare &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Node &#125; <span class="keyword">from</span> <span class="string">&#x27;./models/node&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn; <span class="comment">// 用来比较节点值</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>; <span class="comment">// &#123;1&#125; Node 类型的根节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向二叉搜索树中插入一个键</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.root = <span class="keyword">new</span> Node(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        node.left = <span class="keyword">new</span> Node(key); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertNode(node.left, key); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        node.right = <span class="keyword">new</span> Node(key); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertNode(node.right, key); <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="comment">// 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。</span></span><br><span class="line">  <span class="comment">// 中序遍历的一种应用就是对树进行排序操作。</span></span><br><span class="line">  <span class="function"><span class="title">inOrderTraverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.inOrderTraverseNode(<span class="built_in">this</span>.root, callback); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">inOrderTraverseNode</span>(<span class="params">node, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverseNode(node.left, callback); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      callback(node.key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverseNode(node.right, callback); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="comment">// 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class="line">  <span class="function"><span class="title">preOrderTraverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.preOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">preOrderTraverseNode</span>(<span class="params">node, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(node.key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverseNode(node.left, callback); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverseNode(node.right, callback); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="comment">// 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小</span></span><br><span class="line">  <span class="function"><span class="title">postOrderTraverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.postOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">postOrderTraverseNode</span>(<span class="params">node, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.postOrderTraverseNode(node.left, callback); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.postOrderTraverseNode(node.right, callback); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      callback(node.key); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索最小值和最大值</span></span><br><span class="line">  <span class="function"><span class="title">min</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minNode(<span class="built_in">this</span>.root); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">minNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      current = current.left; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">max</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.maxNode(<span class="built_in">this</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">maxNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索一个特定的值</span></span><br><span class="line">  <span class="function"><span class="title">search</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">searchNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.left, key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.right, key); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除一个节点</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      node.left = <span class="built_in">this</span>.removeNode(node.left, key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      node.right = <span class="built_in">this</span>.removeNode(node.right, key); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 键等于 node.key</span></span><br><span class="line">      <span class="comment">// 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;9&#125;</span></span><br><span class="line">        node = <span class="literal">null</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第二种情况: 移除有一个左侧子节点或右侧子节点的节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;12&#125;</span></span><br><span class="line">        node = node.right; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// &#123;14&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;15&#125;</span></span><br><span class="line">        node = node.left; <span class="comment">// &#123;16&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// &#123;17&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第三种情况: 具体流程可查看后续文章</span></span><br><span class="line">      <span class="keyword">const</span> aux = <span class="built_in">this</span>.minNode(node.right); <span class="comment">// &#123;18&#125;</span></span><br><span class="line">      node.key = aux.key; <span class="comment">// &#123;19&#125;</span></span><br><span class="line">      node.right = <span class="built_in">this</span>.removeNode(node.right, aux.key); <span class="comment">// &#123;20&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;21&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除有两个子节点的节点</strong><br>要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。<br>(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们<br>改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的<br>最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。<br><img src="/2022/10/08/data-structure4/remove-left-right.png" alt="remove-left-right"></p><h6 id="自平衡树"><a href="#自平衡树" class="headerlink" title="自平衡树"></a>自平衡树</h6><p>Adelson-Velskii-Landi 树（AVL 树）<br>AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。</p><p>在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BalanceFactor = &#123;</span><br><span class="line">  <span class="attr">UNBALANCED_RIGHT</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">BALANCED</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">SLIGHTLY_UNBALANCED_LEFT</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">UNBALANCED_LEFT</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(compareFn);</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点的高度和平衡因子</span></span><br><span class="line">  <span class="function"><span class="title">getNodeHeight</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">Math</span>.max(<span class="built_in">this</span>.getNodeHeight(node.left), <span class="built_in">this</span>.getNodeHeight(node.right)) +</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getBalanceFactor</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> heightDifference =</span><br><span class="line">      <span class="built_in">this</span>.getNodeHeight(node.left) - <span class="built_in">this</span>.getNodeHeight(node.right);</span><br><span class="line">    <span class="keyword">switch</span> (heightDifference) &#123;</span><br><span class="line">      <span class="keyword">case</span> -<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class="line">      <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.BALANCED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationLL</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.left; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    node.left = tmp.right; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    tmp.right = node; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationRR</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.right; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    node.right = tmp.left; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    tmp.left = node; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationLR</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    node.left = <span class="built_in">this</span>.rotationRR(node.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rotationLL(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationRL</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    node.right = <span class="built_in">this</span>.rotationLL(node.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rotationRR(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  向 AVL 树插入节点</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 像在 BST 树中一样插入节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>.insertNode(node.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>.insertNode(node.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// 重复的键</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要，将树进行平衡操作</span></span><br><span class="line">    <span class="keyword">const</span> balanceFactor = <span class="built_in">this</span>.getBalanceFactor(node); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">        <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        node = <span class="built_in">this</span>.rotationLL(node); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationLR(node); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        node = <span class="built_in">this</span>.rotationRR(node); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationRL(node); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 AVL 树中移除节点</span></span><br><span class="line">  <span class="function"><span class="title">removeNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    node = <span class="built_in">super</span>.removeNode(node, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// null，不需要进行平衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测树是否平衡</span></span><br><span class="line">    <span class="keyword">const</span> balanceFactor = <span class="built_in">this</span>.getBalanceFactor(node); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> balanceFactorLeft = <span class="built_in">this</span>.getBalanceFactor(node.left); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        balanceFactorLeft === BalanceFactor.BALANCED ||</span><br><span class="line">        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationLL(node); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class="line">        <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationLR(node.left); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class="line">      <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      <span class="keyword">const</span> balanceFactorRight = <span class="built_in">this</span>.getBalanceFactor(node.right); <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        balanceFactorRight === BalanceFactor.BALANCED ||</span><br><span class="line">        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// &#123;11&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationRR(node); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class="line">        <span class="comment">// &#123;13&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationRL(node.right); <span class="comment">// &#123;14&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平衡操作——AVL 旋转</strong><br>(1)左-左（LL）：向右的单旋转<br>这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的<br><img src="/2022/10/08/data-structure4/left-left-1.png" alt="left-left-1"><br><img src="/2022/10/08/data-structure4/left-left-2.png" alt="left-left-2"></p><p>rotationLL 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；<br>节点 X 的左子树保持不变；<br>将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；<br>将节点 X 的右子节点置为节点 Y（行{3}）</p><p>(2)右-右（RR）：向左的单旋转<br>右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的<br><img src="/2022/10/08/data-structure4/right-right-1.png" alt="right-right-1"><br><img src="/2022/10/08/data-structure4/right-right-2.png" alt="right-right-2"></p><p>rotationRR 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；<br>节点 X 的右子树保持不变；<br>将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；<br>将节点 X 的左子节点置为节点 Y（行{3}）</p><p>(3)左-右（LR）：向右的双旋转<br>这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复<br><img src="/2022/10/08/data-structure4/left-right-1.png" alt="left-right-1"><br><img src="/2022/10/08/data-structure4/left-right-2.png" alt="left-right-2"></p><p>rotationLR 方法<br>将节点 X 置于节点 Y（平衡因子为 2）所在的位置；<br>将节点 Z 的左子节点置为节点 X 的右子节点；<br>将节点 Y 的右子节点置为节点 X 的左子节点；<br>将节点 X 的右子节点置为节点 Y；<br>将节点 X 的左子节点置为节点 Z</p><p>(4)右-左（RL）：向左的双旋转<br>右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复<br><img src="/2022/10/08/data-structure4/right-left-1.png" alt="right-left-1"><br><img src="/2022/10/08/data-structure4/right-left-2.png" alt="right-left-2"></p><p>rotationRL 方法<br>将节点 X 置于节点 Y（平衡因子为+2）所在的位置；<br>将节点 Y 的左子节点置为节点 X 的右子节点；<br>将节点 Z 的右子节点置为节点 X 的左子节点；<br>将节点 X 的左子节点置为节点 Y；<br>将节点 X 的右子节点置为节点 Z</p><h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好</p><p>在红黑树中，每个节点都遵循以下规则：<br>(1) 顾名思义，每个节点不是红的就是黑的；<br>(2) 树的根节点是黑的；<br>(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；<br>(4) 如果一个节点是红的，那么它的两个子节点都是黑的；<br>(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；<br>(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(key);</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.color = Colors.RED; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isRed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color === Colors.RED;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(compareFn);</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key: T</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.root = <span class="keyword">new</span> RedBlackNode(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.root.color = Colors.BLACK; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newNode = <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.fixTreeProperties(newNode); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = <span class="keyword">new</span> RedBlackNode(key);</span><br><span class="line">        node.left.parent = node; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node.left; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.insertNode(node.left, key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      node.right = <span class="keyword">new</span> RedBlackNode(key);</span><br><span class="line">      node.right.parent = node; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node.right; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.insertNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">fixTreeProperties</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      node &amp;&amp;</span><br><span class="line">      node.parent &amp;&amp;</span><br><span class="line">      node.parent.color.isRed() &amp;&amp; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      node.color !== Colors.BLACK</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">let</span> parent = node.parent; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> grandParent = parent.parent; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="comment">// 情形 A：父节点是左侧子节点</span></span><br><span class="line">      <span class="keyword">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="keyword">const</span> uncle = grandParent.right; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        <span class="comment">// 情形 1A：叔节点也是红色——只需要重新填色</span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class="line">          <span class="comment">// &#123;7&#125;</span></span><br><span class="line">          grandParent.color = Colors.RED;</span><br><span class="line">          parent.color = Colors.BLACK;</span><br><span class="line">          uncle.color = Colors.BLACK;</span><br><span class="line">          node = grandParent; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 情形 2A：节点是右侧子节点——左旋转</span></span><br><span class="line">          <span class="keyword">if</span> (node === parent.right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rotationRR(parent); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">            node = parent; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">            parent = node.parent; <span class="comment">// &#123;14&#125;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 情形 3A：节点是左侧子节点——右旋转</span></span><br><span class="line">          <span class="built_in">this</span>.rotationLL(grandParent); <span class="comment">// &#123;15&#125;</span></span><br><span class="line">          parent.color = Colors.BLACK; <span class="comment">// &#123;16&#125;</span></span><br><span class="line">          grandParent.color = Colors.RED; <span class="comment">// &#123;17&#125;</span></span><br><span class="line">          node = parent; <span class="comment">// &#123;18&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情形 B：父节点是右侧子节点</span></span><br><span class="line">        <span class="keyword">const</span> uncle = grandParent.left; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">        <span class="comment">// 情形 1B：叔节点是红色——只需要重新填色</span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class="line">          <span class="comment">// &#123;10&#125;</span></span><br><span class="line">          grandParent.color = Colors.RED;</span><br><span class="line">          parent.color = Colors.BLACK;</span><br><span class="line">          uncle.color = Colors.BLACK;</span><br><span class="line">          node = grandParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 情形 2B：节点是左侧子节点——左旋转</span></span><br><span class="line">          <span class="keyword">if</span> (node === parent.left) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rotationLL(parent); <span class="comment">// &#123;19&#125;</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 情形 3B：节点是右侧子节点——左旋转</span></span><br><span class="line">          <span class="built_in">this</span>.rotationRR(grandParent); <span class="comment">// &#123;20&#125;</span></span><br><span class="line">          parent.color = Colors.BLACK;</span><br><span class="line">          grandParent.color = Colors.RED;</span><br><span class="line">          node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.root.color = Colors.BLACK; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationLL</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.left;</span><br><span class="line">    node.left = tmp.right;</span><br><span class="line">    <span class="keyword">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class="line">      tmp.right.parent = node;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (!node.parent) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node === node.parent.left) &#123;</span><br><span class="line">        node.parent.left = tmp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.parent.right = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.right = node;</span><br><span class="line">    node.parent = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationRR</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.right;</span><br><span class="line">    node.right = tmp.left;</span><br><span class="line">    <span class="keyword">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class="line">      tmp.left.parent = node;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (!node.parent) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node === node.parent.left) &#123;</span><br><span class="line">        node.parent.left = tmp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.parent.right = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.left = node;</span><br><span class="line">    node.parent = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。<br>左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。<br><img src="/2022/10/08/data-structure4/red-black-2a.png" alt="red-black-2a"><br><img src="/2022/10/08/data-structure4/red-black-3a.png" alt="red-black-3a"><br><img src="/2022/10/08/data-structure4/red-black-2b.png" alt="red-black-2b"><br><img src="/2022/10/08/data-structure4/red-black-3b.png" alt="red-black-3b"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h4&gt;&lt;p&gt;递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。&lt;/p&gt;
&lt;p&gt;每个递归函数都必须有</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法阅读笔记(3)</title>
    <link href="https://sunjinkang.github.io/2022/09/29/data-structure3/"/>
    <id>https://sunjinkang.github.io/2022/09/29/data-structure3/</id>
    <published>2022-09-29T02:49:51.000Z</published>
    <updated>2022-10-08T05:24:51.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合是由一组无序且唯一（即不能重复）的项组成的</p><h6 id="创建集合类"><a href="#创建集合类" class="headerlink" title="创建集合类"></a>创建集合类</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element <span class="keyword">in</span> items;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。</span></span><br><span class="line">  <span class="comment">// in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。</span></span><br><span class="line">  <span class="comment">// has(element) &#123;</span></span><br><span class="line">  <span class="comment">//   return Object.prototype.hasOwnProperty.call(this.items, element);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.items[element] = element; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">delete</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.items[element]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// sizeLegacy() &#123;</span></span><br><span class="line">  <span class="comment">//  let count = 0;</span></span><br><span class="line">  <span class="comment">//  for(let key in this.items) &#123; // &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量</span></span><br><span class="line">  <span class="comment">// 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原</span></span><br><span class="line">  <span class="comment">// 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对</span></span><br><span class="line">  <span class="comment">// 象自身、未用于数据结构的）</span></span><br><span class="line">  <span class="comment">//  if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125;</span></span><br><span class="line">  <span class="comment">//  count++; // &#123;4&#125;</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line">  <span class="comment">//  return count;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// valuesLegacy() &#123;</span></span><br><span class="line">  <span class="comment">//  let values = [];</span></span><br><span class="line">  <span class="comment">//  for(let key in this.items) &#123; // &#123;1&#125;</span></span><br><span class="line">  <span class="comment">//    if(this.items.hasOwnProperty(key)) &#123;</span></span><br><span class="line">  <span class="comment">//       values.push(key); // &#123;2&#125;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line">  <span class="comment">//  return values;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h6><p>(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</span></span><br><span class="line"><span class="function"><span class="title">union</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="comment">// 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中</span></span><br><span class="line">  <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> unionSet.add(value)); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  otherSet.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> unionSet.add(value)); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line">setB.add(<span class="number">5</span>);</span><br><span class="line">setB.add(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> unionAB = setA.union(setB);</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values());</span><br><span class="line"><span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><p>(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">intersection</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"> <span class="keyword">const</span> values = <span class="built_in">this</span>.values();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">   <span class="keyword">if</span> (otherSet.has(values[i])) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">     intersectionSet.add(values[i]); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> intersectionAB = setA.intersection(setB);</span><br><span class="line"><span class="built_in">console</span>.log(intersectionAB.values());</span><br><span class="line"><span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="function"><span class="title">intersection</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"> <span class="keyword">const</span> values = <span class="built_in">this</span>.values(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line"> <span class="keyword">const</span> otherValues = otherSet.values(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line"> <span class="keyword">let</span> biggerSet = values; <span class="comment">// &#123;4&#125;</span></span><br><span class="line"> <span class="keyword">let</span> smallerSet = otherValues; <span class="comment">// &#123;5&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (otherValues.length - values.length &gt; <span class="number">0</span>) &#123; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">   biggerSet = otherValues;</span><br><span class="line">   smallerSet = values;</span><br><span class="line"> &#125;</span><br><span class="line"> smallerSet.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">   <span class="keyword">if</span> (biggerSet.includes(value)) &#123;</span><br><span class="line">     intersectionSet.add(value);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">difference</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!otherSet.has(value)) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      differenceSet.add(value); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> differenceAB = setA.difference(setB);</span><br><span class="line"><span class="built_in">console</span>.log(differenceAB.values());</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p>(4)子集：验证一个给定集合是否是另一集合的子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isSubsetOf</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.size() &gt; otherSet.size()) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isSubset = <span class="literal">true</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止</span></span><br><span class="line">  <span class="built_in">this</span>.values().every(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!otherSet.has(value)) &#123; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      isSubset = <span class="literal">false</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> isSubset; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">1</span>);</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setC = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setC.add(<span class="number">2</span>);</span><br><span class="line">setC.add(<span class="number">3</span>);</span><br><span class="line">setC.add(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(setA.isSubsetOf(setB));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSubsetOf(setC));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h6 id="使用扩展运算符"><a href="#使用扩展运算符" class="headerlink" title="使用扩展运算符"></a>使用扩展运算符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...setA, ...setB]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> setB.has(x))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !setB.has(x))));</span><br></pre></td></tr></table></figure><h4 id="字典和散列表"><a href="#字典和散列表" class="headerlink" title="字典和散列表"></a>字典和散列表</h4><h6 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h6><p>在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。<br>字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。<br>字典也称作映射、符号表或关联数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultToString</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;NULL&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;UNDEFINED&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;string&#x27;</span> || item <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.toString(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;<span class="built_in">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defaultToString &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测一个键是否存在于字典中</span></span><br><span class="line">  <span class="function"><span class="title">hasKey</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)] != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在字典和 ValuePair 类中设置键和值</span></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.table[tableKey] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从字典中移除一个值</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.hasKey(key)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从字典中检索一个值</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">keyValues</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.table);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function">(<span class="params">valuePair</span>) =&gt;</span> valuePair.key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function">(<span class="params">valuePair</span>) =&gt;</span> valuePair.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">forEach</span>(<span class="params">callbackFn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (result === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.table).length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues();</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;valuePairs[<span class="number">0</span>].toString()&#125;</span>`</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h6><p>散列算法的作用是尽可能快地在数据结构中找到一个值</p><p>散列函数的作用是给定一个键值，然后返回值在表中的地址</p><p>散列表有一些在计算机科学中应用的例子:<br>(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用<br>(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。</p><p>散列函数 —- lose lose 散列函数<br><img src="/2022/09/29/data-structure3/lose-lose.png" alt="lose-lose"></p><p>HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我<br>们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而<br>在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存<br>在 hash 位置（或属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建散列函数</span></span><br><span class="line">  <span class="function"><span class="title">loseloseHashCode</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 根据组成 key 的每个字符的 ASCII 码值的和得到一个数</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class="line">      hash += tableKey.charCodeAt(i); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;）</span></span><br><span class="line">    <span class="comment">// 这可以规避操作数超过数值变量最大表示范围的风险</span></span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hashCode</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.loseloseHashCode(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.hashCode(key)];</span><br><span class="line">    <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="built_in">this</span>.hashCode(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[hash]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.table[hash]; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = <span class="keyword">new</span> HashTable();</span><br><span class="line">hash.put(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">hash.put(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line">hash.put(<span class="string">&#x27;Tyrion&#x27;</span>, <span class="string">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.hashCode(<span class="string">&#x27;Gandalf&#x27;</span>) + <span class="string">&#x27; - Gandalf&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.hashCode(<span class="string">&#x27;John&#x27;</span>) + <span class="string">&#x27; - John&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.hashCode(<span class="string">&#x27;Tyrion&#x27;</span>) + <span class="string">&#x27; - Tyrion&#x27;</span>);</span><br><span class="line"><span class="comment">// 19 - Gandalf</span></span><br><span class="line"><span class="comment">// 29 - John</span></span><br><span class="line"><span class="comment">// 16 - Tyrion</span></span><br></pre></td></tr></table></figure><p><strong>散列集合</strong><br>散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数<br>散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。</p><p><strong>散列表中的冲突</strong><br>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突</p><p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p><p>(1)分离链接<br>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间<br><img src="/2022/09/29/data-structure3/sperate-chain.png" alt="sperate-chain"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTableSeparateChaining</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">      <span class="comment">//  将验证要加入新元素的位置是否已经被占据</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> LinkedList(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.table[position].push(<span class="keyword">new</span> ValuePair(key, value)); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化</span></span><br><span class="line">  <span class="comment">// LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key</span></span><br><span class="line">  <span class="comment">// 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较</span></span><br><span class="line">  <span class="comment">// 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要</span></span><br><span class="line">  <span class="comment">// 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。</span></span><br><span class="line">  <span class="comment">// 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">const</span> linkedList = <span class="built_in">this</span>.table[position]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (linkedList != <span class="literal">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">let</span> current = linkedList.getHead(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123;</span><br><span class="line">          <span class="comment">// &#123;5&#125;</span></span><br><span class="line">          <span class="keyword">return</span> current.element.value; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">const</span> linkedList = <span class="built_in">this</span>.table[position];</span><br><span class="line">    <span class="keyword">if</span> (linkedList != <span class="literal">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = linkedList.getHead();</span><br><span class="line">      <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123;</span><br><span class="line">          <span class="comment">// &#123;1&#125;</span></span><br><span class="line">          linkedList.remove(current.element); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">          <span class="keyword">if</span> (linkedList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// &#123;3&#125;</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.table[position]; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)线性探查<br>它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中<br>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置<br><img src="/2022/09/29/data-structure3/linear-probing.png" alt="linear-probing"></p><p>线性探查技术分为两种。</p><p>第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因<br><img src="/2022/09/29/data-structure3/soft-delete.png" alt="soft-delete"><br><a href="http://github.com/loiane/javascript-datastructures-algorithms">源代码</a></p><p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。<br><img src="/2022/09/29/data-structure3/move-key.png" alt="move-key"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move-key</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTableSeparateChainingMoveKey</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = position + <span class="number">1</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// &#123;4&#125;</span></span><br><span class="line">          index++; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.table[index] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注</span></span><br><span class="line">  <span class="comment">// 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需</span></span><br><span class="line">  <span class="comment">// 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数</span></span><br><span class="line">  <span class="comment">// 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需</span></span><br><span class="line">  <span class="comment">// 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一</span></span><br><span class="line">  <span class="comment">// 个功能</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position].key === key) &#123;</span><br><span class="line">        <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.table[position].value; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> index = position + <span class="number">1</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key !== key) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key === key) &#123;</span><br><span class="line">        <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.table[position].value; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position].key === key) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.table[position]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.verifyRemoveSideEffect(key, position); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> index = position + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key !== key) &#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key === key) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.table[index]; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.verifyRemoveSideEffect(key, index); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">verifyRemoveSideEffect</span>(<span class="params">key, removedPosition</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="built_in">this</span>.hashCode(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> index = removedPosition + <span class="number">1</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> posHash = <span class="built_in">this</span>.hashCode(<span class="built_in">this</span>.table[index].key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.table[removedPosition] = <span class="built_in">this</span>.table[index]; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.table[index];</span><br><span class="line">        removedPosition = index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更好的散列函数</strong><br>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">djb2HashCode</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"><span class="comment">//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381</span></span><br><span class="line"> <span class="keyword">let</span> hash = <span class="number">5381</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.length; i++) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line"><span class="comment">//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加</span></span><br><span class="line"> hash = (hash * <span class="number">33</span>) + tableKey.charCodeAt(i); <span class="comment">// &#123;4&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//  将使用相加的和与另一个随机质数相除的余数</span></span><br><span class="line"> <span class="keyword">return</span> hash % <span class="number">1013</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0</span></span><br></pre></td></tr></table></figure><p><strong>ES2015 Map 类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;Tyrion&#x27;</span>, <span class="string">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;Gandalf&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,</span></span><br><span class="line"><span class="string">&quot;tyrion@email.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;Tyrion&#x27;</span>)); <span class="comment">// tyrion@email.com</span></span><br><span class="line">map.delete(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>ES2105 WeakMap 类和 WeakSet 类</strong><br>Map 和 Set 与其弱化版本之间仅有的区别是:<br>(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法<br>(2)WeakSet 和 WeakMap 只能用对象作为键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> ob1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Gandalf&#x27;</span> &#125;; <span class="comment">// &#123;1&#125;</span></span><br><span class="line"><span class="keyword">const</span> ob2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ob3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tyrion&#x27;</span> &#125;;</span><br><span class="line">map.set(ob1, <span class="string">&#x27;gandalf@email.com&#x27;</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">map.set(ob2, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line">map.set(ob3, <span class="string">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob1)); <span class="comment">// true &#123;3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(ob3)); <span class="comment">// tyrion@email.com &#123;4&#125;</span></span><br><span class="line">map.delete(ob2); <span class="comment">// &#123;5&#125;</span></span><br></pre></td></tr></table></figure><p>注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h4&gt;&lt;p&gt;集合是由一组无序且唯一（即不能重复）的项组成的&lt;/p&gt;
&lt;h6 id=&quot;创建集合类&quot;&gt;&lt;a href=&quot;#创建集合类&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法阅读笔记(2)</title>
    <link href="https://sunjinkang.github.io/2022/09/23/data-structure2/"/>
    <id>https://sunjinkang.github.io/2022/09/23/data-structure2/</id>
    <published>2022-09-23T07:52:54.000Z</published>
    <updated>2022-09-27T09:21:29.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向队列添加元素</span></span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从队列移除元素</span></span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.lowestCount++; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看队列头元素</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查队列是否为空</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取队列的长度</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h6><p>双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列</p><p>由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 向双端队列的前端添加元素</span></span><br><span class="line">  <span class="function"><span class="title">addFront</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.addBack(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.lowestCount &gt; <span class="number">0</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.lowestCount--;</span><br><span class="line">      <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount] = element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.count; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.items[i] = <span class="built_in">this</span>.items[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">      <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">this</span>.items[<span class="number">0</span>] = element; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addBack</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeFront</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.lowestCount++; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeBack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peekFront</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peekBack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="循环队列-击鼓传花"><a href="#循环队列-击鼓传花" class="headerlink" title="循环队列 - 击鼓传花"></a>循环队列 - 击鼓传花</h6><p>场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">elementsList, num</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue(); <span class="comment">// &#123;1&#125; </span></span><br><span class="line">  <span class="keyword">const</span> elimitatedList = [];</span><br><span class="line">  <span class="comment">// 把名单的名字全都加入队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elementsList.length; i++) &#123; </span><br><span class="line">    queue.enqueue(elementsList[i]); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代队列</span></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123; </span><br><span class="line">      <span class="comment">// 将队列开头一项移除，添加到队列末尾</span></span><br><span class="line">      queue.enqueue(queue.dequeue()); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 将超出限制的队列开头一项移除，作为淘汰项</span></span><br><span class="line">    elimitatedList.push(queue.dequeue()); <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">eliminated</span>: elimitatedList, </span><br><span class="line">    <span class="attr">winner</span>: queue.dequeue() <span class="comment">// &#123;5&#125; </span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Camila&#x27;</span>, <span class="string">&#x27;Ingrid&#x27;</span>, <span class="string">&#x27;Carl&#x27;</span>]; </span><br><span class="line"><span class="keyword">const</span> result = hotPotato(names, <span class="number">7</span>);</span><br><span class="line">result.eliminated.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`胜利者： <span class="subst">$&#123;result.winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h6 id="回文检查器"><a href="#回文检查器" class="headerlink" title="回文检查器"></a>回文检查器</h6><p>回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindromeChecker</span>(<span class="params">aString</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查传入的字符串参数是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (aString === <span class="literal">undefined</span> || aString === <span class="literal">null</span> || (aString !== <span class="literal">null</span> &amp;&amp; aString.length === <span class="number">0</span>)) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> Deque(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class="line">  <span class="keyword">const</span> lowerString = aString.toLocaleLowerCase().split(<span class="string">&#x27; &#x27;</span>).join(<span class="string">&#x27;&#x27;</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">  <span class="keyword">let</span> isEqual = <span class="literal">true</span>; </span><br><span class="line">  <span class="keyword">let</span> firstChar, lastChar;</span><br><span class="line">  <span class="comment">// 将所有字符串加入队列中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerString.length; i++) &#123; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">    deque.addBack(lowerString.charAt(i)); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (deque.size() &gt; <span class="number">1</span> &amp;&amp; isEqual) &#123; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">    firstChar = deque.removeFront(); <span class="comment">// &#123;6&#125; </span></span><br><span class="line">    lastChar = deque.removeBack(); <span class="comment">// &#123;7&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123; </span><br><span class="line">      isEqual = <span class="literal">false</span>; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> isEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">javascript事件循环</a></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h6 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h6><p><img src="/2022/09/23/data-structure2/chain-table-1.png" alt="链表"><br>链表的好处：添加或移除元素的时候不需要移动其他元素<br>要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> a === b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// models/linked-list-models</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element; </span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">undefined</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defaultEquals &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; Node &#125; <span class="keyword">from</span> <span class="string">&#x27;./models/linked-list-models&#x27;</span>; <span class="comment">// &#123;1&#125; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="literal">undefined</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.equalsFn = equalsFn; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向链表尾部添加元素</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element); <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">let</span> current; <span class="comment">// &#123;2&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">      <span class="built_in">this</span>.head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = <span class="built_in">this</span>.head; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">      <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123; <span class="comment">// &#123;5&#125; 获得最后一项</span></span><br><span class="line">        current = current.next; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将其 next 赋为新元素，建立链接</span></span><br><span class="line">      current.next = node; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">this</span>.count++; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从链表中移除元素</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">      <span class="comment">// 移除第一项</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.head = current.next; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前index的前一个节点</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">        current = previous.next;</span><br><span class="line">        <span class="comment">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class="line">        previous.next = current.next; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--; <span class="comment">// &#123;9&#125; </span></span><br><span class="line">      <span class="keyword">return</span> current.element; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;10&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环迭代链表直到目标位置</span></span><br><span class="line">  <span class="function"><span class="title">getElementAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">let</span> node = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index &amp;&amp; node != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        node = node.next;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在任意位置插入元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置添加</span></span><br><span class="line">        <span class="keyword">const</span> current = <span class="built_in">this</span>.head; </span><br><span class="line">        node.next = current; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.head = node; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        <span class="keyword">const</span> current = previous.next; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">        node.next = current; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">        previous.next = node; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">this</span>.count++; <span class="comment">// 更新链表的长度</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  indexOf 方法：返回一个元素的位置</span></span><br><span class="line">  <span class="function"><span class="title">indexOf</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.equalsFn(element, current.element)) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从链表中移除元素</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.indexOf(element); </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count === <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHead</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.head; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.head.element&#125;</span>`</span>; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head.next; <span class="comment">// &#123;3&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;current.element&#125;</span>`</span>; </span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> objString; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">javascript垃圾回收器</a></p><h6 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h6><p>在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素<br><img src="/2022/09/23/data-structure2/chain-table-2.png" alt="双向链表"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">element, next, prev</span>)</span> &#123; </span><br><span class="line">  <span class="built_in">super</span>(element, next); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">  <span class="built_in">this</span>.prev = prev; <span class="comment">// &#123;3&#125; 新增的</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">super</span>(equalsFn); <span class="comment">// &#123;5&#125; </span></span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="literal">undefined</span>; <span class="comment">// &#123;6&#125; 新增的</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  在任意位置插入新元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element); </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;1&#125; 新增的</span></span><br><span class="line">            <span class="built_in">this</span>.head = node; </span><br><span class="line">            <span class="built_in">this</span>.tail = node; </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            node.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">            current.prev = node; <span class="comment">// &#123;3&#125; 新增的</span></span><br><span class="line">            <span class="built_in">this</span>.head = node; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">          &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count) &#123; <span class="comment">// 最后一项 // 新增的</span></span><br><span class="line">        current = <span class="built_in">this</span>.tail; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">        current.next = node; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">        node.prev = current; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.tail = node; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;9&#125; </span></span><br><span class="line">        current = previous.next; <span class="comment">// &#123;10&#125; </span></span><br><span class="line">        node.next = current; <span class="comment">// &#123;11&#125; </span></span><br><span class="line">        previous.next = node; <span class="comment">// &#123;12&#125; </span></span><br><span class="line">        current.prev = node; <span class="comment">// &#123;13&#125; 新增的</span></span><br><span class="line">        node.prev = previous; <span class="comment">// &#123;14&#125; 新增的</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count++; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">this</span>.head = current.next; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">        <span class="comment">// 如果只有一项，更新 tail // 新增的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count === <span class="number">1</span>) &#123; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">          <span class="built_in">this</span>.tail = <span class="literal">undefined</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="built_in">this</span>.head.prev = <span class="literal">undefined</span>; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count - <span class="number">1</span>) &#123; <span class="comment">// 最后一项 //新增的</span></span><br><span class="line">        current = <span class="built_in">this</span>.tail; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.tail = current.prev; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.tail.next = <span class="literal">undefined</span>; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        current = <span class="built_in">this</span>.getElementAt(index); <span class="comment">// &#123;7&#125; </span></span><br><span class="line">        <span class="keyword">const</span> previous = current.prev; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">        <span class="comment">// 将 previous 与 current 的下一项链接起来——跳过 current </span></span><br><span class="line">        previous.next = current.next; <span class="comment">// &#123;9&#125; </span></span><br><span class="line">        current.next.prev = previous; <span class="comment">// &#123;10&#125; 新增的</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--; </span><br><span class="line">      <span class="keyword">return</span> current.element; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源码：https://github.com/loiane/javascript-datastructures-algorithms</span></span><br></pre></td></tr></table></figure><h6 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h6><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）<br>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev<br><img src="/2022/09/23/data-structure2/chain-table-3.png" alt="循环链表"><br><img src="/2022/09/23/data-structure2/chain-table-4.png" alt="双向循环链表"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(equalsFn); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在任意位置插入新元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element); </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; </span><br><span class="line">          <span class="built_in">this</span>.head = node; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">          node.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; 新增的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          node.next = current; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">          current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size()); <span class="comment">// &#123;4&#125; </span></span><br><span class="line">          <span class="comment">// 更新最后一个元素</span></span><br><span class="line">          <span class="built_in">this</span>.head = node; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">          current.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;6&#125; 新增的</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这种场景没有变化</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); </span><br><span class="line">        node.next = previous.next; </span><br><span class="line">        previous.next = node; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">this</span>.count++; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() === <span class="number">1</span>) &#123; </span><br><span class="line">          <span class="built_in">this</span>.head = <span class="literal">undefined</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="keyword">const</span> removed = <span class="built_in">this</span>.head; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">          current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size()); <span class="comment">// &#123;2&#125; 新增的</span></span><br><span class="line">          <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">          current.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">          current = removed; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 不需要修改循环链表最后一个元素</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); </span><br><span class="line">        current = previous.next; </span><br><span class="line">        previous.next = current.next; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--; </span><br><span class="line">      <span class="keyword">return</span> current.element; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h6><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Compare = &#123; </span><br><span class="line">  <span class="attr">LESS_THAN</span>: -<span class="number">1</span>, </span><br><span class="line">  <span class="attr">BIGGER_THAN</span>: <span class="number">1</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals, compareFn = defaultCompare</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">super</span>(equalsFn); </span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有序插入元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index = <span class="number">0</span></span>)</span> &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, <span class="number">0</span>); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">const</span> pos = <span class="built_in">this</span>.getIndexNextSortedElement(element); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, pos); <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="title">getIndexNextSortedElement</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head; </span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current; i++) &#123; </span><br><span class="line">      <span class="keyword">const</span> comp = <span class="built_in">this</span>.compareFn(element, current.element); <span class="comment">// &#123;5&#125; </span></span><br><span class="line">      <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">      &#125; </span><br><span class="line">      current = current.next; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-StackLinkedList-类"><a href="#创建-StackLinkedList-类" class="headerlink" title="创建 StackLinkedList 类"></a>创建 StackLinkedList 类</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackLinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> DoublyLinkedList(); <span class="comment">// &#123;1&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.items.push(element); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.removeAt(<span class="built_in">this</span>.size() - <span class="number">1</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h4&gt;&lt;p&gt;队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js中apply怎么把数组转化为参数？</title>
    <link href="https://sunjinkang.github.io/2022/09/21/apply-array-to-params/"/>
    <id>https://sunjinkang.github.io/2022/09/21/apply-array-to-params/</id>
    <published>2022-09-21T09:07:53.000Z</published>
    <updated>2022-09-21T09:08:28.460Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法阅读笔记(1)</title>
    <link href="https://sunjinkang.github.io/2022/09/20/data-structure1/"/>
    <id>https://sunjinkang.github.io/2022/09/20/data-structure1/</id>
    <published>2022-09-20T09:41:00.000Z</published>
    <updated>2022-09-23T07:51:52.037Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 和 javascript 的关系<br>ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。</p><p>ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别</p><p>(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)</p><p>(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性<br>一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)</p><p>(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)</p><p>(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)</p><p>(5)ES.Next 用来指代下一个版本的 ECMAScript</p><p>ES6 兼容性：<a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a><br>ES7 兼容性：<a href="http://kangax.github.io/compat-table/es2016plus/">http://kangax.github.io/compat-table/es2016plus/</a></p><p>ES5 中 class 类，使用属性存取器<br>(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字<br>(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lotrChar = <span class="keyword">new</span> Person(<span class="string">&#x27;Frodo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lotrChar.name); <span class="comment">// &#123;4&#125; // Frodo</span></span><br><span class="line">lotrChar.name = <span class="string">&#x27;Gandalf&#x27;</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(lotrChar.name); <span class="comment">// Gandalf</span></span><br><span class="line">lotrChar._name = <span class="string">&#x27;Sam&#x27;</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(lotrChar.name); <span class="comment">// Sam</span></span><br></pre></td></tr></table></figure><p>乘方运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * r * r;</span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * <span class="built_in">Math</span>.pow(r, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ES2016 中引入了**运算符，用来进行指数运算</span></span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * r ** <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript 和 ECMAScript 的完整功能列表</a></p><h6 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h6><p>TypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.<br>(1)接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种定义接口的方式</span></span><br><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，</span></span><br><span class="line"><span class="comment">并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/</span></span><br><span class="line">interface Comparable &#123;</span><br><span class="line">  compareTo(b): number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="title">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="attr">age</span>: number;</span><br><span class="line">  compareTo(b): number &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.age === b.age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age &gt; b.age ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check</strong></p><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组</p><p>(1)使用@@iterator 对象<br>ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制已有数组</span></span><br><span class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers);</span><br><span class="line"><span class="keyword">let</span> numbers3 = <span class="built_in">Array</span>.of(...numbers);</span><br></pre></td></tr></table></figure><p>(2)copyWithin<br>copyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copyArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">copyArray.copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// copyWithin(起始位置，开始位置，结束位置)</span></span><br><span class="line"><span class="comment">// [1, 4, 5, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>(3)排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line"><span class="keyword">const</span> friends = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Ana&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Chris&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;, <span class="comment">// ES2017 允许存在尾逗号</span></span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">comparePerson</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.age &lt; b.age) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a.age &gt; b.age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(friends.sort(comparePerson));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[ </span></span><br><span class="line"><span class="comment"> &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, </span></span><br><span class="line"><span class="comment"> &#123; name: &#x27;Chris&#x27;, age: 25 &#125;,</span></span><br><span class="line"><span class="comment"> &#123; name: &#x27;John&#x27;, age: 30 &#125;, </span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 忽略大小写的比较</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;ana&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;John&#x27;</span>]; <span class="comment">// 重置数组的初始状态</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  names.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.toLowerCase() &lt; b.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.toLowerCase() &gt; b.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;ana&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;John&#x27;</span>];</span><br><span class="line">names.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class="line"><span class="comment">// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names2 = [<span class="string">&#x27;Maève&#x27;</span>, <span class="string">&#x27;Maeve&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(names2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b)));</span><br><span class="line"><span class="comment">// [&quot;Maeve&quot;, &quot;Maève&quot;]</span></span><br></pre></td></tr></table></figure><h6 id="类型数组"><a href="#类型数组" class="headerlink" title="类型数组"></a>类型数组</h6><table><thead><tr><th>类型数组</th><th>数据类型</th></tr></thead><tbody><tr><td>Int8Array</td><td>8 位二进制补码整数</td></tr><tr><td>Uint8Array</td><td>8 位无符号整数</td></tr><tr><td>Uint8ClampedArray</td><td>8 位无符号整数</td></tr><tr><td>Int16Array</td><td>16 位二进制补码整数</td></tr><tr><td>Uint16Array</td><td>16 位无符号整数</td></tr><tr><td>Int32Array</td><td>32 位二进制补码整数</td></tr><tr><td>Uint32Array</td><td>32 位无符号整数</td></tr><tr><td>Float32Array</td><td>32 位 IEEE 浮点数</td></tr><tr><td>Float64Array</td><td>64 位 IEEE 浮点数</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> length = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> int16 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(length);</span><br><span class="line"><span class="keyword">let</span> array16 = [];</span><br><span class="line">array16.length = length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  int16[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(int16);</span><br></pre></td></tr></table></figure><p>类型数组作用：WebGL API、位操作、处理文件和图像</p><p><a href="https://web.dev/webgl-typed-arrays/">类型数组文档</a></p><h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底</p><p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）</p><p>(1)创建一个基于数组的栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个（或几个）新元素到栈顶</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈里的元素个数。该方法和数组的 length 属性很类似</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈里的所有元素</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。</strong><br>(2)创建一个基于 JavaScript 对象的 Stack 类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素</span></span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向栈中插入元素,只允许一次插入一个元素</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 验证一个栈的大小</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取栈是否为空</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶的值</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  while (!this.isEmpty()) &#123;</span></span><br><span class="line">    <span class="comment">//  this.pop();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>javascript 实现私有属性的方法</strong><br>下划线命名约定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中使用下划线命名约定来标记一个属性为私有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>._items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识</em></p><p><strong>用 ES2015 的限定作用域 Symbol 实现类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _items = <span class="built_in">Symbol</span>(<span class="string">&#x27;stackItems&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 栈的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(stack);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].push(<span class="number">1</span>);</span><br><span class="line">stack.print(); <span class="comment">// 输出 5, 8, 1</span></span><br></pre></td></tr></table></figure><p><em>访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求</em></p><p><strong>用 ES2015 的 WeakMap 实现类</strong><br>WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    items.set(<span class="built_in">this</span>, []); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = items.get(<span class="built_in">this</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    s.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = items.get(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">const</span> r = s.pop();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>代码的可读性不强，而且在扩展该类时无法继承私有属性</em></p><p><strong>ECMAScript 类属性提案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  #items = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 栈的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从十进制转二进制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">let</span> number = decNumber;</span><br><span class="line">  <span class="keyword">let</span> rem;</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(number % <span class="number">2</span>);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    binaryString += remStack.pop().toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进制转换算法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">decNumber, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">const</span> digits = <span class="string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  <span class="keyword">let</span> number = decNumber;</span><br><span class="line">  <span class="keyword">let</span> rem;</span><br><span class="line">  <span class="keyword">let</span> baseString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(base &gt;= <span class="number">2</span> &amp;&amp; base &lt;= <span class="number">36</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(number % base);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / base);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    baseString += digits[remStack.pop()]; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ECMAScript 和 javascript 的关系&lt;br&gt;ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。&lt;/p&gt;
&lt;p&gt;ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式读书笔记(6)</title>
    <link href="https://sunjinkang.github.io/2022/09/20/about-design-model5/"/>
    <id>https://sunjinkang.github.io/2022/09/20/about-design-model5/</id>
    <published>2022-09-20T07:22:12.000Z</published>
    <updated>2022-09-23T06:59:38.606Z</updated>
    
    <content type="html"><![CDATA[<h4 id="架构型设计模式"><a href="#架构型设计模式" class="headerlink" title="架构型设计模式"></a>架构型设计模式</h4><p>架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。</p><h6 id="同步模块模式"><a href="#同步模块模式" class="headerlink" title="同步模块模式"></a>同步模块模式</h6><p>模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。<br>同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。</p><p>(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。</p><p><img src="/2022/09/20/about-design-model5/module-model-1.png" alt="module-model-1"><br><img src="/2022/09/20/about-design-model5/module-model-2.png" alt="module-model-2"><br><img src="/2022/09/20/about-design-model5/module-model-3.png" alt="module-model-3"><br><img src="/2022/09/20/about-design-model5/module-model-4.png" alt="module-model-4"><br><img src="/2022/09/20/about-design-model5/module-model-5.png" alt="module-model-5"></p><h6 id="异步模块模式"><a href="#异步模块模式" class="headerlink" title="异步模块模式"></a>异步模块模式</h6><p>异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。</p><p><img src="/2022/09/20/about-design-model5/async-module-model-1.png" alt="async-module-model-1"><br><img src="/2022/09/20/about-design-model5/async-module-model-2.png" alt="async-module-model-2"><br><img src="/2022/09/20/about-design-model5/async-module-model-3.png" alt="async-module-model-3"><br><img src="/2022/09/20/about-design-model5/async-module-model-4.png" alt="async-module-model-4"><br><img src="/2022/09/20/about-design-model5/async-module-model-5.png" alt="async-module-model-5"><br><img src="/2022/09/20/about-design-model5/async-module-model-6.png" alt="async-module-model-6"><br><img src="/2022/09/20/about-design-model5/async-module-model-7.png" alt="async-module-model-7"><br><img src="/2022/09/20/about-design-model5/async-module-model-8.png" alt="async-module-model-8"><br><img src="/2022/09/20/about-design-model5/async-module-model-9.png" alt="async-module-model-9"></p><h6 id="Widget模式"><a href="#Widget模式" class="headerlink" title="Widget模式"></a>Widget模式</h6><p>Widget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。</p><p><img src="/2022/09/20/about-design-model5/widget-model-1.png" alt="widget-model-1"><br><img src="/2022/09/20/about-design-model5/widget-model-2.png" alt="widget-model-2"><br><img src="/2022/09/20/about-design-model5/widget-model-3.png" alt="widget-model-3"><br><img src="/2022/09/20/about-design-model5/widget-model-4.png" alt="widget-model-4"><br><img src="/2022/09/20/about-design-model5/widget-model-5.png" alt="widget-model-5"><br><img src="/2022/09/20/about-design-model5/widget-model-6.png" alt="widget-model-6"></p><h6 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h6><p>MVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。</p><p><img src="/2022/09/20/about-design-model5/mvc-model-1.png" alt="mvc-model-1"></p><p><strong>每个对象是一个自动执行的函数</strong><br><strong>3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法</strong></p><p><img src="/2022/09/20/about-design-model5/mvc-model-2.png" alt="mvc-model-2"><br><img src="/2022/09/20/about-design-model5/mvc-model-3.png" alt="mvc-model-3"><br>视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口</p><p><img src="/2022/09/20/about-design-model5/mvc-model-4.png" alt="mvc-model-4"></p><h6 id="MVP模式"><a href="#MVP模式" class="headerlink" title="MVP模式"></a>MVP模式</h6><p>MVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。</p><p><img src="/2022/09/20/about-design-model5/mvp-model-1.png" alt="mvp-model-1"><br><img src="/2022/09/20/about-design-model5/mvp-model-2.png" alt="mvp-model-2"><br><img src="/2022/09/20/about-design-model5/mvp-model-3.png" alt="mvp-model-3"><br><img src="/2022/09/20/about-design-model5/mvp-model-4.png" alt="mvp-model-4"><br><img src="/2022/09/20/about-design-model5/mvp-model-5.png" alt="mvp-model-5"><br><img src="/2022/09/20/about-design-model5/mvp-model-6.png" alt="mvp-model-6"><br><img src="/2022/09/20/about-design-model5/mvp-model-7.png" alt="mvp-model-7"></p><p>MVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。</p><h6 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h6><p>MVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。</p><p><img src="/2022/09/20/about-design-model5/mvvm-model-1.png" alt="mvvm-model-1"><br><img src="/2022/09/20/about-design-model5/mvvm-model-2.png" alt="mvvm-model-2"><br><img src="/2022/09/20/about-design-model5/mvvm-model-3.png" alt="mvvm-model-3"><br><img src="/2022/09/20/about-design-model5/mvvm-model-4.png" alt="mvvm-model-4"><br><img src="/2022/09/20/about-design-model5/mvvm-model-5.png" alt="mvvm-model-5"><br><img src="/2022/09/20/about-design-model5/mvvm-model-6.png" alt="mvvm-model-6"><br><img src="/2022/09/20/about-design-model5/mvvm-model-7.png" alt="mvvm-model-7"><br><img src="/2022/09/20/about-design-model5/mvvm-model-8.png" alt="mvvm-model-8"></p><h6 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h6><p><img src="/2022/09/20/about-design-model5/appendix-1.png" alt="appendix-1"><br><img src="/2022/09/20/about-design-model5/appendix-2.png" alt="appendix-2"><br><img src="/2022/09/20/about-design-model5/appendix-3.png" alt="appendix-3"><br><img src="/2022/09/20/about-design-model5/appendix-4.png" alt="appendix-4"><br><img src="/2022/09/20/about-design-model5/appendix-5.png" alt="appendix-5"><br><img src="/2022/09/20/about-design-model5/appendix-6.png" alt="appendix-6"><br><img src="/2022/09/20/about-design-model5/appendix-7.png" alt="appendix-7"><br><img src="/2022/09/20/about-design-model5/appendix-8.png" alt="appendix-8"><br><img src="/2022/09/20/about-design-model5/appendix-9.png" alt="appendix-9"><br><img src="/2022/09/20/about-design-model5/appendix-10.png" alt="appendix-10"></p><p>疑问点：<br>(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice<br>编程方式区分，不要糅合在一起<br>对性能影响可以忽略不计</p><p>(2)有一些模式很像，一定需要做区分吗？<br>从实际场景触发，贴合场景选择设计模式<br>设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题</p><p>(3)柯理化<br>函数；<br>接受多个参数（一个参数没必要用柯理化）；<br>将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果<br>调用方式不一样。普通函数：函数名(参数1, 参数2, …);   柯理化：函数名(参数1)(参数2)…</p><p>对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;架构型设计模式&quot;&gt;&lt;a href=&quot;#架构型设计模式&quot; class=&quot;headerlink&quot; title=&quot;架构型设计模式&quot;&gt;&lt;/a&gt;架构型设计模式&lt;/h4&gt;&lt;p&gt;架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式读书笔记(5)</title>
    <link href="https://sunjinkang.github.io/2022/09/19/about-design-model4/"/>
    <id>https://sunjinkang.github.io/2022/09/19/about-design-model4/</id>
    <published>2022-09-19T09:51:10.000Z</published>
    <updated>2022-09-23T06:51:25.454Z</updated>
    
    <content type="html"><![CDATA[<h4 id="技巧型设计模式"><a href="#技巧型设计模式" class="headerlink" title="技巧型设计模式"></a>技巧型设计模式</h4><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。</p><h6 id="链模式"><a href="#链模式" class="headerlink" title="链模式"></a>链模式</h6><p>链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。</p><p><img src="/2022/09/19/about-design-model4/chain-model-1.png" alt="chain-model-1"><br><img src="/2022/09/19/about-design-model4/chain-model-2.png" alt="chain-model-2"><br><img src="/2022/09/19/about-design-model4/chain-model-3.png" alt="chain-model-3"></p><p>jOuery获取的元素更像一个数组，上面框架返回的更像是一个对象<br>原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了<br><img src="/2022/09/19/about-design-model4/chain-model-4.png" alt="chain-model-4"></p><p><img src="/2022/09/19/about-design-model4/chain-model-5.png" alt="chain-model-5"><br><img src="/2022/09/19/about-design-model4/chain-model-6.png" alt="chain-model-6"></p><h6 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h6><p>委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。</p><p>委托模式可以优化页面中事件的数量。</p><p>事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑</p><p><img src="/2022/09/19/about-design-model4/entrust-model-1.png" alt="entrust-model-1"><br><img src="/2022/09/19/about-design-model4/entrust-model-2.png" alt="entrust-model-2"></p><h6 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h6><p>数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。</p><p><img src="/2022/09/19/about-design-model4/localstorage-model-1.png" alt="localstorage-model-1"><br><img src="/2022/09/19/about-design-model4/localstorage-model-2.png" alt="localstorage-model-2"><br><img src="/2022/09/19/about-design-model4/localstorage-model-3.png" alt="localstorage-model-3"><br><img src="/2022/09/19/about-design-model4/localstorage-model-4.png" alt="localstorage-model-4"><br><img src="/2022/09/19/about-design-model4/localstorage-model-5.png" alt="localstorage-model-5"><br><img src="/2022/09/19/about-design-model4/localstorage-model-6.png" alt="localstorage-model-6"></p><h6 id="节流模式"><a href="#节流模式" class="headerlink" title="节流模式"></a>节流模式</h6><p>节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。</p><p><img src="/2022/09/19/about-design-model4/throttle-model-1.png" alt="throttle-model-1"><br><img src="/2022/09/19/about-design-model4/throttle-model-2.png" alt="throttle-model-2"><br><img src="/2022/09/19/about-design-model4/throttle-model-3.png" alt="throttle-model-3"></p><p>节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。</p><p>节流模式优势<br>(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行<br>(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。</p><h6 id="简单模板模式"><a href="#简单模板模式" class="headerlink" title="简单模板模式"></a>简单模板模式</h6><p>简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。</p><p><img src="/2022/09/19/about-design-model4/template-model-1.png" alt="template-model-1"><br><img src="/2022/09/19/about-design-model4/template-model-2.png" alt="template-model-2"><br><img src="/2022/09/19/about-design-model4/template-model-3.png" alt="template-model-3"><br><img src="/2022/09/19/about-design-model4/template-model-4.png" alt="template-model-4"><br><img src="/2022/09/19/about-design-model4/template-model-5.png" alt="template-model-5"><br><img src="/2022/09/19/about-design-model4/template-model-6.png" alt="template-model-6"></p><h6 id="惰性模式"><a href="#惰性模式" class="headerlink" title="惰性模式"></a>惰性模式</h6><p>惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。</p><p>两种实现方式<br>(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。<br>(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗</p><p><img src="/2022/09/19/about-design-model4/lazy-model-1.png" alt="lazy-model-1"><br><img src="/2022/09/19/about-design-model4/lazy-model-2.png" alt="lazy-model-2"><br><img src="/2022/09/19/about-design-model4/lazy-model-3.png" alt="lazy-model-3"><br><img src="/2022/09/19/about-design-model4/lazy-model-4.png" alt="lazy-model-4"><br><img src="/2022/09/19/about-design-model4/lazy-model-5.png" alt="lazy-model-5"><br><img src="/2022/09/19/about-design-model4/lazy-model-6.png" alt="lazy-model-6"></p><h6 id="参与者模式"><a href="#参与者模式" class="headerlink" title="参与者模式"></a>参与者模式</h6><p>参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。</p><p><img src="/2022/09/19/about-design-model4/participate-model-1.png" alt="participate-model-1"><br><img src="/2022/09/19/about-design-model4/participate-model-2.png" alt="participate-model-2"></p><p>函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能</p><p><img src="/2022/09/19/about-design-model4/participate-model-3.png" alt="participate-model-3"><br><img src="/2022/09/19/about-design-model4/participate-model-4.png" alt="participate-model-4"><br><img src="/2022/09/19/about-design-model4/participate-model-5.png" alt="participate-model-5"></p><p>参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化<br>(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。<br>(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。</p><p>随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用<br><img src="/2022/09/19/about-design-model4/participate-model-6.png" alt="participate-model-6"></p><h6 id="等待者模式"><a href="#等待者模式" class="headerlink" title="等待者模式"></a>等待者模式</h6><p>等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。</p><p><img src="/2022/09/19/about-design-model4/waiter-model-1.png" alt="waiter-model-1"><br><img src="/2022/09/19/about-design-model4/waiter-model-2.png" alt="waiter-model-2"><br><img src="/2022/09/19/about-design-model4/waiter-model-3.png" alt="waiter-model-3"><br><img src="/2022/09/19/about-design-model4/waiter-model-4.png" alt="waiter-model-4"><br><img src="/2022/09/19/about-design-model4/waiter-model-5.png" alt="waiter-model-5"><br><img src="/2022/09/19/about-design-model4/waiter-model-6.png" alt="waiter-model-6"><br><img src="/2022/09/19/about-design-model4/waiter-model-7.png" alt="waiter-model-7"><br><img src="/2022/09/19/about-design-model4/waiter-model-8.png" alt="waiter-model-8"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;技巧型设计模式&quot;&gt;&lt;a href=&quot;#技巧型设计模式&quot; class=&quot;headerlink&quot; title=&quot;技巧型设计模式&quot;&gt;&lt;/a&gt;技巧型设计模式&lt;/h4&gt;&lt;p&gt;技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式读书笔记(4)</title>
    <link href="https://sunjinkang.github.io/2022/09/07/about-design-model3/"/>
    <id>https://sunjinkang.github.io/2022/09/07/about-design-model3/</id>
    <published>2022-09-07T09:40:43.000Z</published>
    <updated>2022-09-22T09:17:06.427Z</updated>
    
    <content type="html"><![CDATA[<h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现</p><h6 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h6><p>模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。</p><p>多用于归一化组件</p><p><img src="/2022/09/07/about-design-model3/basic-model.png" alt="basic-model"><br><img src="/2022/09/07/about-design-model3/inherit-model.png" alt="inherit-model"><br><img src="/2022/09/07/about-design-model3/inherit-as-basic-model.png" alt="inherit-as-basic-model"></p><h6 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h6><p>观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p><p>观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法</p><p><img src="/2022/09/07/about-design-model3/observer.png" alt="observer"><br><img src="/2022/09/07/about-design-model3/observer-regist.png" alt="observer-regist"><br><img src="/2022/09/07/about-design-model3/observer-fire.png" alt="observer-fire"><br><img src="/2022/09/07/about-design-model3/observer-remove.png" alt="observer-remove"></p><p><img src="/2022/09/07/about-design-model3/regist-message.png" alt="regist-message"><br><img src="/2022/09/07/about-design-model3/regist-change-num.png" alt="regist-change-num"><br><img src="/2022/09/07/about-design-model3/add-message.png" alt="add-message"></p><h6 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h6><p>状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p><p>状态模式简化了分支判断遍历逻辑</p><p><img src="/2022/09/07/about-design-model3/vote-status.png" alt="vote-status"></p><p>示例<br>思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用<br><img src="/2022/09/07/about-design-model3/marry-state.png" alt="marry-state"><br><img src="/2022/09/07/about-design-model3/marry-state1.png" alt="marry-state1"></p><h6 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h6><p>策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p><p><strong>与状态模式异同点</strong><br>相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用<br>不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法</p><p><img src="/2022/09/07/about-design-model3/price-strategy.png" alt="price-strategy"></p><p><strong>策略模式的优点</strong><br>第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。<br>第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。<br>第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。</p><p><strong>策略模式的缺点</strong><br>由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。<br>由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费</p><p><strong>优化分支语句的模式</strong><br>工厂方法模式，状态模式与策略模式<br>工厂方法模式：一种创建型模式，最终目的是创建对象。<br>状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。<br>策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。</p><h6 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h6><p>职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。</p><p>示例<br><img src="/2022/09/07/about-design-model3/send-data.png" alt="send-data"><br><img src="/2022/09/07/about-design-model3/deal-data.png" alt="deal-data"><br><img src="/2022/09/07/about-design-model3/create-component.png" alt="create-component"></p><p><strong>缺点</strong><br>职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费<br>多个对象参与请求的传递，在代码调试时增加了调试成本</p><h6 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h6><p>命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。<br>命令模式常用于解耦<br><img src="/2022/09/07/about-design-model3/command-model-1.png" alt="command-model-1"><br><img src="/2022/09/07/about-design-model3/command-model-2.png" alt="command-model-2"><br><img src="/2022/09/07/about-design-model3/command-model-3.png" alt="command-model-3"></p><p>命令模式的优点:<br>解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。<br>命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。</p><p>命令模式的缺点:<br>命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。</p><h6 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h6><p>访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。</p><p><img src="/2022/09/07/about-design-model3/visitor-model.png" alt="visitor-model"></p><h6 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h6><p>中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。</p><p>(1)观察者模式与中介者模式的区别<br>相同点<br>都是通过消息的收发机制实现的<br>差异点<br>在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统<br>中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者</p><p><img src="/2022/09/07/about-design-model3/mediator-model.png" alt="mediator-model"></p><h6 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h6><p>备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。</p><p><img src="/2022/09/07/about-design-model3/cache-model.png" alt="cache-model"></p><h6 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h6><p>迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p><p><img src="/2022/09/07/about-design-model3/iterator-model.png" alt="iterator-model"></p><h6 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h6><p>解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p><p><img src="/2022/09/07/about-design-model3/explain-model-1.png" alt="explain-model-1"><br><img src="/2022/09/07/about-design-model3/explain-model-2.png" alt="explain-model-2"><br><img src="/2022/09/07/about-design-model3/explain-model-3.png" alt="explain-model-3"></p><p>解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是<strong>能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的</strong>。因为解释器要按照这套规则才能实现相应的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;行为型设计模式&quot;&gt;&lt;a href=&quot;#行为型设计模式&quot; class=&quot;headerlink&quot; title=&quot;行为型设计模式&quot;&gt;&lt;/a&gt;行为型设计模式&lt;/h4&gt;&lt;p&gt;行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式读书笔记(3)</title>
    <link href="https://sunjinkang.github.io/2022/09/06/about-design-model2/"/>
    <id>https://sunjinkang.github.io/2022/09/06/about-design-model2/</id>
    <published>2022-09-06T07:11:48.000Z</published>
    <updated>2022-09-22T09:16:44.404Z</updated>
    
    <content type="html"><![CDATA[<h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计</p><h6 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h6><p>外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用</p><p>多用于兼容模式<br><img src="/2022/09/06/about-design-model2/out-look.png" alt="out-look"></p><h6 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h6><p>适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决</p><p>(1)适配异类框架<br>(2)参数适配器：通常是以一个参数对象方式传入<br>(3)数据适配<br>比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等<br>(4)服务端数据适配<br>获取接口的数据，先做一个适配，再使用统一的处理方法</p><h6 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h6><p>代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用</p><p><strong>代理对象</strong><br>(1)img之类的标签通过src属性可以向其他域下的服务器发送请求<br>缺点：请求是get请求，且是单向的，不会有响应数据<br>示例：站长统计<br><img src="/2022/09/06/about-design-model2/station-culculate.png" alt="station-culculate"></p><p>(2)JSONP<br>通过script标签<br>需要其他域下的服务端配合前端做出针对处理</p><p>(3)代理模板<br>不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A</p><h6 id="装修者模式"><a href="#装修者模式" class="headerlink" title="装修者模式"></a>装修者模式</h6><p>装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求<br><img src="/2022/09/06/about-design-model2/decorator.png" alt="decorator"></p><p><strong>适配器与装修者的区别</strong><br>适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节<br>装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用</p><h6 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h6><p>桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦</p><p>先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用</p><p><img src="/2022/09/06/about-design-model2/bridge1.png" alt="bridge1"><br><img src="/2022/09/06/about-design-model2/bridge2.png" alt="bridge2"><br><img src="/2022/09/06/about-design-model2/bridge3.png" alt="bridge3"></p><p>桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化</p><h6 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h6><p>组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>组合模式常用语创建表单。</p><h6 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h6><p>享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p><p>享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。</p><p>在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;结构型设计模式&quot;&gt;&lt;a href=&quot;#结构型设计模式&quot; class=&quot;headerlink&quot; title=&quot;结构型设计模式&quot;&gt;&lt;/a&gt;结构型设计模式&lt;/h4&gt;&lt;p&gt;结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计&lt;/p&gt;
&lt;h6 id=&quot;外观</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Object获取及设置原型对象</title>
    <link href="https://sunjinkang.github.io/2022/09/05/get-and-set-prototypeof/"/>
    <id>https://sunjinkang.github.io/2022/09/05/get-and-set-prototypeof/</id>
    <published>2022-09-05T05:54:58.000Z</published>
    <updated>2022-09-05T06:42:22.960Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Object获取原型对象：Object-getPrototypeOf"><a href="#Object获取原型对象：Object-getPrototypeOf" class="headerlink" title="Object获取原型对象：Object.getPrototypeOf"></a>Object获取原型对象：Object.getPrototypeOf</h6><p>Object.getPrototypeOf用于获取指定对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure><p><strong>参数</strong><br>obj: 参数为要获取原型对象的对象<br><strong>返回值</strong><br>返回指定对象的原型对象或null<br>注意：<br>es5中，如果参数不是对象，会抛出TypeError错误<br>es6中，如果参数不是对象，会强制类型转换为对象<br><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="string">&#x27;12&#x27;</span>) === <span class="built_in">String</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="number">12</span>) === <span class="built_in">Number</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) === <span class="built_in">Boolean</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Symbol</span>(<span class="string">&#x27;test&#x27;</span>)) === <span class="built_in">Symbol</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="literal">null</span>)); <span class="comment">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="literal">undefined</span>)); <span class="comment">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对没有原型对象的对象进行操作</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj)); <span class="comment">// null</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj)); <span class="comment">// Uncaught TypeError: Object prototype may only be an Object or null: undefined</span></span><br></pre></td></tr></table></figure><h6 id="Object修改原型对象-Object-setPrototypeOf"><a href="#Object修改原型对象-Object-setPrototypeOf" class="headerlink" title="Object修改原型对象: Object.setPrototypeOf"></a>Object修改原型对象: Object.setPrototypeOf</h6><p>Object.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br></pre></td></tr></table></figure><p><strong>参数</strong><br>obj: 要设置原型对象的对象<br>proto: 要设置的新原型对象或null，未设置时抛出TypeError错误</p><p><strong>返回值</strong><br>设置了新原型对象的对象</p><p>注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象</p><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(newObj, obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj.name); <span class="comment">// &#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> otherObj = &#123; <span class="attr">age</span>: <span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newObj) === obj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(newObj, otherObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newObj) === obj); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newObj) === otherObj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.age); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;Object获取原型对象：Object-getPrototypeOf&quot;&gt;&lt;a href=&quot;#Object获取原型对象：Object-getPrototypeOf&quot; class=&quot;headerlink&quot; title=&quot;Object获取原型对象：Object.getP</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开发中使用的便捷代码</title>
    <link href="https://sunjinkang.github.io/2022/09/05/some-convenient-code/"/>
    <id>https://sunjinkang.github.io/2022/09/05/some-convenient-code/</id>
    <published>2022-09-05T05:24:10.000Z</published>
    <updated>2022-09-05T05:42:03.830Z</updated>
    
    <content type="html"><![CDATA[<h6 id="基于条件设置对象属性"><a href="#基于条件设置对象属性" class="headerlink" title="基于条件设置对象属性"></a>基于条件设置对象属性</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空值</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="comment">// 非空值</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;test_name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; name: &#x27;test_name&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h6 id="无中间变量交换变量值"><a href="#无中间变量交换变量值" class="headerlink" title="无中间变量交换变量值"></a>无中间变量交换变量值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one = <span class="string">&#x27;12&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> two = <span class="string">&#x27;34&#x27;</span>;</span><br><span class="line">[one, two] = [two, one];</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// &#x27;34&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure><h6 id="过滤Boolean值为false的值"><a href="#过滤Boolean值为false的值" class="headerlink" title="过滤Boolean值为false的值"></a>过滤Boolean值为false的值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>, <span class="literal">false</span>, <span class="number">12</span>, <span class="literal">true</span>, <span class="string">&#x27;12&#x27;</span>, <span class="literal">undefined</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">8</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [12, true, &#x27;12&#x27;, 8]</span></span><br></pre></td></tr></table></figure><h6 id="转换元素类型"><a href="#转换元素类型" class="headerlink" title="转换元素类型"></a>转换元素类型</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Number类型转换为String</span></span><br><span class="line"><span class="keyword">const</span> string = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>].map(<span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;]</span></span><br><span class="line"><span class="comment">// 将String类型转换为Number</span></span><br><span class="line"><span class="keyword">const</span> string = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;12&#x27;</span>].map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// [1, 2, 3, 12]</span></span><br></pre></td></tr></table></figure><h6 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatArray = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(repeatArray)];</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;基于条件设置对象属性&quot;&gt;&lt;a href=&quot;#基于条件设置对象属性&quot; class=&quot;headerlink&quot; title=&quot;基于条件设置对象属性&quot;&gt;&lt;/a&gt;基于条件设置对象属性&lt;/h6&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;tab</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式读书笔记(2)</title>
    <link href="https://sunjinkang.github.io/2022/09/04/about-design-model1/"/>
    <id>https://sunjinkang.github.io/2022/09/04/about-design-model1/</id>
    <published>2022-09-04T13:29:09.000Z</published>
    <updated>2022-09-22T09:16:30.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度</p><h6 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h6><p>(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。<br><img src="/2022/09/04/about-design-model1/simple-factory1.png" alt="simple-factory1"><br><img src="/2022/09/04/about-design-model1/simple-factory2.png" alt="simple-factory2"></p><p>(2)一个对象有时也可代替许多类<br><img src="/2022/09/04/about-design-model1/create-pop.png" alt="create-pop"></p><p>第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了</p><h6 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h6><p>安全模式类：可以屏蔽使用这对类的错误使用造成的错误<br><img src="/2022/09/04/about-design-model1/safe-model-class.png" alt="safe-model-class"><br><img src="/2022/09/04/about-design-model1/safe-factory-model.png" alt="safe-factory-model"></p><h6 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h6><p>抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例</p><p>(1)抽象类<br>抽象类是一种声明但不能使用的类<br><img src="/2022/09/04/about-design-model1/abstract-car.png" alt="abstract-car"><br>创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类<br>中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。</p><p>(2)抽象工厂模式：一般用它来作为父类创建一些子类<br><img src="/2022/09/04/about-design-model1/abstract-factory1.png" alt="abstract-factory1"><br><img src="/2022/09/04/about-design-model1/abstract-factory2.png" alt="abstract-factory2"><br>抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck<br><img src="/2022/09/04/about-design-model1/abstract-factory3.png" alt="abstract-factory3"></p><h6 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h6><p>建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示</p><p>工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。<br>建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节<br><img src="/2022/09/04/about-design-model1/human.png" alt="human"><br><img src="/2022/09/04/about-design-model1/name.png" alt="name"><br><img src="/2022/09/04/about-design-model1/work.png" alt="work"><br><img src="/2022/09/04/about-design-model1/person.png" alt="person"></p><p>工厂模式创建出来的是一个对象，它追求的是创建的结果<br>建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象</p><p><strong>注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象</strong></p><h6 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h6><p>原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法</p><p>原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法<br><img src="/2022/09/04/about-design-model1/prototype-model.png" alt="prototype-model"><br>原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法</p><p>(1)原型继承<br>原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法<br><img src="/2022/09/04/about-design-model1/prototype-inherit1.png" alt="prototype-inherit1"><br><img src="/2022/09/04/about-design-model1/prototype-inherit2.png" alt="prototype-inherit2"></p><p><strong>原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现</strong></p><h6 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h6><p>单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法</p><p>(1)命名空间<br>命名空间就是人们所说的namespace，有人也叫它名称空间。<br>它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题</p><p>(2)静态变量<br><img src="/2022/09/04/about-design-model1/static-param.png" alt="static-param"></p><p>(3)惰性单例<br><img src="/2022/09/04/about-design-model1/lazy-single-instance.png" alt="lazy-single-instance"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;创建型设计模式&quot;&gt;&lt;a href=&quot;#创建型设计模式&quot; class=&quot;headerlink&quot; title=&quot;创建型设计模式&quot;&gt;&lt;/a&gt;创建型设计模式&lt;/h4&gt;&lt;p&gt;创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>es6对象增强</title>
    <link href="https://sunjinkang.github.io/2022/09/02/es6-object-strong/"/>
    <id>https://sunjinkang.github.io/2022/09/02/es6-object-strong/</id>
    <published>2022-09-02T02:42:05.000Z</published>
    <updated>2022-09-02T05:49:32.109Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h4><p>(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &#x27;test&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">const</span> es5Obj = &#123;</span><br><span class="line">  <span class="attr">testFunction</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;es5&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es5Obj.testFunction()); <span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> es6Obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">testFunction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;es6&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es6Obj.testFunction()); <span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// **注意：只有赋值的是匿名函数，才可以使用简介语法**</span></span><br><span class="line"><span class="keyword">const</span> es6Obj1 = &#123;</span><br><span class="line">  <span class="attr">testFunction</span>: <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es6Obj1.testFunction()); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p><strong>常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位</strong></p><p>(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> es6Obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;first&#x27;</span> + <span class="string">&#x27;second&#x27;</span>]: <span class="string">&#x27;hanmeimei&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es6Obj[<span class="string">&#x27;first&#x27;</span> + <span class="string">&#x27;second&#x27;</span>]); <span class="comment">// hanmeimei</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> first = <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> es6Obj1 = &#123;</span><br><span class="line">  [first + <span class="string">&#x27;second&#x27;</span>]: <span class="string">&#x27;hanmeimei&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es6Obj[first + <span class="string">&#x27;second&#x27;</span>]); <span class="comment">// hanmeimei</span></span><br></pre></td></tr></table></figure><p>(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> es6Obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(es6Obj); <span class="comment">// &#123;name: &#x27;second&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h4><p>(1)Object.is()<br>作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(2)Object.assign()<br>作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.assign(target, ...sources);  target为目标对象  sources为源对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget); <span class="comment">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure><p>(3)Object.setPrototypeOf()<br>作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.setPrototypeOf(object, prototypeObject);</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// obj 链接到person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, person);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// hello</span></span><br><span class="line"><span class="comment">// obj 链接到dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, dog);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// woof</span></span><br></pre></td></tr></table></figure><p>当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;obj&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, person);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// obj</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, dog);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p>在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.greeting() + <span class="string">&#x27;obj&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, person);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// helloobj</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, dog);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// woofobj</span></span><br></pre></td></tr></table></figure><p>对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: ‘super’ keyword unexpected here<br><strong>为什么？？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="comment">// 以下写法报错：Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line"> <span class="attr">greeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.greeting() + <span class="string">&#x27;obj&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, person);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting());</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, dog);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="comment">// 以下方法可以正常运行</span></span><br><span class="line"> <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.greeting() + <span class="string">&#x27;obj&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, person);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// helloobj</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, dog);</span><br><span class="line"><span class="built_in">console</span>.log(obj.greeting()); <span class="comment">// woofobj</span></span><br></pre></td></tr></table></figure><p><strong>在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;对象字面量语法扩展&quot;&gt;&lt;a href=&quot;#对象字面量语法扩展&quot; class=&quot;headerlink&quot; title=&quot;对象字面量语法扩展&quot;&gt;&lt;/a&gt;对象字面量语法扩展&lt;/h4&gt;&lt;p&gt;(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式读书笔记(1)</title>
    <link href="https://sunjinkang.github.io/2022/08/20/about-design-model/"/>
    <id>https://sunjinkang.github.io/2022/08/20/about-design-model/</id>
    <published>2022-08-20T06:47:46.000Z</published>
    <updated>2022-09-22T09:15:58.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>一、面向过程与面向对象<br>面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里<br>二、封装<br>1、使用原型(prototype)为类添加属性和方法的两种方式(<strong>注意两种不能混用</strong>)：<br>(1)为原型对象属性赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book.prototype.display = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)将一个对象赋值给类的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book.prototype = &#123;</span><br><span class="line">  display = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用this和原型(prototype)为类添加属性和方法的区别：<br>(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建<br>(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法</p><p>3、constructor是什么？<br>constructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。<br><img src="/2022/08/20/about-design-model/prototype.png" alt="prototype"></p><p>4、属性与方法的封装<br>(1)私有属性与私有方法<br>由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法<br>(2)共有属性和共有方法<br>在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法<br>(3)特权方法(类的构造器)<br>通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器<br><img src="/2022/08/20/about-design-model/public-and-private.png" alt="public-and-private"></p><p>5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用<br>(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法<br>(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法<br><img src="/2022/08/20/about-design-model/static-and-public.png" alt="static-and-public"><br>通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。</p><p>6、闭包<br>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量</p><p>7、创建对象的安全模式<br>new关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量<br><img src="/2022/08/20/about-design-model/safe-model.png" alt="safe-model"></p><p>三、继承<br>1、子类的原型对象 - 类式继承<br><img src="/2022/08/20/about-design-model/class-inherit.png" alt="class-inherit"><br>声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型<br>类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。<br>新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理</p><p>(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类<br>注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构<br><strong>instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass</strong></p><p>(2)类式继承的缺点<br>其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类<br>其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</p><p>2、创建即继承 - 构造函数继承<br><img src="/2022/08/20/about-design-model/constructor-inherit.png" alt="constructor-inherit"><br>SuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则</p><p>3、将优点为我所用 - 组合继承<br>(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的<br><img src="/2022/08/20/about-design-model/combination-inherit.png" alt="combination-inherit"><br>在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式<br>(2)缺点<br>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍</p><p>4、洁净的继承者 - 原型式继承<br><img src="/2022/08/20/about-design-model/prototype-inherit.png" alt="prototype-inherit"><br>对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象<br><img src="/2022/08/20/about-design-model/test-prototype-inherit.png" alt="test-prototype-inherit"></p><p>5、如虎添翼 - 寄生式继承<br><img src="/2022/08/20/about-design-model/parasitic-inherit.png" alt="parasitic-inherit"><br>寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法</p><p>6、终极继承者 - 寄生组合式继承<br>寄生式继承和构造函数继承</p><p>寄生式继承的改造<br><img src="/2022/08/20/about-design-model/parasitic-inherit-change.png" alt="parasitic-inherit-change"></p><p><img src="/2022/08/20/about-design-model/parasitic-combination-inherit.png" alt="parasitic-combination-inherit"></p><p><img src="/2022/08/20/about-design-model/how-to-inherit.png" alt="how-to-inherit"></p><p><strong>子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象</strong></p><p>四、多继承<br>单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性<br><img src="/2022/08/20/about-design-model/multiple-inherit.png" alt="multiple-inherit"></p><p>五、多态<br>同一个方法多种调用方式<br><img src="/2022/08/20/about-design-model/multiple-status.png" alt="multiple-status"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h4&gt;&lt;p&gt;一、面向过程与面向对象&lt;br&gt;面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基本数据类型-Symbol</title>
    <link href="https://sunjinkang.github.io/2022/08/19/about-symbol/"/>
    <id>https://sunjinkang.github.io/2022/08/19/about-symbol/</id>
    <published>2022-08-19T05:37:24.000Z</published>
    <updated>2022-08-19T05:42:42.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Symbol"><a href="#什么是Symbol" class="headerlink" title="什么是Symbol?"></a>什么是Symbol?</h4><h4 id="有什么用处？"><a href="#有什么用处？" class="headerlink" title="有什么用处？"></a>有什么用处？</h4><h4 id="Symbol的属性"><a href="#Symbol的属性" class="headerlink" title="Symbol的属性"></a>Symbol的属性</h4><h4 id="Symbol的方法"><a href="#Symbol的方法" class="headerlink" title="Symbol的方法"></a>Symbol的方法</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是Symbol&quot;&gt;&lt;a href=&quot;#什么是Symbol&quot; class=&quot;headerlink&quot; title=&quot;什么是Symbol?&quot;&gt;&lt;/a&gt;什么是Symbol?&lt;/h4&gt;&lt;h4 id=&quot;有什么用处？&quot;&gt;&lt;a href=&quot;#有什么用处？&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sunjinkang.github.io/2022/08/11/js-transform/js-transform/"/>
    <id>https://sunjinkang.github.io/2022/08/11/js-transform/js-transform/</id>
    <published>2022-08-11T05:19:34.637Z</published>
    <updated>2022-08-11T09:29:33.722Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>  </head>  <body>    <script>      console.log(`1 - true: ${1 - true}`);      console.log(`1 - false: ${1 - false}`);      console.log(`1 - null: ${1 - null}`);      console.log(`1 - undefined: ${1 - undefined}`);      console.log(`2 * ['5']: ${2 * ['5']}`);      console.log(`123 + '123': ${123 + '123'}`);      console.log(`123 + null: ${123 + null}`);      console.log(`123 + true: ${123 + true}`);      console.log(`123 + {}: ${123 + {}}`);      console.log(`NaN == NaN: ${NaN == NaN}`);      console.log(`true == 1: ${true == 1}`);      console.log(`true == '2': ${true == '2'}`);      console.log(`true == ['1']: ${true == ['1']}`);      console.log(`true == ['2']: ${true == ['2']}`);      console.log(`undefined == false: ${undefined == false}`);      console.log(`null == false: ${null == false}`);      console.log(`123 == '123': ${123 == '123'}`);      console.log(`'' == 0: ${'' == 0}`);      console.log(`null == undefined: ${null == undefined}`); // true      console.log(`null == '': ${null == ''}`); // false      console.log(`null == 0: ${null == 0}`); // false      console.log(`null == false: ${null == false}`); // false      console.log(`undefined == '': ${undefined == ''}`); // false      console.log(`undefined == 0: ${undefined == 0}`); // false      console.log(`undefined == false: ${undefined == false}`); // false      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true      console.log(`'10' > '2': ${'10' > '2'}`); // false    </script>  </body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta nam</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>装箱拆箱操作</title>
    <link href="https://sunjinkang.github.io/2022/08/09/devan-operation/"/>
    <id>https://sunjinkang.github.io/2022/08/09/devan-operation/</id>
    <published>2022-08-09T05:43:57.000Z</published>
    <updated>2022-08-18T07:29:53.069Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。</p><h4 id="什么是装箱拆箱？"><a href="#什么是装箱拆箱？" class="headerlink" title="什么是装箱拆箱？"></a>什么是装箱拆箱？</h4><p>装箱：把基本数据类型转化为对应的引用类型的操作<br>拆箱：把引用类型转化为基本数据类型的操作</p><p>基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)<br>四个基本的包装类型 String、Number、Boolean、Symbol</p><p>什么是包装类型？<br>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型</p><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>装箱分为显式装箱和隐式装箱</p><h6 id="显式装箱"><a href="#显式装箱" class="headerlink" title="显式装箱"></a>显式装箱</h6><p>通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;test_string&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> number = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;test_string&#x27;</span>);</span><br><span class="line">string.name = <span class="string">&#x27;for test&#x27;</span>;</span><br><span class="line">string.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is test string&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(string.name); <span class="comment">// for test</span></span><br><span class="line">string.sayHi(); <span class="comment">// this is test string</span></span><br></pre></td></tr></table></figure><h6 id="隐式装箱"><a href="#隐式装箱" class="headerlink" title="隐式装箱"></a>隐式装箱</h6><p>隐式装箱是引擎自动执行的<br>基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：’test_string’.substring()、’test_string’.indexOf()等，这是由于浏览器在内部做了隐式装箱。</p><p>下面以一个例子进行说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;test_string&#x27;</span>;</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line"><span class="keyword">var</span> result = string.substring(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// _string</span></span><br></pre></td></tr></table></figure><p>在上面这段代码里面实际的执行步骤是：<br>1、先创建一个String类型的一个实例<br>2、在实例中调用方法<br>3、销毁这个实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;test_string&#x27;</span>;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> newString = <span class="keyword">new</span> <span class="built_in">String</span>(string);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> result = newString.substring(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">newString = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>基于以上的隐式装箱操作，我们可以在基本类型上使用方法<br>隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了</p><p>显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法</p><p>引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。</p><h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。<br>需要注意的是，toString() 和 valueOf() 返回的值有一定差别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">var</span> stringObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;64&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> stringObj); <span class="comment">// object</span></span><br><span class="line"><span class="comment">// 拆箱</span></span><br><span class="line"><span class="built_in">console</span>.log(numberObj.valueOf()); <span class="comment">// 64</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObj.valueOf()); <span class="comment">// number 基本的数字类型</span></span><br><span class="line"><span class="built_in">console</span>.log(numberObj.toString()); <span class="comment">// &#x27;64&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObj.toString()); <span class="comment">// string 基本的字符类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringObj.valueOf()); <span class="comment">// &#x27;64&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> stringObj.valueOf()); <span class="comment">// string 基本的数据类型</span></span><br><span class="line"><span class="built_in">console</span>.log(stringObj.toString()); <span class="comment">// &#x27;64&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> stringObj.toString()); <span class="comment">// string 基本的数据类型</span></span><br></pre></td></tr></table></figure><p>在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。</p><p>这里简单介绍一下Symbol，感兴趣的可以自己去学习。</p><h6 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h6><p>Symbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突<br>创建Symbol</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意：<br>1、每次调用Symbol都会创建新的symbol<br>2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）<br>3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身<br>4、创建Symbol包装器对象，可以使用Object()函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>) === <span class="built_in">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> sym2; <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">let</span> sym2Obj = <span class="built_in">Object</span>(sym2);</span><br><span class="line"><span class="keyword">typeof</span> sym2Obj; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">symbol的文档</a>中，有一个属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">Symbol.toPrimitive</a>。文档中关于它的介绍是：</p><p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 “number”、”string” 和 “default” 中的任意一个。</p><p>我们看一下这个属性是怎么干扰一个对象转换为原始值的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj1);     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj1&#125;</span>`</span>); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 + <span class="string">&quot;&quot;</span>); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(+obj2);     <span class="comment">// 10      -- hint 参数值是 &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj2&#125;</span>`</span>); <span class="comment">// &quot;hello&quot; -- hint 参数值是 &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2 + <span class="string">&quot;&quot;</span>); <span class="comment">// &quot;true&quot;  -- hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<br>hint 取值为：<br>‘number’:该场合需要转成数值，<br>‘string’:该场合需要转成字符串，<br>‘default’:该场合可以转成数值，也可以转成字符串。</p><h4 id="对象转换成原始值的方法及执行顺序"><a href="#对象转换成原始值的方法及执行顺序" class="headerlink" title="对象转换成原始值的方法及执行顺序"></a>对象转换成原始值的方法及执行顺序</h4><p>以下优先级从上到下依次降低<br>1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法<br>2、如果预期被转化成字符串类型时，则优先执行toString()方法<br>3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法<br>注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(hint);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;valueOf&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj)); <span class="comment">// string symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(obj)); <span class="comment">// number NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;valueOf&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj1)); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(obj1)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj2)); <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(obj2)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(obj3)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj3)); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。&lt;/p&gt;
&lt;h4 id=&quot;什么是装箱拆箱？&quot;&gt;&lt;a href=&quot;#什么是装箱拆箱？&quot; class=&quot;headerlin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开发一个vscode插件的流程</title>
    <link href="https://sunjinkang.github.io/2022/08/05/create-vscode-plugin/"/>
    <id>https://sunjinkang.github.io/2022/08/05/create-vscode-plugin/</id>
    <published>2022-08-05T02:33:23.000Z</published>
    <updated>2022-08-05T06:08:56.829Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vscode中文手册"><a href="#vscode中文手册" class="headerlink" title="vscode中文手册"></a>vscode中文手册</h4><p><a href="https://www.bookstack.cn/read/CN-VScode-Docs/README.md">https://www.bookstack.cn/read/CN-VScode-Docs/README.md</a></p><h4 id="vscode插件脚手架"><a href="#vscode插件脚手架" class="headerlink" title="vscode插件脚手架"></a>vscode插件脚手架</h4><p>安装脚手架和代码生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br></pre></td></tr></table></figure><p>生成vscode脚手架项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;vscode中文手册&quot;&gt;&lt;a href=&quot;#vscode中文手册&quot; class=&quot;headerlink&quot; title=&quot;vscode中文手册&quot;&gt;&lt;/a&gt;vscode中文手册&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.bookstack.cn/read</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Map 结构</title>
    <link href="https://sunjinkang.github.io/2022/08/04/about-map/"/>
    <id>https://sunjinkang.github.io/2022/08/04/about-map/</id>
    <published>2022-08-04T06:07:12.000Z</published>
    <updated>2022-08-04T07:31:23.549Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map?"></a>什么是Map?</h4><p>由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。</p><h4 id="怎么创建map？"><a href="#怎么创建map？" class="headerlink" title="怎么创建map？"></a>怎么创建map？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>map可以使用一个对象作为键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">p</span>: <span class="string">&#x27;string&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">map.set(o, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">map.get(o); <span class="comment">// text</span></span><br><span class="line"></span><br><span class="line">map.has(o); <span class="comment">// true</span></span><br><span class="line">map.delete(o);</span><br></pre></td></tr></table></figure><p>map还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>]]);</span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;age&#x27;</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>如果对同一个键多次赋值，后面的值将覆盖前面的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.set(<span class="number">1</span>, <span class="string">&#x27;qw&#x27;</span>).set(<span class="number">1</span>, <span class="string">&#x27;sdf&#x27;</span>);</span><br><span class="line">map.get(<span class="number">1</span>); <span class="comment">// sdf</span></span><br></pre></td></tr></table></figure><h4 id="map的实例属性和方法"><a href="#map的实例属性和方法" class="headerlink" title="map的实例属性和方法"></a>map的实例属性和方法</h4><p>1、size<br>用法：map.size<br>作用：获取map结构的大小<br>返回：map结构的长度大小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.size; <span class="comment">// 0</span></span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">map.size; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>2、set()<br>用法：map.set(key, value)<br>作用：向map中添加或修改map的数据<br>返回：修改后的map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>3、get()<br>用法：map.get(key)<br>作用：获取对应key的value值<br>返回：map结构中key对应的值，不存在对应key时，返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">map.get(<span class="number">1</span>); <span class="comment">// 12</span></span><br><span class="line">map.get(<span class="number">2</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>4、has()<br>用法：map.has(key)<br>作用：判断map中是否有对应的key<br>返回：true/false，依据map中是否有对应的key，返回true或false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">map.has(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">map.has(<span class="number">2</span>); <span class="comment">// has</span></span><br></pre></td></tr></table></figure><p>5、delete()<br>用法：map.delete(key)<br>作用：删除map中对应的key及value<br>返回：true/false，删除成功返回true，删除失败返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">map.delete(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">map.delete(<span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>6、clear()<br>用法：map.clear()<br>作用：清空map中的数据<br>返回：undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">map.clear(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="map的遍历方法"><a href="#map的遍历方法" class="headerlink" title="map的遍历方法"></a>map的遍历方法</h4><p>1、keys()<br>2、values()<br>3、entries()<br>4、forEach()</p><p>参考：<a href="https://www.jianshu.com/p/93b5a5940de8">https://www.jianshu.com/p/93b5a5940de8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是Map&quot;&gt;&lt;a href=&quot;#什么是Map&quot; class=&quot;headerlink&quot; title=&quot;什么是Map?&quot;&gt;&lt;/a&gt;什么是Map?&lt;/h4&gt;&lt;p&gt;由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，ma</summary>
      
    
    
    
    
  </entry>
  
</feed>
