<h1 id="Co"><a href="#Co" class="headerlink" title="Co"></a>Co</h1><p>  <a href="https://travis-ci.org/visionmedia/co"><img src="https://travis-ci.org/visionmedia/co.svg?branch=master" alt="Build Status"></a></p>
<p>  Generator based flow-control goodness for nodejs and the browser, using<br>  thunks <em>or</em> promises, letting you write non-blocking code in a nice-ish<br>  way.</p>
<p>  Co is careful to relay any errors that occur back to the generator, including those<br>  within the thunk, or from the thunk’s callback. “Uncaught” exceptions in the generator<br>  are passed to <code>co()</code>‘s thunk.</p>
<p>  Make sure to view the <a href="https://github.com/visionmedia/co/tree/master/examples">examples</a>.</p>
<h2 id="Platform-Compatibility"><a href="#Platform-Compatibility" class="headerlink" title="Platform Compatibility"></a>Platform Compatibility</h2><p>  When using node 0.11.x or greater, you must use the <code>--harmony-generators</code><br>  flag or just <code>--harmony</code> to get access to generators.</p>
<p>  When using node 0.10.x and lower or browsers without generator support,<br>  you must use <a href="https://github.com/TooTallNate/gnode">gnode</a> and/or <a href="http://facebook.github.io/regenerator/">regenerator</a>.</p>
<p>  When using node 0.8.x and lower or browsers without <code>setImmediate</code>,<br>  you must include a <code>setImmediate</code> polyfill.<br>  For a really simple polyfill, you may use <a href="https://github.com/component/setimmediate.js">component/setimmediate.js</a>.<br>  For a more robust polyfill, you may use <a href="https://github.com/YuzuJS/setImmediate">YuzuJS/setImmediate</a>.</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><pre><code>$ npm install co
</code></pre>
<h2 id="Associated-libraries"><a href="#Associated-libraries" class="headerlink" title="Associated libraries"></a>Associated libraries</h2><p>  View the <a href="https://github.com/visionmedia/co/wiki">wiki</a> for libraries that<br>  work well with Co.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="js">var co = require(&#39;co&#39;);
var thunkify = require(&#39;thunkify&#39;);
var request = require(&#39;request&#39;);
var get = thunkify(request.get);

co(function *(){
  var a = yield get(&#39;http://google.com&#39;);
  var b = yield get(&#39;http://yahoo.com&#39;);
  var c = yield get(&#39;http://cloudup.com&#39;);
  console.log(a[0].statusCode);
  console.log(b[0].statusCode);
  console.log(c[0].statusCode);
})()

co(function *(){
  var a = get(&#39;http://google.com&#39;);
  var b = get(&#39;http://yahoo.com&#39;);
  var c = get(&#39;http://cloudup.com&#39;);
  var res = yield [a, b, c];
  console.log(res);
})()

// Error handling

co(function *(){
  try {
    var res = yield get(&#39;http://badhost.invalid&#39;);
    console.log(res);
  } catch(e) {
    console.log(e.code) // ENOTFOUND
 }
})()
</code></pre>
<h2 id="Yieldables"><a href="#Yieldables" class="headerlink" title="Yieldables"></a>Yieldables</h2><p>  The “yieldable” objects currently supported are:</p>
<ul>
<li>promises</li>
<li>thunks (functions)</li>
<li>array (parallel execution)</li>
<li>objects (parallel execution)</li>
<li>generators (delegation)</li>
<li>generator functions (delegation)</li>
</ul>
<p>To convert a regular node function that accepts a callback into one which returns a thunk you may want to use <a href="https://github.com/visionmedia/node-thunkify">thunkify</a> or similar.</p>
<h2 id="Thunks-vs-promises"><a href="#Thunks-vs-promises" class="headerlink" title="Thunks vs promises"></a>Thunks vs promises</h2><p>  While co supports promises, you may return “thunks” from your functions,<br>  which otherwise behaves just like the traditional node-style callback<br>  with a signature of: <code>(err, result)</code>.</p>
<p>  For example take <code>fs.readFile</code>, we all know the signature is:</p>
<pre><code class="js">fs.readFile(path, encoding, function(err, result){

});
</code></pre>
<p>  To work with Co we need a function to return another function of<br>  the same signature:</p>
<pre><code class="js">fs.readFile(path, encoding)(function(err, result){

});
</code></pre>
<p>  Which basically looks like this:</p>
<pre><code class="js">function read(path, encoding) {
  return function(cb){
    fs.readFile(path, encoding, cb);
  }
}
</code></pre>
<p>  or to execute immediately like this (see <a href="https://github.com/visionmedia/node-thunkify"><code>thunkify</code></a>):</p>
<pre><code class="js">function read(path, encoding) {
  // call fs.readFile immediately, store result later
  return function(cb){
    // cb(err, result) or when result ready
  }
}
</code></pre>
<h2 id="Receiver-propagation"><a href="#Receiver-propagation" class="headerlink" title="Receiver propagation"></a>Receiver propagation</h2><p>  When <code>co</code> is invoked with a receiver it will propagate to most yieldables,<br>  allowing you to alter <code>this</code>.</p>
<pre><code class="js">var ctx = {};

function foo() {
  assert(this == ctx);
}

co(function *(){
  assert(this == ctx);
  yield foo;
}).call(ctx)
</code></pre>
<p>  You also pass arguments through the generator:</p>
<pre><code class="js">co(function *(a){
  assert(this == ctx);
  assert(&#39;yay&#39; == a);
  yield foo;
}).call(ctx, &#39;yay&#39;);
</code></pre>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="co-fn"><a href="#co-fn" class="headerlink" title="co(fn)"></a>co(fn)</h3><p>  Pass a generator <code>fn</code> and return a thunk. The thunk’s signature is<br>  <code>(err, result)</code>, where <code>result</code> is the value passed to the <code>return</code><br>  statement.</p>
<pre><code class="js">var co = require(&#39;co&#39;);
var fs = require(&#39;fs&#39;);

function read(file) {
  return function(fn){
    fs.readFile(file, &#39;utf8&#39;, fn);
  }
}

co(function *(){
  var a = yield read(&#39;.gitignore&#39;);
  var b = yield read(&#39;Makefile&#39;);
  var c = yield read(&#39;package.json&#39;);
  return [a, b, c];
})()
</code></pre>
<p>  You may also yield <code>Generator</code> objects to support nesting:</p>
<pre><code class="js">var co = require(&#39;co&#39;);
var fs = require(&#39;fs&#39;);

function size(file) {
  return function(fn){
    fs.stat(file, function(err, stat){
      if (err) return fn(err);
      fn(null, stat.size);
    });
  }
}

function *foo(){
  var a = yield size(&#39;.gitignore&#39;);
  var b = yield size(&#39;Makefile&#39;);
  var c = yield size(&#39;package.json&#39;);
  return [a, b, c];
}

function *bar(){
  var a = yield size(&#39;examples/parallel.js&#39;);
  var b = yield size(&#39;examples/nested.js&#39;);
  var c = yield size(&#39;examples/simple.js&#39;);
  return [a, b, c];
}

co(function *(){
  var results = yield [foo(), bar()];
  console.log(results);
})()
</code></pre>
<p>  Or if the generator functions do not require arguments, simply <code>yield</code> the function:</p>
<pre><code class="js">var co = require(&#39;co&#39;);
var thunkify = require(&#39;thunkify&#39;);
var request = require(&#39;request&#39;);

var get = thunkify(request.get);

function *results() {
  var a = get(&#39;http://google.com&#39;)
  var b = get(&#39;http://yahoo.com&#39;)
  var c = get(&#39;http://ign.com&#39;)
  return yield [a, b, c]
}

co(function *(){
  // 3 concurrent requests at a time
  var a = yield results;
  var b = yield results;
  console.log(a, b);

  // 6 concurrent requests
  console.log(yield [results, results]);
})()
</code></pre>
<p>  If a thunk is written to execute immediately you may achieve parallelism<br>  by simply <code>yield</code>-ing <em>after</em> the call. The following are equivalent if<br>  each call kicks off execution immediately:</p>
<pre><code class="js">co(function *(){
  var a = size(&#39;package.json&#39;);
  var b = size(&#39;Readme.md&#39;);
  var c = size(&#39;Makefile&#39;);

  return [yield a, yield b, yield c];
})()
</code></pre>
<p>  Or:</p>
<pre><code class="js">co(function *(){
  var a = size(&#39;package.json&#39;);
  var b = size(&#39;Readme.md&#39;);
  var c = size(&#39;Makefile&#39;);

  return yield [a, b, c];
})()
</code></pre>
<p>  You can also pass arguments into the generator. The last argument, <code>done</code>, is<br>  the callback function. Here’s an example:</p>
<pre><code class="js">var exec = require(&#39;co-exec&#39;);
co(function *(cmd) {
  var res = yield exec(cmd);
  return res;
})(&#39;pwd&#39;, done);
</code></pre>
<h3 id="yield-array"><a href="#yield-array" class="headerlink" title="yield array"></a>yield array</h3><p>  By yielding an array of thunks you may “join” them all into a single thunk which executes them all concurrently,<br>  instead of in sequence. Note that the resulting array ordering <em>is</em> retained.</p>
<pre><code class="js">
var co = require(&#39;co&#39;);
var fs = require(&#39;fs&#39;);

function size(file) {
  return function(fn){
    fs.stat(file, function(err, stat){
      if (err) return fn(err);
      fn(null, stat.size);
    });
  }
}

co(function *(){
  var a = size(&#39;.gitignore&#39;);
  var b = size(&#39;index.js&#39;);
  var c = size(&#39;Makefile&#39;);
  var res = yield [a, b, c];
  console.log(res);
  // =&gt; [ 13, 1687, 129 ]
})()
</code></pre>
<p>Nested arrays may also be expressed as simple nested arrays:</p>
<pre><code class="js">var a = [
  get(&#39;http://google.com&#39;),
  get(&#39;http://yahoo.com&#39;),
  get(&#39;http://ign.com&#39;)
];

var b = [
  get(&#39;http://google.com&#39;),
  get(&#39;http://yahoo.com&#39;),
  get(&#39;http://ign.com&#39;)
];

console.log(yield [a, b]);
</code></pre>
<h3 id="yield-object"><a href="#yield-object" class="headerlink" title="yield object"></a>yield object</h3><p>  Yielding an object behaves much like yielding an array, however recursion is supported:</p>
<pre><code class="js">co(function *(){
  var user = yield {
    name: {
      first: get(&#39;name.first&#39;),
      last: get(&#39;name.last&#39;)
    }
  };
})()
</code></pre>
<p>  Here is the sequential equivalent without yielding an object:</p>
<pre><code class="js">co(function *(){
  var user = {
    name: {
      first: yield get(&#39;name.first&#39;),
      last: yield get(&#39;name.last&#39;)
    }
  };
})()
</code></pre>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>  On my machine 30,000 sequential stat()s takes an avg of 570ms,<br>  while the same number of sequential stat()s with <code>co()</code> takes<br>  610ms, aka the overhead introduced by generators is <em>extremely</em> negligible.</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>  MIT</p>
