<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sunjinkang.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Sun ...something">
<meta property="og:url" content="https://sunjinkang.github.io/default-index/index.html">
<meta property="og:site_name" content="Sun ...something">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sun Jinkang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://sunjinkang.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sun ...something - about what I have learned and some interesting things</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Sun ...something" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sun ...something</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">about what I have learned and some interesting things</p>
      <img class="custom-logo-image" src="/images/logo.jpeg" alt="Sun ...something">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-vue"><a href="/vue/" rel="section"><i class="fa fa-archive fa-fw"></i>vue</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sun Jinkang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Sun Jinkang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sunjinkang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sunjinkang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2060037942@qq.com" title="E-Mail → mailto:2060037942@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/10/26/41-js-equal-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/26/41-js-equal-type/" class="post-title-link" itemprop="url">42-js-equal-type</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-26 14:24:02 / Modified: 17:26:49" itemprop="dateCreated datePublished" datetime="2022-10-26T14:24:02+08:00">2022-10-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="javascript中的相等比较算法"><a href="#javascript中的相等比较算法" class="headerlink" title="javascript中的相等比较算法"></a>javascript中的相等比较算法</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/10/17/40-tail-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/17/40-tail-call/" class="post-title-link" itemprop="url">尾调用与尾递归</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-17 10:26:13 / Modified: 14:06:31" itemprop="dateCreated datePublished" datetime="2022-10-17T10:26:13+08:00">2022-10-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h6 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h6><p><strong>某个函数的最后一步调用另一个函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> call2(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三种情况不属于尾调用！！！</span></span><br><span class="line"><span class="comment">// 函数调用后还有其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> x = call2(a);</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> call2(a) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"> call2(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下属于尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!!a) &#123;</span><br><span class="line">  <span class="keyword">return</span> call2(a);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> call3(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h6><p><em>注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度</em></p>
<p>函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。</p>
<p><img src="/.io//call-stack.png" alt="call-stack"></p>
<p>但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。</p>
<p><em>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’</em></p>
<h6 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h6><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阶乘计算</span></span><br><span class="line"><span class="comment">// 复杂度 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> factorial(n -<span class="number">1</span>, n* total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// factorial(5, 1);</span></span><br><span class="line"><span class="comment">// factorial(4, 5);</span></span><br><span class="line"><span class="comment">// factorial(3, 20);</span></span><br><span class="line"><span class="comment">// factorial(2, 60);</span></span><br><span class="line"><span class="comment">// factorial(1, 120);</span></span><br><span class="line"><span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<h6 id="递归函数的改写优化"><a href="#递归函数的改写优化" class="headerlink" title="递归函数的改写优化"></a>递归函数的改写优化</h6><p>尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：</p>
<p>(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailCall</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> tailCall(n -<span class="number">1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> tailCall(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>(2) 使用柯理化，将多参数的函数转化为单参数形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, m, n);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailCall</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> tailCall(n -<span class="number">1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailCall, <span class="number">1</span>);</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用ES6函数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> tailCall(n -<span class="number">1</span>, n*total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><em>ES6的尾调用优化只在严格模式下开启，正常模式无效</em><br>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈</p>
<ul>
<li>arguments 返回调用时函数的参数</li>
<li>func.caller 返回调用当前函数的那个函数<br>尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾调用-维基百科</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/10/13/39-data-structure7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/13/39-data-structure7/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(7)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-13 16:13:40" itemprop="dateCreated datePublished" datetime="2022-10-13T16:13:40+08:00">2022-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-25 10:34:13" itemprop="dateModified" datetime="2022-10-25T10:34:13+08:00">2022-10-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="算法设计与技巧"><a href="#算法设计与技巧" class="headerlink" title="算法设计与技巧"></a>算法设计与技巧</h4><h6 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h6><p>将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p>
<p>分而治之算法可以分成三个部分。<br>(1) 分解原问题为多个子问题（原问题的多个小实例）。<br>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。<br>(3) 组合这些子问题的解决方式，得到原问题的解。</p>
<p><strong>二分搜索</strong><br>分解：计算 mid 并搜索数组较小或较大的一半。<br>解决：在较小或较大的一半中搜索值。<br>合并：这步不需要，因为我们直接返回了索引值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearchRecursive</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  array,</span></span></span><br><span class="line"><span class="params"><span class="function">  value,</span></span></span><br><span class="line"><span class="params"><span class="function">  low,</span></span></span><br><span class="line"><span class="params"><span class="function">  high,</span></span></span><br><span class="line"><span class="params"><span class="function">  compareFn = defaultCompare</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> element = array[mid];</span><br><span class="line">    <span class="keyword">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> binarySearchRecursive(array, value, mid + <span class="number">1</span>, high, compareFn);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> binarySearchRecursive(array, value, low, mid - <span class="number">1</span>, compareFn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DOES_NOT_EXIST; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sortedArray = quickSort(array);</span><br><span class="line">  <span class="keyword">const</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> high = sortedArray.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> binarySearchRecursive(array, value, low, high, compareFn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//technology-1.png" alt="technology-1"></p>
<p><strong>动态规划</strong><br>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>
<p><em>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</em></p>
<p>步骤：<br>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分；<br>(3) 识别并求解出基线条件。</p>
<p><em>能用动态规划解决的一些著名问题如下。</em><br>(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)</p>
<p><em>最少硬币找零问题</em><br>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coins 硬币面额的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minCoinChange</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = []; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">const</span> makeChange = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache[value]) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">return</span> cache[value];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> min = [];</span><br><span class="line">    <span class="keyword">let</span> newMin;</span><br><span class="line">    <span class="keyword">let</span> newAmount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="keyword">const</span> coin = coins[i];</span><br><span class="line">      newAmount = value - coin; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (newAmount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        newMin = makeChange(newAmount); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        newAmount &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        (newMin.length &lt; min.length - <span class="number">1</span> || !min.length) &amp;&amp; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">        (newMin.length || !newAmount) <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        min = [coin].concat(newMin); <span class="comment">// &#123;11&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;new Min &#x27;</span> + min + <span class="string">&#x27; for &#x27;</span> + amount);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cache[value] = min); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> makeChange(amount); <span class="comment">// &#123;13&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>背包问题</em><br>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapSack</span>(<span class="params">capacity, weights, values, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> kS = [];</span><br><span class="line">  <span class="comment">// 初始化将用于寻找解决方案的矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    kS[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> w = <span class="number">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span> || w === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        kS[i][w] = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &lt;= w) &#123;</span><br><span class="line">        <span class="comment">// 。物品 i 的重量必须小于约束</span></span><br><span class="line">        <span class="keyword">const</span> a = values[i - <span class="number">1</span>] + kS[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">const</span> b = kS[i - <span class="number">1</span>][w];</span><br><span class="line">        <span class="comment">// 当找到可以构成解决方案的物品时，选择价值最大的那个</span></span><br><span class="line">        kS[i][w] = a &gt; b ? a : b; <span class="comment">// &#123;4&#125; max(a,b)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kS[i][w] = kS[i - <span class="number">1</span>][w]; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  findValues(n, capacity, kS, weights, values); <span class="comment">// &#123;6&#125; 增加的代码</span></span><br><span class="line">  <span class="keyword">return</span> kS[n][capacity]; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findValues</span>(<span class="params">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = n;</span><br><span class="line">  <span class="keyword">let</span> k = capacity;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;构成解的物品：&#x27;</span>);</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kS[i][k] !== kS[i - <span class="number">1</span>][k]) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`物品 <span class="subst">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class="subst">$&#123;weights[i - <span class="number">1</span>]&#125;</span>, <span class="subst">$&#123;values[i - <span class="number">1</span>]&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">      i--;</span><br><span class="line">      k -= kS[i][k];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//technology-2.png" alt="technology-2"></p>
<p><em>最长公共子序列(LCS)</em><br>找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。<br><img src="/.io//technology-3.png" alt="technology-3"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lcs</span>(<span class="params">wordX, wordY</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = wordX.length;</span><br><span class="line">  <span class="keyword">const</span> n = wordY.length;</span><br><span class="line">  <span class="keyword">const</span> l = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    l[i] = []; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="comment">// solution[i] = [];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      l[i][j] = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="comment">// solution[i][j] = &#x27;0&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span> || j === <span class="number">0</span>) &#123;</span><br><span class="line">        l[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordX[i - <span class="number">1</span>] === wordY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        l[i][j] = l[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="comment">// solution[i][j] = &#x27;diagonal&#x27;;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> a = l[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">const</span> b = l[i][j - <span class="number">1</span>];</span><br><span class="line">        l[i][j] = a &gt; b ? a : b; <span class="comment">// &#123;4&#125; max(a,b)</span></span><br><span class="line">        <span class="comment">// solution[i][j]=(l[i][j] == l[i-1][j]) ? &#x27;top&#x27; : &#x27;left&#x27;;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l[m][n]; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  <span class="comment">// printSolution(solution, wordX, m, n);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSolution</span>(<span class="params">solution, wordX, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = m;</span><br><span class="line">  <span class="keyword">let</span> b = n;</span><br><span class="line">  <span class="keyword">let</span> x = solution[a][b];</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (x !== <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (solution[a][b] === <span class="string">&#x27;diagonal&#x27;</span>) &#123;</span><br><span class="line">      answer = wordX[a - <span class="number">1</span>] + answer;</span><br><span class="line">      a--;</span><br><span class="line">      b--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (solution[a][b] === <span class="string">&#x27;left&#x27;</span>) &#123;</span><br><span class="line">      b--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (solution[a][b] === <span class="string">&#x27;top&#x27;</span>) &#123;</span><br><span class="line">      a--;</span><br><span class="line">    &#125;</span><br><span class="line">    x = solution[a][b];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;lcs: &#x27;</span> + answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//technology-4.png" alt="technology-4"></p>
<p><em>矩阵链相乘</em><br>要找出一组矩阵相乘的最佳方式（顺序）</p>
<p>A<em>B</em>C*D 的乘法</p>
<p>A 是一个 10 行 100 列的矩阵；<br>B 是一个 100 行 5 列的矩阵；<br>C 是一个 5 行 50 列的矩阵；<br>D 是一个 50 行 1 列的矩阵；<br>A<em>B</em>C*D 的结果是一个 10 行 1 列的矩阵</p>
<p>(1) (A(B(CD)))：乘法运算的次数是 1750 次。<br>(2) ((AB)(CD))：乘法运算的次数是 5300 次。<br>(3) (((AB)C)D)：乘法运算的次数是 8000 次。<br>(4) ((A(BC))D)：乘法运算的次数是 75 500 次。<br>(5) (A((BC)D))：乘法运算的次数是 31 000 次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrixChainOrder</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = p.length;</span><br><span class="line">  <span class="keyword">const</span> m = [];</span><br><span class="line">  <span class="keyword">const</span> s = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    m[i] = [];</span><br><span class="line">    m[i][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   const s = [];</span></span><br><span class="line">  <span class="comment">// for (let i = 0; i &lt;= n; i++)&#123;</span></span><br><span class="line">  <span class="comment">//  s[i] = [];</span></span><br><span class="line">  <span class="comment">//  for (let j=0; j &lt;= n; j++)&#123;</span></span><br><span class="line">  <span class="comment">//  s[i][j] = 0;</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">2</span>; l &lt; n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">      m[i][j] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = i; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">const</span> q = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (q &lt; m[i][j]) &#123;</span><br><span class="line">          m[i][j] = q; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">          <span class="comment">// s[i][j] = k;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m[<span class="number">1</span>][n - <span class="number">1</span>]; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  <span class="comment">// printOptimalParenthesis(s, 1, n-1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printOptimalParenthesis</span>(<span class="params">s, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i === j) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    printOptimalParenthesis(s, i, s[i][j]);</span><br><span class="line">    printOptimalParenthesis(s, s[i][j] + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (A[1](A[2](A[3]A[4]))) =&gt; (A(B(CD)))</span></span><br></pre></td></tr></table></figure>

<h6 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h6><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p>
<p><strong>最少硬币找零问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minCoinChange</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> change = [];</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = coins.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">const</span> coin = coins[i];</span><br><span class="line">    <span class="keyword">while</span> (total + coin &lt;= amount) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      change.push(coin); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      total += coin; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//technology-5.png" alt="technology-5"></p>
<p><em>比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</em></p>
<p><strong>分数背包问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapSack</span>(<span class="params">capacity, weights, values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = values.length;</span><br><span class="line">  <span class="keyword">let</span> load = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (weights[i] &lt;= capacity - load) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      val += values[i];</span><br><span class="line">      load += weights[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> r = (capacity - load) / weights[i]; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      val += r * values[i];</span><br><span class="line">      load += weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h6><p>回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。</p>
<p><strong>迷宫老鼠问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ratInAMaze</span>(<span class="params">maze</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> solution = [];</span><br><span class="line">  <span class="comment">// 每个位置初始化为零</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maze.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    solution[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; maze[i].length; j++) &#123;</span><br><span class="line">      solution[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (findPath(maze, <span class="number">0</span>, <span class="number">0</span>, solution) === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> solution;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;NO PATH FOUND&#x27;</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPath</span>(<span class="params">maze, x, y, solution</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = maze.length;</span><br><span class="line">  <span class="keyword">if</span> (x === n - <span class="number">1</span> &amp;&amp; y === n - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    solution[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSafe(maze, x, y) === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    solution[x][y] = <span class="number">1</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (findPath(maze, x + <span class="number">1</span>, y, solution)) &#123;</span><br><span class="line">      <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (findPath(maze, x, y + <span class="number">1</span>, solution)) &#123;</span><br><span class="line">      <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    solution[x][y] = <span class="number">0</span>; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSafe</span>(<span class="params">maze, x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = maze.length;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maze = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(ratInAMaze(maze));</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>数独解题器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sudokuSolver</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (solveSudoku(matrix) === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;问题无解！&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UNASSIGNED = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solveSudoku</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> col = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> checkBlankSpaces = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; matrix[row].length; col++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[row][col] === UNASSIGNED) &#123;</span><br><span class="line">        checkBlankSpaces = <span class="literal">true</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBlankSpaces === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (checkBlankSpaces === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; num++) &#123;</span><br><span class="line">    <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (isSafe(matrix, row, col, num)) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      matrix[row][col] = num; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (solveSudoku(matrix)) &#123;</span><br><span class="line">        <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      matrix[row][col] = UNASSIGNED; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSafe</span>(<span class="params">matrix, row, col, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    !usedInRow(matrix, row, num) &amp;&amp;</span><br><span class="line">    !usedInCol(matrix, col, num) &amp;&amp;</span><br><span class="line">    !usedInBox(matrix, row - (row % <span class="number">3</span>), col - (col % <span class="number">3</span>), num)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usedInRow</span>(<span class="params">matrix, row, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; matrix.length; col++) &#123;</span><br><span class="line">    <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (matrix[row][col] === num) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usedInCol</span>(<span class="params">matrix, col, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">    <span class="comment">// &#123;12&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (matrix[row][col] === num) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usedInBox</span>(<span class="params">matrix, boxStartRow, boxStartCol, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; <span class="number">3</span>; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; <span class="number">3</span>; col++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[row + boxStartRow][col + boxStartCol] === num) &#123;</span><br><span class="line">        <span class="comment">// &#123;13&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sudokuGrid = [</span><br><span class="line">  [<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>],</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(sudokuSolver(sudokuGrid));</span><br><span class="line">[</span><br><span class="line">  [<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h6 id="函数式编程-FP-简介"><a href="#函数式编程-FP-简介" class="headerlink" title="函数式编程(FP)简介"></a>函数式编程(FP)简介</h6><p><strong>函数式编程与命令式编程</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式编程</span></span><br><span class="line"><span class="keyword">const</span> printArray = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">printArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式编程</span></span><br><span class="line"><span class="keyword">const</span> forEach = <span class="function"><span class="keyword">function</span> (<span class="params">array, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    action(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> logItem = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;;</span><br><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], logItem);</span><br></pre></td></tr></table></figure>

<p><em>注意：</em><br>(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。<br>(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。<br>(3)函数和数据集合是函数式编程的核心。<br>(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。<br>(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。</p>
<p><strong>JavaScript 函数式类库和数据结构</strong><br>Underscode.js：<a target="_blank" rel="noopener" href="http://underscorejs.org/">http://underscorejs.org/</a><br>Bilby.js：<a target="_blank" rel="noopener" href="http://bilby.brianmckenna.org/">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a target="_blank" rel="noopener" href="http://danieltao.com/lazy.js/">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a target="_blank" rel="noopener" href="https://baconjs.github.io/">https://baconjs.github.io/</a><br>Fn.js：<a target="_blank" rel="noopener" href="http://eliperelman.com/fn.js/">http://eliperelman.com/fn.js/</a><br>Functional.js：<a target="_blank" rel="noopener" href="http://functionaljs.com/">http://functionaljs.com/</a><br>Ramda.js：<a target="_blank" rel="noopener" href="http://ramdajs.com/0.20.1/index.html">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a target="_blank" rel="noopener" href="http://swannodette.github.io/mori/">http://swannodette.github.io/mori/</a></p>
<p>JavaScript 函数式编程：<a target="_blank" rel="noopener" href="https://www.packtpub.com/web-development/functional-programming-javascript">https://www.packtpub.com/web-development/functional-programming-javascript</a></p>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><h6 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h6><p>用于描述算法的性能和复杂程度。<br>大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。</p>
<table>
<thead>
<tr>
<th>符 号</th>
<th>名 称</th>
</tr>
</thead>
<tbody><tr>
<td>O(1)</td>
<td>常数的</td>
</tr>
<tr>
<td>O(log(n))</td>
<td>对数的</td>
</tr>
<tr>
<td>O((log(n))c)</td>
<td>对数多项式的</td>
</tr>
<tr>
<td>O(n)</td>
<td>线性的</td>
</tr>
<tr>
<td>O(n^2)</td>
<td>二次的</td>
</tr>
<tr>
<td>O(n^c)</td>
<td>多项式的</td>
</tr>
<tr>
<td>O(c^n)</td>
<td>指数的</td>
</tr>
</tbody></table>
<p><strong>理解大 O 表示法</strong></p>
<p>衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。</p>
<ol>
<li>O(1)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）</p>
<ol start="2">
<li>O(n)</li>
</ol>
<p>函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。</p>
<p>以顺序搜索算法为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    cost++;</span><br><span class="line">    <span class="keyword">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`cost for sequentialSearch with input size <span class="subst">$&#123;array.length&#125;</span> is <span class="subst">$&#123;cost&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>O(n^2)</li>
</ol>
<p>以冒泡排序为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (compareFn(array[j], array[j + <span class="number">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设行&#123;1&#125;和行&#123;2&#125;的开销分别是 1。修改算法的实现使之计算开销。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array;</span><br><span class="line">  <span class="keyword">let</span> cost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    cost++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      cost++;</span><br><span class="line">      <span class="keyword">if</span> (compareFn(array[j], array[j + <span class="number">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`cost for bubbleSort with input size <span class="subst">$&#123;length&#125;</span> is <span class="subst">$&#123;cost&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久</p>
<p><em>时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)</em></p>
<p><strong>时间复杂度比较</strong></p>
<table>
<thead>
<tr>
<th>输入大小（n）</th>
<th>O(1)</th>
<th>O(log(n))</th>
<th>O(n)</th>
<th>O(nlog(n))</th>
<th>O(n^2)</th>
<th>O(2^n)</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>1</td>
<td>1</td>
<td>10</td>
<td>10</td>
<td>100</td>
<td>1024</td>
</tr>
<tr>
<td>20</td>
<td>1</td>
<td>1.30</td>
<td>20</td>
<td>26.02</td>
<td>400</td>
<td>1 048 576</td>
</tr>
<tr>
<td>50</td>
<td>1</td>
<td>1.69</td>
<td>50</td>
<td>84.94</td>
<td>2500</td>
<td>非常大</td>
</tr>
<tr>
<td>100</td>
<td>1</td>
<td>2</td>
<td>100</td>
<td>200</td>
<td>10 000</td>
<td>非常大</td>
</tr>
<tr>
<td>500</td>
<td>1</td>
<td>2.69</td>
<td>500</td>
<td>1349.48</td>
<td>250 000</td>
<td>非常大</td>
</tr>
<tr>
<td>1000</td>
<td>1</td>
<td>3</td>
<td>1000</td>
<td>3000</td>
<td>1 000 000</td>
<td>非常大</td>
</tr>
<tr>
<td>10 000</td>
<td>1</td>
<td>4</td>
<td>10 000</td>
<td>40 000</td>
<td>100 000 000</td>
<td>非常大</td>
</tr>
</tbody></table>
<p>不同的大 O 表示法的消耗</p>
<p><img src="/.io//big-o-1.png" alt="big-o-1"></p>
<p><em>常用数据结构的时间复杂度</em><br><img src="/.io//big-o-2.png" alt="big-o-2"></p>
<p><em>图的时间复杂度</em><br><img src="/.io//big-o-3.png" alt="big-o-3"></p>
<p><em>排序算法的时间复杂度</em><br><img src="/.io//big-o-4.png" alt="big-o-4"></p>
<p><em>搜索算法的时间复杂度</em><br><img src="/.io//big-o-5.png" alt="big-o-5"></p>
<p><strong>NP 完全理论概述</strong><br>一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.</p>
<p>对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）</p>
<p>NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP</p>
<p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。</p>
<p>NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：<br>(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；<br>(2) 所有的 NP 问题都能在多项式时间内归约为 L。</p>
<p>为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。</p>
<p>还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。</p>
<p>下面是满足 P&lt;&gt;NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。<br><img src="/.io//big-o-6.png" alt="big-o-6"></p>
<p>非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。</p>
<p>NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p>
<p>以上问题，具体可查看：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NP-completeness">https://en.wikipedia.org/wiki/NP-completeness</a></p>
<p><em>不可解问题与启发式算法</em><br>有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。<br>启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。<br>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。<br>详情请查阅 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a></p>
<p>UVa Online Judge（<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/%EF%BC%89">http://uva.onlinejudge.org/）</a><br>Sphere Online Judge（<a target="_blank" rel="noopener" href="http://www.spoj.com/%EF%BC%89">http://www.spoj.com/）</a><br>Coderbyte（<a target="_blank" rel="noopener" href="http://coderbyte.com/%EF%BC%89">http://coderbyte.com/）</a><br>Project Euler（<a target="_blank" rel="noopener" href="https://projecteuler.net/%EF%BC%89">https://projecteuler.net/）</a><br>HackerRank（<a target="_blank" rel="noopener" href="https://www.hackerrank.com)/">https://www.hackerrank.com）</a><br>CodeChef（<a target="_blank" rel="noopener" href="http://www.codechef.com/%EF%BC%89">http://www.codechef.com/）</a><br>Top Coder（<a target="_blank" rel="noopener" href="http://www.topcoder.com/%EF%BC%89">http://www.topcoder.com/）</a></p>
<h4 id="疑问点"><a href="#疑问点" class="headerlink" title="疑问点"></a>疑问点</h4><p>尾调用优化</p>
<ul>
<li>调用栈长</li>
<li>使用后性能有较大的提升<br>Floyd-Warshall 算法<br>Kruskal 算法<br>背包问题<br>最长公共子序列<br>矩阵链相乘<br>NP 完全理论</li>
<li>多项式时间</li>
</ul>
<p>算法的使用，什么情况下用合适？需要将数据转换处理<br>合适</p>
<p>自己写的算法怎么验证正确性？<br>LeetCode或其他刷题网站</p>
<p>antd升级后的visible修改任务<br>评估修改时间<br>testing-library/react测试react组件的库，安装了却没用？<br>umc-ui的项目框架使用的是别的项目的，原来就有，没删</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/10/13/38-data-structure6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/13/38-data-structure6/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(6)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-13 14:15:28 / Modified: 16:12:54" itemprop="dateCreated datePublished" datetime="2022-10-13T14:15:28+08:00">2022-10-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="排序和搜索算法"><a href="#排序和搜索算法" class="headerlink" title="排序和搜索算法"></a>排序和搜索算法</h4><h6 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h6><p><strong>冒泡排序</strong><br>冒泡排序(<em>复杂度是 O(n2)</em>)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (compareFn(array[j], array[j + <span class="number">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        swap(array, j, j + <span class="number">1</span>); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* const temp = array[a]; </span></span><br><span class="line"><span class="comment"> array[a] = array[b]; </span></span><br><span class="line"><span class="comment"> array[b] = temp; */</span> <span class="comment">// 经典方式</span></span><br><span class="line">  [array[a], array[b]] = [array[b], array[a]]; <span class="comment">// ES2015 的方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-1.png" alt="sort-1"><br><em>改进后的冒泡排序</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modifiedBubbleSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (compareFn(array[j], array[j + <span class="number">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-2.png" alt="sort-2"></p>
<p><strong>选择排序</strong><br>选择排序算法(<em>复杂度为 O(n2)</em>)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">let</span> indexMin;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    indexMin = i; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        indexMin = j; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i !== indexMin) &#123;</span><br><span class="line">      <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      swap(array, i, indexMin);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-3.png" alt="sort-3"></p>
<p><strong>插入排序</strong><br>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">let</span> j = i; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    temp = array[i]; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; compareFn(array[j - <span class="number">1</span>], temp) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      array[j] = array[j - <span class="number">1</span>]; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    array[j] = temp; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-4.png" alt="sort-4"><br><em>排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。</em></p>
<p><strong>归并排序</strong><br>归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。</p>
<p><em>JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。</em></p>
<p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>
<p>由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">const</span> left = mergeSort(array.slice(<span class="number">0</span>, middle), compareFn); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">const</span> right = mergeSort(array.slice(middle, length), compareFn); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    array = merge(left, right, compareFn); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">    <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    result.push(</span><br><span class="line">      compareFn(left[i], right[j]) === Compare.LESS_THAN</span><br><span class="line">        ? left[i++]</span><br><span class="line">        : right[j++]</span><br><span class="line">    ); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.concat(i &lt; left.length ? left.slice(i) : right.slice(j)); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-5.png" alt="sort-5"></p>
<p><strong>快速排序</strong><br>快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）</p>
<p>(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。<br>(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。<br>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>, compareFn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">array, left, right, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    index = partition(array, left, right, compareFn); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      quick(array, left, index - <span class="number">1</span>, compareFn); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      quick(array, index, right, compareFn); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 选择中间值作为主元</span></span><br><span class="line">  <span class="keyword">const</span> pivot = array[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)]; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  <span class="keyword">let</span> i = left; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">  <span class="keyword">let</span> j = right; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;12&#125;</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;13&#125;</span></span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="comment">// &#123;14&#125;</span></span><br><span class="line">      swap(array, i, j); <span class="comment">// &#123;15&#125;</span></span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i; <span class="comment">// &#123;16&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>划分操作的第一次执行<br><img src="/.io//sort-6.png" alt="sort-6"><br>对有较小值的子数组执行的划分操作<br><img src="/.io//sort-7.png" alt="sort-7"><br>针对有较大值的子数组<br><img src="/.io//sort-8.png" alt="sort-8"><br><img src="/.io//sort-9.png" alt="sort-9"><br><img src="/.io//sort-10.png" alt="sort-10"></p>
<p><strong>计数排序</strong><br>计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组</p>
<p>它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> maxValue = findMaxValue(array); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="keyword">const</span> counts = <span class="keyword">new</span> <span class="built_in">Array</span>(maxValue + <span class="number">1</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  array.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!counts[element]) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      counts[element] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    counts[element]++; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">  counts.forEach(<span class="function">(<span class="params">count, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      array[sortedIndex++] = i; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      count--; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxValue</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">      max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>桶排序</strong><br>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。</p>
<p><em>默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, bucketSize = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建桶并将元素分布到不同的桶中</span></span><br><span class="line">  <span class="keyword">const</span> buckets = createBuckets(array, bucketSize); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组</span></span><br><span class="line">  <span class="keyword">return</span> sortBuckets(buckets); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBuckets</span>(<span class="params">array, bucketSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> minValue = array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> maxValue = array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; minValue) &#123;</span><br><span class="line">      minValue = array[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &gt; maxValue) &#123;</span><br><span class="line">      maxValue = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算每个桶中需要分布的元素个数</span></span><br><span class="line">  <span class="keyword">const</span> bucketCount = <span class="built_in">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  <span class="keyword">const</span> buckets = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 初始化每个桶</span></span><br><span class="line">    buckets[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    <span class="keyword">const</span> bucketIndex = <span class="built_in">Math</span>.floor((array[i] - minValue) / bucketSize); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    buckets[bucketIndex].push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buckets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortBuckets</span>(<span class="params">buckets</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sortedArray = []; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;10&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (buckets[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">      insertionSort(buckets[i]); <span class="comment">// &#123;11&#125;</span></span><br><span class="line">      sortedArray.push(...buckets[i]); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-11.png" alt="sort-11"></p>
<p><strong>基数排序</strong><br>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">array, radixBase = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> minValue = findMinValue(array);</span><br><span class="line">  <span class="keyword">const</span> maxValue = findMaxValue(array);</span><br><span class="line">  <span class="keyword">let</span> significantDigit = <span class="number">1</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">while</span> ((maxValue - minValue) / significantDigit &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    array = countingSortForRadix(array, radixBase, significantDigit, minValue); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    significantDigit *= radixBase; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSortForRadix</span>(<span class="params">array, radixBase, significantDigit, minValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bucketsIndex;</span><br><span class="line">  <span class="keyword">const</span> buckets = [];</span><br><span class="line">  <span class="keyword">const</span> aux = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; radixBase; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    buckets[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 基于数组中数的有效位（行&#123;7&#125;）进行计数排序</span></span><br><span class="line">    bucketsIndex = <span class="built_in">Math</span>.floor(</span><br><span class="line">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class="line">    ); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    buckets[bucketsIndex]++; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; radixBase; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算累积结果来得到正确的计数值</span></span><br><span class="line">    buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// &#123;10&#125;</span></span><br><span class="line">    bucketsIndex = <span class="built_in">Math</span>.floor(</span><br><span class="line">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class="line">    ); <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    aux[--buckets[bucketsIndex]] = array[i]; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;13&#125;</span></span><br><span class="line">    array[i] = aux[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//sort-12.png" alt="sort-12"></p>
<h6 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h6><p><strong>顺序搜索</strong><br>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DOES_NOT_EXIST = -<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DOES_NOT_EXIST; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//search-1.png" alt="search-1"></p>
<p><strong>二分搜索</strong><br>个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。<br>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sortedArray = quickSort(array); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="keyword">let</span> high = sortedArray.length - <span class="number">1</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  <span class="keyword">while</span> (lesserOrEquals(low, high, compareFn)) &#123;</span><br><span class="line">    <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="keyword">const</span> element = sortedArray[mid]; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      low = mid + <span class="number">1</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      high = mid - <span class="number">1</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DOES_NOT_EXIST; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lesserOrEquals</span>(<span class="params">a, b, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> comp = compareFn(a, b);</span><br><span class="line">  <span class="keyword">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//search-2.png" alt="search-2"></p>
<p><strong>内插搜索</strong><br>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。</p>
<p>算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤</p>
<p>(1) 使用 position 公式选中一个值；<br>(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interpolationSearch</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  array,</span></span></span><br><span class="line"><span class="params"><span class="function">  value,</span></span></span><br><span class="line"><span class="params"><span class="function">  compareFn = defaultCompare,</span></span></span><br><span class="line"><span class="params"><span class="function">  equalsFn = defaultEquals,</span></span></span><br><span class="line"><span class="params"><span class="function">  diffFn = defaultDiff</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array;</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> high = length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> position = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> delta = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    low &lt;= high &amp;&amp;</span><br><span class="line">    biggerOrEquals(value, array[low], compareFn) &amp;&amp;</span><br><span class="line">    lesserOrEquals(value, array[high], compareFn)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">/** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */</span></span><br><span class="line">    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);</span><br><span class="line">    position = low + <span class="built_in">Math</span>.floor((high - low) * delta); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (equalsFn(array[position], value)) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compareFn(array[position], value) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      low = position + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = position - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DOES_NOT_EXIST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lesserOrEquals</span>(<span class="params">a, b, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> comp = compareFn(a, b);</span><br><span class="line">  <span class="keyword">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biggerOrEquals</span>(<span class="params">a, b, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> comp = compareFn(a, b);</span><br><span class="line">  <span class="keyword">return</span> comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//search-3.png" alt="search-3"></p>
<h6 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h6><p><strong>Fisher-Yates 随机</strong><br>它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">    swap(array, i, randomIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//search-4.png" alt="search-4"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/10/08/37-data-structure5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/08/37-data-structure5/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(5)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-08 16:33:37" itemprop="dateCreated datePublished" datetime="2022-10-08T16:33:37+08:00">2022-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-13 14:14:03" itemprop="dateModified" datetime="2022-10-13T14:14:03+08:00">2022-10-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="二叉堆和堆排序"><a href="#二叉堆和堆排序" class="headerlink" title="二叉堆和堆排序"></a>二叉堆和堆排序</h4><h6 id="二叉堆数据结构"><a href="#二叉堆数据结构" class="headerlink" title="二叉堆数据结构"></a>二叉堆数据结构</h6><p>(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。<br>(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性<br><img src="/.io//heat.png" alt="heat"></p>
<p>二叉树有两种表示方式<br>第一种是使用一个动态的表示方式，也就是指针（用节点表示）<br>第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。<br><img src="/.io//min-heat.png" alt="min-heat"></p>
<p>访问使用普通数组的二叉树节点:<br>它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；<br>它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；<br>它的父节点位置是 index / 2（如果位置可用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defaultCompare &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.heap = []; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLeftIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getRightIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getParentIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.heap.push(value); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.siftUp(<span class="built_in">this</span>.heap.length - <span class="number">1</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上移操作</span></span><br><span class="line">  <span class="function"><span class="title">siftUp</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = <span class="built_in">this</span>.getParentIndex(index); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      index &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.compareFn(<span class="built_in">this</span>.heap[parent], <span class="built_in">this</span>.heap[index]) &gt; Compare.BIGGER_THAN</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      swap(<span class="built_in">this</span>.heap, parent, index); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      index = parent;</span><br><span class="line">      parent = <span class="built_in">this</span>.getParentIndex(index); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> temp = array[a]; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      array[a] = array[b]; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      array[b] = temp; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heap.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">findMinimum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? <span class="literal">undefined</span> : <span class="built_in">this</span>.heap[<span class="number">0</span>]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">extract</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.heap.shift(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> removedValue = <span class="built_in">this</span>.heap.shift(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.siftDown(<span class="number">0</span>); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    <span class="keyword">return</span> removedValue; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">siftDown</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> element = index;</span><br><span class="line">    <span class="keyword">const</span> left = <span class="built_in">this</span>.getLeftIndex(index); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">const</span> right = <span class="built_in">this</span>.getRightIndex(index); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">const</span> size = <span class="built_in">this</span>.size();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      left &lt; size &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.compareFn(<span class="built_in">this</span>.heap[element], <span class="built_in">this</span>.heap[left]) &gt; Compare.BIGGER_THAN</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      element = left; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      right &lt; size &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.compareFn(<span class="built_in">this</span>.heap[element], <span class="built_in">this</span>.heap[right]) &gt; Compare.BIGGER_THAN</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      element = right; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index !== element) &#123;</span><br><span class="line">      <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      swap(<span class="built_in">this</span>.heap, index, element); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.siftDown(element); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//min-heat-pic.png" alt="min-heat-pic"></p>
<p><strong>创建最大堆类</strong><br>MaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有&gt;（大于）的比较换成&lt;（小于）的比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseCompare</span>(<span class="params">compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a, b</span>) =&gt;</span> compareFn(b, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> <span class="keyword">extends</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(compareFn);</span><br><span class="line">    <span class="built_in">this</span>.compareFn = reverseCompare(compareFn); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序算法</strong><br>(1) 用数组创建一个最大堆用作源数据。<br>(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。<br>(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heapSize = array.length;</span><br><span class="line">  buildMaxHeap(array, compareFn); <span class="comment">// 步骤 1</span></span><br><span class="line">  <span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(array, <span class="number">0</span>, --heapSize); <span class="comment">// 步骤 2</span></span><br><span class="line">    heapify(array, <span class="number">0</span>, heapSize, compareFn); <span class="comment">// 步骤 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i -= <span class="number">1</span>) &#123;</span><br><span class="line">    heapify(array, i, array.length, compareFn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>heapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法<br><img src="/.io//heap-sort.png" alt="heap-sort"></p>
<p><strong>堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。</strong></p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><h6 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h6><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）<br>G = (V, E)<br>V: 一组顶点<br>E: 一组边，连接 V 中的顶点<br><img src="/.io//graph-1.png" alt="graph-1"></p>
<p>由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。<br>一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。<br>路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。<br>简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。<br>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p>
<p><strong>有向图和无向图</strong><br>图可以是无向的（边没有方向）或是有向的（有向图）。<br>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。<br><img src="/.io//graph-2.png" alt="graph-2"><br>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。<br><img src="/.io//graph-3.png" alt="graph-3"></p>
<h6 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h6><p><strong>邻接矩阵</strong><br>每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0<br><img src="/.io//graph-4.png" alt="graph-4"><br><em>缺点：</em><br>(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。<br>(2)顶点的数量可能会改变，而二维数组不太灵活</p>
<p><strong>邻接表</strong><br>邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。<br>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表<br><img src="/.io//graph-5.png" alt="graph-5"></p>
<p><strong>关联矩阵</strong><br>在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0<br><img src="/.io//graph-6.png" alt="graph-6"><br><em>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存</em></p>
<h6 id="创建-Graph-类"><a href="#创建-Graph-类" class="headerlink" title="创建 Graph 类"></a>创建 Graph 类</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">isDirected = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 表示图是否有向</span></span><br><span class="line">    <span class="built_in">this</span>.isDirected = isDirected; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="comment">//  所有顶点的名字</span></span><br><span class="line">    <span class="built_in">this</span>.vertices = []; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">//  字典将会使用顶点的名字作为键，邻接顶点列表作为值</span></span><br><span class="line">    <span class="built_in">this</span>.adjList = <span class="keyword">new</span> Dictionary(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  一个用来向图中添加一个新的顶点</span></span><br><span class="line">  <span class="function"><span class="title">addVertex</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.vertices.includes(v)) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.vertices.push(v); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.adjList.set(v, []); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 来添加顶点之间的边</span></span><br><span class="line">  <span class="function"><span class="title">addEdge</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.get(v)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addVertex(v); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.get(w)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addVertex(w); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.adjList.get(v).push(w); <span class="comment">// &#123;10&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isDirected) &#123;</span><br><span class="line">      <span class="built_in">this</span>.adjList.get(w).push(v); <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取顶点列表</span></span><br><span class="line">  <span class="function"><span class="title">getVertices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.vertices;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取邻接表</span></span><br><span class="line">  <span class="function"><span class="title">getAdjList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.adjList;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertices.length; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;15&#125;</span></span><br><span class="line">      s += <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.vertices[i]&#125;</span> -&gt; `</span>;</span><br><span class="line">      <span class="keyword">const</span> neighbors = <span class="built_in">this</span>.adjList.get(<span class="built_in">this</span>.vertices[i]); <span class="comment">// &#123;16&#125;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class="line">        <span class="comment">// &#123;17&#125;</span></span><br><span class="line">        s += <span class="string">`<span class="subst">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s += <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// &#123;18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h6><p><em>作用：</em>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。<br>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>
<p><strong>广度优先搜索（breadth-first search，BFS）</strong><br><strong>深度优先搜索（depth-first search，DFS）</strong><br><em>不同点：</em>待访问顶点列表的数据结构<br>| 算 法        | 数据结构 | 描 述                                                          |<br>| ———— | ——– | ————————————————————– |<br>| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |<br>| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 白色：表示该顶点还没有被访问。</span></span><br><span class="line"><span class="comment">// 灰色：表示该顶点被访问过，但并未被探索过。</span></span><br><span class="line"><span class="comment">// 黑色：表示该顶点被访问过且被完全探索过</span></span><br><span class="line"><span class="keyword">const</span> Colors = &#123;</span><br><span class="line">  <span class="attr">WHITE</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">GREY</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">BLACK</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化每个顶点的颜色</span></span><br><span class="line"><span class="keyword">const</span> initializeColor = <span class="function">(<span class="params">vertices</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    color[vertices[i]] = Colors.WHITE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先搜索</strong><br>从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点<br><img src="/.io//graph-7.png" alt="graph-7"><br><em>步骤</em><br>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：</p>
<ul>
<li>(a) 将 u 从 Q 中出队列；</li>
<li>(b) 标注 u 为被发现的（灰色）；</li>
<li>(c) 将 u 所有未被访问过的邻点（白色）入队列；</li>
<li>(d) 标注 u 为已被探索的（黑色）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breadthFirstSearch = <span class="function">(<span class="params">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = initializeColor(vertices); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  queue.enqueue(startVertex); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    <span class="keyword">const</span> u = queue.dequeue(); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    <span class="comment">// 发现了节点，但尚未完成探索</span></span><br><span class="line">    color[u] = Colors.GREY; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      <span class="keyword">const</span> w = neighbors[i]; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class="line">        <span class="comment">// &#123;10&#125;</span></span><br><span class="line">        color[w] = Colors.GREY; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">        queue.enqueue(w); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = Colors.BLACK; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">    <span class="comment">// 可选回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      <span class="comment">// &#123;14&#125;</span></span><br><span class="line">      callback(u);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printVertex = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Visited vertex: &#x27;</span> + value); <span class="comment">// &#123;15&#125;</span></span><br><span class="line">breadthFirstSearch(graph, myVertices[<span class="number">0</span>], printVertex);</span><br></pre></td></tr></table></figure>

<p><em>使用 BFS 寻找最短路径</em><br>给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BFS = <span class="function">(<span class="params">graph, startVertex</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line">  <span class="comment">// 创建一个队列</span></span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">  <span class="keyword">const</span> distances = &#123;&#125;; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">const</span> predecessors = &#123;&#125;; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  queue.enqueue(startVertex);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    distances[vertices[i]] = <span class="number">0</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    predecessors[vertices[i]] = <span class="literal">null</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">const</span> u = queue.dequeue();</span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">    color[u] = Colors.GREY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">      <span class="keyword">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class="line">        color[w] = Colors.GREY;</span><br><span class="line">        distances[w] = distances[u] + <span class="number">1</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        predecessors[w] = u; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        queue.enqueue(w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = Colors.BLACK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    distances, <span class="comment">// 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]</span></span><br><span class="line">    predecessors, <span class="comment">// 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortestPathA = BFS(graph, myVertices[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(shortestPathA);</span><br><span class="line"><span class="comment">// distances: &#123;A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3&#125;,</span></span><br><span class="line"><span class="comment">// predecessors: &#123;A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G: &quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fromVertex = myVertices[<span class="number">0</span>]; <span class="comment">// &#123;9&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">  <span class="comment">// &#123;10&#125;</span></span><br><span class="line">  <span class="keyword">const</span> toVertex = myVertices[i]; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">  <span class="comment">// 创建一个栈</span></span><br><span class="line">  <span class="keyword">const</span> path = <span class="keyword">new</span> Stack(); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">  <span class="comment">// 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) &#123;</span><br><span class="line">    <span class="comment">// &#123;13&#125;</span></span><br><span class="line">    path.push(v); <span class="comment">// &#123;14&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  path.push(fromVertex); <span class="comment">// &#123;15&#125;</span></span><br><span class="line">  <span class="keyword">let</span> s = path.pop(); <span class="comment">// &#123;16&#125;</span></span><br><span class="line">  <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// &#123;17&#125;</span></span><br><span class="line">    s += <span class="string">&#x27; - &#x27;</span> + path.pop(); <span class="comment">// &#123;18&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// &#123;19&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A - B</span></span><br><span class="line"><span class="comment">// A - C</span></span><br><span class="line"><span class="comment">// A - D</span></span><br><span class="line"><span class="comment">// A - B - E</span></span><br><span class="line"><span class="comment">// A - B - F</span></span><br><span class="line"><span class="comment">// A - C - G</span></span><br><span class="line"><span class="comment">// A - D - H</span></span><br><span class="line"><span class="comment">// A - B - E - I</span></span><br></pre></td></tr></table></figure>

<p><em>深入学习最短路径算法</em><br>Dijkstra 算法解决了单源最短路径问题。<br>Bellman-Ford 算法解决了边权值为负的单源最短路径问题。<br>A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。<br>Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题</p>
<p><strong>深度优先搜索</strong><br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点<br><img src="/.io//graph-8.png" alt="graph-8"></p>
<p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。<br><em>步骤</em><br>(1) 标注 v 为被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）。</p>
<p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function">(<span class="params">graph, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      depthFirstSearchVisit(vertices[i], color, adjList, callback); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> depthFirstSearchVisit = <span class="function">(<span class="params">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  color[u] = Colors.GREY; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    callback(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> neighbors = adjList.get(u); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    <span class="keyword">const</span> w = neighbors[i]; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class="line">      <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      depthFirstSearchVisit(w, color, adjList, callback); <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  color[u] = Colors.BLACK; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">depthFirstSearch(graph, printVertex);</span><br><span class="line"><span class="comment">// Visited vertex: A</span></span><br><span class="line"><span class="comment">// Visited vertex: B</span></span><br><span class="line"><span class="comment">// Visited vertex: E</span></span><br><span class="line"><span class="comment">// Visited vertex: I</span></span><br><span class="line"><span class="comment">// Visited vertex: F</span></span><br><span class="line"><span class="comment">// Visited vertex: C</span></span><br><span class="line"><span class="comment">// Visited vertex: D</span></span><br><span class="line"><span class="comment">// Visited vertex: G</span></span><br><span class="line"><span class="comment">// Visited vertex: H</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//graph-9.png" alt="graph-9"></p>
<p><em>Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。</em></p>
<p><em>探索深度优先算法</em><br>对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DFS = <span class="function">(<span class="params">graph</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line">  <span class="keyword">const</span> d = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> f = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> p = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> time = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    f[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">    d[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">    p[vertices[i]] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class="line">      DFSVisit(vertices[i], color, d, f, p, time, adjList);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="attr">discovery</span>: d, <span class="comment">// 顶点 u 的发现时间 d[u]；</span></span><br><span class="line">    <span class="attr">finished</span>: f, <span class="comment">// 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；</span></span><br><span class="line">    <span class="attr">predecessors</span>: p, <span class="comment">// 顶点 u 的前溯点 p[u]</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DFSVisit = <span class="function">(<span class="params">u, color, d, f, p, time, adjList</span>) =&gt;</span> &#123;</span><br><span class="line">  color[u] = Colors.GREY;</span><br><span class="line">  d[u] = ++time.count; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> w = neighbors[i];</span><br><span class="line">    <span class="keyword">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class="line">      p[w] = u; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      DFSVisit(w, color, d, f, p, time, adjList);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  color[u] = Colors.BLACK;</span><br><span class="line">  f[u] = ++time.count; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；<br>(2)对于所有的顶点 u，d[u] &lt; f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。<br>在这两个假设下，我们有如下的规则。<br><em>1 &lt;= d [u] &lt; f [u] &lt;= 2|V|</em><br>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间<br><img src="/.io//graph-10.png" alt="graph-10"></p>
<p><strong>拓扑排序——使用深度优先搜索</strong><br><img src="/.io//graph-11.png" alt="graph-11"><br>有向无环图（DAG）</p>
<p>需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）</p>
<p><em>拓扑排序只能应用于 DAG</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = <span class="keyword">new</span> Graph(<span class="literal">true</span>); <span class="comment">// 有向图</span></span><br><span class="line">myVertices = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">  graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = DFS(graph);</span><br></pre></td></tr></table></figure>

<p><img src="/.io//graph-12.png" alt="graph-12"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fTimes = result.finished;</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> count = <span class="number">0</span>; count &lt; myVertices.length; count++) &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxName = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fTimes[myVertices[i]] &gt; max) &#123;</span><br><span class="line">      max = fTimes[myVertices[i]];</span><br><span class="line">      maxName = myVertices[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&#x27; - &#x27;</span> + maxName;</span><br><span class="line">  <span class="keyword">delete</span> fTimes[maxName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">// B - A - D - C - F - E</span></span><br></pre></td></tr></table></figure>

<h6 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h6><p><em>Dijkstra 算法</em><br>Dijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p>
<p><img src="/.io//graph-13.png" alt="graph-13"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">];</span><br><span class="line"><span class="comment">// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="keyword">const</span> INF = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"><span class="keyword">const</span> dijkstra = <span class="function">(<span class="params">graph, src</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dist = [];</span><br><span class="line">  <span class="keyword">const</span> visited = [];</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    dist[i] = INF; <span class="comment">// 把所有的距离（dist）初始化为无限大</span></span><br><span class="line">    visited[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dist[src] = <span class="number">0</span>; <span class="comment">// &#123;2&#125; 把源顶点到自己的距离设为 0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">const</span> u = minDistance(dist, visited); <span class="comment">// &#123;4&#125; 从尚未处理的顶点中选出距离最近的顶点</span></span><br><span class="line">    visited[u] = <span class="literal">true</span>; <span class="comment">// &#123;5&#125; 把选出的顶点标为 visited，以免重复计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !visited[v] &amp;&amp;</span><br><span class="line">        graph[u][v] !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">        dist[u] !== INF &amp;&amp;</span><br><span class="line">        dist[u] + graph[u][v] &lt; dist[v]</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 如果找到更短的路径，则更新最短路径的值</span></span><br><span class="line">        <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        dist[v] = dist[u] + graph[u][v]; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dist; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minDistance = <span class="function">(<span class="params">dist, visited</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> min = INF;</span><br><span class="line">  <span class="keyword">let</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[v] === <span class="literal">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">      min = dist[v];</span><br><span class="line">      minIndex = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 0</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 4</span></span><br><span class="line"><span class="comment">// 3 6</span></span><br><span class="line"><span class="comment">// 4 4</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br></pre></td></tr></table></figure>

<p><strong>Floyd-Warshall 算法</strong><br>Floyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> floydWarshall = <span class="function">(<span class="params">graph</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dist = [];</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    dist[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === j) &#123;</span><br><span class="line">        dist[i][j] = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isFinite</span>(graph[i][j])) &#123;</span><br><span class="line">        <span class="comment">// 如果两个顶点之间没有边，就将其表示为 Infinity</span></span><br><span class="line">        dist[i][j] = <span class="literal">Infinity</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为 i 到 j 可能的最短距离就是这些顶点间的权值</span></span><br><span class="line">        dist[i][j] = graph[i][j]; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将顶点 0 到 k 作为中间点（行&#123;5&#125;），从 i 到 j 的最短路径经过 k。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">    <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="comment">// 计算通过顶点 k 的 i 和 j 之间的最短路径</span></span><br><span class="line">        <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">          <span class="comment">// &#123;6&#125;</span></span><br><span class="line">          dist[i][j] = dist[i][k] + dist[k][j]; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 0 2 4 6 4 6</span></span><br><span class="line"><span class="comment">// INF 0 2 4 2 4</span></span><br><span class="line"><span class="comment">// INF INF 0 6 3 5</span></span><br><span class="line"><span class="comment">// INF INF INF 0 INF 2</span></span><br><span class="line"><span class="comment">// INF INF INF 3 0 2</span></span><br><span class="line"><span class="comment">// INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure>

<h6 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h6><p><strong>Prim 算法</strong><br>Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INF = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"><span class="keyword">const</span> prim = <span class="function">(<span class="params">graph</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> parent = [];</span><br><span class="line">  <span class="keyword">const</span> key = [];</span><br><span class="line">  <span class="keyword">const</span> visited = [];</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">  <span class="comment">// 把所有顶点（key）初始化为无限大</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    key[i] = INF;</span><br><span class="line">    visited[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1</span></span><br><span class="line">  key[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  parent[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="comment">// 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）</span></span><br><span class="line">    <span class="keyword">const</span> u = minKey(graph, key, visited); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    visited[u] = <span class="literal">true</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">      <span class="comment">// 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值</span></span><br><span class="line">      <span class="keyword">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">        <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        parent[v] = u; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        key[v] = graph[u][v]; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parent; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minDistance = <span class="function">(<span class="params">dist, key, visited</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> min = INF;</span><br><span class="line">  <span class="keyword">let</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; dist[key].length; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[v] === <span class="literal">false</span> &amp;&amp; dist[key][v] &lt;= min) &#123;</span><br><span class="line">      min = dist[key][v];</span><br><span class="line">      minIndex = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edge Weight</span></span><br><span class="line"><span class="comment">// 0 - 1 2</span></span><br><span class="line"><span class="comment">// 1 - 2 2</span></span><br><span class="line"><span class="comment">// 5 - 3 2</span></span><br><span class="line"><span class="comment">// 1 - 4 2</span></span><br><span class="line"><span class="comment">// 4 - 5 2</span></span><br></pre></td></tr></table></figure>

<p><strong>Kruskal 算法</strong><br>是一种求加权无向连通图的 MST 的贪心算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kruskal = <span class="function">(<span class="params">graph</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">  <span class="keyword">const</span> parent = [];</span><br><span class="line">  <span class="keyword">let</span> ne = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">  <span class="keyword">let</span> u;</span><br><span class="line">  <span class="keyword">let</span> v;</span><br><span class="line">  <span class="comment">// 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span></span><br><span class="line">  <span class="keyword">const</span> cost = initializeCost(graph); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="comment">// 当 MST 的边数小于顶点总数减 1 时</span></span><br><span class="line">  <span class="keyword">while</span> (ne &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 找出权值最小的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class="line">          min = cost[i][j];</span><br><span class="line">          a = u = i;</span><br><span class="line">          b = v = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 MST 中是否已存在这条边，以避免环路</span></span><br><span class="line">    u = find(u, parent); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    v = find(v, parent); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="comment">// 如果 u 和 v 是不同的边，则将其加入 MST</span></span><br><span class="line">    <span class="keyword">if</span> (union(u, v, parent)) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      ne++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ：从列表中移除这些边，以免重复计算</span></span><br><span class="line">    cost[a][b] = cost[b][a] = INF; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">i, parent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (parent[i]) &#123;</span><br><span class="line">    i = parent[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">i, j, parent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i !== j) &#123;</span><br><span class="line">    parent[j] = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/10/08/36-data-structure4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/08/36-data-structure4/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(4)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-08 13:25:18 / Modified: 16:25:03" itemprop="dateCreated datePublished" datetime="2022-10-08T13:25:18+08:00">2022-10-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。</p>
<p>每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">understandRecursion</span>(<span class="params">doIunderstandRecursion</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> recursionAnswer = confirm(<span class="string">&#x27;Do you understand recursion?&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (recursionAnswer === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 基线条件或停止点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  understandRecursion(recursionAnswer); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="计算一个数的阶乘"><a href="#计算一个数的阶乘" class="headerlink" title="计算一个数的阶乘"></a>计算一个数的阶乘</h6><p>数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。<br>5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120<br>(1)迭代阶乘<br>(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialIterative</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> n = number; n &gt; <span class="number">1</span>; n--) &#123;</span><br><span class="line">    total = total * n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorialIterative(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>(2)递归阶乘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 基线条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//factorial.png" alt="factorial"></p>
<p>如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）</p>
<p><strong>测试浏览器最大调用栈大小</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  recursiveFn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  recursiveFn();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i = &#x27;</span> + i + <span class="string">&#x27; error: &#x27;</span> + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。</strong><br>有关尾调用优化的更多相关信息，请访问 <a target="_blank" rel="noopener" href="https://www.chromestatus.com/feature/">https://www.chromestatus.com/feature/</a><br>5516876633341952</p>
<h6 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h6><p>(1)位置 0 的斐波那契数是零<br>(2)1 和 2 的斐波那契数是 1<br>(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数</p>
<p><strong>迭代求斐波那契数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciIterative</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> fibNMinus2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fibNMinus1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> fibN = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// n &gt;= 2</span></span><br><span class="line">    fibN = fibNMinus1 + fibNMinus2; <span class="comment">// f(n-1) + f(n-2)</span></span><br><span class="line">    fibNMinus2 = fibNMinus1;</span><br><span class="line">    fibNMinus1 = fibN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br><span class="line">fibonacciIterative(<span class="number">9</span>); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>

<p><strong>递归求斐波那契数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fibonacci(<span class="number">9</span>); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>

<p><strong>记忆化斐波那契数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciMemoization</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memo = [<span class="number">0</span>, <span class="number">1</span>]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">const</span> fibonacci = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="literal">null</span>) <span class="keyword">return</span> memo[n]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (memo[n] = fibonacci(n - <span class="number">1</span>, memo) + fibonacci(n - <span class="number">2</span>, memo)); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n);</span><br><span class="line">&#125;</span><br><span class="line">fibonacciMemoization(<span class="number">9</span>); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>

<p>迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除</p>
<h4 id="树数据结构"><a href="#树数据结构" class="headerlink" title="树数据结构"></a>树数据结构</h4><h6 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h6><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点</p>
<p>位于树顶部的节点叫作根节点。它没有父节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。</p>
<p>一个节点可以有祖先和后代。<br>一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。<br>一个节点的后代包括子节点、孙子节点、曾孙节点等。</p>
<p>子树：子树由节点和它的后代构成。</p>
<p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p>
<p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。<br><img src="/.io//tree.png" alt="tree"></p>
<h6 id="二叉树和二叉搜索树"><a href="#二叉树和二叉搜索树" class="headerlink" title="二叉树和二叉搜索树"></a>二叉树和二叉搜索树</h6><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p>
<p>二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。<br><img src="/.io//binary-search-tree.png" alt="binary-search-tree"></p>
<p>通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）<br>键是树相关的术语中对节点的称呼</p>
<p><strong>中序遍历</strong><br><img src="/.io//in-order-traverse.png" alt="in-order-traverse"><br><strong>先序遍历</strong><br><img src="/.io//pre-order-traverse.png" alt="pre-order-traverse"><br><strong>后序遍历</strong><br><img src="/.io//post-order-traverse.png" alt="post-order-traverse"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key; <span class="comment">// &#123;1&#125; 节点值</span></span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>; <span class="comment">// 左侧子节点引用</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>; <span class="comment">// 右侧子节点引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Compare, defaultCompare &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Node &#125; <span class="keyword">from</span> <span class="string">&#x27;./models/node&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn; <span class="comment">// 用来比较节点值</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>; <span class="comment">// &#123;1&#125; Node 类型的根节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向二叉搜索树中插入一个键</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.root = <span class="keyword">new</span> Node(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        node.left = <span class="keyword">new</span> Node(key); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertNode(node.left, key); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        node.right = <span class="keyword">new</span> Node(key); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertNode(node.right, key); <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="comment">// 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。</span></span><br><span class="line">  <span class="comment">// 中序遍历的一种应用就是对树进行排序操作。</span></span><br><span class="line">  <span class="function"><span class="title">inOrderTraverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.inOrderTraverseNode(<span class="built_in">this</span>.root, callback); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">inOrderTraverseNode</span>(<span class="params">node, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverseNode(node.left, callback); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      callback(node.key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverseNode(node.right, callback); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="comment">// 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class="line">  <span class="function"><span class="title">preOrderTraverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.preOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">preOrderTraverseNode</span>(<span class="params">node, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(node.key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverseNode(node.left, callback); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverseNode(node.right, callback); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="comment">// 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小</span></span><br><span class="line">  <span class="function"><span class="title">postOrderTraverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.postOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">postOrderTraverseNode</span>(<span class="params">node, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.postOrderTraverseNode(node.left, callback); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.postOrderTraverseNode(node.right, callback); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      callback(node.key); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索最小值和最大值</span></span><br><span class="line">  <span class="function"><span class="title">min</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minNode(<span class="built_in">this</span>.root); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">minNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      current = current.left; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">max</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.maxNode(<span class="built_in">this</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">maxNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索一个特定的值</span></span><br><span class="line">  <span class="function"><span class="title">search</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">searchNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.left, key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.right, key); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除一个节点</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      node.left = <span class="built_in">this</span>.removeNode(node.left, key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      node.right = <span class="built_in">this</span>.removeNode(node.right, key); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 键等于 node.key</span></span><br><span class="line">      <span class="comment">// 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;9&#125;</span></span><br><span class="line">        node = <span class="literal">null</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第二种情况: 移除有一个左侧子节点或右侧子节点的节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;12&#125;</span></span><br><span class="line">        node = node.right; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// &#123;14&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;15&#125;</span></span><br><span class="line">        node = node.left; <span class="comment">// &#123;16&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// &#123;17&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第三种情况: 具体流程可查看后续文章</span></span><br><span class="line">      <span class="keyword">const</span> aux = <span class="built_in">this</span>.minNode(node.right); <span class="comment">// &#123;18&#125;</span></span><br><span class="line">      node.key = aux.key; <span class="comment">// &#123;19&#125;</span></span><br><span class="line">      node.right = <span class="built_in">this</span>.removeNode(node.right, aux.key); <span class="comment">// &#123;20&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;21&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>移除有两个子节点的节点</strong><br>要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。<br>(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们<br>改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的<br>最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。<br><img src="/.io//remove-left-right.png" alt="remove-left-right"></p>
<h6 id="自平衡树"><a href="#自平衡树" class="headerlink" title="自平衡树"></a>自平衡树</h6><p>Adelson-Velskii-Landi 树（AVL 树）<br>AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。</p>
<p>在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BalanceFactor = &#123;</span><br><span class="line">  <span class="attr">UNBALANCED_RIGHT</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">BALANCED</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">SLIGHTLY_UNBALANCED_LEFT</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">UNBALANCED_LEFT</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(compareFn);</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点的高度和平衡因子</span></span><br><span class="line">  <span class="function"><span class="title">getNodeHeight</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">Math</span>.max(<span class="built_in">this</span>.getNodeHeight(node.left), <span class="built_in">this</span>.getNodeHeight(node.right)) +</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getBalanceFactor</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> heightDifference =</span><br><span class="line">      <span class="built_in">this</span>.getNodeHeight(node.left) - <span class="built_in">this</span>.getNodeHeight(node.right);</span><br><span class="line">    <span class="keyword">switch</span> (heightDifference) &#123;</span><br><span class="line">      <span class="keyword">case</span> -<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class="line">      <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> BalanceFactor.BALANCED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationLL</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.left; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    node.left = tmp.right; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    tmp.right = node; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationRR</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.right; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    node.right = tmp.left; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    tmp.left = node; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationLR</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    node.left = <span class="built_in">this</span>.rotationRR(node.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rotationLL(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationRL</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    node.right = <span class="built_in">this</span>.rotationLL(node.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rotationRR(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  向 AVL 树插入节点</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 像在 BST 树中一样插入节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>.insertNode(node.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>.insertNode(node.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// 重复的键</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要，将树进行平衡操作</span></span><br><span class="line">    <span class="keyword">const</span> balanceFactor = <span class="built_in">this</span>.getBalanceFactor(node); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">        <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        node = <span class="built_in">this</span>.rotationLL(node); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationLR(node); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class="line">      <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">        <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        node = <span class="built_in">this</span>.rotationRR(node); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationRL(node); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 AVL 树中移除节点</span></span><br><span class="line">  <span class="function"><span class="title">removeNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    node = <span class="built_in">super</span>.removeNode(node, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// null，不需要进行平衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测树是否平衡</span></span><br><span class="line">    <span class="keyword">const</span> balanceFactor = <span class="built_in">this</span>.getBalanceFactor(node); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> balanceFactorLeft = <span class="built_in">this</span>.getBalanceFactor(node.left); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        balanceFactorLeft === BalanceFactor.BALANCED ||</span><br><span class="line">        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationLL(node); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class="line">        <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationLR(node.left); <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class="line">      <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      <span class="keyword">const</span> balanceFactorRight = <span class="built_in">this</span>.getBalanceFactor(node.right); <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        balanceFactorRight === BalanceFactor.BALANCED ||</span><br><span class="line">        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// &#123;11&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationRR(node); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class="line">        <span class="comment">// &#123;13&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rotationRL(node.right); <span class="comment">// &#123;14&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平衡操作——AVL 旋转</strong><br>(1)左-左（LL）：向右的单旋转<br>这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的<br><img src="/.io//left-left-1.png" alt="left-left-1"><br><img src="/.io//left-left-2.png" alt="left-left-2"></p>
<p>rotationLL 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；<br>节点 X 的左子树保持不变；<br>将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；<br>将节点 X 的右子节点置为节点 Y（行{3}）</p>
<p>(2)右-右（RR）：向左的单旋转<br>右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的<br><img src="/.io//right-right-1.png" alt="right-right-1"><br><img src="/.io//right-right-2.png" alt="right-right-2"></p>
<p>rotationRR 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；<br>节点 X 的右子树保持不变；<br>将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；<br>将节点 X 的左子节点置为节点 Y（行{3}）</p>
<p>(3)左-右（LR）：向右的双旋转<br>这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复<br><img src="/.io//left-right-1.png" alt="left-right-1"><br><img src="/.io//left-right-2.png" alt="left-right-2"></p>
<p>rotationLR 方法<br>将节点 X 置于节点 Y（平衡因子为 2）所在的位置；<br>将节点 Z 的左子节点置为节点 X 的右子节点；<br>将节点 Y 的右子节点置为节点 X 的左子节点；<br>将节点 X 的右子节点置为节点 Y；<br>将节点 X 的左子节点置为节点 Z</p>
<p>(4)右-左（RL）：向左的双旋转<br>右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复<br><img src="/.io//right-left-1.png" alt="right-left-1"><br><img src="/.io//right-left-2.png" alt="right-left-2"></p>
<p>rotationRL 方法<br>将节点 X 置于节点 Y（平衡因子为+2）所在的位置；<br>将节点 Y 的左子节点置为节点 X 的右子节点；<br>将节点 Z 的右子节点置为节点 X 的左子节点；<br>将节点 X 的左子节点置为节点 Y；<br>将节点 X 的右子节点置为节点 Z</p>
<h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好</p>
<p>在红黑树中，每个节点都遵循以下规则：<br>(1) 顾名思义，每个节点不是红的就是黑的；<br>(2) 树的根节点是黑的；<br>(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；<br>(4) 如果一个节点是红的，那么它的两个子节点都是黑的；<br>(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；<br>(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(key);</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.color = Colors.RED; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isRed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color === Colors.RED;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(compareFn);</span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key: T</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.root = <span class="keyword">new</span> RedBlackNode(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.root.color = Colors.BLACK; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newNode = <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.fixTreeProperties(newNode); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">node, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = <span class="keyword">new</span> RedBlackNode(key);</span><br><span class="line">        node.left.parent = node; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node.left; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.insertNode(node.left, key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      node.right = <span class="keyword">new</span> RedBlackNode(key);</span><br><span class="line">      node.right.parent = node; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">      <span class="keyword">return</span> node.right; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.insertNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">fixTreeProperties</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      node &amp;&amp;</span><br><span class="line">      node.parent &amp;&amp;</span><br><span class="line">      node.parent.color.isRed() &amp;&amp; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      node.color !== Colors.BLACK</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">let</span> parent = node.parent; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> grandParent = parent.parent; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="comment">// 情形 A：父节点是左侧子节点</span></span><br><span class="line">      <span class="keyword">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="keyword">const</span> uncle = grandParent.right; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        <span class="comment">// 情形 1A：叔节点也是红色——只需要重新填色</span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class="line">          <span class="comment">// &#123;7&#125;</span></span><br><span class="line">          grandParent.color = Colors.RED;</span><br><span class="line">          parent.color = Colors.BLACK;</span><br><span class="line">          uncle.color = Colors.BLACK;</span><br><span class="line">          node = grandParent; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 情形 2A：节点是右侧子节点——左旋转</span></span><br><span class="line">          <span class="keyword">if</span> (node === parent.right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rotationRR(parent); <span class="comment">// &#123;12&#125;</span></span><br><span class="line">            node = parent; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">            parent = node.parent; <span class="comment">// &#123;14&#125;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 情形 3A：节点是左侧子节点——右旋转</span></span><br><span class="line">          <span class="built_in">this</span>.rotationLL(grandParent); <span class="comment">// &#123;15&#125;</span></span><br><span class="line">          parent.color = Colors.BLACK; <span class="comment">// &#123;16&#125;</span></span><br><span class="line">          grandParent.color = Colors.RED; <span class="comment">// &#123;17&#125;</span></span><br><span class="line">          node = parent; <span class="comment">// &#123;18&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情形 B：父节点是右侧子节点</span></span><br><span class="line">        <span class="keyword">const</span> uncle = grandParent.left; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">        <span class="comment">// 情形 1B：叔节点是红色——只需要重新填色</span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class="line">          <span class="comment">// &#123;10&#125;</span></span><br><span class="line">          grandParent.color = Colors.RED;</span><br><span class="line">          parent.color = Colors.BLACK;</span><br><span class="line">          uncle.color = Colors.BLACK;</span><br><span class="line">          node = grandParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 情形 2B：节点是左侧子节点——左旋转</span></span><br><span class="line">          <span class="keyword">if</span> (node === parent.left) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rotationLL(parent); <span class="comment">// &#123;19&#125;</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 情形 3B：节点是右侧子节点——左旋转</span></span><br><span class="line">          <span class="built_in">this</span>.rotationRR(grandParent); <span class="comment">// &#123;20&#125;</span></span><br><span class="line">          parent.color = Colors.BLACK;</span><br><span class="line">          grandParent.color = Colors.RED;</span><br><span class="line">          node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.root.color = Colors.BLACK; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationLL</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.left;</span><br><span class="line">    node.left = tmp.right;</span><br><span class="line">    <span class="keyword">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class="line">      tmp.right.parent = node;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (!node.parent) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node === node.parent.left) &#123;</span><br><span class="line">        node.parent.left = tmp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.parent.right = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.right = node;</span><br><span class="line">    node.parent = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">rotationRR</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = node.right;</span><br><span class="line">    node.right = tmp.left;</span><br><span class="line">    <span class="keyword">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class="line">      tmp.left.parent = node;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (!node.parent) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node === node.parent.left) &#123;</span><br><span class="line">        node.parent.left = tmp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.parent.right = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.left = node;</span><br><span class="line">    node.parent = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。<br>左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。<br><img src="/.io//red-black-2a.png" alt="red-black-2a"><br><img src="/.io//red-black-3a.png" alt="red-black-3a"><br><img src="/.io//red-black-2b.png" alt="red-black-2b"><br><img src="/.io//red-black-3b.png" alt="red-black-3b"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/09/29/35-data-structure3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/29/35-data-structure3/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(3)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-29 10:49:51" itemprop="dateCreated datePublished" datetime="2022-09-29T10:49:51+08:00">2022-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-08 13:24:51" itemprop="dateModified" datetime="2022-10-08T13:24:51+08:00">2022-10-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合是由一组无序且唯一（即不能重复）的项组成的</p>
<h6 id="创建集合类"><a href="#创建集合类" class="headerlink" title="创建集合类"></a>创建集合类</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element <span class="keyword">in</span> items;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。</span></span><br><span class="line">  <span class="comment">// in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。</span></span><br><span class="line">  <span class="comment">// has(element) &#123;</span></span><br><span class="line">  <span class="comment">//   return Object.prototype.hasOwnProperty.call(this.items, element);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.items[element] = element; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">delete</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.items[element]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// sizeLegacy() &#123;</span></span><br><span class="line">  <span class="comment">//  let count = 0;</span></span><br><span class="line">  <span class="comment">//  for(let key in this.items) &#123; // &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量</span></span><br><span class="line">  <span class="comment">// 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原</span></span><br><span class="line">  <span class="comment">// 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对</span></span><br><span class="line">  <span class="comment">// 象自身、未用于数据结构的）</span></span><br><span class="line">  <span class="comment">//  if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125;</span></span><br><span class="line">  <span class="comment">//  count++; // &#123;4&#125;</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line">  <span class="comment">//  return count;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// valuesLegacy() &#123;</span></span><br><span class="line">  <span class="comment">//  let values = [];</span></span><br><span class="line">  <span class="comment">//  for(let key in this.items) &#123; // &#123;1&#125;</span></span><br><span class="line">  <span class="comment">//    if(this.items.hasOwnProperty(key)) &#123;</span></span><br><span class="line">  <span class="comment">//       values.push(key); // &#123;2&#125;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line">  <span class="comment">//  return values;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h6><p>(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</span></span><br><span class="line"><span class="function"><span class="title">union</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="comment">// 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中</span></span><br><span class="line">  <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> unionSet.add(value)); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  otherSet.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> unionSet.add(value)); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line">setB.add(<span class="number">5</span>);</span><br><span class="line">setB.add(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> unionAB = setA.union(setB);</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values());</span><br><span class="line"><span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<p>(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">intersection</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"> <span class="keyword">const</span> values = <span class="built_in">this</span>.values();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">   <span class="keyword">if</span> (otherSet.has(values[i])) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">     intersectionSet.add(values[i]); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> intersectionAB = setA.intersection(setB);</span><br><span class="line"><span class="built_in">console</span>.log(intersectionAB.values());</span><br><span class="line"><span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="function"><span class="title">intersection</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"> <span class="keyword">const</span> values = <span class="built_in">this</span>.values(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line"> <span class="keyword">const</span> otherValues = otherSet.values(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line"> <span class="keyword">let</span> biggerSet = values; <span class="comment">// &#123;4&#125;</span></span><br><span class="line"> <span class="keyword">let</span> smallerSet = otherValues; <span class="comment">// &#123;5&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (otherValues.length - values.length &gt; <span class="number">0</span>) &#123; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">   biggerSet = otherValues;</span><br><span class="line">   smallerSet = values;</span><br><span class="line"> &#125;</span><br><span class="line"> smallerSet.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">   <span class="keyword">if</span> (biggerSet.includes(value)) &#123;</span><br><span class="line">     intersectionSet.add(value);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">difference</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!otherSet.has(value)) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      differenceSet.add(value); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> differenceAB = setA.difference(setB);</span><br><span class="line"><span class="built_in">console</span>.log(differenceAB.values());</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>(4)子集：验证一个给定集合是否是另一集合的子集</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isSubsetOf</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.size() &gt; otherSet.size()) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isSubset = <span class="literal">true</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止</span></span><br><span class="line">  <span class="built_in">this</span>.values().every(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!otherSet.has(value)) &#123; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      isSubset = <span class="literal">false</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> isSubset; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">1</span>);</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> setC = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setC.add(<span class="number">2</span>);</span><br><span class="line">setC.add(<span class="number">3</span>);</span><br><span class="line">setC.add(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(setA.isSubsetOf(setB));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSubsetOf(setC));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="使用扩展运算符"><a href="#使用扩展运算符" class="headerlink" title="使用扩展运算符"></a>使用扩展运算符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...setA, ...setB]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> setB.has(x))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !setB.has(x))));</span><br></pre></td></tr></table></figure>

<h4 id="字典和散列表"><a href="#字典和散列表" class="headerlink" title="字典和散列表"></a>字典和散列表</h4><h6 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h6><p>在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。<br>字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。<br>字典也称作映射、符号表或关联数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultToString</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;NULL&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;UNDEFINED&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;string&#x27;</span> || item <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.toString(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;<span class="built_in">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defaultToString &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测一个键是否存在于字典中</span></span><br><span class="line">  <span class="function"><span class="title">hasKey</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)] != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在字典和 ValuePair 类中设置键和值</span></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.table[tableKey] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从字典中移除一个值</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.hasKey(key)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从字典中检索一个值</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">keyValues</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.table);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function">(<span class="params">valuePair</span>) =&gt;</span> valuePair.key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function">(<span class="params">valuePair</span>) =&gt;</span> valuePair.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">forEach</span>(<span class="params">callbackFn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (result === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.table).length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues();</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;valuePairs[<span class="number">0</span>].toString()&#125;</span>`</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h6><p>散列算法的作用是尽可能快地在数据结构中找到一个值</p>
<p>散列函数的作用是给定一个键值，然后返回值在表中的地址</p>
<p>散列表有一些在计算机科学中应用的例子:<br>(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用<br>(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。</p>
<p>散列函数 —- lose lose 散列函数<br><img src="/.io//lose-lose.png" alt="lose-lose"></p>
<p>HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我<br>们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而<br>在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存<br>在 hash 位置（或属性）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建散列函数</span></span><br><span class="line">  <span class="function"><span class="title">loseloseHashCode</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 根据组成 key 的每个字符的 ASCII 码值的和得到一个数</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class="line">      hash += tableKey.charCodeAt(i); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;）</span></span><br><span class="line">    <span class="comment">// 这可以规避操作数超过数值变量最大表示范围的风险</span></span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hashCode</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.loseloseHashCode(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.hashCode(key)];</span><br><span class="line">    <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="built_in">this</span>.hashCode(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[hash]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.table[hash]; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = <span class="keyword">new</span> HashTable();</span><br><span class="line">hash.put(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">hash.put(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line">hash.put(<span class="string">&#x27;Tyrion&#x27;</span>, <span class="string">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.hashCode(<span class="string">&#x27;Gandalf&#x27;</span>) + <span class="string">&#x27; - Gandalf&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.hashCode(<span class="string">&#x27;John&#x27;</span>) + <span class="string">&#x27; - John&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.hashCode(<span class="string">&#x27;Tyrion&#x27;</span>) + <span class="string">&#x27; - Tyrion&#x27;</span>);</span><br><span class="line"><span class="comment">// 19 - Gandalf</span></span><br><span class="line"><span class="comment">// 29 - John</span></span><br><span class="line"><span class="comment">// 16 - Tyrion</span></span><br></pre></td></tr></table></figure>

<p><strong>散列集合</strong><br>散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数<br>散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。</p>
<p><strong>散列表中的冲突</strong><br>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突</p>
<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>
<p>(1)分离链接<br>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间<br><img src="/.io//sperate-chain.png" alt="sperate-chain"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTableSeparateChaining</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">      <span class="comment">//  将验证要加入新元素的位置是否已经被占据</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> LinkedList(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.table[position].push(<span class="keyword">new</span> ValuePair(key, value)); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化</span></span><br><span class="line">  <span class="comment">// LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key</span></span><br><span class="line">  <span class="comment">// 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较</span></span><br><span class="line">  <span class="comment">// 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要</span></span><br><span class="line">  <span class="comment">// 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。</span></span><br><span class="line">  <span class="comment">// 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">const</span> linkedList = <span class="built_in">this</span>.table[position]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (linkedList != <span class="literal">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">let</span> current = linkedList.getHead(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123;</span><br><span class="line">          <span class="comment">// &#123;5&#125;</span></span><br><span class="line">          <span class="keyword">return</span> current.element.value; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">const</span> linkedList = <span class="built_in">this</span>.table[position];</span><br><span class="line">    <span class="keyword">if</span> (linkedList != <span class="literal">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = linkedList.getHead();</span><br><span class="line">      <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123;</span><br><span class="line">          <span class="comment">// &#123;1&#125;</span></span><br><span class="line">          linkedList.remove(current.element); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">          <span class="keyword">if</span> (linkedList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// &#123;3&#125;</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.table[position]; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)线性探查<br>它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中<br>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置<br><img src="/.io//linear-probing.png" alt="linear-probing"></p>
<p>线性探查技术分为两种。</p>
<p>第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因<br><img src="/.io//soft-delete.png" alt="soft-delete"><br><a target="_blank" rel="noopener" href="http://github.com/loiane/javascript-datastructures-algorithms">源代码</a></p>
<p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。<br><img src="/.io//move-key.png" alt="move-key"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move-key</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTableSeparateChainingMoveKey</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">    <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = position + <span class="number">1</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// &#123;4&#125;</span></span><br><span class="line">          index++; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.table[index] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注</span></span><br><span class="line">  <span class="comment">// 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需</span></span><br><span class="line">  <span class="comment">// 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数</span></span><br><span class="line">  <span class="comment">// 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需</span></span><br><span class="line">  <span class="comment">// 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一</span></span><br><span class="line">  <span class="comment">// 个功能</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position].key === key) &#123;</span><br><span class="line">        <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.table[position].value; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> index = position + <span class="number">1</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key !== key) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key === key) &#123;</span><br><span class="line">        <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.table[position].value; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="built_in">this</span>.hashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.table[position] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[position].key === key) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.table[position]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.verifyRemoveSideEffect(key, position); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> index = position + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key !== key) &#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.table[index].key === key) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.table[index]; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.verifyRemoveSideEffect(key, index); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">verifyRemoveSideEffect</span>(<span class="params">key, removedPosition</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="built_in">this</span>.hashCode(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> index = removedPosition + <span class="number">1</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.table[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> posHash = <span class="built_in">this</span>.hashCode(<span class="built_in">this</span>.table[index].key); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;</span><br><span class="line">        <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.table[removedPosition] = <span class="built_in">this</span>.table[index]; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.table[index];</span><br><span class="line">        removedPosition = index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更好的散列函数</strong><br>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">djb2HashCode</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"><span class="comment">//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381</span></span><br><span class="line"> <span class="keyword">let</span> hash = <span class="number">5381</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.length; i++) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line"><span class="comment">//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加</span></span><br><span class="line"> hash = (hash * <span class="number">33</span>) + tableKey.charCodeAt(i); <span class="comment">// &#123;4&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//  将使用相加的和与另一个随机质数相除的余数</span></span><br><span class="line"> <span class="keyword">return</span> hash % <span class="number">1013</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0</span></span><br></pre></td></tr></table></figure>

<p><strong>ES2015 Map 类</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;Tyrion&#x27;</span>, <span class="string">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;Gandalf&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,</span></span><br><span class="line"><span class="string">&quot;tyrion@email.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;Tyrion&#x27;</span>)); <span class="comment">// tyrion@email.com</span></span><br><span class="line">map.delete(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ES2105 WeakMap 类和 WeakSet 类</strong><br>Map 和 Set 与其弱化版本之间仅有的区别是:<br>(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法<br>(2)WeakSet 和 WeakMap 只能用对象作为键</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> ob1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Gandalf&#x27;</span> &#125;; <span class="comment">// &#123;1&#125;</span></span><br><span class="line"><span class="keyword">const</span> ob2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ob3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tyrion&#x27;</span> &#125;;</span><br><span class="line">map.set(ob1, <span class="string">&#x27;gandalf@email.com&#x27;</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">map.set(ob2, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line">map.set(ob3, <span class="string">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob1)); <span class="comment">// true &#123;3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(ob3)); <span class="comment">// tyrion@email.com &#123;4&#125;</span></span><br><span class="line">map.delete(ob2); <span class="comment">// &#123;5&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/09/23/34-data-structure2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/23/34-data-structure2/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(2)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-23 15:52:54" itemprop="dateCreated datePublished" datetime="2022-09-23T15:52:54+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-27 17:21:29" itemprop="dateModified" datetime="2022-09-27T17:21:29+08:00">2022-09-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向队列添加元素</span></span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从队列移除元素</span></span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.lowestCount++; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看队列头元素</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查队列是否为空</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取队列的长度</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h6><p>双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列</p>
<p>由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 向双端队列的前端添加元素</span></span><br><span class="line">  <span class="function"><span class="title">addFront</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.addBack(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.lowestCount &gt; <span class="number">0</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.lowestCount--;</span><br><span class="line">      <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount] = element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.count; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="built_in">this</span>.items[i] = <span class="built_in">this</span>.items[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">      <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">this</span>.items[<span class="number">0</span>] = element; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addBack</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeFront</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.lowestCount++; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeBack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peekFront</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peekBack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="循环队列-击鼓传花"><a href="#循环队列-击鼓传花" class="headerlink" title="循环队列 - 击鼓传花"></a>循环队列 - 击鼓传花</h6><p>场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">elementsList, num</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue(); <span class="comment">// &#123;1&#125; </span></span><br><span class="line">  <span class="keyword">const</span> elimitatedList = [];</span><br><span class="line">  <span class="comment">// 把名单的名字全都加入队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elementsList.length; i++) &#123; </span><br><span class="line">    queue.enqueue(elementsList[i]); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代队列</span></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123; </span><br><span class="line">      <span class="comment">// 将队列开头一项移除，添加到队列末尾</span></span><br><span class="line">      queue.enqueue(queue.dequeue()); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 将超出限制的队列开头一项移除，作为淘汰项</span></span><br><span class="line">    elimitatedList.push(queue.dequeue()); <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">eliminated</span>: elimitatedList, </span><br><span class="line">    <span class="attr">winner</span>: queue.dequeue() <span class="comment">// &#123;5&#125; </span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Camila&#x27;</span>, <span class="string">&#x27;Ingrid&#x27;</span>, <span class="string">&#x27;Carl&#x27;</span>]; </span><br><span class="line"><span class="keyword">const</span> result = hotPotato(names, <span class="number">7</span>);</span><br><span class="line">result.eliminated.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`胜利者： <span class="subst">$&#123;result.winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<h6 id="回文检查器"><a href="#回文检查器" class="headerlink" title="回文检查器"></a>回文检查器</h6><p>回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindromeChecker</span>(<span class="params">aString</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查传入的字符串参数是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (aString === <span class="literal">undefined</span> || aString === <span class="literal">null</span> || (aString !== <span class="literal">null</span> &amp;&amp; aString.length === <span class="number">0</span>)) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> Deque(); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  <span class="comment">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class="line">  <span class="keyword">const</span> lowerString = aString.toLocaleLowerCase().split(<span class="string">&#x27; &#x27;</span>).join(<span class="string">&#x27;&#x27;</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">  <span class="keyword">let</span> isEqual = <span class="literal">true</span>; </span><br><span class="line">  <span class="keyword">let</span> firstChar, lastChar;</span><br><span class="line">  <span class="comment">// 将所有字符串加入队列中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerString.length; i++) &#123; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">    deque.addBack(lowerString.charAt(i)); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (deque.size() &gt; <span class="number">1</span> &amp;&amp; isEqual) &#123; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">    firstChar = deque.removeFront(); <span class="comment">// &#123;6&#125; </span></span><br><span class="line">    lastChar = deque.removeBack(); <span class="comment">// &#123;7&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123; </span><br><span class="line">      isEqual = <span class="literal">false</span>; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> isEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">javascript事件循环</a></p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h6 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h6><p><img src="/.io//chain-table-1.png" alt="链表"><br>链表的好处：添加或移除元素的时候不需要移动其他元素<br>要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> a === b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// models/linked-list-models</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element; </span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">undefined</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defaultEquals &#125; <span class="keyword">from</span> <span class="string">&#x27;../util&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; Node &#125; <span class="keyword">from</span> <span class="string">&#x27;./models/linked-list-models&#x27;</span>; <span class="comment">// &#123;1&#125; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="literal">undefined</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.equalsFn = equalsFn; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向链表尾部添加元素</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element); <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">let</span> current; <span class="comment">// &#123;2&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">      <span class="built_in">this</span>.head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = <span class="built_in">this</span>.head; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">      <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123; <span class="comment">// &#123;5&#125; 获得最后一项</span></span><br><span class="line">        current = current.next; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将其 next 赋为新元素，建立链接</span></span><br><span class="line">      current.next = node; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">this</span>.count++; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从链表中移除元素</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">      <span class="comment">// 移除第一项</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.head = current.next; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前index的前一个节点</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">        current = previous.next;</span><br><span class="line">        <span class="comment">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class="line">        previous.next = current.next; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--; <span class="comment">// &#123;9&#125; </span></span><br><span class="line">      <span class="keyword">return</span> current.element; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;10&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环迭代链表直到目标位置</span></span><br><span class="line">  <span class="function"><span class="title">getElementAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">let</span> node = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index &amp;&amp; node != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        node = node.next;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在任意位置插入元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置添加</span></span><br><span class="line">        <span class="keyword">const</span> current = <span class="built_in">this</span>.head; </span><br><span class="line">        node.next = current; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.head = node; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        <span class="keyword">const</span> current = previous.next; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">        node.next = current; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">        previous.next = node; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">this</span>.count++; <span class="comment">// 更新链表的长度</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  indexOf 方法：返回一个元素的位置</span></span><br><span class="line">  <span class="function"><span class="title">indexOf</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.equalsFn(element, current.element)) &#123; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从链表中移除元素</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.indexOf(element); </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count === <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHead</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.head; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.head.element&#125;</span>`</span>; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head.next; <span class="comment">// &#123;3&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;current.element&#125;</span>`</span>; </span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> objString; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">javascript垃圾回收器</a></p>
<h6 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h6><p>在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素<br><img src="/.io//chain-table-2.png" alt="双向链表"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">element, next, prev</span>)</span> &#123; </span><br><span class="line">  <span class="built_in">super</span>(element, next); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">  <span class="built_in">this</span>.prev = prev; <span class="comment">// &#123;3&#125; 新增的</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">super</span>(equalsFn); <span class="comment">// &#123;5&#125; </span></span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="literal">undefined</span>; <span class="comment">// &#123;6&#125; 新增的</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  在任意位置插入新元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element); </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;1&#125; 新增的</span></span><br><span class="line">            <span class="built_in">this</span>.head = node; </span><br><span class="line">            <span class="built_in">this</span>.tail = node; </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            node.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">            current.prev = node; <span class="comment">// &#123;3&#125; 新增的</span></span><br><span class="line">            <span class="built_in">this</span>.head = node; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">          &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count) &#123; <span class="comment">// 最后一项 // 新增的</span></span><br><span class="line">        current = <span class="built_in">this</span>.tail; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">        current.next = node; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">        node.prev = current; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.tail = node; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;9&#125; </span></span><br><span class="line">        current = previous.next; <span class="comment">// &#123;10&#125; </span></span><br><span class="line">        node.next = current; <span class="comment">// &#123;11&#125; </span></span><br><span class="line">        previous.next = node; <span class="comment">// &#123;12&#125; </span></span><br><span class="line">        current.prev = node; <span class="comment">// &#123;13&#125; 新增的</span></span><br><span class="line">        node.prev = previous; <span class="comment">// &#123;14&#125; 新增的</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count++; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">this</span>.head = current.next; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">        <span class="comment">// 如果只有一项，更新 tail // 新增的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count === <span class="number">1</span>) &#123; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">          <span class="built_in">this</span>.tail = <span class="literal">undefined</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="built_in">this</span>.head.prev = <span class="literal">undefined</span>; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">        &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count - <span class="number">1</span>) &#123; <span class="comment">// 最后一项 //新增的</span></span><br><span class="line">        current = <span class="built_in">this</span>.tail; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.tail = current.prev; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">        <span class="built_in">this</span>.tail.next = <span class="literal">undefined</span>; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        current = <span class="built_in">this</span>.getElementAt(index); <span class="comment">// &#123;7&#125; </span></span><br><span class="line">        <span class="keyword">const</span> previous = current.prev; <span class="comment">// &#123;8&#125; </span></span><br><span class="line">        <span class="comment">// 将 previous 与 current 的下一项链接起来——跳过 current </span></span><br><span class="line">        previous.next = current.next; <span class="comment">// &#123;9&#125; </span></span><br><span class="line">        current.next.prev = previous; <span class="comment">// &#123;10&#125; 新增的</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--; </span><br><span class="line">      <span class="keyword">return</span> current.element; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源码：https://github.com/loiane/javascript-datastructures-algorithms</span></span><br></pre></td></tr></table></figure>

<h6 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h6><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）<br>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev<br><img src="/.io//chain-table-3.png" alt="循环链表"><br><img src="/.io//chain-table-4.png" alt="双向循环链表"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(equalsFn); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在任意位置插入新元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element); </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123; </span><br><span class="line">          <span class="built_in">this</span>.head = node; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">          node.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;2&#125; 新增的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          node.next = current; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">          current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size()); <span class="comment">// &#123;4&#125; </span></span><br><span class="line">          <span class="comment">// 更新最后一个元素</span></span><br><span class="line">          <span class="built_in">this</span>.head = node; <span class="comment">// &#123;5&#125; </span></span><br><span class="line">          current.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;6&#125; 新增的</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这种场景没有变化</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); </span><br><span class="line">        node.next = previous.next; </span><br><span class="line">        previous.next = node; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">this</span>.count++; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">index</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123; </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() === <span class="number">1</span>) &#123; </span><br><span class="line">          <span class="built_in">this</span>.head = <span class="literal">undefined</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="keyword">const</span> removed = <span class="built_in">this</span>.head; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">          current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size()); <span class="comment">// &#123;2&#125; 新增的</span></span><br><span class="line">          <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">          current.next = <span class="built_in">this</span>.head; <span class="comment">// &#123;4&#125; </span></span><br><span class="line">          current = removed; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 不需要修改循环链表最后一个元素</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>); </span><br><span class="line">        current = previous.next; </span><br><span class="line">        previous.next = current.next; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--; </span><br><span class="line">      <span class="keyword">return</span> current.element; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h6><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Compare = &#123; </span><br><span class="line">  <span class="attr">LESS_THAN</span>: -<span class="number">1</span>, </span><br><span class="line">  <span class="attr">BIGGER_THAN</span>: <span class="number">1</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class="comment">// &#123;2&#125; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">equalsFn = defaultEquals, compareFn = defaultCompare</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">super</span>(equalsFn); </span><br><span class="line">    <span class="built_in">this</span>.compareFn = compareFn; <span class="comment">// &#123;3&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有序插入元素</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">element, index = <span class="number">0</span></span>)</span> &#123; <span class="comment">// &#123;1&#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, <span class="number">0</span>); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">const</span> pos = <span class="built_in">this</span>.getIndexNextSortedElement(element); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, pos); <span class="comment">// &#123;4&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="title">getIndexNextSortedElement</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head; </span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current; i++) &#123; </span><br><span class="line">      <span class="keyword">const</span> comp = <span class="built_in">this</span>.compareFn(element, current.element); <span class="comment">// &#123;5&#125; </span></span><br><span class="line">      <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123; <span class="comment">// &#123;6&#125; </span></span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">      &#125; </span><br><span class="line">      current = current.next; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// &#123;7&#125; </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建-StackLinkedList-类"><a href="#创建-StackLinkedList-类" class="headerlink" title="创建 StackLinkedList 类"></a>创建 StackLinkedList 类</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackLinkedList</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> DoublyLinkedList(); <span class="comment">// &#123;1&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.items.push(element); <span class="comment">// &#123;2&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.removeAt(<span class="built_in">this</span>.size() - <span class="number">1</span>); <span class="comment">// &#123;3&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/09/21/32-apply-array-to-params/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/21/32-apply-array-to-params/" class="post-title-link" itemprop="url">js中apply怎么把数组转化为参数？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-21 17:07:53" itemprop="dateCreated datePublished" datetime="2022-09-21T17:07:53+08:00">2022-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-25 14:46:40" itemprop="dateModified" datetime="2022-10-25T14:46:40+08:00">2022-10-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h6 id="apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组"><a href="#apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组" class="headerlink" title="apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组"></a>apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(a);</span><br><span class="line"> <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line">test(array);</span><br><span class="line"><span class="comment">// [1, 10]</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">test.apply(<span class="literal">null</span>, array);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line"> <span class="attr">func</span>: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line">test.func(array);</span><br><span class="line"><span class="comment">// [1, 10]</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line">test.func.apply(test.func, array);</span><br><span class="line">test.func.apply(<span class="literal">null</span>, array);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(array);</span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array);</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h6 id="ES6中的扩展符"><a href="#ES6中的扩展符" class="headerlink" title="ES6中的扩展符"></a>ES6中的扩展符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(a);</span><br><span class="line"> <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line">test(...array);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line"> <span class="attr">func</span>: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">10</span>];</span><br><span class="line">test.func(...array);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...array);</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h6 id="使用arguments对象（不建议使用）"><a href="#使用arguments对象（不建议使用）" class="headerlink" title="使用arguments对象（不建议使用）"></a>使用arguments对象（不建议使用）</h6><p>函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 1 12 5</span></span><br><span class="line">test(<span class="number">1</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 1 12 3 4 5</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://sunjinkang.github.io/2022/09/20/33-data-structure1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Sun Jinkang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun ...something">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sun ...something">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/20/33-data-structure1/" class="post-title-link" itemprop="url">数据结构与算法阅读笔记(1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-20 17:41:00" itemprop="dateCreated datePublished" datetime="2022-09-20T17:41:00+08:00">2022-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-23 15:51:52" itemprop="dateModified" datetime="2022-09-23T15:51:52+08:00">2022-09-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ECMAScript 和 javascript 的关系<br>ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。</p>
<p>ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别</p>
<p>(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)</p>
<p>(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性<br>一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)</p>
<p>(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)</p>
<p>(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)</p>
<p>(5)ES.Next 用来指代下一个版本的 ECMAScript</p>
<p>ES6 兼容性：<a target="_blank" rel="noopener" href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a><br>ES7 兼容性：<a target="_blank" rel="noopener" href="http://kangax.github.io/compat-table/es2016plus/">http://kangax.github.io/compat-table/es2016plus/</a></p>
<p>ES5 中 class 类，使用属性存取器<br>(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字<br>(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lotrChar = <span class="keyword">new</span> Person(<span class="string">&#x27;Frodo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lotrChar.name); <span class="comment">// &#123;4&#125; // Frodo</span></span><br><span class="line">lotrChar.name = <span class="string">&#x27;Gandalf&#x27;</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(lotrChar.name); <span class="comment">// Gandalf</span></span><br><span class="line">lotrChar._name = <span class="string">&#x27;Sam&#x27;</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(lotrChar.name); <span class="comment">// Sam</span></span><br></pre></td></tr></table></figure>

<p>乘方运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * r * r;</span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * <span class="built_in">Math</span>.pow(r, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ES2016 中引入了**运算符，用来进行指数运算</span></span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * r ** <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript 和 ECMAScript 的完整功能列表</a></p>
<h6 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h6><p>TypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.<br>(1)接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种定义接口的方式</span></span><br><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，</span></span><br><span class="line"><span class="comment">并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/</span></span><br><span class="line">interface Comparable &#123;</span><br><span class="line">  compareTo(b): number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="title">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="attr">age</span>: number;</span><br><span class="line">  compareTo(b): number &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.age === b.age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age &gt; b.age ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check</strong></p>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组</p>
<p>(1)使用@@iterator 对象<br>ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制已有数组</span></span><br><span class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers);</span><br><span class="line"><span class="keyword">let</span> numbers3 = <span class="built_in">Array</span>.of(...numbers);</span><br></pre></td></tr></table></figure>

<p>(2)copyWithin<br>copyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copyArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">copyArray.copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// copyWithin(起始位置，开始位置，结束位置)</span></span><br><span class="line"><span class="comment">// [1, 4, 5, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>(3)排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line"><span class="keyword">const</span> friends = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Ana&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;Chris&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;, <span class="comment">// ES2017 允许存在尾逗号</span></span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">comparePerson</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.age &lt; b.age) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a.age &gt; b.age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(friends.sort(comparePerson));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[ </span></span><br><span class="line"><span class="comment"> &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, </span></span><br><span class="line"><span class="comment"> &#123; name: &#x27;Chris&#x27;, age: 25 &#125;,</span></span><br><span class="line"><span class="comment"> &#123; name: &#x27;John&#x27;, age: 30 &#125;, </span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 忽略大小写的比较</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;ana&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;John&#x27;</span>]; <span class="comment">// 重置数组的初始状态</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  names.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.toLowerCase() &lt; b.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.toLowerCase() &gt; b.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;ana&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;John&#x27;</span>];</span><br><span class="line">names.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class="line"><span class="comment">// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names2 = [<span class="string">&#x27;Maève&#x27;</span>, <span class="string">&#x27;Maeve&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(names2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b)));</span><br><span class="line"><span class="comment">// [&quot;Maeve&quot;, &quot;Maève&quot;]</span></span><br></pre></td></tr></table></figure>

<h6 id="类型数组"><a href="#类型数组" class="headerlink" title="类型数组"></a>类型数组</h6><table>
<thead>
<tr>
<th>类型数组</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>Int8Array</td>
<td>8 位二进制补码整数</td>
</tr>
<tr>
<td>Uint8Array</td>
<td>8 位无符号整数</td>
</tr>
<tr>
<td>Uint8ClampedArray</td>
<td>8 位无符号整数</td>
</tr>
<tr>
<td>Int16Array</td>
<td>16 位二进制补码整数</td>
</tr>
<tr>
<td>Uint16Array</td>
<td>16 位无符号整数</td>
</tr>
<tr>
<td>Int32Array</td>
<td>32 位二进制补码整数</td>
</tr>
<tr>
<td>Uint32Array</td>
<td>32 位无符号整数</td>
</tr>
<tr>
<td>Float32Array</td>
<td>32 位 IEEE 浮点数</td>
</tr>
<tr>
<td>Float64Array</td>
<td>64 位 IEEE 浮点数</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> length = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> int16 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(length);</span><br><span class="line"><span class="keyword">let</span> array16 = [];</span><br><span class="line">array16.length = length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  int16[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(int16);</span><br></pre></td></tr></table></figure>

<p>类型数组作用：WebGL API、位操作、处理文件和图像</p>
<p><a target="_blank" rel="noopener" href="https://web.dev/webgl-typed-arrays/">类型数组文档</a></p>
<h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底</p>
<p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）</p>
<p>(1)创建一个基于数组的栈</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个（或几个）新元素到栈顶</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈里的元素个数。该方法和数组的 length 属性很类似</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈里的所有元素</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。</strong><br>(2)创建一个基于 JavaScript 对象的 Stack 类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素</span></span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向栈中插入元素,只允许一次插入一个元素</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 验证一个栈的大小</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取栈是否为空</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶的值</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  while (!this.isEmpty()) &#123;</span></span><br><span class="line">    <span class="comment">//  this.pop();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">      <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>javascript 实现私有属性的方法</strong><br>下划线命名约定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中使用下划线命名约定来标记一个属性为私有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>._items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识</em></p>
<p><strong>用 ES2015 的限定作用域 Symbol 实现类</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _items = <span class="built_in">Symbol</span>(<span class="string">&#x27;stackItems&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 栈的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(stack);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].push(<span class="number">1</span>);</span><br><span class="line">stack.print(); <span class="comment">// 输出 5, 8, 1</span></span><br></pre></td></tr></table></figure>

<p><em>访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求</em></p>
<p><strong>用 ES2015 的 WeakMap 实现类</strong><br>WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    items.set(<span class="built_in">this</span>, []); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = items.get(<span class="built_in">this</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    s.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = items.get(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">const</span> r = s.pop();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>代码的可读性不强，而且在扩展该类时无法继承私有属性</em></p>
<p><strong>ECMAScript 类属性提案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  #items = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 栈的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从十进制转二进制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">let</span> number = decNumber;</span><br><span class="line">  <span class="keyword">let</span> rem;</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(number % <span class="number">2</span>);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    binaryString += remStack.pop().toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进制转换算法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">decNumber, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">const</span> digits = <span class="string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  <span class="keyword">let</span> number = decNumber;</span><br><span class="line">  <span class="keyword">let</span> rem;</span><br><span class="line">  <span class="keyword">let</span> baseString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(base &gt;= <span class="number">2</span> &amp;&amp; base &lt;= <span class="number">36</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(number % base);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / base);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    baseString += digits[remStack.pop()]; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/5/">5</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Jinkang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
