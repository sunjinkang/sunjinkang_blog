{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.jpeg","path":"images/logo.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/index.md","hash":"91cb1e72963ad40b848ddf44f36eb46c0391cc22","modified":1666681088887},{"_id":"source/_posts/1-hello-world.md","hash":"270b836ccfe6be2557efe7cff4f7508dcbe21bba","modified":1655949513679},{"_id":"source/_posts/10-about-meta.md","hash":"bb4ea509d4e70d028ab897066775a3c5daa92e4c","modified":1658389708630},{"_id":"source/_posts/11-github-push-insert-password.md","hash":"4b012a4cc4f906f27b1073639d349af384637565","modified":1656566532389},{"_id":"source/_posts/12-create-github-tokens.md","hash":"36bc1839b5bbc1938ce1e8b84ada86cb81b5683b","modified":1656566299719},{"_id":"source/_posts/13-document-location.md","hash":"2edfccf29ce6fa6ce3eb7ff5c961df6d8446ddd3","modified":1660619166205},{"_id":"source/_posts/14-about-fe-theory.md","hash":"5a090673e16c377c4d2d578998cb29d6fb88aa5a","modified":1658123245279},{"_id":"source/_posts/15-js-transform.md","hash":"e696a1a70a8634cac69b43cd2892f45e82838a37","modified":1660101077050},{"_id":"source/_posts/16-origin-type-and-reference-type.md","hash":"10b010393111f0a8cf7c4644b8acd4bfc87cf2ef","modified":1660101267201},{"_id":"source/_posts/17-about-dom.md","hash":"8b9d82b293d05a8607338ba7805995668a2a75bc","modified":1661856873610},{"_id":"source/_posts/18-fake-array.md","hash":"1c2ab5ff218428b5e1de4a589f681afd808e21ec","modified":1659597456091},{"_id":"source/_posts/2-var-const-let.md","hash":"41e5f191349193383557269ea8ec33cf0d9ce21c","modified":1660101369107},{"_id":"source/_posts/19-about-map.md","hash":"f39821c6d8c12680cecf25f6abddd8430f3ed0eb","modified":1659598283549},{"_id":"source/_posts/20-create-vscode-plugin.md","hash":"653b6b918bb11faa8cc85909e37b971d5d07bf0e","modified":1659679736829},{"_id":"source/_posts/21-devan-operation.md","hash":"6bbc2c6364decd9a99cb4f72c1626a757fa4a871","modified":1660807793069},{"_id":"source/_posts/22-about-symbol.md","hash":"99d71ea1b58e50276b11a2debd131027221678e0","modified":1660887762437},{"_id":"source/_posts/23-about-design-model.md","hash":"9eb2c5bd6124d1a582158156ccc553a079934b46","modified":1663838158613},{"_id":"source/_posts/24-about-design-model1.md","hash":"8f76ec64f22977e4d5a6486f4e4090779a91f5c5","modified":1663838190022},{"_id":"source/_posts/25-about-design-model2.md","hash":"6adc57fe87e1a23af4cb2ccf359caaa5e9d52a23","modified":1663838204404},{"_id":"source/_posts/26-about-design-model3.md","hash":"5f3244ba3d46a81d344ad7a0436b1ed877ed6121","modified":1663838226427},{"_id":"source/_posts/27-about-design-model4.md","hash":"8b9f3064b26ee72f6a4d886726923dab412a6043","modified":1663915885454},{"_id":"source/_posts/28-about-design-model5.md","hash":"8fb3151d527abdb7b72d37b7072df8e9cf9e90a0","modified":1663916378606},{"_id":"source/_posts/29-es6-object-strong.md","hash":"6ae821db818da9d8730d16f9569103b5e560f350","modified":1662097772109},{"_id":"source/_posts/3-about-use-hexo.md","hash":"bba5bc4aff5263c99eed59daf779fe7a3fbd2b93","modified":1660101113291},{"_id":"source/_posts/30-some-convenient-code.md","hash":"77144e1fdf0f043b670668068dfce18ff5c73b18","modified":1662356523830},{"_id":"source/_posts/31-get-and-set-prototypeof.md","hash":"035d9fccc65f0c58943ade176ca7d6ec49026c7f","modified":1662360142960},{"_id":"source/_posts/33-data-structure1.md","hash":"e6524756037ae38015b2ada98ef9e8c3783b0090","modified":1663919512037},{"_id":"source/_posts/32-apply-array-to-params.md","hash":"52d35507e347e52b26921224d017b6d2a82edc58","modified":1666680400737},{"_id":"source/_posts/34-data-structure2.md","hash":"4e0f33961038eb3349bcb221f53886a7b8732882","modified":1664270489523},{"_id":"source/_posts/35-data-structure3.md","hash":"c92d6cb215fc4f8386a98274573e19ca678ff032","modified":1665206691061},{"_id":"source/_posts/36-data-structure4.md","hash":"7951edc4e2ffb8d2e63b958726c452062cd91c06","modified":1665217503909},{"_id":"source/_posts/37-data-structure5.md","hash":"ffc693174996ef51966af77150292509158b426b","modified":1665641643893},{"_id":"source/_posts/38-data-structure6.md","hash":"d912b4354998b96e9dfab0b0781172ece08451de","modified":1665648774939},{"_id":"source/_posts/39-data-structure7.md","hash":"8a45476dfce18636b702ba2e62b184cb5d27feae","modified":1666665253998},{"_id":"source/_posts/4-browser-render.md","hash":"748dabbf3eaa00f47492d9d5909abaebbb4ae79e","modified":1666668016618},{"_id":"source/_posts/40-tail-call.md","hash":"83cd41ca9828cc618c12778743be460088938096","modified":1665986791462},{"_id":"source/_posts/41-nodejs-base.md","hash":"722a36d827bf691629c1d63d3e799c9d06d3230d","modified":1666595053140},{"_id":"source/_posts/5-react-render.md","hash":"3d1ecf1f8ba758118a9958874f508559db7f5a93","modified":1660101306301},{"_id":"source/_posts/6-vue3-render.md","hash":"0e7f667b40d879002559a3e6be9ea488e11a467b","modified":1660101380555},{"_id":"source/_posts/7-question-about-render.md","hash":"362aefe2d4a9469e1320feb49412433993979820","modified":1660101293040},{"_id":"source/_posts/8-create-fixed-length-array.md","hash":"bb6b775930a2282b80b9b78f0239c17461fec807","modified":1660101146408},{"_id":"source/_posts/9-text-type-about-markdown.md","hash":"0d57e2234ae893536c0e0a54f958129b02e46ed7","modified":1665716504781},{"_id":"source/commonweal/index.md","hash":"ad7fb815e56ba127e811a3567a619a7ab7edf654","modified":1660024567905},{"_id":"source/vue/change.md","hash":"0657a56e1da4d07caae9b44aae3d845ade2e7325","modified":1643105454040},{"_id":"source/vue/dependency.md","hash":"b96d71c3fd9006df71d6a7e7a25602472b1caa0d","modified":1643105980849},{"_id":"source/vue/index.md","hash":"a57df7e0596d7db725d855a700185c74dcfed5c4","modified":1643106514167},{"_id":"source/_posts/15-js-transform/js-transform.html","hash":"f4f8d85e5386d9b251c24aea038d4c57c88ede50","modified":1660210173722},{"_id":"source/_posts/18-fake-array/array_from.png","hash":"50733fd866277f6aa27e12e432f2511fa886855f","modified":1659583606408},{"_id":"source/_posts/18-fake-array/document.png","hash":"c0e73c5d922eaf7f899856685f5fbd8245517fe8","modified":1659583001215},{"_id":"source/_posts/18-fake-array/prototype_call.png","hash":"166ae1ed6f21a1c4ee961508d06adae89f22c6d6","modified":1659583249658},{"_id":"source/_posts/18-fake-array/slice_call.png","hash":"a97bd9fef96df18bbe6097521df710bd9615090a","modified":1659583430484},{"_id":"source/_posts/24-about-design-model1/abstract-car.png","hash":"63b2384c0b130f2d40907996aeb528d2131ab01f","modified":1662443039673},{"_id":"source/_posts/24-about-design-model1/safe-model-class.png","hash":"90a874baec5df9156cf7b65d7c7754d28c82337e","modified":1662442491219},{"_id":"source/_posts/24-about-design-model1/static-param.png","hash":"ec22668e0901214c3d2efadcdae0ae34f801c2ac","modified":1662448007534},{"_id":"source/_posts/25-about-design-model2/bridge1.png","hash":"70973d153e1e628ebf1152bce98b1a68b7530784","modified":1662458463138},{"_id":"source/_posts/25-about-design-model2/bridge2.png","hash":"0d4e3980c0c177ef97e690e69919f954f2292ddb","modified":1662458485135},{"_id":"source/_posts/25-about-design-model2/bridge3.png","hash":"8358d5a031c07b8a0dbe61df13f0642bf03b7c5d","modified":1662458499287},{"_id":"source/_posts/26-about-design-model3/command-model-3.png","hash":"f8973520dfc9d241d4e418d016dbde7cf647482f","modified":1663577292848},{"_id":"source/_posts/26-about-design-model3/explain-model-2.png","hash":"13dd495c6f42e9820c60034d2e87bc917486129e","modified":1663580905852},{"_id":"source/_posts/26-about-design-model3/observer-regist.png","hash":"160d15173ed43415298e65c9b3d9a63159aacb91","modified":1662604465638},{"_id":"source/_posts/27-about-design-model4/entrust-model-2.png","hash":"71764eebae7d27ba83deff08b4d925307914e3d0","modified":1663651049352},{"_id":"source/_posts/27-about-design-model4/lazy-model-1.png","hash":"5237b5b92b4b542f593af63d48afb088237eb2ed","modified":1663654190148},{"_id":"source/_posts/27-about-design-model4/localstorage-model-1.png","hash":"d78dd470675aa3f2a42ad1ce9617ef7d89e2168a","modified":1663651957734},{"_id":"source/_posts/27-about-design-model4/participate-model-1.png","hash":"44ef46104d7428d99d7b80b7ca8e2f9059d02340","modified":1663655013113},{"_id":"source/_posts/27-about-design-model4/participate-model-2.png","hash":"04cb3a2efcc6a9a9b3cc52a11c14b75ebfa332d6","modified":1663655036348},{"_id":"source/_posts/27-about-design-model4/template-model-6.png","hash":"f34ff79b1d619c45ccb21c2158a4680a6617942f","modified":1663653640090},{"_id":"source/_posts/27-about-design-model4/waiter-model-3.png","hash":"b59dca3e470f10063815167bca6227f8341dbc8e","modified":1663657400528},{"_id":"source/_posts/27-about-design-model4/waiter-model-8.png","hash":"9be78a26ae2db46d9ec8d4bb36902be64991e2f9","modified":1663658341497},{"_id":"source/_posts/28-about-design-model5/async-module-model-2.png","hash":"8898b83e3301783ee9bfb43b2488f4171e86a2bc","modified":1663661641923},{"_id":"source/_posts/28-about-design-model5/async-module-model-7.png","hash":"8473d1889cf3ba7e45e0b71a8dd861cc233f05c2","modified":1663661966862},{"_id":"source/_posts/28-about-design-model5/async-module-model-9.png","hash":"3959c02225b63e07adce93a968ed0bb0e2e6c365","modified":1663662019419},{"_id":"source/_posts/28-about-design-model5/async-module-model-8.png","hash":"3a03fb902c96d787e256412ebc5a604a26aabd93","modified":1663662004136},{"_id":"source/_posts/28-about-design-model5/module-model-5.png","hash":"c866de378508cfdbfd9307dd72b719577d2a3cff","modified":1663659938940},{"_id":"source/_posts/28-about-design-model5/mvc-model-1.png","hash":"9fe4ed86ba3315ba722de0660cc6ec5770666487","modified":1663663438592},{"_id":"source/_posts/28-about-design-model5/mvc-model-4.png","hash":"03b64f2faf10dbcc8c3a32fb96b29e0b135f2f49","modified":1663663969725},{"_id":"source/_posts/28-about-design-model5/mvp-model-1.png","hash":"ff42b48b0eb5f6ac14adc79c348d093c14f164de","modified":1663664391940},{"_id":"source/_posts/28-about-design-model5/mvp-model-7.png","hash":"85c76e7e1a84df4345885b58a4495b8472da6c7c","modified":1663664792064},{"_id":"source/_posts/28-about-design-model5/mvvm-model-2.png","hash":"3cb6051a5054c50231162690a8494170b90397f4","modified":1663665412492},{"_id":"source/_posts/28-about-design-model5/widget-model-1.png","hash":"4f89287a4f8aa1122864cbc4c77f89d592a68c45","modified":1663662384573},{"_id":"source/_posts/34-data-structure2/chain-table-1.png","hash":"b4a240e43972349b743117265ca1897051389bed","modified":1664174288096},{"_id":"source/_posts/34-data-structure2/chain-table-3.png","hash":"6db25c5f058ceecae16751cea75e2a13e62a6b3d","modified":1664264590232},{"_id":"source/_posts/34-data-structure2/chain-table-2.png","hash":"ea63e231035c3929b320bb52dc63c363a1b1ff39","modified":1664263190912},{"_id":"source/_posts/34-data-structure2/chain-table-4.png","hash":"04054fdc4cbdfb48b13bde3769b7ccb590e6bff9","modified":1664264606764},{"_id":"source/_posts/35-data-structure3/linear-probing.png","hash":"0a020e8afc93027a2f5d6873414f7afbfa4b6f83","modified":1665198665394},{"_id":"source/_posts/35-data-structure3/lose-lose.png","hash":"55e49878d996f933010c1ac93b306b407a74019a","modified":1665196106863},{"_id":"source/_posts/35-data-structure3/move-key.png","hash":"ebb4944fee6e7aa9426ad27101ccaaca152e2fa2","modified":1665199125857},{"_id":"source/_posts/35-data-structure3/soft-delete.png","hash":"f8fc5195e6b92a91af6b1a283be51fea18d95ccb","modified":1665198884241},{"_id":"source/_posts/35-data-structure3/sperate-chain.png","hash":"1c7b05c0f24bd68757a3497182c41da36cf91bbc","modified":1665197999026},{"_id":"source/_posts/36-data-structure4/binary-search-tree.png","hash":"ad74f8c6b96f77ca95d6b9b48cf87fda5efcfdbc","modified":1665211252907},{"_id":"source/_posts/36-data-structure4/factorial.png","hash":"ddfb0d84eab3db09c51a4b87376c023e35c597be","modified":1665207523429},{"_id":"source/_posts/36-data-structure4/in-order-traverse.png","hash":"db6c59fc444e910a9921f50bc9e8e66964ef2849","modified":1665212570747},{"_id":"source/_posts/36-data-structure4/left-left-2.png","hash":"31829f0a81c4d517a768b0d824702e96ed38af94","modified":1665215213180},{"_id":"source/_posts/36-data-structure4/left-left-1.png","hash":"655a6a8118dd11fffc1c0bf38c1a06fd9d861fb7","modified":1665215196749},{"_id":"source/_posts/36-data-structure4/left-right-1.png","hash":"b0d03e54c49df4be3cdc60f9436e4ecb40a3c6b6","modified":1665216006922},{"_id":"source/_posts/36-data-structure4/left-right-2.png","hash":"dde339c5a7c4a70be0a832190a2678237f10331d","modified":1665216028366},{"_id":"source/_posts/36-data-structure4/post-order-traverse.png","hash":"aee9c88702a4fa397c4146e997f7ba3504b19a3e","modified":1665212712548},{"_id":"source/_posts/36-data-structure4/pre-order-traverse.png","hash":"d93c415f7de4fd6c9d5bf3dfc7fdaf4484d6173c","modified":1665212594930},{"_id":"source/_posts/36-data-structure4/red-black-2a.png","hash":"618993219918c6d178ac4f468129647d0c0d6f72","modified":1665217313231},{"_id":"source/_posts/36-data-structure4/red-black-2b.png","hash":"88a4290e21e993ca3a39a86a83283bc607f24b9c","modified":1665217348189},{"_id":"source/_posts/36-data-structure4/red-black-3b.png","hash":"e4f8a20d976abc667a94482eeeeaa0f5281c410e","modified":1665217363966},{"_id":"source/_posts/36-data-structure4/red-black-3a.png","hash":"6db63a5d31e7477b9d3a7ce036c9607db9262fb8","modified":1665217328381},{"_id":"source/_posts/36-data-structure4/remove-left-right.png","hash":"4141ff9827c5c74323d60196c96038c898c07cf6","modified":1665214241529},{"_id":"source/_posts/36-data-structure4/right-left-1.png","hash":"3d1ec645ec1def7aeb460386d421b9dc3cc684e0","modified":1665216318337},{"_id":"source/_posts/36-data-structure4/right-left-2.png","hash":"9fd153762d1b34409ac583c8dd871153f0ce5fc1","modified":1665216334102},{"_id":"source/_posts/36-data-structure4/right-right-1.png","hash":"5d6258c158f22e8582f538f06c89dc86bbedfba7","modified":1665215690448},{"_id":"source/_posts/36-data-structure4/right-right-2.png","hash":"b6a6f5a17aa73fc8daf16313e0204a05314c3c16","modified":1665215704532},{"_id":"source/_posts/36-data-structure4/tree.png","hash":"c1a3dff14361fa7bfc3f73bf7391d46c57044737","modified":1665210436072},{"_id":"source/_posts/37-data-structure5/graph-1.png","hash":"a1b2db6ab3de04b1adf413855eaa4220c96ae523","modified":1665297136845},{"_id":"source/_posts/37-data-structure5/graph-10.png","hash":"be4ed69d06ae7dcea2b875b3b0ce92922a7fd0b2","modified":1665638234796},{"_id":"source/_posts/37-data-structure5/graph-11.png","hash":"070f67f44e46097fb8750af9a315c9bca7fc6c0f","modified":1665638354099},{"_id":"source/_posts/37-data-structure5/graph-12.png","hash":"b557ac7c33f3672b559a4a1eacf84aba2fcff1cf","modified":1665638654654},{"_id":"source/_posts/37-data-structure5/graph-13.png","hash":"0ef979dea025ae063ccc8477915e14c2bada6f77","modified":1665639214755},{"_id":"source/_posts/37-data-structure5/graph-3.png","hash":"4bca0b6ea37be10e8ab4b015ab1879bc9c95f98b","modified":1665297485922},{"_id":"source/_posts/37-data-structure5/graph-2.png","hash":"f56455b618e7b41e84fba80e91ade7ed29df91ca","modified":1665297469781},{"_id":"source/_posts/37-data-structure5/graph-4.png","hash":"47bcd4a1de612d5af3bd3301602b4b6bc07b4c6a","modified":1665543988878},{"_id":"source/_posts/37-data-structure5/graph-5.png","hash":"a85fa2dffae020f8d02eebce15b1592e9b222a5e","modified":1665544487331},{"_id":"source/_posts/37-data-structure5/graph-6.png","hash":"3781b637547025de758bec7262c50fe45bb57774","modified":1665544659172},{"_id":"source/_posts/37-data-structure5/graph-8.png","hash":"93de61e5c29df7b193e41f2595521446bc81226d","modified":1665630724506},{"_id":"source/_posts/37-data-structure5/graph-7.png","hash":"dbd8e52679bcbf321c3a8d17006729c4af0c87ad","modified":1665627475943},{"_id":"source/_posts/37-data-structure5/heat.png","hash":"a37ac1abfbbf1bd9742deec30a783d0f90e49657","modified":1665220131039},{"_id":"source/_posts/37-data-structure5/min-heat.png","hash":"c2c5f8cc68ba6cf3d89bebb94c0a7a7d22c1e5a0","modified":1665220362202},{"_id":"source/_posts/38-data-structure6/search-3.png","hash":"719072030a73de7c3054974d55b626d221894218","modified":1665648563915},{"_id":"source/_posts/38-data-structure6/search-1.png","hash":"a844a9c7aabbe1a2fc3c7151e88a35f494e9d09b","modified":1665647613587},{"_id":"source/_posts/38-data-structure6/search-2.png","hash":"3626ed24aaf5d1563eb1daa3a4f8d5136150bb83","modified":1665648010123},{"_id":"source/_posts/38-data-structure6/search-4.png","hash":"ecf4e1f8dd0fdf38b91d89de529f09da6eb88dd8","modified":1665648752017},{"_id":"source/_posts/38-data-structure6/sort-10.png","hash":"cbb2fbde7d06aae552356dd7e4c65274d322f0fe","modified":1665645027520},{"_id":"source/_posts/38-data-structure6/sort-1.png","hash":"97f90c860ce1d2669135aa5a7a474aeb7a799ad6","modified":1665642448596},{"_id":"source/_posts/38-data-structure6/sort-11.png","hash":"067113a10d14e5524fe4e7972c61d1b077811134","modified":1665646466063},{"_id":"source/_posts/38-data-structure6/sort-2.png","hash":"a63daadd4590ed6b4ad7519bd1a14ae4be364a64","modified":1665642647310},{"_id":"source/_posts/38-data-structure6/sort-12.png","hash":"a8fdcaca8fd646997a58eca48c76809cb25c7571","modified":1665647384547},{"_id":"source/_posts/38-data-structure6/sort-3.png","hash":"913bb3906ff437f6dfe6a773b852918b7a49ae0d","modified":1665642939385},{"_id":"source/_posts/38-data-structure6/sort-4.png","hash":"273c67388337e6e5eeb6c6e3486e5047d8d02321","modified":1665643284083},{"_id":"source/_posts/38-data-structure6/sort-5.png","hash":"05867cc82ce12a1a2b6c92d0d37e2155df04d0a5","modified":1665643898545},{"_id":"source/_posts/38-data-structure6/sort-6.png","hash":"c4802ae6c84bee330fec94ddd888543a590ec692","modified":1665644667547},{"_id":"source/_posts/38-data-structure6/sort-7.png","hash":"681be89ab6425489c526125d890ae38ef8ee1435","modified":1665644820524},{"_id":"source/_posts/38-data-structure6/sort-8.png","hash":"f62f618f88c3715fa98532f136e36afea5153b3b","modified":1665644910757},{"_id":"source/_posts/38-data-structure6/sort-9.png","hash":"b1a616076a59411ae21537a155e8f12e198c78b0","modified":1665645011262},{"_id":"source/_posts/39-data-structure7/big-o-1.png","hash":"bfc4e8cd9822858a4f5afd7ea21ac69ae391248f","modified":1665725447129},{"_id":"source/_posts/39-data-structure7/big-o-2.png","hash":"5abf1a71a4b31ade53b60d5d6edf850266d502e2","modified":1665725587116},{"_id":"source/_posts/39-data-structure7/big-o-3.png","hash":"b7140be66eb3272f0dd9c183b48cfb8555cb4511","modified":1665725727100},{"_id":"source/_posts/39-data-structure7/big-o-5.png","hash":"0e81454c15a22289ae8fd29e9ba356f9058ca226","modified":1665725847508},{"_id":"source/_posts/39-data-structure7/big-o-4.png","hash":"75fd12b92a8ef511524bb5306c73fb63346d586d","modified":1665725788955},{"_id":"source/_posts/39-data-structure7/big-o-6.png","hash":"443cef5a2ff290edd7a7b9f9c3e4580e9d8375b3","modified":1665726382980},{"_id":"source/_posts/39-data-structure7/technology-1.png","hash":"25d324e43b4ae5d4921a2fa9bf40479a54ba55d2","modified":1665649253588},{"_id":"source/_posts/39-data-structure7/technology-2.png","hash":"00436e4649e1f7cdeecb39e78e1cece84a8c0591","modified":1665650645629},{"_id":"source/_posts/39-data-structure7/technology-3.png","hash":"fe308b75c03e0efc9bc24154073ae4a31c1fc73f","modified":1665650992570},{"_id":"source/_posts/39-data-structure7/technology-4.png","hash":"956d458c4792a6a56ad0f9292f3e7773bafca1d1","modified":1665651529899},{"_id":"source/_posts/39-data-structure7/technology-5.png","hash":"61dc4bb992375a4f2d5c5b5afdb594877f58510a","modified":1665652235775},{"_id":"source/_posts/40-tail-call/call-stack.png","hash":"9ceba234d31d636baca2b4f2af1384b6b25d4a4a","modified":1665977002591},{"_id":"source/_posts/6-vue3-render/render.png","hash":"0b20ebf2700ccd675e40f6330e07dce8341807a0","modified":1658223255522},{"_id":"source/_posts/23-about-design-model/how-to-inherit.png","hash":"2610b10429de1454b684733ede30778da89da750","modified":1661856873590},{"_id":"source/_posts/23-about-design-model/parasitic-inherit.png","hash":"dcde79d7db360d5f56bf441be778908d3056f693","modified":1661856873597},{"_id":"source/_posts/23-about-design-model/prototype-inherit.png","hash":"a5f0085a3caf9e0519fe3cb26129dd144cfc7594","modified":1661856873599},{"_id":"source/_posts/23-about-design-model/prototype.png","hash":"fe3518ce58c5945b8f5db473d69be75f67a98b0a","modified":1661490846012},{"_id":"source/_posts/23-about-design-model/public-and-private.png","hash":"275fce752eaeadf6eee22e10bf14451ed9eb675c","modified":1661490846014},{"_id":"source/_posts/23-about-design-model/simple-factory2.png","hash":"e8d75951fa119c24b2c188eb639f16a32bf70928","modified":1662355408197},{"_id":"source/_posts/23-about-design-model/static-and-public.png","hash":"aef2330dce27ebc420b7654abdf1859266ec48a4","modified":1661856873605},{"_id":"source/_posts/24-about-design-model1/abstract-factory2.png","hash":"a1a8a6b4b0c2aa47bbc543add6b6a675670b41ce","modified":1662443556932},{"_id":"source/_posts/24-about-design-model1/lazy-single-instance.png","hash":"4bbd91090a4364cc48ec5cf388ae29f1f3626b8a","modified":1662448167315},{"_id":"source/_posts/24-about-design-model1/human.png","hash":"f78b9964ce7223cc99122c99667673d9242df348","modified":1662444891472},{"_id":"source/_posts/24-about-design-model1/name.png","hash":"d46e84150e7fdea9eb17d8ad0624e7eb79654ace","modified":1662444908093},{"_id":"source/_posts/24-about-design-model1/person.png","hash":"12e19fccdb8ee0dea2ec9e55c4f55125a536b76e","modified":1662444952362},{"_id":"source/_posts/24-about-design-model1/prototype-inherit2.png","hash":"cd61b59785ea6144fabce855bd363ff7906468a9","modified":1662446461834},{"_id":"source/_posts/25-about-design-model2/decorator.png","hash":"a0fdfe4dc2b74b52a33fd13ed7e1b3c1fba8480e","modified":1662457093764},{"_id":"source/_posts/25-about-design-model2/out-look.png","hash":"d9f11180b44ccded8da8ecba5593bdd6ebd58eb4","modified":1662450856453},{"_id":"source/_posts/25-about-design-model2/station-culculate.png","hash":"26cda447bac04b0260f0ec11ca1dcb836f93855a","modified":1662454433567},{"_id":"source/_posts/26-about-design-model3/add-message.png","hash":"03712141c27e51d24f4361c6c48a609b366f5692","modified":1662605334378},{"_id":"source/_posts/26-about-design-model3/marry-state1.png","hash":"2f5c004568231ff2a14ab499c91aabd48c302f28","modified":1662606880721},{"_id":"source/_posts/26-about-design-model3/observer-fire.png","hash":"0204e744bdcb2480cae91e03d4e79c26913cf85a","modified":1662604570583},{"_id":"source/_posts/26-about-design-model3/observer-remove.png","hash":"e0e97122604f5eaa716042ffd19d7e6fc4d9535f","modified":1662604648684},{"_id":"source/_posts/26-about-design-model3/observer.png","hash":"05738a02cd73736025351c0e9e3fc0d0de27158f","modified":1662604356379},{"_id":"source/_posts/26-about-design-model3/regist-change-num.png","hash":"3aa9791db11e1985c21e29959201f022a0f98a88","modified":1662605277899},{"_id":"source/_posts/27-about-design-model4/chain-model-1.png","hash":"ac13400dfce89f26fe4bcadca5c2a1f4994083ca","modified":1663643204079},{"_id":"source/_posts/27-about-design-model4/chain-model-2.png","hash":"8a59f234053c9a85a94f74273fafed9051ec578d","modified":1663643706105},{"_id":"source/_posts/27-about-design-model4/chain-model-4.png","hash":"33fa9dc7cb773d0e519dcb4a4a5869aa78234950","modified":1663644189761},{"_id":"source/_posts/27-about-design-model4/entrust-model-1.png","hash":"900a7cc246a17adae923b5e0b87d5b8b8d255674","modified":1663650878995},{"_id":"source/_posts/27-about-design-model4/lazy-model-2.png","hash":"29a6f621b06f9283d3caff7d3c63f7c711095978","modified":1663654206105},{"_id":"source/_posts/27-about-design-model4/lazy-model-3.png","hash":"7cf3eba1156eb71177fee16c281edfd2f7d3d0e0","modified":1663654271863},{"_id":"source/_posts/27-about-design-model4/lazy-model-5.png","hash":"ce1428d6b73612a3290d3cbd0efa607829fdb233","modified":1663654372118},{"_id":"source/_posts/27-about-design-model4/lazy-model-6.png","hash":"bb1487d2e1e38d3c2ea4cb6dcc310f0025664444","modified":1663654392861},{"_id":"source/_posts/27-about-design-model4/participate-model-3.png","hash":"257320d7e940dcef49305ea8d1642621bfbf3ff1","modified":1663655711666},{"_id":"source/_posts/27-about-design-model4/participate-model-4.png","hash":"5f13e728cfa8cf2eabd3925f1a0798bc905d267b","modified":1663655973145},{"_id":"source/_posts/27-about-design-model4/participate-model-5.png","hash":"9694840f32c90094e37228de41fc2cfdf4f66388","modified":1663656014526},{"_id":"source/_posts/27-about-design-model4/template-model-1.png","hash":"41e2537938230a77a4072987778016031fe92291","modified":1663653270177},{"_id":"source/_posts/27-about-design-model4/template-model-4.png","hash":"b301423b25f6447a52369e96a6f0d1c3b93da6c5","modified":1663653602447},{"_id":"source/_posts/27-about-design-model4/template-model-3.png","hash":"3a24763c6d9e280dd6c26d966da99ceb0d658ec5","modified":1663653576402},{"_id":"source/_posts/27-about-design-model4/waiter-model-5.png","hash":"30412937d3a27e5d8bf1db0d87fce38a8d59839e","modified":1663658170337},{"_id":"source/_posts/27-about-design-model4/waiter-model-4.png","hash":"ad67d02d972353793d59f1ca5f1191fb9a220e52","modified":1663658084841},{"_id":"source/_posts/27-about-design-model4/waiter-model-6.png","hash":"007198e00695be520e246815152687e250bf4941","modified":1663658288382},{"_id":"source/_posts/27-about-design-model4/waiter-model-7.png","hash":"0eefaa7468c3726aecd02980b1c10574a1d06c40","modified":1663658323937},{"_id":"source/_posts/28-about-design-model5/async-module-model-4.png","hash":"731b4ee9c777c9d9bd6664bf674e1abf1f48af65","modified":1663661830015},{"_id":"source/_posts/28-about-design-model5/async-module-model-5.png","hash":"436f66ba99f8bd7400ad91b3d857d255f6f3034c","modified":1663661873825},{"_id":"source/_posts/28-about-design-model5/module-model-2.png","hash":"a22fb6b41b50875766d5382664361095fca59051","modified":1663659739443},{"_id":"source/_posts/28-about-design-model5/module-model-3.png","hash":"aa42c569b2a73fae726d6518fda8a48a325c5a3f","modified":1663659772912},{"_id":"source/_posts/28-about-design-model5/mvc-model-3.png","hash":"28fd4de773e1352941b4b0773858520ec4e21039","modified":1663663871483},{"_id":"source/_posts/28-about-design-model5/mvp-model-4.png","hash":"59ab08a2d276eb142c4789000d2c484aaaeb4890","modified":1663664644640},{"_id":"source/_posts/28-about-design-model5/mvvm-model-3.png","hash":"b4f73f397dcb296b03350b04390a8f2cdc0906d4","modified":1663665441365},{"_id":"source/_posts/28-about-design-model5/mvvm-model-7.png","hash":"4d8187320d10b1bb36a49169575baf54fe7e7a71","modified":1663665616436},{"_id":"source/_posts/28-about-design-model5/widget-model-4.png","hash":"7c2ca9c608b6829fa768590455a8785c9ff13781","modified":1663662590740},{"_id":"source/_posts/28-about-design-model5/widget-model-5.png","hash":"5ff7151981d6c83fa8a45556de7e17f4e527c093","modified":1663662677871},{"_id":"source/_posts/37-data-structure5/heap-sort.png","hash":"a344a2264bed09372c160b691a6e0a581bea3bd6","modified":1665222218747},{"_id":"source/_posts/37-data-structure5/min-heat-pic.png","hash":"6d8794be490f9dd7f0664813070eea6169c49181","modified":1665221648680},{"_id":"source/_posts/5-react-render/force_update.png","hash":"f0333239066cd2e4a8cdf12bff8fcdfcc01a7616","modified":1658223255498},{"_id":"source/_posts/5-react-render/update_class.png","hash":"5854028928496a0b6c4ad02452cd07c12650f8e8","modified":1658223255534},{"_id":"source/_posts/6-vue3-render/render_node1.png","hash":"4a4266c87a315afeb55de174b11784431f3c40b9","modified":1658223255527},{"_id":"source/_posts/6-vue3-render/render_node2.png","hash":"bd8cbab05ce653b80a1cc89e609b7ae9c309b7fe","modified":1658223255530},{"_id":"source/_posts/15-js-transform/convert-table.png","hash":"fdffd1b86ddacb402a9a3a423cffd91fcc229fce","modified":1658223643116},{"_id":"source/_posts/23-about-design-model/class-inherit.png","hash":"7316cf53af5ae3d11eb708f911ddc2b9fbf35027","modified":1661856873580},{"_id":"source/_posts/23-about-design-model/create-pop.png","hash":"43feb1eed0b060643140cfa80c073e12729b47af","modified":1662355408187},{"_id":"source/_posts/23-about-design-model/parasitic-combination-inherit.png","hash":"5b7c9be2d070fe04cd77d8923eaa4e1585ad9e02","modified":1661856873592},{"_id":"source/_posts/23-about-design-model/multiple-inherit.png","hash":"3370f1d5c3f1c73449ddc04e438559b4a0925ad0","modified":1662355408189},{"_id":"source/_posts/23-about-design-model/parasitic-inherit-change.png","hash":"0b683e58266a2816c17a932a910be6ce1bdbbf1e","modified":1661856873595},{"_id":"source/_posts/24-about-design-model1/abstract-factory3.png","hash":"565cc1a91ec9f7f4113759d8ee84d9e7e5765dec","modified":1662443974163},{"_id":"source/_posts/24-about-design-model1/prototype-inherit1.png","hash":"3d8d602b70b2a85f84ccb77667bfdf58688ef1e6","modified":1662446439629},{"_id":"source/_posts/24-about-design-model1/abstract-factory1.png","hash":"27096d5d5c2a949d2b5a0b8b4483cd0955007a30","modified":1662443533233},{"_id":"source/_posts/26-about-design-model3/command-model-2.png","hash":"394963fe76e75b6ff152d0bc64eb440812f181e4","modified":1663577276883},{"_id":"source/_posts/26-about-design-model3/deal-data.png","hash":"229c21fa8cd0891d9cf137520e2756088d805b32","modified":1662616593064},{"_id":"source/_posts/24-about-design-model1/safe-factory-model.png","hash":"1d4838406d573590c135cb651e98e970dd03d761","modified":1662442704945},{"_id":"source/_posts/26-about-design-model3/create-component.png","hash":"313f9c4b04afdb3c0bbb24d02394ff7ed7f7afa9","modified":1662616644243},{"_id":"source/_posts/26-about-design-model3/marry-state.png","hash":"9d3b9fd7f74062d32194ddee1084db94ab8f2f5e","modified":1662606865403},{"_id":"source/_posts/26-about-design-model3/send-data.png","hash":"f2dd937ad9d5dbd6373c78b766b0ca7d18689bb8","modified":1662616481110},{"_id":"source/_posts/27-about-design-model4/chain-model-6.png","hash":"0a2af8c6826567da8695e8010d13bf7101a75d0a","modified":1663644305196},{"_id":"source/_posts/27-about-design-model4/lazy-model-4.png","hash":"d2cec3917cabaf4da67a6ac877730c32d27d6b82","modified":1663654340065},{"_id":"source/_posts/27-about-design-model4/localstorage-model-2.png","hash":"b130a85fa7ca8cc738c636091e35ce86095e4da4","modified":1663651981780},{"_id":"source/_posts/27-about-design-model4/localstorage-model-4.png","hash":"c7d8b6cd9bc0093ceaaa9a731d6b721dabf0c2e2","modified":1663652031905},{"_id":"source/_posts/26-about-design-model3/vote-status.png","hash":"ce2f7e1b2250efafac59e7e0a6c69a8f2f57e1fb","modified":1662606197496},{"_id":"source/_posts/27-about-design-model4/chain-model-5.png","hash":"6c1d9aaa8a2f5c8a33e827428f33df74156af591","modified":1663644269641},{"_id":"source/_posts/27-about-design-model4/template-model-2.png","hash":"f0f1cf1e6328ed7dd2da13e3ef19f0ba3090d50b","modified":1663653559773},{"_id":"source/_posts/27-about-design-model4/template-model-5.png","hash":"a615f27465cba32bd7ef16f4aa2d229123c6cd04","modified":1663653621150},{"_id":"source/_posts/27-about-design-model4/throttle-model-3.png","hash":"9ba30093c88bda5cdf0b74397078c98615ab14e8","modified":1663652906337},{"_id":"source/_posts/27-about-design-model4/waiter-model-1.png","hash":"4ecd76529d5af3bab1200944f956550c438d7e4c","modified":1663657090941},{"_id":"source/_posts/27-about-design-model4/throttle-model-2.png","hash":"4d06f2204e6a312ad534b08e4aa3a0cc199b0fe4","modified":1663652874513},{"_id":"source/_posts/27-about-design-model4/waiter-model-2.png","hash":"115d73933b2c9e3b333f0173a9c67b40b82b360e","modified":1663657379627},{"_id":"source/_posts/28-about-design-model5/appendix-10.png","hash":"47f4c469384a2ae6ee68920c9c9d056323bc6964","modified":1663666108395},{"_id":"source/_posts/28-about-design-model5/appendix-1.png","hash":"63d1fb2d7060dc8e20879b271cfc0fae5ba53ce5","modified":1663665944379},{"_id":"source/_posts/28-about-design-model5/async-module-model-3.png","hash":"955761aa1d41f38f58070239091ec7ef56eab433","modified":1663661813279},{"_id":"source/_posts/28-about-design-model5/async-module-model-6.png","hash":"c0234e34b71f60317c8532f9b4332297ddbfc3b2","modified":1663661929958},{"_id":"source/_posts/28-about-design-model5/mvp-model-5.png","hash":"b38b48df97224ac10c391b5231c27b5ff9439d15","modified":1663664712013},{"_id":"source/_posts/28-about-design-model5/mvp-model-2.png","hash":"a05c2d67784dc8a0c9dadb55ff4cb313ff0a4581","modified":1663664414889},{"_id":"source/_posts/28-about-design-model5/mvp-model-6.png","hash":"b678a14aa7203ed211d9b03cc517629296d39ccb","modified":1663664732256},{"_id":"source/_posts/28-about-design-model5/mvvm-model-1.png","hash":"dec3d9b3d1b759d8ab97b596942a57870ea5e899","modified":1663665306275},{"_id":"source/_posts/28-about-design-model5/mvvm-model-5.png","hash":"f5b38278a65c50724df598782714d46b16198ddb","modified":1663665520771},{"_id":"source/_posts/28-about-design-model5/mvvm-model-8.png","hash":"ae0f8837c7bf0b7cebcf1b643602ef1b7c91d9b0","modified":1663665710456},{"_id":"source/_posts/28-about-design-model5/widget-model-3.png","hash":"8caaa1350394bb4924a26779474bd8ffdedfd1a3","modified":1663662560598},{"_id":"source/_posts/28-about-design-model5/widget-model-2.png","hash":"d5b2a749b270b467d4e5ca0442f079ad0d68c0ad","modified":1663662526925},{"_id":"source/_posts/28-about-design-model5/widget-model-6.png","hash":"17625b96826cacb789210181082942b9d92c9685","modified":1663662713550},{"_id":"source/_posts/37-data-structure5/graph-9.png","hash":"3e0a9c9a2cb3f8145448b3dab7b9066c53f468d2","modified":1665631403989},{"_id":"source/_posts/4-brower-render/hover.png","hash":"310534f76efad7820e4f9527f39b9232feb717da","modified":1666667873150},{"_id":"source/_posts/4-brower-render/network.png","hash":"bb36a90979d2b630aa4c09b7187c9e4ca300f3d4","modified":1666667960216},{"_id":"source/_posts/4-brower-render/performance.png","hash":"c54be1dc0abe417046e5abd2a9ac3bbfc89bb98e","modified":1666667920282},{"_id":"source/_posts/5-react-render/fiber_tree.png","hash":"947d11b845e1abb74cbb2d4e135767a377692041","modified":1658223255494},{"_id":"source/_posts/6-vue3-render/render_function.png","hash":"ab09e61382c872069a70212525d4333d6ba8cd19","modified":1658223255525},{"_id":"source/_posts/23-about-design-model/multiple-status.png","hash":"99f1acc2445ec0c692d48660ddbd71b510f1284b","modified":1662355408192},{"_id":"source/_posts/23-about-design-model/test-prototype-inherit.png","hash":"ffe8e406495b76ed7e8fa5fa95247335f0842bd8","modified":1661856873608},{"_id":"source/_posts/23-about-design-model/safe-model.png","hash":"8ddf098b287fc1582ef3c57f6641b8cdfe529ee0","modified":1661856873602},{"_id":"source/_posts/23-about-design-model/simple-factory1.png","hash":"7a9ab5660cbd92e1e0f851985402404fb0f49814","modified":1662355408196},{"_id":"source/_posts/24-about-design-model1/work.png","hash":"85878cbf259712eba4a4d960bef9fc8f72361f7d","modified":1662444928587},{"_id":"source/_posts/26-about-design-model3/basic-model.png","hash":"d11299e00239d8eee68fa84742cf934d7b2b7455","modified":1662544252055},{"_id":"source/_posts/26-about-design-model3/cache-model.png","hash":"849dac393027d49c7932b80aeacdeb6dc665ad8d","modified":1663579414660},{"_id":"source/_posts/26-about-design-model3/command-model-1.png","hash":"e8f27f13a8b8964e1f98cf90c9d11336745ce4cd","modified":1663577254334},{"_id":"source/_posts/26-about-design-model3/explain-model-3.png","hash":"7090631280b778e1a081cf14ee1aef4eaddf2724","modified":1663580922971},{"_id":"source/_posts/26-about-design-model3/explain-model-1.png","hash":"b41f3ee9472b65e45fd3699586fe343b90801e1c","modified":1663580887647},{"_id":"source/_posts/26-about-design-model3/inherit-model.png","hash":"c458570cfbf5cb544f160dbf7f5ea2688eb54cfe","modified":1662544386649},{"_id":"source/_posts/26-about-design-model3/inherit-as-basic-model.png","hash":"04bcb6c49805f61c210a276673688925342a97a2","modified":1662544568359},{"_id":"source/_posts/26-about-design-model3/mediator-model.png","hash":"037a378a4fd6a9b68621c714239390a175768283","modified":1663578864540},{"_id":"source/_posts/26-about-design-model3/regist-message.png","hash":"94993ad78c5391eb4cc60f851d1bf5de794d680a","modified":1662605173515},{"_id":"source/_posts/26-about-design-model3/price-strategy.png","hash":"8c9b4bc9e46d85dbd5ff1db682f35d7727ac2d24","modified":1662615179307},{"_id":"source/_posts/26-about-design-model3/visitor-model.png","hash":"b47054fdf9198975a39ebfc6b4ea46cb988dc080","modified":1663578342393},{"_id":"source/_posts/27-about-design-model4/chain-model-3.png","hash":"de232baf72880e1c2bfca1e52ca3dece90b30922","modified":1663643787303},{"_id":"source/_posts/27-about-design-model4/localstorage-model-5.png","hash":"f60b1b8098b39c8d16bef6ce21e93f80eed6a06d","modified":1663652051324},{"_id":"source/_posts/27-about-design-model4/localstorage-model-6.png","hash":"af1bc9d6bd7aa6c6582b3b498aaace38b3beb7d0","modified":1663652073728},{"_id":"source/_posts/27-about-design-model4/localstorage-model-3.png","hash":"0dd09a8620412a0a10e0749a2eae5b990e14131f","modified":1663652010756},{"_id":"source/_posts/27-about-design-model4/participate-model-6.png","hash":"a27676bb25d07081323b4801ff167a2f9c830583","modified":1663656339712},{"_id":"source/_posts/27-about-design-model4/throttle-model-1.png","hash":"efe9c32037c01c30eef7c906b1477675a4b22296","modified":1663652476137},{"_id":"source/_posts/28-about-design-model5/appendix-4.png","hash":"0caa8c2b2efef085bf73708c696b163b27cf4acd","modified":1663666001722},{"_id":"source/_posts/28-about-design-model5/appendix-3.png","hash":"972a431f1b9f113e9c28acd09c21965abf3ae776","modified":1663665981472},{"_id":"source/_posts/28-about-design-model5/appendix-2.png","hash":"c793bb154006138580dfe636e8e96f48af31c136","modified":1663665961797},{"_id":"source/_posts/28-about-design-model5/appendix-5.png","hash":"7d00695f69933f1493a5b215459372aa8922aa90","modified":1663666020584},{"_id":"source/_posts/28-about-design-model5/appendix-6.png","hash":"ebaf47a4d6e618ed357e3ef105bf1a78aac86dcd","modified":1663666041654},{"_id":"source/_posts/28-about-design-model5/appendix-7.png","hash":"c12235fa4218a1f12d5f04de3c292d9d8a1cc606","modified":1663666058765},{"_id":"source/_posts/28-about-design-model5/appendix-8.png","hash":"acc5e67aafb4ec4d3a10ca9507832f965d05bb86","modified":1663666074927},{"_id":"source/_posts/28-about-design-model5/appendix-9.png","hash":"5128c7e89b6784e2e75e7f74154a3a2a36859a4a","modified":1663666091964},{"_id":"source/_posts/28-about-design-model5/module-model-4.png","hash":"0591ff679bd8b40d96b399c2df5db22e5d6857f1","modified":1663659920967},{"_id":"source/_posts/28-about-design-model5/mvc-model-2.png","hash":"2ad2eeb884aac27d63ceb815d119f4bdab3b28bf","modified":1663663790767},{"_id":"source/_posts/28-about-design-model5/mvvm-model-4.png","hash":"362b306d44bd195ca4adee181dabcbbb524da1ac","modified":1663665502377},{"_id":"source/_posts/28-about-design-model5/mvvm-model-6.png","hash":"7d62d18ec951b6be1b53157c9380618cb8f65cc2","modified":1663665578927},{"_id":"source/_posts/23-about-design-model/combination-inherit.png","hash":"51a2c5f4775a37e5f2a21ab257749912178476c3","modified":1661856873584},{"_id":"source/_posts/24-about-design-model1/prototype-model.png","hash":"7e1b5e0841203ae571b20c1c21fc40fb6589f946","modified":1662445978153},{"_id":"source/_posts/26-about-design-model3/iterator-model.png","hash":"b372e782497790afdac5ef90a53eb4ecd88bc18f","modified":1663580424387},{"_id":"source/_posts/28-about-design-model5/async-module-model-1.png","hash":"f465cd97d9c16ecea67b0d0f8ee7d3bb6ebb545c","modified":1663661413721},{"_id":"source/_posts/28-about-design-model5/module-model-1.png","hash":"940ec1732a0d822780c486ccb9ffc6cc29119a6f","modified":1663659235916},{"_id":"source/_posts/28-about-design-model5/mvp-model-3.png","hash":"f3ebcf32efc3e9b536605c9df96654c81cfc9b82","modified":1663664626784},{"_id":"source/_posts/23-about-design-model/constructor-inherit.png","hash":"e1eb49fe9cd4796f60678113b6f865f2e1576464","modified":1661856873588},{"_id":"source/_posts/6-vue3-render/vue3_render.png","hash":"c27773553432184cba670aac70e69865c21a4727","modified":1658223255541},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1654110695000},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1654110695000},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1654110695000},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1654110695000},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1654110695000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1654110695000},{"_id":"themes/next/_config.yml","hash":"6d3de61ac0c5b734a0263f4782e06e6744d201e9","modified":1666678870400},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1654110695000},{"_id":"themes/next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":1654110695000},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1654110695000},{"_id":"themes/next/_vendors.yml","hash":"8c2886a6af624f04fc6a376daf48c0698ea71bf7","modified":1654110695000},{"_id":"themes/next/package.json","hash":"b32be32269dd2e241790a766a60357bfe13f2d45","modified":1654110695000},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1654110695000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1654110695000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1654110695000},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1654110695000},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1654110695000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1654110695000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1654110695000},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1654110695000},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1654110695000},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1654110695000},{"_id":"themes/next/.github/release-drafter.yml","hash":"423275ec021104b263cd88776936a8c8d6872b66","modified":1654110695000},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1654110695000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1654110695000},{"_id":"themes/next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":1654110695000},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1654110695000},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1654110695000},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1654110695000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1654110695000},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1654110695000},{"_id":"themes/next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1654110695000},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1654110695000},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1654110695000},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1654110695000},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1654110695000},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1654110695000},{"_id":"themes/next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1654110695000},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1654110695000},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1654110695000},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1654110695000},{"_id":"themes/next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1654110695000},{"_id":"themes/next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1654110695000},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1654110695000},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1654110695000},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1654110695000},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1654110695000},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1654110695000},{"_id":"themes/next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1654110695000},{"_id":"themes/next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1654110695000},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1654110695000},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1654110695000},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1654110695000},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1654110695000},{"_id":"themes/next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1654110695000},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1654110695000},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1654110695000},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1654110695000},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1654110695000},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1654110695000},{"_id":"themes/next/.github/workflows/lock.yml","hash":"e48d1ced9a673d3f0911a700d3e68c0f4ca79263","modified":1654110695000},{"_id":"themes/next/.github/workflows/linter.yml","hash":"b6c111344bc0f3500ca69d7590791ff85ef1090d","modified":1654110695000},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1654110695000},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1654110695000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1654110695000},{"_id":"themes/next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":1654110695000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1654110695000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":1654110695000},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1654110695000},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1654110695000},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1654110695000},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1654110695000},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1654110695000},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1654110695000},{"_id":"themes/next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1654110695000},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1654110695000},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1654110695000},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1654110695000},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1654110695000},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1654110695000},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1654110695000},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1654110695000},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1654110695000},{"_id":"themes/next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1654110695000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1654110695000},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1654110695000},{"_id":"themes/next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1654110695000},{"_id":"themes/next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":1654110695000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1654110695000},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1654110695000},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1654110695000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1654110695000},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1654110695000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1654110695000},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1654110695000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1654110695000},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1654110695000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1654110695000},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1654110695000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1654110695000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1654110695000},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1654110695000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1654110695000},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1654110695000},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1654110695000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1654110695000},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1654110695000},{"_id":"themes/next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1654110695000},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1654110695000},{"_id":"themes/next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1654110695000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1654110695000},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1654110695000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1654110695000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1654110695000},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1654110695000},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1654110695000},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1654110695000},{"_id":"themes/next/source/images/logo.jpeg","hash":"cf0f17140f5d4eefe4607db39c354c73eb9b6500","modified":1660025565133},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1654110695000},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1654110695000},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1654110695000},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1654110695000},{"_id":"themes/next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1654110695000},{"_id":"themes/next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1654110695000},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1654110695000},{"_id":"themes/next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1654110695000},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1654110695000},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1654110695000},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1654110695000},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1654110695000},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1654110695000},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1654110695000},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1654110695000},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1654110695000},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1654110695000},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1654110695000},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1654110695000},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1654110695000},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1654110695000},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1654110695000},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1654110695000},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1654110695000},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1654110695000},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1654110695000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1654110695000},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1654110695000},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1654110695000},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1654110695000},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"45477a04cf2b3c077061c8c3ada216c1ae288e0e","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1654110695000},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1654110695000},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1654110695000},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1654110695000},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1654110695000},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1654110695000},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1654110695000},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1654110695000},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1654110695000},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1654110695000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1654110695000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1654110695000},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1654110695000},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1654110695000},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1654110695000},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1654110695000},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1654110695000},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1654110695000},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1654110695000},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1654110695000},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1654110695000},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1654110695000},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1654110695000},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1654110695000},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1654110695000},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1654110695000},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1654110695000},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1654110695000},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1654110695000},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1654110695000},{"_id":"themes/next/source/images/avatar.jpg","hash":"6c8990146a8952732d3fa65f7933f4644c62f475","modified":1660025159934},{"_id":"public/atom.xml","hash":"86c337abe18a006e018fd86d0189871a9f7fa93e","modified":1666675828988},{"_id":"public/index.html","hash":"a6470efaab03d53201aec4ff6cb2e3f3e5a0cbc0","modified":1666675828988},{"_id":"public/commonweal/index.html","hash":"8620c4fa07faa37001aa36cd3a3b0f0b33147dd0","modified":1666675828988},{"_id":"public/vue/index.html","hash":"e7a7d75149d0f21bdebd087610271e02516f234d","modified":1666675828988},{"_id":"public/vue/dependency.html","hash":"42c69abf415449c783e89f9710ecea7963b539ad","modified":1666675828988},{"_id":"public/2022/10/19/41-nodejs-base/index.html","hash":"d15bc3d1834b6d6fa66e8c72b73a1a9c05410762","modified":1666675828988},{"_id":"public/2022/09/21/32-apply-array-to-params/index.html","hash":"d1809c48e2057ee644a99eaa771cc17ddf0d45aa","modified":1666675828988},{"_id":"public/2022/08/19/22-about-symbol/index.html","hash":"31d0b98ef3dedac3bb0edd63708f85b107225a46","modified":1666675828988},{"_id":"public/2022/08/11/15-js-transform/js-transform/index.html","hash":"f5215f97d238d1a757167145cc95b283cfc10e23","modified":1666675828988},{"_id":"public/2022/08/05/20-create-vscode-plugin/index.html","hash":"34107a26980dfaf691de432c9197eba45260fc72","modified":1666675828988},{"_id":"public/2022/08/04/18-fake-array/index.html","hash":"08ca8efd8c941de2a21a493ff97e08e180bb02c8","modified":1666675828988},{"_id":"public/2022/07/19/16-origin-type-and-reference-type/index.html","hash":"53c9eff5666175f251903168238e97db16456a3e","modified":1666675828988},{"_id":"public/2022/07/05/13-document-location/index.html","hash":"3fca8bae500365623ed2ec8b917d19389871198a","modified":1666675828988},{"_id":"public/2022/06/30/12-create-github-tokens/index.html","hash":"f06e943cbb8da1308e1bca7477a9ad0ea0ebaf42","modified":1666675828988},{"_id":"public/2022/06/23/7-question-about-render/index.html","hash":"95a8623461cd3410f66b1a814e57396335b7694e","modified":1666675828988},{"_id":"public/2022/06/22/6-vue3-render/index.html","hash":"2762b9e26a076a2d84c0903fe6b4d0326ef216d9","modified":1666675828988},{"_id":"public/2022/06/22/5-react-render/index.html","hash":"20ffdd59bc7c82f7c73f415e6ad47fef2ae235c2","modified":1666675828988},{"_id":"public/2022/03/26/3-about-use-hexo/index.html","hash":"f9b63b094dd9d17da056470842e6a1bbe2a920f3","modified":1666675828988},{"_id":"public/2022/03/26/2-var-const-let/index.html","hash":"703cb4a9573b987b544d3741262f7f52841b5bc6","modified":1666675828988},{"_id":"public/2022/01/05/1-hello-world/index.html","hash":"47fb00298af442d4ea70e1c227478511097d260b","modified":1666675828988},{"_id":"public/archives/page/3/index.html","hash":"8b6ab4fe4e93614bdee61c6b24efc91c3478c2cb","modified":1666675828988},{"_id":"public/archives/2022/page/3/index.html","hash":"f163afca5365693800ff92c44a4c52b803821caf","modified":1666675828988},{"_id":"public/archives/2022/01/index.html","hash":"0f6f737b7dcbc684a0f3e933994497bf82b31540","modified":1666675828988},{"_id":"public/archives/2022/03/index.html","hash":"086a1c03c3ac68816351ce249545b61d8730de0d","modified":1666675828988},{"_id":"public/archives/2022/05/index.html","hash":"a7382406599c6cfecaad400b96a2799cc38efba3","modified":1666675828988},{"_id":"public/archives/2022/06/index.html","hash":"cdd99922f87fc3b513a9a350b256bd1984e87c84","modified":1666675828988},{"_id":"public/archives/2022/07/index.html","hash":"2e234d11d850bdff0399cd662e01edfc0b96e5ee","modified":1666675828988},{"_id":"public/archives/2022/08/index.html","hash":"961c27b545a472f05bce261474579352a73f2ccf","modified":1666675828988},{"_id":"public/archives/2022/09/index.html","hash":"042f89d11dc1ca1a2d1c6063a4159f06552bbc66","modified":1666675828988},{"_id":"public/archives/2022/10/index.html","hash":"4792d27659dd9ee8496b426dffb46450a7b7e424","modified":1666675828988},{"_id":"public/vue/change.html","hash":"6207e8f5e1d9aa8b76e751a9073b1896b16d11a7","modified":1666675828988},{"_id":"public/2022/10/17/40-tail-call/index.html","hash":"3c7e6864a23877f80bf1bba3cd3f33c9700920ef","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/index.html","hash":"fb75c9279deadf3360c0d9bb7909fcca0957c662","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/index.html","hash":"44ea7068562a03de8b19aba31614dd801e1a7863","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/index.html","hash":"0f66920cb20e0d5ea1bc04d0048eae9ad13d65c3","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/index.html","hash":"dba13e6a1336aa94a01ca7fafa1466cc785d51c5","modified":1666675828988},{"_id":"public/2022/09/23/34-data-structure2/index.html","hash":"aaba80c23e84b9baf794c34756dc079ef0a5a532","modified":1666675828988},{"_id":"public/2022/09/29/35-data-structure3/index.html","hash":"1ee2bdd68694fc371fcc80c374c1581f93bb46e7","modified":1666675828988},{"_id":"public/2022/09/20/33-data-structure1/index.html","hash":"f131ca3022e5f5ed000e1b5618071fadf528b99e","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/index.html","hash":"04d3e71116c3080d4aae8b1a4b54b381b147cf28","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/index.html","hash":"53eb7fba9b9efca8dbdc691d1e08afd754f8bb98","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/index.html","hash":"702de577179f584487bc7b87ef20a5e8465287ff","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/index.html","hash":"e5d57a4c4b20db30139174ba00fb5d0237e8a850","modified":1666675828988},{"_id":"public/2022/09/05/31-get-and-set-prototypeof/index.html","hash":"430b7052b85512356d8fb86a3c5711613574a1cb","modified":1666675828988},{"_id":"public/2022/09/05/30-some-convenient-code/index.html","hash":"ae77797f1c783b7b75412687c67a2ef5a953d975","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/index.html","hash":"bd7a57073912932d3c753991514a26fde105272c","modified":1666675828988},{"_id":"public/2022/09/02/29-es6-object-strong/index.html","hash":"3809a8b53583aae2e881c31dfe7ec9ca2012e001","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/index.html","hash":"c8f84a2c5b0c50d607e29e6f90b57d6b6ea6bce6","modified":1666675828988},{"_id":"public/2022/08/09/21-devan-operation/index.html","hash":"1461c28762f8a157f0afe00d7c166602141aaeca","modified":1666675828988},{"_id":"public/2022/08/04/19-about-map/index.html","hash":"029360d54dd19deb19a66125d88a720bf40a772d","modified":1666675828988},{"_id":"public/2022/07/31/17-about-dom/index.html","hash":"ccdc48a5ff980e99a08f2e4aefbbe4eeae9397fd","modified":1666675828988},{"_id":"public/2022/07/19/15-js-transform/index.html","hash":"f676855434570a9d988dca982d819e5726a65c28","modified":1666675828988},{"_id":"public/2022/07/12/14-about-fe-theory/index.html","hash":"3dd51820d6ba28f58e7d16da11b37469407a8552","modified":1666675828988},{"_id":"public/2022/06/30/11-github-push-insert-password/index.html","hash":"d34352dc8c8198a1e67768855ce7d767281e9078","modified":1666675828988},{"_id":"public/2022/06/28/10-about-meta/index.html","hash":"a3abcd369bc721898f5c93bb2d8f6b9afa6f62ee","modified":1666675828988},{"_id":"public/2022/06/27/9-text-type-about-markdown/index.html","hash":"258f7d7b9d624f7e7c8dda81260e34bf7c1e8d93","modified":1666675828988},{"_id":"public/2022/06/27/8-create-fixed-length-array/index.html","hash":"7e625c0583a67de998373fd5a1e06a602a6bba09","modified":1666675828988},{"_id":"public/2022/05/23/4-browser-render/index.html","hash":"136f5c37d121f3817edc77fa48719537c225760c","modified":1666675828988},{"_id":"public/archives/index.html","hash":"81675d6f98a02f4e8baa77de4292008c591fb755","modified":1666675828988},{"_id":"public/archives/page/2/index.html","hash":"85e0be8a098caffded2fca288b4ba7699840ee21","modified":1666675828988},{"_id":"public/archives/2022/index.html","hash":"bd616b5fbd1ad7e416bcb774e72e736a03392afb","modified":1666675828988},{"_id":"public/archives/2022/page/2/index.html","hash":"3eea192d76d706ca333155208990a8c21efe92a5","modified":1666675828988},{"_id":"public/default-index/index.html","hash":"9723621b34f5e88da1aedb7a03985bb4fb67b0f2","modified":1666675828988},{"_id":"public/default-index/page/2/index.html","hash":"7ef9e9f7b42976e18224e7524a3bcbaa2790aaac","modified":1666675828988},{"_id":"public/default-index/page/3/index.html","hash":"0f460465e00d92d1b4e9e263811200174abb0852","modified":1666675828988},{"_id":"public/default-index/page/4/index.html","hash":"610b4199be9782d170c4593f9cef7b2b147bcecc","modified":1666675828988},{"_id":"public/default-index/page/5/index.html","hash":"816ce025b30b6564f3acb24fa92abb487bfe41ba","modified":1666675828988},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1666675828988},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1666675828988},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1666675828988},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1666675828988},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1666675828988},{"_id":"public/images/logo.jpeg","hash":"cf0f17140f5d4eefe4607db39c354c73eb9b6500","modified":1666675828988},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1666675828988},{"_id":"public/2022/08/04/18-fake-array/array_from.png","hash":"50733fd866277f6aa27e12e432f2511fa886855f","modified":1666675828988},{"_id":"public/2022/08/04/18-fake-array/document.png","hash":"c0e73c5d922eaf7f899856685f5fbd8245517fe8","modified":1666675828988},{"_id":"public/2022/08/04/18-fake-array/prototype_call.png","hash":"166ae1ed6f21a1c4ee961508d06adae89f22c6d6","modified":1666675828988},{"_id":"public/2022/08/04/18-fake-array/slice_call.png","hash":"a97bd9fef96df18bbe6097521df710bd9615090a","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/abstract-car.png","hash":"63b2384c0b130f2d40907996aeb528d2131ab01f","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/safe-model-class.png","hash":"90a874baec5df9156cf7b65d7c7754d28c82337e","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/static-param.png","hash":"ec22668e0901214c3d2efadcdae0ae34f801c2ac","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/command-model-3.png","hash":"f8973520dfc9d241d4e418d016dbde7cf647482f","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/explain-model-2.png","hash":"13dd495c6f42e9820c60034d2e87bc917486129e","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/observer-regist.png","hash":"160d15173ed43415298e65c9b3d9a63159aacb91","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/bridge1.png","hash":"70973d153e1e628ebf1152bce98b1a68b7530784","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/bridge3.png","hash":"8358d5a031c07b8a0dbe61df13f0642bf03b7c5d","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/bridge2.png","hash":"0d4e3980c0c177ef97e690e69919f954f2292ddb","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/entrust-model-2.png","hash":"71764eebae7d27ba83deff08b4d925307914e3d0","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-1.png","hash":"5237b5b92b4b542f593af63d48afb088237eb2ed","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-1.png","hash":"d78dd470675aa3f2a42ad1ce9617ef7d89e2168a","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-1.png","hash":"44ef46104d7428d99d7b80b7ca8e2f9059d02340","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-2.png","hash":"04cb3a2efcc6a9a9b3cc52a11c14b75ebfa332d6","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/template-model-6.png","hash":"f34ff79b1d619c45ccb21c2158a4680a6617942f","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-3.png","hash":"b59dca3e470f10063815167bca6227f8341dbc8e","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-8.png","hash":"9be78a26ae2db46d9ec8d4bb36902be64991e2f9","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-2.png","hash":"8898b83e3301783ee9bfb43b2488f4171e86a2bc","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-8.png","hash":"3a03fb902c96d787e256412ebc5a604a26aabd93","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-7.png","hash":"8473d1889cf3ba7e45e0b71a8dd861cc233f05c2","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-9.png","hash":"3959c02225b63e07adce93a968ed0bb0e2e6c365","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/module-model-5.png","hash":"c866de378508cfdbfd9307dd72b719577d2a3cff","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-1.png","hash":"9fe4ed86ba3315ba722de0660cc6ec5770666487","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-1.png","hash":"ff42b48b0eb5f6ac14adc79c348d093c14f164de","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-4.png","hash":"03b64f2faf10dbcc8c3a32fb96b29e0b135f2f49","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-7.png","hash":"85c76e7e1a84df4345885b58a4495b8472da6c7c","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-2.png","hash":"3cb6051a5054c50231162690a8494170b90397f4","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-1.png","hash":"4f89287a4f8aa1122864cbc4c77f89d592a68c45","modified":1666675828988},{"_id":"public/2022/09/23/34-data-structure2/chain-table-1.png","hash":"b4a240e43972349b743117265ca1897051389bed","modified":1666675828988},{"_id":"public/2022/09/23/34-data-structure2/chain-table-2.png","hash":"ea63e231035c3929b320bb52dc63c363a1b1ff39","modified":1666675828988},{"_id":"public/2022/09/23/34-data-structure2/chain-table-3.png","hash":"6db25c5f058ceecae16751cea75e2a13e62a6b3d","modified":1666675828988},{"_id":"public/2022/09/29/35-data-structure3/linear-probing.png","hash":"0a020e8afc93027a2f5d6873414f7afbfa4b6f83","modified":1666675828988},{"_id":"public/2022/09/23/34-data-structure2/chain-table-4.png","hash":"04054fdc4cbdfb48b13bde3769b7ccb590e6bff9","modified":1666675828988},{"_id":"public/2022/09/29/35-data-structure3/lose-lose.png","hash":"55e49878d996f933010c1ac93b306b407a74019a","modified":1666675828988},{"_id":"public/2022/09/29/35-data-structure3/move-key.png","hash":"ebb4944fee6e7aa9426ad27101ccaaca152e2fa2","modified":1666675828988},{"_id":"public/2022/09/29/35-data-structure3/soft-delete.png","hash":"f8fc5195e6b92a91af6b1a283be51fea18d95ccb","modified":1666675828988},{"_id":"public/2022/09/29/35-data-structure3/sperate-chain.png","hash":"1c7b05c0f24bd68757a3497182c41da36cf91bbc","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/search-2.png","hash":"3626ed24aaf5d1563eb1daa3a4f8d5136150bb83","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/search-1.png","hash":"a844a9c7aabbe1a2fc3c7151e88a35f494e9d09b","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/search-3.png","hash":"719072030a73de7c3054974d55b626d221894218","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-10.png","hash":"cbb2fbde7d06aae552356dd7e4c65274d322f0fe","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/search-4.png","hash":"ecf4e1f8dd0fdf38b91d89de529f09da6eb88dd8","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-1.png","hash":"97f90c860ce1d2669135aa5a7a474aeb7a799ad6","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-11.png","hash":"067113a10d14e5524fe4e7972c61d1b077811134","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-12.png","hash":"a8fdcaca8fd646997a58eca48c76809cb25c7571","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-2.png","hash":"a63daadd4590ed6b4ad7519bd1a14ae4be364a64","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-3.png","hash":"913bb3906ff437f6dfe6a773b852918b7a49ae0d","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-4.png","hash":"273c67388337e6e5eeb6c6e3486e5047d8d02321","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-5.png","hash":"05867cc82ce12a1a2b6c92d0d37e2155df04d0a5","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-6.png","hash":"c4802ae6c84bee330fec94ddd888543a590ec692","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-7.png","hash":"681be89ab6425489c526125d890ae38ef8ee1435","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-8.png","hash":"f62f618f88c3715fa98532f136e36afea5153b3b","modified":1666675828988},{"_id":"public/2022/10/13/38-data-structure6/sort-9.png","hash":"b1a616076a59411ae21537a155e8f12e198c78b0","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/binary-search-tree.png","hash":"ad74f8c6b96f77ca95d6b9b48cf87fda5efcfdbc","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/factorial.png","hash":"ddfb0d84eab3db09c51a4b87376c023e35c597be","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/in-order-traverse.png","hash":"db6c59fc444e910a9921f50bc9e8e66964ef2849","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/left-left-1.png","hash":"655a6a8118dd11fffc1c0bf38c1a06fd9d861fb7","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/left-left-2.png","hash":"31829f0a81c4d517a768b0d824702e96ed38af94","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/left-right-2.png","hash":"dde339c5a7c4a70be0a832190a2678237f10331d","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/post-order-traverse.png","hash":"aee9c88702a4fa397c4146e997f7ba3504b19a3e","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/pre-order-traverse.png","hash":"d93c415f7de4fd6c9d5bf3dfc7fdaf4484d6173c","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/red-black-2b.png","hash":"88a4290e21e993ca3a39a86a83283bc607f24b9c","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/red-black-3a.png","hash":"6db63a5d31e7477b9d3a7ce036c9607db9262fb8","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/left-right-1.png","hash":"b0d03e54c49df4be3cdc60f9436e4ecb40a3c6b6","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/red-black-3b.png","hash":"e4f8a20d976abc667a94482eeeeaa0f5281c410e","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/remove-left-right.png","hash":"4141ff9827c5c74323d60196c96038c898c07cf6","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/right-left-1.png","hash":"3d1ec645ec1def7aeb460386d421b9dc3cc684e0","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/red-black-2a.png","hash":"618993219918c6d178ac4f468129647d0c0d6f72","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/right-left-2.png","hash":"9fd153762d1b34409ac583c8dd871153f0ce5fc1","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/right-right-1.png","hash":"5d6258c158f22e8582f538f06c89dc86bbedfba7","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/right-right-2.png","hash":"b6a6f5a17aa73fc8daf16313e0204a05314c3c16","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-1.png","hash":"a1b2db6ab3de04b1adf413855eaa4220c96ae523","modified":1666675828988},{"_id":"public/2022/10/08/36-data-structure4/tree.png","hash":"c1a3dff14361fa7bfc3f73bf7391d46c57044737","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-11.png","hash":"070f67f44e46097fb8750af9a315c9bca7fc6c0f","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-10.png","hash":"be4ed69d06ae7dcea2b875b3b0ce92922a7fd0b2","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-12.png","hash":"b557ac7c33f3672b559a4a1eacf84aba2fcff1cf","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-13.png","hash":"0ef979dea025ae063ccc8477915e14c2bada6f77","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-2.png","hash":"f56455b618e7b41e84fba80e91ade7ed29df91ca","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-3.png","hash":"4bca0b6ea37be10e8ab4b015ab1879bc9c95f98b","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-4.png","hash":"47bcd4a1de612d5af3bd3301602b4b6bc07b4c6a","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-5.png","hash":"a85fa2dffae020f8d02eebce15b1592e9b222a5e","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-6.png","hash":"3781b637547025de758bec7262c50fe45bb57774","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-7.png","hash":"dbd8e52679bcbf321c3a8d17006729c4af0c87ad","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-8.png","hash":"93de61e5c29df7b193e41f2595521446bc81226d","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/heat.png","hash":"a37ac1abfbbf1bd9742deec30a783d0f90e49657","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/min-heat.png","hash":"c2c5f8cc68ba6cf3d89bebb94c0a7a7d22c1e5a0","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/big-o-1.png","hash":"bfc4e8cd9822858a4f5afd7ea21ac69ae391248f","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/big-o-2.png","hash":"5abf1a71a4b31ade53b60d5d6edf850266d502e2","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/big-o-3.png","hash":"b7140be66eb3272f0dd9c183b48cfb8555cb4511","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/big-o-4.png","hash":"75fd12b92a8ef511524bb5306c73fb63346d586d","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/big-o-5.png","hash":"0e81454c15a22289ae8fd29e9ba356f9058ca226","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/big-o-6.png","hash":"443cef5a2ff290edd7a7b9f9c3e4580e9d8375b3","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/technology-1.png","hash":"25d324e43b4ae5d4921a2fa9bf40479a54ba55d2","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/technology-2.png","hash":"00436e4649e1f7cdeecb39e78e1cece84a8c0591","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/technology-5.png","hash":"61dc4bb992375a4f2d5c5b5afdb594877f58510a","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/technology-4.png","hash":"956d458c4792a6a56ad0f9292f3e7773bafca1d1","modified":1666675828988},{"_id":"public/2022/10/13/39-data-structure7/technology-3.png","hash":"fe308b75c03e0efc9bc24154073ae4a31c1fc73f","modified":1666675828988},{"_id":"public/2022/10/17/40-tail-call/call-stack.png","hash":"9ceba234d31d636baca2b4f2af1384b6b25d4a4a","modified":1666675828988},{"_id":"public/2022/06/22/6-vue3-render/render.png","hash":"0b20ebf2700ccd675e40f6330e07dce8341807a0","modified":1666675828988},{"_id":"public/images/avatar.jpg","hash":"6c8990146a8952732d3fa65f7933f4644c62f475","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/how-to-inherit.png","hash":"2610b10429de1454b684733ede30778da89da750","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/parasitic-inherit.png","hash":"dcde79d7db360d5f56bf441be778908d3056f693","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/prototype-inherit.png","hash":"a5f0085a3caf9e0519fe3cb26129dd144cfc7594","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/public-and-private.png","hash":"275fce752eaeadf6eee22e10bf14451ed9eb675c","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/prototype.png","hash":"fe3518ce58c5945b8f5db473d69be75f67a98b0a","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/simple-factory2.png","hash":"e8d75951fa119c24b2c188eb639f16a32bf70928","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/static-and-public.png","hash":"aef2330dce27ebc420b7654abdf1859266ec48a4","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/abstract-factory2.png","hash":"a1a8a6b4b0c2aa47bbc543add6b6a675670b41ce","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/human.png","hash":"f78b9964ce7223cc99122c99667673d9242df348","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/lazy-single-instance.png","hash":"4bbd91090a4364cc48ec5cf388ae29f1f3626b8a","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/name.png","hash":"d46e84150e7fdea9eb17d8ad0624e7eb79654ace","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/person.png","hash":"12e19fccdb8ee0dea2ec9e55c4f55125a536b76e","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/prototype-inherit2.png","hash":"cd61b59785ea6144fabce855bd363ff7906468a9","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/add-message.png","hash":"03712141c27e51d24f4361c6c48a609b366f5692","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/marry-state1.png","hash":"2f5c004568231ff2a14ab499c91aabd48c302f28","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/observer-fire.png","hash":"0204e744bdcb2480cae91e03d4e79c26913cf85a","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/observer-remove.png","hash":"e0e97122604f5eaa716042ffd19d7e6fc4d9535f","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/observer.png","hash":"05738a02cd73736025351c0e9e3fc0d0de27158f","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/regist-change-num.png","hash":"3aa9791db11e1985c21e29959201f022a0f98a88","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/decorator.png","hash":"a0fdfe4dc2b74b52a33fd13ed7e1b3c1fba8480e","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/out-look.png","hash":"d9f11180b44ccded8da8ecba5593bdd6ebd58eb4","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-1.png","hash":"ac13400dfce89f26fe4bcadca5c2a1f4994083ca","modified":1666675828988},{"_id":"public/2022/09/06/25-about-design-model2/station-culculate.png","hash":"26cda447bac04b0260f0ec11ca1dcb836f93855a","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-2.png","hash":"8a59f234053c9a85a94f74273fafed9051ec578d","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-4.png","hash":"33fa9dc7cb773d0e519dcb4a4a5869aa78234950","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/entrust-model-1.png","hash":"900a7cc246a17adae923b5e0b87d5b8b8d255674","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-2.png","hash":"29a6f621b06f9283d3caff7d3c63f7c711095978","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-3.png","hash":"7cf3eba1156eb71177fee16c281edfd2f7d3d0e0","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-5.png","hash":"ce1428d6b73612a3290d3cbd0efa607829fdb233","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-6.png","hash":"bb1487d2e1e38d3c2ea4cb6dcc310f0025664444","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-3.png","hash":"257320d7e940dcef49305ea8d1642621bfbf3ff1","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-4.png","hash":"5f13e728cfa8cf2eabd3925f1a0798bc905d267b","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-5.png","hash":"9694840f32c90094e37228de41fc2cfdf4f66388","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/template-model-1.png","hash":"41e2537938230a77a4072987778016031fe92291","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/template-model-3.png","hash":"3a24763c6d9e280dd6c26d966da99ceb0d658ec5","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/template-model-4.png","hash":"b301423b25f6447a52369e96a6f0d1c3b93da6c5","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-4.png","hash":"ad67d02d972353793d59f1ca5f1191fb9a220e52","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-5.png","hash":"30412937d3a27e5d8bf1db0d87fce38a8d59839e","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-7.png","hash":"0eefaa7468c3726aecd02980b1c10574a1d06c40","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-6.png","hash":"007198e00695be520e246815152687e250bf4941","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-4.png","hash":"731b4ee9c777c9d9bd6664bf674e1abf1f48af65","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-5.png","hash":"436f66ba99f8bd7400ad91b3d857d255f6f3034c","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/module-model-2.png","hash":"a22fb6b41b50875766d5382664361095fca59051","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/module-model-3.png","hash":"aa42c569b2a73fae726d6518fda8a48a325c5a3f","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-3.png","hash":"28fd4de773e1352941b4b0773858520ec4e21039","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-4.png","hash":"59ab08a2d276eb142c4789000d2c484aaaeb4890","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-3.png","hash":"b4f73f397dcb296b03350b04390a8f2cdc0906d4","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-7.png","hash":"4d8187320d10b1bb36a49169575baf54fe7e7a71","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-4.png","hash":"7c2ca9c608b6829fa768590455a8785c9ff13781","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-5.png","hash":"5ff7151981d6c83fa8a45556de7e17f4e527c093","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/heap-sort.png","hash":"a344a2264bed09372c160b691a6e0a581bea3bd6","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/min-heat-pic.png","hash":"6d8794be490f9dd7f0664813070eea6169c49181","modified":1666675828988},{"_id":"public/2022/06/22/5-react-render/force_update.png","hash":"f0333239066cd2e4a8cdf12bff8fcdfcc01a7616","modified":1666675828988},{"_id":"public/2022/06/22/5-react-render/update_class.png","hash":"5854028928496a0b6c4ad02452cd07c12650f8e8","modified":1666675828988},{"_id":"public/2022/06/22/6-vue3-render/render_node1.png","hash":"4a4266c87a315afeb55de174b11784431f3c40b9","modified":1666675828988},{"_id":"public/2022/06/22/6-vue3-render/render_node2.png","hash":"bd8cbab05ce653b80a1cc89e609b7ae9c309b7fe","modified":1666675828988},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1666675828988},{"_id":"public/css/noscript.css","hash":"ec89b3425fbce20863d554c6fd495ea29c3c303d","modified":1666675828988},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1666675828988},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1666675828988},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1666675828988},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1666675828988},{"_id":"public/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1666675828988},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1666675828988},{"_id":"public/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1666675828988},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1666675828988},{"_id":"public/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1666675828988},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1666675828988},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1666675828988},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1666675828988},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1666675828988},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1666675828988},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1666675828988},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1666675828988},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1666675828988},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1666675828988},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1666675828988},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1666675828988},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1666675828988},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1666675828988},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1666675828988},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1666675828988},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1666675828988},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1666675828988},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1666675828988},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1666675828988},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1666675828988},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1666675828988},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1666675828988},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1666675828988},{"_id":"public/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1666675828988},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1666675828988},{"_id":"public/2022/07/19/15-js-transform/js-transform.html","hash":"18caf0ae505ad384d3fa4c402aaf049e263f6fc0","modified":1666675828988},{"_id":"public/css/main.css","hash":"691e6c349d2c53e152277bb709c31758dc8ada9d","modified":1666675828988},{"_id":"public/2022/07/19/15-js-transform/convert-table.png","hash":"fdffd1b86ddacb402a9a3a423cffd91fcc229fce","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/class-inherit.png","hash":"7316cf53af5ae3d11eb708f911ddc2b9fbf35027","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/create-pop.png","hash":"43feb1eed0b060643140cfa80c073e12729b47af","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/multiple-inherit.png","hash":"3370f1d5c3f1c73449ddc04e438559b4a0925ad0","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/parasitic-combination-inherit.png","hash":"5b7c9be2d070fe04cd77d8923eaa4e1585ad9e02","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/parasitic-inherit-change.png","hash":"0b683e58266a2816c17a932a910be6ce1bdbbf1e","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/abstract-factory1.png","hash":"27096d5d5c2a949d2b5a0b8b4483cd0955007a30","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/abstract-factory3.png","hash":"565cc1a91ec9f7f4113759d8ee84d9e7e5765dec","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/prototype-inherit1.png","hash":"3d8d602b70b2a85f84ccb77667bfdf58688ef1e6","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/safe-factory-model.png","hash":"1d4838406d573590c135cb651e98e970dd03d761","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/command-model-2.png","hash":"394963fe76e75b6ff152d0bc64eb440812f181e4","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/create-component.png","hash":"313f9c4b04afdb3c0bbb24d02394ff7ed7f7afa9","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/deal-data.png","hash":"229c21fa8cd0891d9cf137520e2756088d805b32","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/marry-state.png","hash":"9d3b9fd7f74062d32194ddee1084db94ab8f2f5e","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/send-data.png","hash":"f2dd937ad9d5dbd6373c78b766b0ca7d18689bb8","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/vote-status.png","hash":"ce2f7e1b2250efafac59e7e0a6c69a8f2f57e1fb","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-5.png","hash":"6c1d9aaa8a2f5c8a33e827428f33df74156af591","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-6.png","hash":"0a2af8c6826567da8695e8010d13bf7101a75d0a","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-4.png","hash":"d2cec3917cabaf4da67a6ac877730c32d27d6b82","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-2.png","hash":"b130a85fa7ca8cc738c636091e35ce86095e4da4","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-4.png","hash":"c7d8b6cd9bc0093ceaaa9a731d6b721dabf0c2e2","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/template-model-2.png","hash":"f0f1cf1e6328ed7dd2da13e3ef19f0ba3090d50b","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/template-model-5.png","hash":"a615f27465cba32bd7ef16f4aa2d229123c6cd04","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/throttle-model-2.png","hash":"4d06f2204e6a312ad534b08e4aa3a0cc199b0fe4","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-1.png","hash":"4ecd76529d5af3bab1200944f956550c438d7e4c","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/throttle-model-3.png","hash":"9ba30093c88bda5cdf0b74397078c98615ab14e8","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-2.png","hash":"115d73933b2c9e3b333f0173a9c67b40b82b360e","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-1.png","hash":"63d1fb2d7060dc8e20879b271cfc0fae5ba53ce5","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-10.png","hash":"47f4c469384a2ae6ee68920c9c9d056323bc6964","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-3.png","hash":"955761aa1d41f38f58070239091ec7ef56eab433","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-6.png","hash":"c0234e34b71f60317c8532f9b4332297ddbfc3b2","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-2.png","hash":"a05c2d67784dc8a0c9dadb55ff4cb313ff0a4581","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-5.png","hash":"b38b48df97224ac10c391b5231c27b5ff9439d15","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-6.png","hash":"b678a14aa7203ed211d9b03cc517629296d39ccb","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-5.png","hash":"f5b38278a65c50724df598782714d46b16198ddb","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-1.png","hash":"dec3d9b3d1b759d8ab97b596942a57870ea5e899","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-8.png","hash":"ae0f8837c7bf0b7cebcf1b643602ef1b7c91d9b0","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-2.png","hash":"d5b2a749b270b467d4e5ca0442f079ad0d68c0ad","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-3.png","hash":"8caaa1350394bb4924a26779474bd8ffdedfd1a3","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-6.png","hash":"17625b96826cacb789210181082942b9d92c9685","modified":1666675828988},{"_id":"public/2022/10/08/37-data-structure5/graph-9.png","hash":"3e0a9c9a2cb3f8145448b3dab7b9066c53f468d2","modified":1666675828988},{"_id":"public/2022/06/22/5-react-render/fiber_tree.png","hash":"947d11b845e1abb74cbb2d4e135767a377692041","modified":1666675828988},{"_id":"public/2022/06/22/6-vue3-render/render_function.png","hash":"ab09e61382c872069a70212525d4333d6ba8cd19","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/safe-model.png","hash":"8ddf098b287fc1582ef3c57f6641b8cdfe529ee0","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/multiple-status.png","hash":"99f1acc2445ec0c692d48660ddbd71b510f1284b","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/simple-factory1.png","hash":"7a9ab5660cbd92e1e0f851985402404fb0f49814","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/test-prototype-inherit.png","hash":"ffe8e406495b76ed7e8fa5fa95247335f0842bd8","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/work.png","hash":"85878cbf259712eba4a4d960bef9fc8f72361f7d","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/basic-model.png","hash":"d11299e00239d8eee68fa84742cf934d7b2b7455","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/cache-model.png","hash":"849dac393027d49c7932b80aeacdeb6dc665ad8d","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/command-model-1.png","hash":"e8f27f13a8b8964e1f98cf90c9d11336745ce4cd","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/inherit-as-basic-model.png","hash":"04bcb6c49805f61c210a276673688925342a97a2","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/explain-model-1.png","hash":"b41f3ee9472b65e45fd3699586fe343b90801e1c","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/explain-model-3.png","hash":"7090631280b778e1a081cf14ee1aef4eaddf2724","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/inherit-model.png","hash":"c458570cfbf5cb544f160dbf7f5ea2688eb54cfe","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/price-strategy.png","hash":"8c9b4bc9e46d85dbd5ff1db682f35d7727ac2d24","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/mediator-model.png","hash":"037a378a4fd6a9b68621c714239390a175768283","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/regist-message.png","hash":"94993ad78c5391eb4cc60f851d1bf5de794d680a","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/visitor-model.png","hash":"b47054fdf9198975a39ebfc6b4ea46cb988dc080","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-3.png","hash":"de232baf72880e1c2bfca1e52ca3dece90b30922","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-5.png","hash":"f60b1b8098b39c8d16bef6ce21e93f80eed6a06d","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-3.png","hash":"0dd09a8620412a0a10e0749a2eae5b990e14131f","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-6.png","hash":"af1bc9d6bd7aa6c6582b3b498aaace38b3beb7d0","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-6.png","hash":"a27676bb25d07081323b4801ff167a2f9c830583","modified":1666675828988},{"_id":"public/2022/09/19/27-about-design-model4/throttle-model-1.png","hash":"efe9c32037c01c30eef7c906b1477675a4b22296","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-5.png","hash":"7d00695f69933f1493a5b215459372aa8922aa90","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-4.png","hash":"0caa8c2b2efef085bf73708c696b163b27cf4acd","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-3.png","hash":"972a431f1b9f113e9c28acd09c21965abf3ae776","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-2.png","hash":"c793bb154006138580dfe636e8e96f48af31c136","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-6.png","hash":"ebaf47a4d6e618ed357e3ef105bf1a78aac86dcd","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-7.png","hash":"c12235fa4218a1f12d5f04de3c292d9d8a1cc606","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-8.png","hash":"acc5e67aafb4ec4d3a10ca9507832f965d05bb86","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/appendix-9.png","hash":"5128c7e89b6784e2e75e7f74154a3a2a36859a4a","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/module-model-4.png","hash":"0591ff679bd8b40d96b399c2df5db22e5d6857f1","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-2.png","hash":"2ad2eeb884aac27d63ceb815d119f4bdab3b28bf","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-4.png","hash":"362b306d44bd195ca4adee181dabcbbb524da1ac","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-6.png","hash":"7d62d18ec951b6be1b53157c9380618cb8f65cc2","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/combination-inherit.png","hash":"51a2c5f4775a37e5f2a21ab257749912178476c3","modified":1666675828988},{"_id":"public/2022/09/04/24-about-design-model1/prototype-model.png","hash":"7e1b5e0841203ae571b20c1c21fc40fb6589f946","modified":1666675828988},{"_id":"public/2022/09/07/26-about-design-model3/iterator-model.png","hash":"b372e782497790afdac5ef90a53eb4ecd88bc18f","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-1.png","hash":"f465cd97d9c16ecea67b0d0f8ee7d3bb6ebb545c","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/module-model-1.png","hash":"940ec1732a0d822780c486ccb9ffc6cc29119a6f","modified":1666675828988},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-3.png","hash":"f3ebcf32efc3e9b536605c9df96654c81cfc9b82","modified":1666675828988},{"_id":"public/2022/08/20/23-about-design-model/constructor-inherit.png","hash":"e1eb49fe9cd4796f60678113b6f865f2e1576464","modified":1666675828988},{"_id":"public/2022/06/22/6-vue3-render/vue3_render.png","hash":"c27773553432184cba670aac70e69865c21a4727","modified":1666675828988}],"Category":[],"Data":[],"Page":[{"_content":"#### This is Sun Jinkang＇s page.\n\n* [Post文章](/archives/)\n* [vue相关](/vue/)\n\n\n[常用官网地址](/2022/07/05/13-document-location/)","source":"index.md","raw":"#### This is Sun Jinkang＇s page.\n\n* [Post文章](/archives/)\n* [vue相关](/vue/)\n\n\n[常用官网地址](/2022/07/05/13-document-location/)","date":"2022-10-25T06:58:08.887Z","updated":"2022-10-25T06:58:08.887Z","path":"index.html","_id":"cl9nrr8pc0000k4tt4fktb13i","title":"","comments":1,"layout":"page","content":"<h4 id=\"This-is-Sun-Jinkang＇s-page\"><a href=\"#This-is-Sun-Jinkang＇s-page\" class=\"headerlink\" title=\"This is Sun Jinkang＇s page.\"></a>This is Sun Jinkang＇s page.</h4><ul>\n<li><a href=\"/archives/\">Post文章</a></li>\n<li><a href=\"/vue/\">vue相关</a></li>\n</ul>\n<p><a href=\"/2022/07/05/13-document-location/\">常用官网地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"This-is-Sun-Jinkang＇s-page\"><a href=\"#This-is-Sun-Jinkang＇s-page\" class=\"headerlink\" title=\"This is Sun Jinkang＇s page.\"></a>This is Sun Jinkang＇s page.</h4><ul>\n<li><a href=\"/archives/\">Post文章</a></li>\n<li><a href=\"/vue/\">vue相关</a></li>\n</ul>\n<p><a href=\"/2022/07/05/13-document-location/\">常用官网地址</a></p>\n"},{"title":"2.x迁移到3.x变更点","date":"2022-01-25T06:17:57.000Z","_content":"### 生命周期变更\n| 选项式 API | Hook inside setup |\n| :------: | :------: |\n| beforeCreate | Not needed* |\n| created | Not needed* |\n| beforeMount | onBeforeMount |\n| mounted | onMounted |\n| beforeUpdate | onBeforeUpdate |\n| updated | onUpdated |\n| beforeUnmount | onBeforeUnmount |\n| unmounted | onUnmounted |\n| errorCaptured | onErrorCaptured |\n| renderTracked | onRenderTracked |\n| renderTriggered | onRenderTriggered |\n| activated | onActivated |\n| deactivated | onDeactivated |\n\n### vue3允许组件有多个根节点\n\n### 移除过滤器\n过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器\n\n### template应用挂载变更\n在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。\n在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML\n\n### 过渡的 class 名更改\n过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from\n\n### <transition> 组件的相关 prop 名称变化\nleave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)\nenter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)\n\n### Transition Group 根元素\n<transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag='span' 即可\n\n### 移除v-on.native修饰符\nv-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。\n\n### v-if 与 v-for 的优先级变更\n| vue2 | vue3 |\n| :--- | :--- |\n| 在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用 | v-if 总是优先于 v-for 生效 |\n\n### v-bind 合并行为\n| vue2 | vue3 |\n| :--- | :--- |\n| 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后） | 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前） |\n\n### VNode 生命周期事件\n| vue2 | vue3 |\n| :--- | :--- |\n| 事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字 | 以 vnode- 前缀开头，事件也可用于 HTML 元素 |\n\n举例：vnode- 前缀：@vnode-updated=\"onUpdated\"；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=\"onUpdated\"；\n生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。\n\n[从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)](https://v3.cn.vuejs.org/guide/migration/introduction.html)\n","source":"vue/change.md","raw":"---\ntitle: 2.x迁移到3.x变更点\ndate: 2022-01-25 14:17:57\n---\n### 生命周期变更\n| 选项式 API | Hook inside setup |\n| :------: | :------: |\n| beforeCreate | Not needed* |\n| created | Not needed* |\n| beforeMount | onBeforeMount |\n| mounted | onMounted |\n| beforeUpdate | onBeforeUpdate |\n| updated | onUpdated |\n| beforeUnmount | onBeforeUnmount |\n| unmounted | onUnmounted |\n| errorCaptured | onErrorCaptured |\n| renderTracked | onRenderTracked |\n| renderTriggered | onRenderTriggered |\n| activated | onActivated |\n| deactivated | onDeactivated |\n\n### vue3允许组件有多个根节点\n\n### 移除过滤器\n过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器\n\n### template应用挂载变更\n在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。\n在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML\n\n### 过渡的 class 名更改\n过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from\n\n### <transition> 组件的相关 prop 名称变化\nleave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)\nenter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)\n\n### Transition Group 根元素\n<transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag='span' 即可\n\n### 移除v-on.native修饰符\nv-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。\n\n### v-if 与 v-for 的优先级变更\n| vue2 | vue3 |\n| :--- | :--- |\n| 在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用 | v-if 总是优先于 v-for 生效 |\n\n### v-bind 合并行为\n| vue2 | vue3 |\n| :--- | :--- |\n| 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后） | 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前） |\n\n### VNode 生命周期事件\n| vue2 | vue3 |\n| :--- | :--- |\n| 事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字 | 以 vnode- 前缀开头，事件也可用于 HTML 元素 |\n\n举例：vnode- 前缀：@vnode-updated=\"onUpdated\"；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=\"onUpdated\"；\n生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。\n\n[从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)](https://v3.cn.vuejs.org/guide/migration/introduction.html)\n","updated":"2022-01-25T10:10:54.040Z","path":"vue/change.html","comments":1,"layout":"page","_id":"cl9nrr8ph0002k4tt9hh2e2xa","content":"<h3 id=\"生命周期变更\"><a href=\"#生命周期变更\" class=\"headerlink\" title=\"生命周期变更\"></a>生命周期变更</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选项式 API</th>\n<th align=\"center\">Hook inside setup</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">beforeCreate</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">created</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">beforeMount</td>\n<td align=\"center\">onBeforeMount</td>\n</tr>\n<tr>\n<td align=\"center\">mounted</td>\n<td align=\"center\">onMounted</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUpdate</td>\n<td align=\"center\">onBeforeUpdate</td>\n</tr>\n<tr>\n<td align=\"center\">updated</td>\n<td align=\"center\">onUpdated</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUnmount</td>\n<td align=\"center\">onBeforeUnmount</td>\n</tr>\n<tr>\n<td align=\"center\">unmounted</td>\n<td align=\"center\">onUnmounted</td>\n</tr>\n<tr>\n<td align=\"center\">errorCaptured</td>\n<td align=\"center\">onErrorCaptured</td>\n</tr>\n<tr>\n<td align=\"center\">renderTracked</td>\n<td align=\"center\">onRenderTracked</td>\n</tr>\n<tr>\n<td align=\"center\">renderTriggered</td>\n<td align=\"center\">onRenderTriggered</td>\n</tr>\n<tr>\n<td align=\"center\">activated</td>\n<td align=\"center\">onActivated</td>\n</tr>\n<tr>\n<td align=\"center\">deactivated</td>\n<td align=\"center\">onDeactivated</td>\n</tr>\n</tbody></table>\n<h3 id=\"vue3允许组件有多个根节点\"><a href=\"#vue3允许组件有多个根节点\" class=\"headerlink\" title=\"vue3允许组件有多个根节点\"></a>vue3允许组件有多个根节点</h3><h3 id=\"移除过滤器\"><a href=\"#移除过滤器\" class=\"headerlink\" title=\"移除过滤器\"></a>移除过滤器</h3><p>过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器</p>\n<h3 id=\"template应用挂载变更\"><a href=\"#template应用挂载变更\" class=\"headerlink\" title=\"template应用挂载变更\"></a>template应用挂载变更</h3><p>在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。<br>在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML</p>\n<h3 id=\"过渡的-class-名更改\"><a href=\"#过渡的-class-名更改\" class=\"headerlink\" title=\"过渡的 class 名更改\"></a>过渡的 class 名更改</h3><p>过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from</p>\n<h3 id=\"组件的相关-prop-名称变化\"><a href=\"#组件的相关-prop-名称变化\" class=\"headerlink\" title=\" 组件的相关 prop 名称变化\"></a><transition> 组件的相关 prop 名称变化</transition></h3><p>leave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)<br>enter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)</p>\n<h3 id=\"Transition-Group-根元素\"><a href=\"#Transition-Group-根元素\" class=\"headerlink\" title=\"Transition Group 根元素\"></a>Transition Group 根元素</h3><p><transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag=’span’ 即可</transition-group></p>\n<h3 id=\"移除v-on-native修饰符\"><a href=\"#移除v-on-native修饰符\" class=\"headerlink\" title=\"移除v-on.native修饰符\"></a>移除v-on.native修饰符</h3><p>v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。</p>\n<h3 id=\"v-if-与-v-for-的优先级变更\"><a href=\"#v-if-与-v-for-的优先级变更\" class=\"headerlink\" title=\"v-if 与 v-for 的优先级变更\"></a>v-if 与 v-for 的优先级变更</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用</td>\n<td align=\"left\">v-if 总是优先于 v-for 生效</td>\n</tr>\n</tbody></table>\n<h3 id=\"v-bind-合并行为\"><a href=\"#v-bind-合并行为\" class=\"headerlink\" title=\"v-bind 合并行为\"></a>v-bind 合并行为</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后）</td>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前）</td>\n</tr>\n</tbody></table>\n<h3 id=\"VNode-生命周期事件\"><a href=\"#VNode-生命周期事件\" class=\"headerlink\" title=\"VNode 生命周期事件\"></a>VNode 生命周期事件</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字</td>\n<td align=\"left\">以 vnode- 前缀开头，事件也可用于 HTML 元素</td>\n</tr>\n</tbody></table>\n<p>举例：vnode- 前缀：@vnode-updated=”onUpdated”；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=”onUpdated”；<br>生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。</p>\n<p><a href=\"https://v3.cn.vuejs.org/guide/migration/introduction.html\">从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"生命周期变更\"><a href=\"#生命周期变更\" class=\"headerlink\" title=\"生命周期变更\"></a>生命周期变更</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选项式 API</th>\n<th align=\"center\">Hook inside setup</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">beforeCreate</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">created</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">beforeMount</td>\n<td align=\"center\">onBeforeMount</td>\n</tr>\n<tr>\n<td align=\"center\">mounted</td>\n<td align=\"center\">onMounted</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUpdate</td>\n<td align=\"center\">onBeforeUpdate</td>\n</tr>\n<tr>\n<td align=\"center\">updated</td>\n<td align=\"center\">onUpdated</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUnmount</td>\n<td align=\"center\">onBeforeUnmount</td>\n</tr>\n<tr>\n<td align=\"center\">unmounted</td>\n<td align=\"center\">onUnmounted</td>\n</tr>\n<tr>\n<td align=\"center\">errorCaptured</td>\n<td align=\"center\">onErrorCaptured</td>\n</tr>\n<tr>\n<td align=\"center\">renderTracked</td>\n<td align=\"center\">onRenderTracked</td>\n</tr>\n<tr>\n<td align=\"center\">renderTriggered</td>\n<td align=\"center\">onRenderTriggered</td>\n</tr>\n<tr>\n<td align=\"center\">activated</td>\n<td align=\"center\">onActivated</td>\n</tr>\n<tr>\n<td align=\"center\">deactivated</td>\n<td align=\"center\">onDeactivated</td>\n</tr>\n</tbody></table>\n<h3 id=\"vue3允许组件有多个根节点\"><a href=\"#vue3允许组件有多个根节点\" class=\"headerlink\" title=\"vue3允许组件有多个根节点\"></a>vue3允许组件有多个根节点</h3><h3 id=\"移除过滤器\"><a href=\"#移除过滤器\" class=\"headerlink\" title=\"移除过滤器\"></a>移除过滤器</h3><p>过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器</p>\n<h3 id=\"template应用挂载变更\"><a href=\"#template应用挂载变更\" class=\"headerlink\" title=\"template应用挂载变更\"></a>template应用挂载变更</h3><p>在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。<br>在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML</p>\n<h3 id=\"过渡的-class-名更改\"><a href=\"#过渡的-class-名更改\" class=\"headerlink\" title=\"过渡的 class 名更改\"></a>过渡的 class 名更改</h3><p>过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from</p>\n<h3 id=\"组件的相关-prop-名称变化\"><a href=\"#组件的相关-prop-名称变化\" class=\"headerlink\" title=\" 组件的相关 prop 名称变化\"></a><transition> 组件的相关 prop 名称变化</transition></h3><p>leave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)<br>enter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)</p>\n<h3 id=\"Transition-Group-根元素\"><a href=\"#Transition-Group-根元素\" class=\"headerlink\" title=\"Transition Group 根元素\"></a>Transition Group 根元素</h3><p><transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag=’span’ 即可</transition-group></p>\n<h3 id=\"移除v-on-native修饰符\"><a href=\"#移除v-on-native修饰符\" class=\"headerlink\" title=\"移除v-on.native修饰符\"></a>移除v-on.native修饰符</h3><p>v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。</p>\n<h3 id=\"v-if-与-v-for-的优先级变更\"><a href=\"#v-if-与-v-for-的优先级变更\" class=\"headerlink\" title=\"v-if 与 v-for 的优先级变更\"></a>v-if 与 v-for 的优先级变更</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用</td>\n<td align=\"left\">v-if 总是优先于 v-for 生效</td>\n</tr>\n</tbody></table>\n<h3 id=\"v-bind-合并行为\"><a href=\"#v-bind-合并行为\" class=\"headerlink\" title=\"v-bind 合并行为\"></a>v-bind 合并行为</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后）</td>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前）</td>\n</tr>\n</tbody></table>\n<h3 id=\"VNode-生命周期事件\"><a href=\"#VNode-生命周期事件\" class=\"headerlink\" title=\"VNode 生命周期事件\"></a>VNode 生命周期事件</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字</td>\n<td align=\"left\">以 vnode- 前缀开头，事件也可用于 HTML 元素</td>\n</tr>\n</tbody></table>\n<p>举例：vnode- 前缀：@vnode-updated=”onUpdated”；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=”onUpdated”；<br>生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。</p>\n<p><a href=\"https://v3.cn.vuejs.org/guide/migration/introduction.html\">从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)</a></p>\n"},{"title":"commonweal","date":"2022-08-09T05:51:41.000Z","_content":"\n### 找不到对应页面，请确认是否存在页面！！！","source":"commonweal/index.md","raw":"---\ntitle: commonweal\ndate: 2022-08-09 13:51:41\n---\n\n### 找不到对应页面，请确认是否存在页面！！！","updated":"2022-08-09T05:56:07.905Z","path":"commonweal/index.html","comments":1,"layout":"page","_id":"cl9nrr8pj0004k4tt9loq5pnv","content":"<h3 id=\"找不到对应页面，请确认是否存在页面！！！\"><a href=\"#找不到对应页面，请确认是否存在页面！！！\" class=\"headerlink\" title=\"找不到对应页面，请确认是否存在页面！！！\"></a>找不到对应页面，请确认是否存在页面！！！</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"找不到对应页面，请确认是否存在页面！！！\"><a href=\"#找不到对应页面，请确认是否存在页面！！！\" class=\"headerlink\" title=\"找不到对应页面，请确认是否存在页面！！！\"></a>找不到对应页面，请确认是否存在页面！！！</h3>"},{"title":"vue","date":"2022-01-07T09:11:56.000Z","_content":"## VUE 2\n\n### 本部分用于记录vue2相关的文章地址\n暂无\n\n## VUE 3\n\n### 本部分用于记录vue3相关的文章地址\n[2.x迁移到3.x变更点](/vue/change.html)\n[vue3.x生态环境](/vue/dependency.html)","source":"vue/index.md","raw":"---\ntitle: vue\ndate: 2022-01-07 17:11:56\n---\n## VUE 2\n\n### 本部分用于记录vue2相关的文章地址\n暂无\n\n## VUE 3\n\n### 本部分用于记录vue3相关的文章地址\n[2.x迁移到3.x变更点](/vue/change.html)\n[vue3.x生态环境](/vue/dependency.html)","updated":"2022-01-25T10:28:34.167Z","path":"vue/index.html","comments":1,"layout":"page","_id":"cl9nrr8pl0006k4tt8hgg5djp","content":"<h2 id=\"VUE-2\"><a href=\"#VUE-2\" class=\"headerlink\" title=\"VUE 2\"></a>VUE 2</h2><h3 id=\"本部分用于记录vue2相关的文章地址\"><a href=\"#本部分用于记录vue2相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue2相关的文章地址\"></a>本部分用于记录vue2相关的文章地址</h3><p>暂无</p>\n<h2 id=\"VUE-3\"><a href=\"#VUE-3\" class=\"headerlink\" title=\"VUE 3\"></a>VUE 3</h2><h3 id=\"本部分用于记录vue3相关的文章地址\"><a href=\"#本部分用于记录vue3相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue3相关的文章地址\"></a>本部分用于记录vue3相关的文章地址</h3><p><a href=\"/vue/change.html\">2.x迁移到3.x变更点</a><br><a href=\"/vue/dependency.html\">vue3.x生态环境</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"VUE-2\"><a href=\"#VUE-2\" class=\"headerlink\" title=\"VUE 2\"></a>VUE 2</h2><h3 id=\"本部分用于记录vue2相关的文章地址\"><a href=\"#本部分用于记录vue2相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue2相关的文章地址\"></a>本部分用于记录vue2相关的文章地址</h3><p>暂无</p>\n<h2 id=\"VUE-3\"><a href=\"#VUE-3\" class=\"headerlink\" title=\"VUE 3\"></a>VUE 3</h2><h3 id=\"本部分用于记录vue3相关的文章地址\"><a href=\"#本部分用于记录vue3相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue3相关的文章地址\"></a>本部分用于记录vue3相关的文章地址</h3><p><a href=\"/vue/change.html\">2.x迁移到3.x变更点</a><br><a href=\"/vue/dependency.html\">vue3.x生态环境</a></p>\n"},{"title":"3.x生态环境","date":"2022-01-25T09:02:52.000Z","_content":"#### [Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！](https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75)\n[基于 Vite 的极速构建工具链](https://vitejs.dev/)\n\n`<script setup>` 带来的开发体验更丝滑的组合式 API 语法\n\n[Volar 提供的单文件组件 TypeScript IDE 支持](https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar)\n\n[vue-tsc 提供的针对单文件组件的命令行类型检查和生成](https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc)\n\n[Pinia 提供的更简洁的状态管理](https://pinia.vuejs.org/) / [Vuex4](https://next.vuex.vuejs.org/)\n\n[新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板](https://devtools.vuejs.org/plugin/plugins-guide.html)\n\n[vuejs/core](https://github.com/vuejs/core)\n\n[Vue Router 4.0](https://next.router.vuejs.org/)\n[代码地址](https://github.com/vuejs/router)\n\n[vuejs/docs](https://github.com/vuejs/docs)\n\n[vuejs/test-utils](https://github.com/vuejs/test-utils)\n\n[vuejs/babel-plugin-jsx](https://github.com/vuejs/babel-plugin-jsx)\n\n[Element Plus(稳定版本预计于2022/02/07发布)](https://element-plus.gitee.io/zh-CN/)\n\n[Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)](https://next.antdv.com/)\n\n其他Vue UI框架：[Vuetify](https://vuetifyjs.com/zh-Hans/)、[Quasar](https://quasar.dev/)\n\n[全新的文档(目前只能预览)](https://staging.vuejs.org/)（[中文翻译中](https://staging-cn.vuejs.org/)）","source":"vue/dependency.md","raw":"---\ntitle: 3.x生态环境\ndate: 2022-01-25 17:02:52\n---\n#### [Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！](https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75)\n[基于 Vite 的极速构建工具链](https://vitejs.dev/)\n\n`<script setup>` 带来的开发体验更丝滑的组合式 API 语法\n\n[Volar 提供的单文件组件 TypeScript IDE 支持](https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar)\n\n[vue-tsc 提供的针对单文件组件的命令行类型检查和生成](https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc)\n\n[Pinia 提供的更简洁的状态管理](https://pinia.vuejs.org/) / [Vuex4](https://next.vuex.vuejs.org/)\n\n[新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板](https://devtools.vuejs.org/plugin/plugins-guide.html)\n\n[vuejs/core](https://github.com/vuejs/core)\n\n[Vue Router 4.0](https://next.router.vuejs.org/)\n[代码地址](https://github.com/vuejs/router)\n\n[vuejs/docs](https://github.com/vuejs/docs)\n\n[vuejs/test-utils](https://github.com/vuejs/test-utils)\n\n[vuejs/babel-plugin-jsx](https://github.com/vuejs/babel-plugin-jsx)\n\n[Element Plus(稳定版本预计于2022/02/07发布)](https://element-plus.gitee.io/zh-CN/)\n\n[Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)](https://next.antdv.com/)\n\n其他Vue UI框架：[Vuetify](https://vuetifyjs.com/zh-Hans/)、[Quasar](https://quasar.dev/)\n\n[全新的文档(目前只能预览)](https://staging.vuejs.org/)（[中文翻译中](https://staging-cn.vuejs.org/)）","updated":"2022-01-25T10:19:40.849Z","path":"vue/dependency.html","comments":1,"layout":"page","_id":"cl9nrr8pl0008k4tt1trzazgu","content":"<h4 id=\"Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\"><a href=\"#Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\" class=\"headerlink\" title=\"Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！\"></a><a href=\"https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75\">Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！</a></h4><p><a href=\"https://vitejs.dev/\">基于 Vite 的极速构建工具链</a></p>\n<p><code>&lt;script setup&gt;</code> 带来的开发体验更丝滑的组合式 API 语法</p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar\">Volar 提供的单文件组件 TypeScript IDE 支持</a></p>\n<p><a href=\"https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc\">vue-tsc 提供的针对单文件组件的命令行类型检查和生成</a></p>\n<p><a href=\"https://pinia.vuejs.org/\">Pinia 提供的更简洁的状态管理</a> / <a href=\"https://next.vuex.vuejs.org/\">Vuex4</a></p>\n<p><a href=\"https://devtools.vuejs.org/plugin/plugins-guide.html\">新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板</a></p>\n<p><a href=\"https://github.com/vuejs/core\">vuejs/core</a></p>\n<p><a href=\"https://next.router.vuejs.org/\">Vue Router 4.0</a><br><a href=\"https://github.com/vuejs/router\">代码地址</a></p>\n<p><a href=\"https://github.com/vuejs/docs\">vuejs/docs</a></p>\n<p><a href=\"https://github.com/vuejs/test-utils\">vuejs/test-utils</a></p>\n<p><a href=\"https://github.com/vuejs/babel-plugin-jsx\">vuejs/babel-plugin-jsx</a></p>\n<p><a href=\"https://element-plus.gitee.io/zh-CN/\">Element Plus(稳定版本预计于2022/02/07发布)</a></p>\n<p><a href=\"https://next.antdv.com/\">Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)</a></p>\n<p>其他Vue UI框架：<a href=\"https://vuetifyjs.com/zh-Hans/\">Vuetify</a>、<a href=\"https://quasar.dev/\">Quasar</a></p>\n<p><a href=\"https://staging.vuejs.org/\">全新的文档(目前只能预览)</a>（<a href=\"https://staging-cn.vuejs.org/\">中文翻译中</a>）</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\"><a href=\"#Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\" class=\"headerlink\" title=\"Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！\"></a><a href=\"https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75\">Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！</a></h4><p><a href=\"https://vitejs.dev/\">基于 Vite 的极速构建工具链</a></p>\n<p><code>&lt;script setup&gt;</code> 带来的开发体验更丝滑的组合式 API 语法</p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar\">Volar 提供的单文件组件 TypeScript IDE 支持</a></p>\n<p><a href=\"https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc\">vue-tsc 提供的针对单文件组件的命令行类型检查和生成</a></p>\n<p><a href=\"https://pinia.vuejs.org/\">Pinia 提供的更简洁的状态管理</a> / <a href=\"https://next.vuex.vuejs.org/\">Vuex4</a></p>\n<p><a href=\"https://devtools.vuejs.org/plugin/plugins-guide.html\">新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板</a></p>\n<p><a href=\"https://github.com/vuejs/core\">vuejs/core</a></p>\n<p><a href=\"https://next.router.vuejs.org/\">Vue Router 4.0</a><br><a href=\"https://github.com/vuejs/router\">代码地址</a></p>\n<p><a href=\"https://github.com/vuejs/docs\">vuejs/docs</a></p>\n<p><a href=\"https://github.com/vuejs/test-utils\">vuejs/test-utils</a></p>\n<p><a href=\"https://github.com/vuejs/babel-plugin-jsx\">vuejs/babel-plugin-jsx</a></p>\n<p><a href=\"https://element-plus.gitee.io/zh-CN/\">Element Plus(稳定版本预计于2022/02/07发布)</a></p>\n<p><a href=\"https://next.antdv.com/\">Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)</a></p>\n<p>其他Vue UI框架：<a href=\"https://vuetifyjs.com/zh-Hans/\">Vuetify</a>、<a href=\"https://quasar.dev/\">Quasar</a></p>\n<p><a href=\"https://staging.vuejs.org/\">全新的文档(目前只能预览)</a>（<a href=\"https://staging-cn.vuejs.org/\">中文翻译中</a>）</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### deploy产生如下错误的解决方法\n(1)使用hexo部署报错Error: Spawn failed\n解决办法：删除.deploy_git文件夹 -> 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -> 按顺序执行命令hexo clean、hexo generate、hexo deploy\n","source":"_posts/1-hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### deploy产生如下错误的解决方法\n(1)使用hexo部署报错Error: Spawn failed\n解决办法：删除.deploy_git文件夹 -> 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -> 按顺序执行命令hexo clean、hexo generate、hexo deploy\n","slug":"1-hello-world","published":1,"date":"2022-01-05T09:20:43.363Z","updated":"2022-06-23T01:58:33.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pf0001k4ttddaq8lrb","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"deploy产生如下错误的解决方法\"><a href=\"#deploy产生如下错误的解决方法\" class=\"headerlink\" title=\"deploy产生如下错误的解决方法\"></a>deploy产生如下错误的解决方法</h3><p>(1)使用hexo部署报错Error: Spawn failed<br>解决办法：删除.deploy_git文件夹 -&gt; 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -&gt; 按顺序执行命令hexo clean、hexo generate、hexo deploy</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"deploy产生如下错误的解决方法\"><a href=\"#deploy产生如下错误的解决方法\" class=\"headerlink\" title=\"deploy产生如下错误的解决方法\"></a>deploy产生如下错误的解决方法</h3><p>(1)使用hexo部署报错Error: Spawn failed<br>解决办法：删除.deploy_git文件夹 -&gt; 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -&gt; 按顺序执行命令hexo clean、hexo generate、hexo deploy</p>\n"},{"title":"github推送代码弹窗应该怎么输入？","date":"2022-06-30T02:45:15.000Z","_content":"\n#### github推送代码弹窗应该怎么输入?\n\n当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，\n鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。\n\n(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。\n```javascript\ngit push\n```\n---- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试\n```javascript\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': Failed to connect to github.com port 443: Timed out\n\n// --------\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': OpenSSL SSL_read: Connection was aborted, errno 10053\n```\n(2)第一个GitHub登录弹窗\n![github_login]()\n该弹窗中 **username为github的登录邮箱，password为GitHub的登录密码**\n---- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败\n```javascript\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n```\n(3)第二个登录弹窗\n![login_insert]\n该弹窗会出现两次，第一次输入username，第二次输入password，**username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章[github生成令牌](/2022/06/30/github生成令牌-Personal-access-tokens-操作步骤/))</font>**\n---- 注意：如果password输入错误，会导致无法提交\n```javascript\n$ git push\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\nfatal: Authentication failed for 'https://github.com/xxxxxxx.git/'\n```\n\n当username和password输入完成后，就可以正常push代码啦","source":"_posts/11-github-push-insert-password.md","raw":"---\ntitle: github推送代码弹窗应该怎么输入？\ndate: 2022-06-30 10:45:15\ntags:\n---\n\n#### github推送代码弹窗应该怎么输入?\n\n当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，\n鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。\n\n(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。\n```javascript\ngit push\n```\n---- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试\n```javascript\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': Failed to connect to github.com port 443: Timed out\n\n// --------\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': OpenSSL SSL_read: Connection was aborted, errno 10053\n```\n(2)第一个GitHub登录弹窗\n![github_login]()\n该弹窗中 **username为github的登录邮箱，password为GitHub的登录密码**\n---- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败\n```javascript\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n```\n(3)第二个登录弹窗\n![login_insert]\n该弹窗会出现两次，第一次输入username，第二次输入password，**username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章[github生成令牌](/2022/06/30/github生成令牌-Personal-access-tokens-操作步骤/))</font>**\n---- 注意：如果password输入错误，会导致无法提交\n```javascript\n$ git push\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\nfatal: Authentication failed for 'https://github.com/xxxxxxx.git/'\n```\n\n当username和password输入完成后，就可以正常push代码啦","slug":"11-github-push-insert-password","published":1,"updated":"2022-06-30T05:22:12.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pi0003k4ttblmq24s8","content":"<h4 id=\"github推送代码弹窗应该怎么输入\"><a href=\"#github推送代码弹窗应该怎么输入\" class=\"headerlink\" title=\"github推送代码弹窗应该怎么输入?\"></a>github推送代码弹窗应该怎么输入?</h4><p>当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，<br>鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。</p>\n<p>(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>—- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: Failed to connect to github.com port <span class=\"number\">443</span>: Timed out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --------</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: OpenSSL SSL_read: Connection was aborted, errno <span class=\"number\">10053</span></span><br></pre></td></tr></table></figure>\n<p>(2)第一个GitHub登录弹窗<br><img src alt=\"github_login\"><br>该弹窗中 <strong>username为github的登录邮箱，password为GitHub的登录密码</strong><br>—- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br></pre></td></tr></table></figure>\n<p>(3)第二个登录弹窗<br>![login_insert]<br>该弹窗会出现两次，第一次输入username，第二次输入password，<strong>username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章<a href=\"/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/\">github生成令牌</a>)</font></strong><br>—- 注意：如果password输入错误，会导致无法提交</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Please see https:<span class=\"comment\">//github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span></span><br><span class=\"line\">fatal: Authentication failed <span class=\"keyword\">for</span> <span class=\"string\">&#x27;https://github.com/xxxxxxx.git/&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>当username和password输入完成后，就可以正常push代码啦</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"github推送代码弹窗应该怎么输入\"><a href=\"#github推送代码弹窗应该怎么输入\" class=\"headerlink\" title=\"github推送代码弹窗应该怎么输入?\"></a>github推送代码弹窗应该怎么输入?</h4><p>当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，<br>鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。</p>\n<p>(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>—- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: Failed to connect to github.com port <span class=\"number\">443</span>: Timed out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --------</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: OpenSSL SSL_read: Connection was aborted, errno <span class=\"number\">10053</span></span><br></pre></td></tr></table></figure>\n<p>(2)第一个GitHub登录弹窗<br><img src alt=\"github_login\"><br>该弹窗中 <strong>username为github的登录邮箱，password为GitHub的登录密码</strong><br>—- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br></pre></td></tr></table></figure>\n<p>(3)第二个登录弹窗<br>![login_insert]<br>该弹窗会出现两次，第一次输入username，第二次输入password，<strong>username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章<a href=\"/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/\">github生成令牌</a>)</font></strong><br>—- 注意：如果password输入错误，会导致无法提交</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Please see https:<span class=\"comment\">//github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span></span><br><span class=\"line\">fatal: Authentication failed <span class=\"keyword\">for</span> <span class=\"string\">&#x27;https://github.com/xxxxxxx.git/&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>当username和password输入完成后，就可以正常push代码啦</p>\n"},{"title":"meta标签的使用","date":"2022-06-28T14:16:30.000Z","_content":"\n#### meta标签的使用\n\n###### <meta>文档级元数据元素\nmeta标签一般放在HTML页面的head里面，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta)定义：\n>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(\\<base\\>,\\<link\\>,\\<script\\>,\\<style\\> 或 \\<title\\>）之一表示的任何元数据信息。\n\n###### meta定义的元数据类型\n(1)name属性：meta元素提供文档级别元数据，应用于整个页面\n-- name和content一起使用，name表示元数据名称，content表示元数据的值\n---- name=\"author\"，表示网页作者的名字，例如某个组织或机构\n```\n<mate name=\"author\" content=\"xxx@mail.com\">\n```\n\n---- name=\"description\"，是一段简短而精确的，对页面内容的描述\n```javascript\n//淘宝网页的meta\n<meta name=\"description\" content=\"淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！\">\n```\n\n---- name=\"keywords\"，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类\n```javascript\n//淘宝网页的meta\n<meta name=\"keyword\" content=\"淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺\">\n```\n\n---- name=\"viewport\"，为viewport（视口）的初始大小提供指示，目前仅用于移动设备\n```javascript\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\nwidth：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？\ninitial-scale：为设备宽度与viewport大小之间的缩放比例\nmaximum-scale：？？？？\nminimum-scale：？？？？\nuser-scalable：？？？？\nminimal-ui：？？？？\n\n---- name=\"robots\"，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的\ncontent类型：\nall：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索\nnone：搜索引擎将忽略此网页\nindex：搜索引擎索引此网页\nfollow：搜索引擎继续通过此网页的链接索引搜索其它的网页\n\n---- name=\"renderer\"，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式\n```javascript\n<meta name=\"renderer\" content=\"webkit\"> //默认webkit内核\n<meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式\n<meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式\n```\ncontent类型：\n？？？？\n\n---- name=\"spm-id\"，？？？？\n```javascript\n// 淘宝\n<meta name=\"spm-id\" content=\"a21bo\">\n```\n---- name=\"aplus-xplug\"，？？？？\n```javascript\n// 淘宝网\n<meta name=\"aplus-xplug\" content=\"NONE\">\n```\n\n\n(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同\n-- http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值\n-- http-equiv所有允许的值都是特定http头部的名称\n---- http-equiv=\"X-UA-Compatible\"\n```javascript\n// 淘宝网\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=10,chrome=1\">//IE浏览器适配\n```\nIE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。\nchrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。\n两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。\n另外，这个属性支持的范围是IE8-IE11\n如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。\n\n---- http-equiv=\"content-type\"，用来声明文档类型和字符集\n```javascript\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n```\n\n---- http-equiv=\"x-dns-prefetch-control\"\n一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：\n```javascript\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n```\n\n---- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？\n\n(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码\n(4)itemprop属性：meta元素提供用户定义的元数据","source":"_posts/10-about-meta.md","raw":"---\ntitle: meta标签的使用\ndate: 2022-06-28 22:16:30\ntags:\n---\n\n#### meta标签的使用\n\n###### <meta>文档级元数据元素\nmeta标签一般放在HTML页面的head里面，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta)定义：\n>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(\\<base\\>,\\<link\\>,\\<script\\>,\\<style\\> 或 \\<title\\>）之一表示的任何元数据信息。\n\n###### meta定义的元数据类型\n(1)name属性：meta元素提供文档级别元数据，应用于整个页面\n-- name和content一起使用，name表示元数据名称，content表示元数据的值\n---- name=\"author\"，表示网页作者的名字，例如某个组织或机构\n```\n<mate name=\"author\" content=\"xxx@mail.com\">\n```\n\n---- name=\"description\"，是一段简短而精确的，对页面内容的描述\n```javascript\n//淘宝网页的meta\n<meta name=\"description\" content=\"淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！\">\n```\n\n---- name=\"keywords\"，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类\n```javascript\n//淘宝网页的meta\n<meta name=\"keyword\" content=\"淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺\">\n```\n\n---- name=\"viewport\"，为viewport（视口）的初始大小提供指示，目前仅用于移动设备\n```javascript\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\nwidth：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？\ninitial-scale：为设备宽度与viewport大小之间的缩放比例\nmaximum-scale：？？？？\nminimum-scale：？？？？\nuser-scalable：？？？？\nminimal-ui：？？？？\n\n---- name=\"robots\"，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的\ncontent类型：\nall：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索\nnone：搜索引擎将忽略此网页\nindex：搜索引擎索引此网页\nfollow：搜索引擎继续通过此网页的链接索引搜索其它的网页\n\n---- name=\"renderer\"，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式\n```javascript\n<meta name=\"renderer\" content=\"webkit\"> //默认webkit内核\n<meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式\n<meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式\n```\ncontent类型：\n？？？？\n\n---- name=\"spm-id\"，？？？？\n```javascript\n// 淘宝\n<meta name=\"spm-id\" content=\"a21bo\">\n```\n---- name=\"aplus-xplug\"，？？？？\n```javascript\n// 淘宝网\n<meta name=\"aplus-xplug\" content=\"NONE\">\n```\n\n\n(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同\n-- http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值\n-- http-equiv所有允许的值都是特定http头部的名称\n---- http-equiv=\"X-UA-Compatible\"\n```javascript\n// 淘宝网\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=10,chrome=1\">//IE浏览器适配\n```\nIE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。\nchrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。\n两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。\n另外，这个属性支持的范围是IE8-IE11\n如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。\n\n---- http-equiv=\"content-type\"，用来声明文档类型和字符集\n```javascript\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n```\n\n---- http-equiv=\"x-dns-prefetch-control\"\n一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：\n```javascript\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n```\n\n---- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？\n\n(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码\n(4)itemprop属性：meta元素提供用户定义的元数据","slug":"10-about-meta","published":1,"updated":"2022-07-21T07:48:28.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pk0005k4ttda5048re","content":"<h4 id=\"meta标签的使用\"><a href=\"#meta标签的使用\" class=\"headerlink\" title=\"meta标签的使用\"></a>meta标签的使用</h4><h6 id=\"文档级元数据元素\"><a href=\"#文档级元数据元素\" class=\"headerlink\" title=\"文档级元数据元素\"></a><meta>文档级元数据元素</h6><p>meta标签一般放在HTML页面的head里面，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta\">MDN</a>定义：</p>\n<blockquote>\n<p>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。</p>\n</blockquote>\n<h6 id=\"meta定义的元数据类型\"><a href=\"#meta定义的元数据类型\" class=\"headerlink\" title=\"meta定义的元数据类型\"></a>meta定义的元数据类型</h6><p>(1)name属性：meta元素提供文档级别元数据，应用于整个页面<br>– name和content一起使用，name表示元数据名称，content表示元数据的值<br>—- name=”author”，表示网页作者的名字，例如某个组织或机构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mate name=&quot;author&quot; content=&quot;xxx@mail.com&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”description”，是一段简短而精确的，对页面内容的描述</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;description&quot;</span> content=<span class=\"string\">&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”keywords”，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;keyword&quot;</span> content=<span class=\"string\">&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”viewport”，为viewport（视口）的初始大小提供指示，目前仅用于移动设备</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;viewport&quot;</span> content=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>width：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？<br>initial-scale：为设备宽度与viewport大小之间的缩放比例<br>maximum-scale：？？？？<br>minimum-scale：？？？？<br>user-scalable：？？？？<br>minimal-ui：？？？？</p>\n<p>—- name=”robots”，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的<br>content类型：<br>all：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索<br>none：搜索引擎将忽略此网页<br>index：搜索引擎索引此网页<br>follow：搜索引擎继续通过此网页的链接索引搜索其它的网页</p>\n<p>—- name=”renderer”，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;renderer&quot;</span> content=<span class=\"string\">&quot;webkit&quot;</span>&gt; <span class=\"comment\">//默认webkit内核</span></span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式</span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式</span><br></pre></td></tr></table></figure>\n<p>content类型：<br>？？？？</p>\n<p>—- name=”spm-id”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;spm-id&quot;</span> content=<span class=\"string\">&quot;a21bo&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>—- name=”aplus-xplug”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;aplus-xplug&quot;</span> content=<span class=\"string\">&quot;NONE&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同<br>– http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值<br>– http-equiv所有允许的值都是特定http头部的名称<br>—- http-equiv=”X-UA-Compatible”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> content=<span class=\"string\">&quot;IE=10,chrome=1&quot;</span>&gt;<span class=\"comment\">//IE浏览器适配</span></span><br></pre></td></tr></table></figure>\n<p>IE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。<br>chrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。<br>两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。<br>另外，这个属性支持的范围是IE8-IE11<br>如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。</p>\n<p>—- http-equiv=”content-type”，用来声明文档类型和字符集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;content-type&quot;</span> content=<span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- http-equiv=”x-dns-prefetch-control”<br>一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;x-dns-prefetch-control&quot;</span> content=<span class=\"string\">&quot;on&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？</p>\n<p>(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码<br>(4)itemprop属性：meta元素提供用户定义的元数据</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"meta标签的使用\"><a href=\"#meta标签的使用\" class=\"headerlink\" title=\"meta标签的使用\"></a>meta标签的使用</h4><h6 id=\"文档级元数据元素\"><a href=\"#文档级元数据元素\" class=\"headerlink\" title=\"文档级元数据元素\"></a><meta>文档级元数据元素</h6><p>meta标签一般放在HTML页面的head里面，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta\">MDN</a>定义：</p>\n<blockquote>\n<p>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。</p>\n</blockquote>\n<h6 id=\"meta定义的元数据类型\"><a href=\"#meta定义的元数据类型\" class=\"headerlink\" title=\"meta定义的元数据类型\"></a>meta定义的元数据类型</h6><p>(1)name属性：meta元素提供文档级别元数据，应用于整个页面<br>– name和content一起使用，name表示元数据名称，content表示元数据的值<br>—- name=”author”，表示网页作者的名字，例如某个组织或机构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mate name=&quot;author&quot; content=&quot;xxx@mail.com&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”description”，是一段简短而精确的，对页面内容的描述</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;description&quot;</span> content=<span class=\"string\">&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”keywords”，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;keyword&quot;</span> content=<span class=\"string\">&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”viewport”，为viewport（视口）的初始大小提供指示，目前仅用于移动设备</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;viewport&quot;</span> content=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>width：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？<br>initial-scale：为设备宽度与viewport大小之间的缩放比例<br>maximum-scale：？？？？<br>minimum-scale：？？？？<br>user-scalable：？？？？<br>minimal-ui：？？？？</p>\n<p>—- name=”robots”，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的<br>content类型：<br>all：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索<br>none：搜索引擎将忽略此网页<br>index：搜索引擎索引此网页<br>follow：搜索引擎继续通过此网页的链接索引搜索其它的网页</p>\n<p>—- name=”renderer”，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;renderer&quot;</span> content=<span class=\"string\">&quot;webkit&quot;</span>&gt; <span class=\"comment\">//默认webkit内核</span></span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式</span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式</span><br></pre></td></tr></table></figure>\n<p>content类型：<br>？？？？</p>\n<p>—- name=”spm-id”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;spm-id&quot;</span> content=<span class=\"string\">&quot;a21bo&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>—- name=”aplus-xplug”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;aplus-xplug&quot;</span> content=<span class=\"string\">&quot;NONE&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同<br>– http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值<br>– http-equiv所有允许的值都是特定http头部的名称<br>—- http-equiv=”X-UA-Compatible”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> content=<span class=\"string\">&quot;IE=10,chrome=1&quot;</span>&gt;<span class=\"comment\">//IE浏览器适配</span></span><br></pre></td></tr></table></figure>\n<p>IE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。<br>chrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。<br>两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。<br>另外，这个属性支持的范围是IE8-IE11<br>如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。</p>\n<p>—- http-equiv=”content-type”，用来声明文档类型和字符集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;content-type&quot;</span> content=<span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- http-equiv=”x-dns-prefetch-control”<br>一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;x-dns-prefetch-control&quot;</span> content=<span class=\"string\">&quot;on&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？</p>\n<p>(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码<br>(4)itemprop属性：meta元素提供用户定义的元数据</p>\n"},{"title":"前端概念相关-渐进增强与优雅降级","date":"2022-07-12T02:37:56.000Z","_content":"\n#### 渐进增强(Progressive Enhancement)(相当于向上兼容)\n一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验\n\n#### 优雅降级(Graceful Degradation)(相当于向下兼容)\n一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览\n\n向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少\n大多数软件都是向下兼容的\n\n#### 渐进增强与优雅降级的区别\n优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度\n关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程\n\n优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n渐进增强观点则认为应关注于内容本身。\n```javascript\n.transition { /*渐进增强写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*优雅降级写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n```\n前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：\n\n1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；\n2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；\n3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；\n4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.\n\n渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。\n","source":"_posts/14-about-fe-theory.md","raw":"---\ntitle: 前端概念相关-渐进增强与优雅降级\ndate: 2022-07-12 10:37:56\ntags:\n---\n\n#### 渐进增强(Progressive Enhancement)(相当于向上兼容)\n一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验\n\n#### 优雅降级(Graceful Degradation)(相当于向下兼容)\n一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览\n\n向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少\n大多数软件都是向下兼容的\n\n#### 渐进增强与优雅降级的区别\n优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度\n关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程\n\n优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n渐进增强观点则认为应关注于内容本身。\n```javascript\n.transition { /*渐进增强写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*优雅降级写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n```\n前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：\n\n1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；\n2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；\n3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；\n4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.\n\n渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。\n","slug":"14-about-fe-theory","published":1,"updated":"2022-07-18T05:47:25.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pl0007k4ttcxpngz4o","content":"<h4 id=\"渐进增强-Progressive-Enhancement-相当于向上兼容\"><a href=\"#渐进增强-Progressive-Enhancement-相当于向上兼容\" class=\"headerlink\" title=\"渐进增强(Progressive Enhancement)(相当于向上兼容)\"></a>渐进增强(Progressive Enhancement)(相当于向上兼容)</h4><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验</p>\n<h4 id=\"优雅降级-Graceful-Degradation-相当于向下兼容\"><a href=\"#优雅降级-Graceful-Degradation-相当于向下兼容\" class=\"headerlink\" title=\"优雅降级(Graceful Degradation)(相当于向下兼容)\"></a>优雅降级(Graceful Degradation)(相当于向下兼容)</h4><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览</p>\n<p>向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少<br>大多数软件都是向下兼容的</p>\n<h4 id=\"渐进增强与优雅降级的区别\"><a href=\"#渐进增强与优雅降级的区别\" class=\"headerlink\" title=\"渐进增强与优雅降级的区别\"></a>渐进增强与优雅降级的区别</h4><p>优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度<br>关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程</p>\n<p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>渐进增强观点则认为应关注于内容本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition &#123; <span class=\"comment\">/*渐进增强写法*/</span></span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">          transition: all .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.transition &#123; <span class=\"comment\">/*优雅降级写法*/</span></span><br><span class=\"line\">          <span class=\"attr\">transition</span>: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：</p>\n<p>1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；<br>2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；<br>3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；<br>4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>\n<p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"渐进增强-Progressive-Enhancement-相当于向上兼容\"><a href=\"#渐进增强-Progressive-Enhancement-相当于向上兼容\" class=\"headerlink\" title=\"渐进增强(Progressive Enhancement)(相当于向上兼容)\"></a>渐进增强(Progressive Enhancement)(相当于向上兼容)</h4><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验</p>\n<h4 id=\"优雅降级-Graceful-Degradation-相当于向下兼容\"><a href=\"#优雅降级-Graceful-Degradation-相当于向下兼容\" class=\"headerlink\" title=\"优雅降级(Graceful Degradation)(相当于向下兼容)\"></a>优雅降级(Graceful Degradation)(相当于向下兼容)</h4><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览</p>\n<p>向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少<br>大多数软件都是向下兼容的</p>\n<h4 id=\"渐进增强与优雅降级的区别\"><a href=\"#渐进增强与优雅降级的区别\" class=\"headerlink\" title=\"渐进增强与优雅降级的区别\"></a>渐进增强与优雅降级的区别</h4><p>优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度<br>关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程</p>\n<p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>渐进增强观点则认为应关注于内容本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition &#123; <span class=\"comment\">/*渐进增强写法*/</span></span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">          transition: all .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.transition &#123; <span class=\"comment\">/*优雅降级写法*/</span></span><br><span class=\"line\">          <span class=\"attr\">transition</span>: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：</p>\n<p>1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；<br>2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；<br>3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；<br>4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>\n<p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</p>\n"},{"title":"各类文档地址","date":"2022-07-05T08:17:32.000Z","_content":"\n#### code spell checker配置项说明\n[文档地址](https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker)\n\n#### 查看chrome各个版本功能变更\n[chrome status](https://chromestatus.com/features)\n\n#### 查看== 、=== 、if()在不同情况下的执行结果\n[地址](https://dorey.github.io/JavaScript-Equality-Table/)\n\n#### css层叠样式表\n[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)\n\n#### Recoil\n[官方文档](https://recoiljs.org/)\n\n#### React\n[官方文档](https://reactjs.org/)\n\n#### vue\n[官方文档](https://vuejs.org/)\n\n#### VueUse--vue使用的hooks库\n[官方文档](https://vueuse.org/)\n\n#### HTML\n[官方文档](https://html.spec.whatwg.org/)\n\n#### testing-library/react\n[官方文档](https://testing-library.com/)\n\n#### nodejs\n[官方文档-英文版](https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html)\n[中文文档](https://www.nodeapp.cn/assert.html)\n\n#### ahooks\n[官方文档](https://ahooks.js.org/)","source":"_posts/13-document-location.md","raw":"---\ntitle: 各类文档地址\ndate: 2022-07-05 16:17:32\ntags:\n---\n\n#### code spell checker配置项说明\n[文档地址](https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker)\n\n#### 查看chrome各个版本功能变更\n[chrome status](https://chromestatus.com/features)\n\n#### 查看== 、=== 、if()在不同情况下的执行结果\n[地址](https://dorey.github.io/JavaScript-Equality-Table/)\n\n#### css层叠样式表\n[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)\n\n#### Recoil\n[官方文档](https://recoiljs.org/)\n\n#### React\n[官方文档](https://reactjs.org/)\n\n#### vue\n[官方文档](https://vuejs.org/)\n\n#### VueUse--vue使用的hooks库\n[官方文档](https://vueuse.org/)\n\n#### HTML\n[官方文档](https://html.spec.whatwg.org/)\n\n#### testing-library/react\n[官方文档](https://testing-library.com/)\n\n#### nodejs\n[官方文档-英文版](https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html)\n[中文文档](https://www.nodeapp.cn/assert.html)\n\n#### ahooks\n[官方文档](https://ahooks.js.org/)","slug":"13-document-location","published":1,"updated":"2022-10-25T07:04:14.558Z","_id":"cl9nrr8pm0009k4ttci2shyvw","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"code-spell-checker配置项说明\"><a href=\"#code-spell-checker配置项说明\" class=\"headerlink\" title=\"code spell checker配置项说明\"></a>code spell checker配置项说明</h4><p><a href=\"https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker\">文档地址</a></p>\n<h4 id=\"查看chrome各个版本功能变更\"><a href=\"#查看chrome各个版本功能变更\" class=\"headerlink\" title=\"查看chrome各个版本功能变更\"></a>查看chrome各个版本功能变更</h4><p><a href=\"https://chromestatus.com/features\">chrome status</a></p>\n<h4 id=\"查看-、-、if-在不同情况下的执行结果\"><a href=\"#查看-、-、if-在不同情况下的执行结果\" class=\"headerlink\" title=\"查看== 、=== 、if()在不同情况下的执行结果\"></a>查看== 、=== 、if()在不同情况下的执行结果</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">地址</a></p>\n<h4 id=\"css层叠样式表\"><a href=\"#css层叠样式表\" class=\"headerlink\" title=\"css层叠样式表\"></a>css层叠样式表</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade\">官方文档</a></p>\n<h4 id=\"Recoil\"><a href=\"#Recoil\" class=\"headerlink\" title=\"Recoil\"></a>Recoil</h4><p><a href=\"https://recoiljs.org/\">官方文档</a></p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p><a href=\"https://reactjs.org/\">官方文档</a></p>\n<h4 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h4><p><a href=\"https://vuejs.org/\">官方文档</a></p>\n<h4 id=\"VueUse–vue使用的hooks库\"><a href=\"#VueUse–vue使用的hooks库\" class=\"headerlink\" title=\"VueUse–vue使用的hooks库\"></a>VueUse–vue使用的hooks库</h4><p><a href=\"https://vueuse.org/\">官方文档</a></p>\n<h4 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h4><p><a href=\"https://html.spec.whatwg.org/\">官方文档</a></p>\n<h4 id=\"testing-library-react\"><a href=\"#testing-library-react\" class=\"headerlink\" title=\"testing-library/react\"></a>testing-library/react</h4><p><a href=\"https://testing-library.com/\">官方文档</a></p>\n<h4 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h4><p><a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html\">官方文档-英文版</a><br><a href=\"https://www.nodeapp.cn/assert.html\">中文文档</a></p>\n<h4 id=\"ahooks\"><a href=\"#ahooks\" class=\"headerlink\" title=\"ahooks\"></a>ahooks</h4><p><a href=\"https://ahooks.js.org/\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"code-spell-checker配置项说明\"><a href=\"#code-spell-checker配置项说明\" class=\"headerlink\" title=\"code spell checker配置项说明\"></a>code spell checker配置项说明</h4><p><a href=\"https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker\">文档地址</a></p>\n<h4 id=\"查看chrome各个版本功能变更\"><a href=\"#查看chrome各个版本功能变更\" class=\"headerlink\" title=\"查看chrome各个版本功能变更\"></a>查看chrome各个版本功能变更</h4><p><a href=\"https://chromestatus.com/features\">chrome status</a></p>\n<h4 id=\"查看-、-、if-在不同情况下的执行结果\"><a href=\"#查看-、-、if-在不同情况下的执行结果\" class=\"headerlink\" title=\"查看== 、=== 、if()在不同情况下的执行结果\"></a>查看== 、=== 、if()在不同情况下的执行结果</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">地址</a></p>\n<h4 id=\"css层叠样式表\"><a href=\"#css层叠样式表\" class=\"headerlink\" title=\"css层叠样式表\"></a>css层叠样式表</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade\">官方文档</a></p>\n<h4 id=\"Recoil\"><a href=\"#Recoil\" class=\"headerlink\" title=\"Recoil\"></a>Recoil</h4><p><a href=\"https://recoiljs.org/\">官方文档</a></p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p><a href=\"https://reactjs.org/\">官方文档</a></p>\n<h4 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h4><p><a href=\"https://vuejs.org/\">官方文档</a></p>\n<h4 id=\"VueUse–vue使用的hooks库\"><a href=\"#VueUse–vue使用的hooks库\" class=\"headerlink\" title=\"VueUse–vue使用的hooks库\"></a>VueUse–vue使用的hooks库</h4><p><a href=\"https://vueuse.org/\">官方文档</a></p>\n<h4 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h4><p><a href=\"https://html.spec.whatwg.org/\">官方文档</a></p>\n<h4 id=\"testing-library-react\"><a href=\"#testing-library-react\" class=\"headerlink\" title=\"testing-library/react\"></a>testing-library/react</h4><p><a href=\"https://testing-library.com/\">官方文档</a></p>\n<h4 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h4><p><a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html\">官方文档-英文版</a><br><a href=\"https://www.nodeapp.cn/assert.html\">中文文档</a></p>\n<h4 id=\"ahooks\"><a href=\"#ahooks\" class=\"headerlink\" title=\"ahooks\"></a>ahooks</h4><p><a href=\"https://ahooks.js.org/\">官方文档</a></p>\n"},{"title":"github生成令牌(Personal_access_tokens)操作步骤","date":"2022-06-30T03:23:56.000Z","_content":"\n#### github生成令牌\n(1)登录[GitHub网站](https://github.com/)\n(2)找到setting页面 -> Developer setting\n(3)选择 Personal access tokens ，点击 Generate new token 按钮\n(4)需要填写token的权限范围\n(5)**<font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font>**","source":"_posts/12-create-github-tokens.md","raw":"---\ntitle: github生成令牌(Personal_access_tokens)操作步骤\ndate: 2022-06-30 11:23:56\ntags:\n---\n\n#### github生成令牌\n(1)登录[GitHub网站](https://github.com/)\n(2)找到setting页面 -> Developer setting\n(3)选择 Personal access tokens ，点击 Generate new token 按钮\n(4)需要填写token的权限范围\n(5)**<font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font>**","slug":"12-create-github-tokens","published":1,"updated":"2022-06-30T05:18:19.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pm000ak4tt4pph1vov","content":"<h4 id=\"github生成令牌\"><a href=\"#github生成令牌\" class=\"headerlink\" title=\"github生成令牌\"></a>github生成令牌</h4><p>(1)登录<a href=\"https://github.com/\">GitHub网站</a><br>(2)找到setting页面 -&gt; Developer setting<br>(3)选择 Personal access tokens ，点击 Generate new token 按钮<br>(4)需要填写token的权限范围<br>(5)<strong><font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"github生成令牌\"><a href=\"#github生成令牌\" class=\"headerlink\" title=\"github生成令牌\"></a>github生成令牌</h4><p>(1)登录<a href=\"https://github.com/\">GitHub网站</a><br>(2)找到setting页面 -&gt; Developer setting<br>(3)选择 Personal access tokens ，点击 Generate new token 按钮<br>(4)需要填写token的权限范围<br>(5)<strong><font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font></strong></p>\n"},{"title":"js-类型转换","date":"2022-07-19T07:59:15.000Z","_content":"\n在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。\n== ：比较两个数据是否相等，允许进行类型转化\n比如：1==true、'1'==true，结果都是true\n===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false\n比如：1===true、'1'===true，结果为false\n\n#### 数学运算符中的类型转换\n\n1、减、乘、除运算\n**非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型**\n```javascript\n1 - true // 0, true先转换乘1，然后执行 1 - 1\n1 - false // 1, true先转换乘0，然后执行 1 - 0\n1 - null // 1, true先转换乘0，然后执行 1 - 0\n1 - undefined // NaN, undefined转换为数字为 NaN\n2 * ['5'] // 10, ['5']先变成'5'（这一步涉及拆箱操作）,然后变成数字5\n```\n{% btn /2022/08/09/devan-operation/, 拆箱操作, %}\n\n2、加运算\n**js中的加法运算，还可以用来拼接字符串**\n* 加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型\n* 加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型\n* 加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接\n**以上三点，优先级从高到低**\n\n```javascript\n123 + '123' // '123123' (规则1)\n123 + null //  123 (规则2)\n123 + true //  124 (规则2)\n123 + {}   //  '123[object Object]' (规则3)\n```\n\n#### 逻辑运算中的类型转换\n1、单个变量\n先将变量转换为Boolean值\n**只有null、undefined、''、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]**\n\n2、使用 == 比较中的5条规则\n**建议使用 ===**\n* 规则1：NaN和其他任何类型比较永远返回false(包括和他自己)\n```javascript\nNaN == NaN // false\n```\n* 规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型\n```javascript\ntrue == 1 // true\ntrue == '2' // false,先将true转换为1，而不是把'2'变成true\ntrue == ['1'] // true, 先将true转换为1，['1']拆箱成'1',在参考规则3\ntrue == ['2'] // false, 同上\nundefined == false // false, 首先false变成0，然后参考规则4\nnull == false // false, 同上\n```\n* String和Number比较，先将String转换为Number类型\n```javascript\n123 == '123' // true, '123'会变成123\n'' == 0 // true，''会变成 0\n```\n* null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false\n```javascript\nnull == undefined  // true\nnull == '' // false\nnull == 0 // false\nnull == false // false\nundefined == '' // false\nundefined == 0 // false\nundefined == false // false\n```\n* 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型\n**ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError**\n```javascript\n'[object Object]' == {} // true, 对象和字符串比较，对象通过toString 得到一个基本类型值\n'1,2,3' == [1,2,3] // true, [1,2,3]通过toString得到一个基本类型\n```\n\n#### 类型转换表\n![类型转换对照表](convert-table.png)\n\n#### 类型转换对照网站\nhttps://dorey.github.io/JavaScript-Equality-Table/\n\n{% btn /,, home %}","source":"_posts/15-js-transform.md","raw":"---\ntitle: js-类型转换\ndate: 2022-07-19 15:59:15\ntags:\n---\n\n在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。\n== ：比较两个数据是否相等，允许进行类型转化\n比如：1==true、'1'==true，结果都是true\n===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false\n比如：1===true、'1'===true，结果为false\n\n#### 数学运算符中的类型转换\n\n1、减、乘、除运算\n**非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型**\n```javascript\n1 - true // 0, true先转换乘1，然后执行 1 - 1\n1 - false // 1, true先转换乘0，然后执行 1 - 0\n1 - null // 1, true先转换乘0，然后执行 1 - 0\n1 - undefined // NaN, undefined转换为数字为 NaN\n2 * ['5'] // 10, ['5']先变成'5'（这一步涉及拆箱操作）,然后变成数字5\n```\n{% btn /2022/08/09/devan-operation/, 拆箱操作, %}\n\n2、加运算\n**js中的加法运算，还可以用来拼接字符串**\n* 加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型\n* 加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型\n* 加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接\n**以上三点，优先级从高到低**\n\n```javascript\n123 + '123' // '123123' (规则1)\n123 + null //  123 (规则2)\n123 + true //  124 (规则2)\n123 + {}   //  '123[object Object]' (规则3)\n```\n\n#### 逻辑运算中的类型转换\n1、单个变量\n先将变量转换为Boolean值\n**只有null、undefined、''、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]**\n\n2、使用 == 比较中的5条规则\n**建议使用 ===**\n* 规则1：NaN和其他任何类型比较永远返回false(包括和他自己)\n```javascript\nNaN == NaN // false\n```\n* 规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型\n```javascript\ntrue == 1 // true\ntrue == '2' // false,先将true转换为1，而不是把'2'变成true\ntrue == ['1'] // true, 先将true转换为1，['1']拆箱成'1',在参考规则3\ntrue == ['2'] // false, 同上\nundefined == false // false, 首先false变成0，然后参考规则4\nnull == false // false, 同上\n```\n* String和Number比较，先将String转换为Number类型\n```javascript\n123 == '123' // true, '123'会变成123\n'' == 0 // true，''会变成 0\n```\n* null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false\n```javascript\nnull == undefined  // true\nnull == '' // false\nnull == 0 // false\nnull == false // false\nundefined == '' // false\nundefined == 0 // false\nundefined == false // false\n```\n* 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型\n**ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError**\n```javascript\n'[object Object]' == {} // true, 对象和字符串比较，对象通过toString 得到一个基本类型值\n'1,2,3' == [1,2,3] // true, [1,2,3]通过toString得到一个基本类型\n```\n\n#### 类型转换表\n![类型转换对照表](convert-table.png)\n\n#### 类型转换对照网站\nhttps://dorey.github.io/JavaScript-Equality-Table/\n\n{% btn /,, home %}","slug":"15-js-transform","published":1,"updated":"2022-08-10T03:11:17.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8po000bk4ttftbz2nyu","content":"<p>在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。<br>== ：比较两个数据是否相等，允许进行类型转化<br>比如：1==true、’1’==true，结果都是true<br>===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false<br>比如：1===true、’1’===true，结果为false</p>\n<h4 id=\"数学运算符中的类型转换\"><a href=\"#数学运算符中的类型转换\" class=\"headerlink\" title=\"数学运算符中的类型转换\"></a>数学运算符中的类型转换</h4><p>1、减、乘、除运算<br><strong>非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">true</span> <span class=\"comment\">// 0, true先转换乘1，然后执行 1 - 1</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">false</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">null</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN, undefined转换为数字为 NaN</span></span><br><span class=\"line\"><span class=\"number\">2</span> * [<span class=\"string\">&#x27;5&#x27;</span>] <span class=\"comment\">// 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5</span></span><br></pre></td></tr></table></figure>\n<a class=\"btn\" href=\"/2022/08/09/devan-operation/\">拆箱操作</a>\n\n<p>2、加运算<br><strong>js中的加法运算，还可以用来拼接字符串</strong></p>\n<ul>\n<li>加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型</li>\n<li>加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li>\n<li>加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接</li>\n<li><em>以上三点，优先级从高到低</em>*</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> + <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// &#x27;123123&#x27; (规则1)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">null</span> <span class=\"comment\">//  123 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">true</span> <span class=\"comment\">//  124 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + &#123;&#125;   <span class=\"comment\">//  &#x27;123[object Object]&#x27; (规则3)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逻辑运算中的类型转换\"><a href=\"#逻辑运算中的类型转换\" class=\"headerlink\" title=\"逻辑运算中的类型转换\"></a>逻辑运算中的类型转换</h4><p>1、单个变量<br>先将变量转换为Boolean值<br><strong>只有null、undefined、’’、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]</strong></p>\n<p>2、使用 == 比较中的5条规则<br><strong>建议使用 ===</strong></p>\n<ul>\n<li>规则1：NaN和其他任何类型比较永远返回false(包括和他自己)<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"string\">&#x27;2&#x27;</span> <span class=\"comment\">// false,先将true转换为1，而不是把&#x27;2&#x27;变成true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;1&#x27;</span>] <span class=\"comment\">// true, 先将true转换为1，[&#x27;1&#x27;]拆箱成&#x27;1&#x27;,在参考规则3</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;2&#x27;</span>] <span class=\"comment\">// false, 同上</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 首先false变成0，然后参考规则4</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 同上</span></span><br></pre></td></tr></table></figure></li>\n<li>String和Number比较，先将String转换为Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> == <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// true, &#x27;123&#x27;会变成123</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> == <span class=\"number\">0</span> <span class=\"comment\">// true，&#x27;&#x27;会变成 0</span></span><br></pre></td></tr></table></figure></li>\n<li>null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型</li>\n<li><em>ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError</em>*<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class=\"comment\">// true, 对象和字符串比较，对象通过toString 得到一个基本类型值</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1,2,3&#x27;</span> == [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// true, [1,2,3]通过toString得到一个基本类型</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"类型转换表\"><a href=\"#类型转换表\" class=\"headerlink\" title=\"类型转换表\"></a>类型转换表</h4><p><img src=\"/2022/07/19/15-js-transform/convert-table.png\" alt=\"类型转换对照表\"></p>\n<h4 id=\"类型转换对照网站\"><a href=\"#类型转换对照网站\" class=\"headerlink\" title=\"类型转换对照网站\"></a>类型转换对照网站</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">https://dorey.github.io/JavaScript-Equality-Table/</a></p>\n<a class=\"btn\" href=\"/\"><i class=\"fa fa-home\"></i></a>","site":{"data":{}},"excerpt":"","more":"<p>在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。<br>== ：比较两个数据是否相等，允许进行类型转化<br>比如：1==true、’1’==true，结果都是true<br>===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false<br>比如：1===true、’1’===true，结果为false</p>\n<h4 id=\"数学运算符中的类型转换\"><a href=\"#数学运算符中的类型转换\" class=\"headerlink\" title=\"数学运算符中的类型转换\"></a>数学运算符中的类型转换</h4><p>1、减、乘、除运算<br><strong>非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">true</span> <span class=\"comment\">// 0, true先转换乘1，然后执行 1 - 1</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">false</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">null</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN, undefined转换为数字为 NaN</span></span><br><span class=\"line\"><span class=\"number\">2</span> * [<span class=\"string\">&#x27;5&#x27;</span>] <span class=\"comment\">// 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5</span></span><br></pre></td></tr></table></figure>\n<a class=\"btn\" href=\"/2022/08/09/devan-operation/\">拆箱操作</a>\n\n<p>2、加运算<br><strong>js中的加法运算，还可以用来拼接字符串</strong></p>\n<ul>\n<li>加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型</li>\n<li>加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li>\n<li>加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接</li>\n<li><em>以上三点，优先级从高到低</em>*</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> + <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// &#x27;123123&#x27; (规则1)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">null</span> <span class=\"comment\">//  123 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">true</span> <span class=\"comment\">//  124 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + &#123;&#125;   <span class=\"comment\">//  &#x27;123[object Object]&#x27; (规则3)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逻辑运算中的类型转换\"><a href=\"#逻辑运算中的类型转换\" class=\"headerlink\" title=\"逻辑运算中的类型转换\"></a>逻辑运算中的类型转换</h4><p>1、单个变量<br>先将变量转换为Boolean值<br><strong>只有null、undefined、’’、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]</strong></p>\n<p>2、使用 == 比较中的5条规则<br><strong>建议使用 ===</strong></p>\n<ul>\n<li>规则1：NaN和其他任何类型比较永远返回false(包括和他自己)<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"string\">&#x27;2&#x27;</span> <span class=\"comment\">// false,先将true转换为1，而不是把&#x27;2&#x27;变成true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;1&#x27;</span>] <span class=\"comment\">// true, 先将true转换为1，[&#x27;1&#x27;]拆箱成&#x27;1&#x27;,在参考规则3</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;2&#x27;</span>] <span class=\"comment\">// false, 同上</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 首先false变成0，然后参考规则4</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 同上</span></span><br></pre></td></tr></table></figure></li>\n<li>String和Number比较，先将String转换为Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> == <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// true, &#x27;123&#x27;会变成123</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> == <span class=\"number\">0</span> <span class=\"comment\">// true，&#x27;&#x27;会变成 0</span></span><br></pre></td></tr></table></figure></li>\n<li>null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型</li>\n<li><em>ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError</em>*<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class=\"comment\">// true, 对象和字符串比较，对象通过toString 得到一个基本类型值</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1,2,3&#x27;</span> == [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// true, [1,2,3]通过toString得到一个基本类型</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"类型转换表\"><a href=\"#类型转换表\" class=\"headerlink\" title=\"类型转换表\"></a>类型转换表</h4><p><img src=\"/2022/07/19/15-js-transform/convert-table.png\" alt=\"类型转换对照表\"></p>\n<h4 id=\"类型转换对照网站\"><a href=\"#类型转换对照网站\" class=\"headerlink\" title=\"类型转换对照网站\"></a>类型转换对照网站</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">https://dorey.github.io/JavaScript-Equality-Table/</a></p>\n<a class=\"btn\" href=\"/\"><i class=\"fa fa-home\"></i></a>"},{"title":"js-基本类型与引用类型","date":"2022-07-19T08:23:28.000Z","_content":"","source":"_posts/16-origin-type-and-reference-type.md","raw":"---\ntitle: js-基本类型与引用类型\ndate: 2022-07-19 16:23:28\ntags:\n---\n","slug":"16-origin-type-and-reference-type","published":1,"updated":"2022-08-10T03:14:27.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8po000ck4tte3zm6vu3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"javascript DOM编程艺术阅读笔记","date":"2022-07-31T05:42:45.000Z","_content":"\n#### JavaScript简史\n1、DOM\nDOM是一套对文档的内容进行抽象和概念化的方法。\n\n第0级DOM(DOM Level 0)\n试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。\n\n第1级DMO(DOM Level 1)\nNetscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。\n\n2、浏览器战争\n2.1 DHTML\nDHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:\n(1)利用HTML把网页标记为各种元素;\n(2)利用CSS设置元素样式和它们的显示位置;\n(3)利用JavaScript实时地操控页面和改变样式。\n\n#### JavaScript语法\n循环语句\n1、while循环\n```javascript\nwhile (condition){\n  statements;\n}\n```\ndo...while循环\n```javascript\ndo {\n  statements;\n} while (condition);\n```\n  2、for循环\n```javascript\nfor (initial condition; test condition; alter condition){\n  statements;\n}\n```\n\n函数\n1、变量的作用域\n全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。\n局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。\n\n对象\n对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :\n-属性是隶属于某个特定对象的变量\n-方法是只有某个特定对象才能调用的函数\n对象就是由一些属性和方法组合在一起而构成的一个数据实体\n\n1、用户定义对象(user-defined object)\n由程序员自行创建的对象\n\n2、内建对象(native object)\nJavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object) \nArray、Math、Date等\n\n3、宿主对象(host object)\n由浏览器提供的预定义对象被称为宿主对象(host object ) \n宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息\n\n#### DOM\n1、文档:DOM中的'D'\n如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象\n\n2、对象:DOM中的'O'\n如上对象\n\n3、模型:DOM中的'M'\nDOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图\n\n4、节点\n(1)元素节点\n(2)文本节点\n(3)属性节点\n(4)CSS\n(5)获取元素\n-getElementById 返回一个对象\n-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点\n```javascript\nvar shopping = document.getElementById(\"purchases\") ;\nvar items = shopping.getElementsByTagName(\"*\") ;\n```\n-getElementsByClassName 返回一个对象数组\n使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可\n注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。\n```javascript\nvar shopping = document.getElementById(\"purchases\");\nvar sales = shopping.getElementsByClassName(\"sale\");\n```\n\n5、获取和设置属性\n(1)getAttribute 只能通过元素节点调用\n(2)setAttribute 只能通过元素节点调用，修改属性值\n细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。\n\n#### 案例研究：JavaScript图片库\nDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。\n1、childNodes属性 用来获取任何一个元素的所有子元素\n2、nodeType属性 共有12中可取值\n以下3种具有实用价值：\n-元素节点的nodeType属性值是1\n-属性节点的nodeType属性值是2\n-文本节点的nodeType属性值是3\n3、nodeValue属性 得到和设置节点的值\n4、firstChild和lastChild\n\n#### 最佳实践\n1、平稳退化\n平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成\n2、“javascript:”伪协议\n“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议\n“javascript:”伪协议让我们通过一个链接来调用JavaScript函数\n```javascript\n<a href=\"javascript:popUp('http://www.example.com/');\">Example</a>\n```\n3、CSS\n结构与样式分离\n渐进增强，用一些额外的信息层去包裹原始数据\n4、分离javascript\n5、向后兼容\n(1)对象检测：检测浏览器对JavaScript的支持程度\n(2)浏览器嗅探技术\n通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。\n首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息\n其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长\n最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本\n6、性能考虑\n(1)尽量少访问DOM和尽量减少标记\n(2)合并和放置脚本\n多个脚本合并，减少请求次数\n把所有/<script/>标签都放到文档的末尾，/</body/>标记之前，就可以让页面变得更快\n(3)压缩脚本\n压缩工具：\n-Douglas Crockford的JSMin (http://www.crockford.com/javascript/jsmin.html)\n-雅虎的YUI Compressor (http://developer.yahoo.com/yui/compressor)\n-谷歌的Closure Compiler (http://closure-compiler.appspot.com/home)\n\n#### 动态创建标记\n1、document.write & innerHTML属性\n2、DOM方法\n(1)createElement\n(1)appendChild\n(1)createTextNode\n(1)insertBefore\n3、Ajax\n(1)XMLHttpRequest对象\n```javascript\nfunction getHTTPObject () {\n  if (typeof XMLHttpRequest == \"undefined\") xMLHttpRequest =function () {\n    try { return new Activexobject ( \"Msxm12.XMLHTTP.6.0\"); )catch (e) { }\n    try { return new ActivexObject (\"Msxm12.XMLHTTP.3.0\");)catch (e) { }\n    try { return new ActivexObject ( \"Msxm12.XMLHTTP\"); )catch (e) { }\n    return false;\n  }\n  return new XMLHttpRequest ( ) ;\n}\n```\n\nXHTML5\n本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。\n\n#### CSS-DOM\n1、三位一体的网页\n(1)结构层\n网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建\n(2)表示层\n表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现\n(3)行为层\n行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域\n(4)分离\n-使用(X)HTML去搭建文档的结构\n-使用CSS去设置文档的呈现效果\n-使用DOM脚本去实现文档的行为\n2、style属性\n在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此\nstyle对象只包含在HTML代码里用style属性声明的样式\n3、何时该使用DOM脚本设置样式\n(1)根据元素在节点树里的位置来设置样式\n(2)根据某种条件反复设置某种样式\n(3)响应事件\n4、className属性\n\n#### HTML5\n1、canvas\n2、video和audio\n\n疑问点：\n1、遇到的知识点觉得掌握了，没有记录，后面又忘了\n重要的知识点都记录，不管有没有掌握\n2、任务拆分评估时间不准\n更深入的了解项目代码和业务逻辑\n3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？\n先记录继续阅读，看后面是否有解答\n4、原型链\n不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承\n理解知识的时候，不要添加太多概念，避免混乱","source":"_posts/17-about-dom.md","raw":"---\ntitle: javascript DOM编程艺术阅读笔记\ndate: 2022-07-31 13:42:45\ntags:\n---\n\n#### JavaScript简史\n1、DOM\nDOM是一套对文档的内容进行抽象和概念化的方法。\n\n第0级DOM(DOM Level 0)\n试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。\n\n第1级DMO(DOM Level 1)\nNetscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。\n\n2、浏览器战争\n2.1 DHTML\nDHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:\n(1)利用HTML把网页标记为各种元素;\n(2)利用CSS设置元素样式和它们的显示位置;\n(3)利用JavaScript实时地操控页面和改变样式。\n\n#### JavaScript语法\n循环语句\n1、while循环\n```javascript\nwhile (condition){\n  statements;\n}\n```\ndo...while循环\n```javascript\ndo {\n  statements;\n} while (condition);\n```\n  2、for循环\n```javascript\nfor (initial condition; test condition; alter condition){\n  statements;\n}\n```\n\n函数\n1、变量的作用域\n全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。\n局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。\n\n对象\n对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :\n-属性是隶属于某个特定对象的变量\n-方法是只有某个特定对象才能调用的函数\n对象就是由一些属性和方法组合在一起而构成的一个数据实体\n\n1、用户定义对象(user-defined object)\n由程序员自行创建的对象\n\n2、内建对象(native object)\nJavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object) \nArray、Math、Date等\n\n3、宿主对象(host object)\n由浏览器提供的预定义对象被称为宿主对象(host object ) \n宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息\n\n#### DOM\n1、文档:DOM中的'D'\n如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象\n\n2、对象:DOM中的'O'\n如上对象\n\n3、模型:DOM中的'M'\nDOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图\n\n4、节点\n(1)元素节点\n(2)文本节点\n(3)属性节点\n(4)CSS\n(5)获取元素\n-getElementById 返回一个对象\n-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点\n```javascript\nvar shopping = document.getElementById(\"purchases\") ;\nvar items = shopping.getElementsByTagName(\"*\") ;\n```\n-getElementsByClassName 返回一个对象数组\n使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可\n注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。\n```javascript\nvar shopping = document.getElementById(\"purchases\");\nvar sales = shopping.getElementsByClassName(\"sale\");\n```\n\n5、获取和设置属性\n(1)getAttribute 只能通过元素节点调用\n(2)setAttribute 只能通过元素节点调用，修改属性值\n细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。\n\n#### 案例研究：JavaScript图片库\nDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。\n1、childNodes属性 用来获取任何一个元素的所有子元素\n2、nodeType属性 共有12中可取值\n以下3种具有实用价值：\n-元素节点的nodeType属性值是1\n-属性节点的nodeType属性值是2\n-文本节点的nodeType属性值是3\n3、nodeValue属性 得到和设置节点的值\n4、firstChild和lastChild\n\n#### 最佳实践\n1、平稳退化\n平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成\n2、“javascript:”伪协议\n“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议\n“javascript:”伪协议让我们通过一个链接来调用JavaScript函数\n```javascript\n<a href=\"javascript:popUp('http://www.example.com/');\">Example</a>\n```\n3、CSS\n结构与样式分离\n渐进增强，用一些额外的信息层去包裹原始数据\n4、分离javascript\n5、向后兼容\n(1)对象检测：检测浏览器对JavaScript的支持程度\n(2)浏览器嗅探技术\n通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。\n首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息\n其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长\n最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本\n6、性能考虑\n(1)尽量少访问DOM和尽量减少标记\n(2)合并和放置脚本\n多个脚本合并，减少请求次数\n把所有/<script/>标签都放到文档的末尾，/</body/>标记之前，就可以让页面变得更快\n(3)压缩脚本\n压缩工具：\n-Douglas Crockford的JSMin (http://www.crockford.com/javascript/jsmin.html)\n-雅虎的YUI Compressor (http://developer.yahoo.com/yui/compressor)\n-谷歌的Closure Compiler (http://closure-compiler.appspot.com/home)\n\n#### 动态创建标记\n1、document.write & innerHTML属性\n2、DOM方法\n(1)createElement\n(1)appendChild\n(1)createTextNode\n(1)insertBefore\n3、Ajax\n(1)XMLHttpRequest对象\n```javascript\nfunction getHTTPObject () {\n  if (typeof XMLHttpRequest == \"undefined\") xMLHttpRequest =function () {\n    try { return new Activexobject ( \"Msxm12.XMLHTTP.6.0\"); )catch (e) { }\n    try { return new ActivexObject (\"Msxm12.XMLHTTP.3.0\");)catch (e) { }\n    try { return new ActivexObject ( \"Msxm12.XMLHTTP\"); )catch (e) { }\n    return false;\n  }\n  return new XMLHttpRequest ( ) ;\n}\n```\n\nXHTML5\n本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。\n\n#### CSS-DOM\n1、三位一体的网页\n(1)结构层\n网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建\n(2)表示层\n表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现\n(3)行为层\n行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域\n(4)分离\n-使用(X)HTML去搭建文档的结构\n-使用CSS去设置文档的呈现效果\n-使用DOM脚本去实现文档的行为\n2、style属性\n在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此\nstyle对象只包含在HTML代码里用style属性声明的样式\n3、何时该使用DOM脚本设置样式\n(1)根据元素在节点树里的位置来设置样式\n(2)根据某种条件反复设置某种样式\n(3)响应事件\n4、className属性\n\n#### HTML5\n1、canvas\n2、video和audio\n\n疑问点：\n1、遇到的知识点觉得掌握了，没有记录，后面又忘了\n重要的知识点都记录，不管有没有掌握\n2、任务拆分评估时间不准\n更深入的了解项目代码和业务逻辑\n3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？\n先记录继续阅读，看后面是否有解答\n4、原型链\n不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承\n理解知识的时候，不要添加太多概念，避免混乱","slug":"17-about-dom","published":1,"updated":"2022-08-30T10:54:33.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pp000dk4ttblrre5ox","content":"<h4 id=\"JavaScript简史\"><a href=\"#JavaScript简史\" class=\"headerlink\" title=\"JavaScript简史\"></a>JavaScript简史</h4><p>1、DOM<br>DOM是一套对文档的内容进行抽象和概念化的方法。</p>\n<p>第0级DOM(DOM Level 0)<br>试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。</p>\n<p>第1级DMO(DOM Level 1)<br>Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。</p>\n<p>2、浏览器战争<br>2.1 DHTML<br>DHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:<br>(1)利用HTML把网页标记为各种元素;<br>(2)利用CSS设置元素样式和它们的显示位置;<br>(3)利用JavaScript实时地操控页面和改变样式。</p>\n<h4 id=\"JavaScript语法\"><a href=\"#JavaScript语法\" class=\"headerlink\" title=\"JavaScript语法\"></a>JavaScript语法</h4><p>循环语句<br>1、while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>do…while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (condition);</span><br></pre></td></tr></table></figure>\n<p>  2、for循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (initial condition; test condition; alter condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数<br>1、变量的作用域<br>全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。<br>局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。</p>\n<p>对象<br>对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :<br>-属性是隶属于某个特定对象的变量<br>-方法是只有某个特定对象才能调用的函数<br>对象就是由一些属性和方法组合在一起而构成的一个数据实体</p>\n<p>1、用户定义对象(user-defined object)<br>由程序员自行创建的对象</p>\n<p>2、内建对象(native object)<br>JavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object)<br>Array、Math、Date等</p>\n<p>3、宿主对象(host object)<br>由浏览器提供的预定义对象被称为宿主对象(host object )<br>宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息</p>\n<h4 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h4><p>1、文档:DOM中的’D’<br>如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象</p>\n<p>2、对象:DOM中的’O’<br>如上对象</p>\n<p>3、模型:DOM中的’M’<br>DOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图</p>\n<p>4、节点<br>(1)元素节点<br>(2)文本节点<br>(3)属性节点<br>(4)CSS<br>(5)获取元素<br>-getElementById 返回一个对象<br>-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>) ;</span><br><span class=\"line\"><span class=\"keyword\">var</span> items = shopping.getElementsByTagName(<span class=\"string\">&quot;*&quot;</span>) ;</span><br></pre></td></tr></table></figure>\n<p>-getElementsByClassName 返回一个对象数组<br>使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可<br>注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sales = shopping.getElementsByClassName(<span class=\"string\">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>5、获取和设置属性<br>(1)getAttribute 只能通过元素节点调用<br>(2)setAttribute 只能通过元素节点调用，修改属性值<br>细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。</p>\n<h4 id=\"案例研究：JavaScript图片库\"><a href=\"#案例研究：JavaScript图片库\" class=\"headerlink\" title=\"案例研究：JavaScript图片库\"></a>案例研究：JavaScript图片库</h4><p>DOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。<br>1、childNodes属性 用来获取任何一个元素的所有子元素<br>2、nodeType属性 共有12中可取值<br>以下3种具有实用价值：<br>-元素节点的nodeType属性值是1<br>-属性节点的nodeType属性值是2<br>-文本节点的nodeType属性值是3<br>3、nodeValue属性 得到和设置节点的值<br>4、firstChild和lastChild</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>1、平稳退化<br>平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成<br>2、“javascript:”伪协议<br>“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议<br>“javascript:”伪协议让我们通过一个链接来调用JavaScript函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;javascript:popUp(&#x27;http://www.example.com/&#x27;);&quot;</span>&gt;Example&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>3、CSS<br>结构与样式分离<br>渐进增强，用一些额外的信息层去包裹原始数据<br>4、分离javascript<br>5、向后兼容<br>(1)对象检测：检测浏览器对JavaScript的支持程度<br>(2)浏览器嗅探技术<br>通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。<br>首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息<br>其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长<br>最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本<br>6、性能考虑<br>(1)尽量少访问DOM和尽量减少标记<br>(2)合并和放置脚本<br>多个脚本合并，减少请求次数<br>把所有/<script>标签都放到文档的末尾，/&lt;/body/&gt;标记之前，就可以让页面变得更快<br>(3)压缩脚本<br>压缩工具：<br>-Douglas Crockford的JSMin (<a href=\"http://www.crockford.com/javascript/jsmin.html\">http://www.crockford.com/javascript/jsmin.html</a>)<br>-雅虎的YUI Compressor (<a href=\"http://developer.yahoo.com/yui/compressor\">http://developer.yahoo.com/yui/compressor</a>)<br>-谷歌的Closure Compiler (<a href=\"http://closure-compiler.appspot.com/home\">http://closure-compiler.appspot.com/home</a>)</p>\n<h4 id=\"动态创建标记\"><a href=\"#动态创建标记\" class=\"headerlink\" title=\"动态创建标记\"></a>动态创建标记</h4><p>1、document.write &amp; innerHTML属性<br>2、DOM方法<br>(1)createElement<br>(1)appendChild<br>(1)createTextNode<br>(1)insertBefore<br>3、Ajax<br>(1)XMLHttpRequest对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHTTPObject</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> XMLHttpRequest == <span class=\"string\">&quot;undefined&quot;</span>) xMLHttpRequest =<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Activexobject ( <span class=\"string\">&quot;Msxm12.XMLHTTP.6.0&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject (<span class=\"string\">&quot;Msxm12.XMLHTTP.3.0&quot;</span>);)<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject ( <span class=\"string\">&quot;Msxm12.XMLHTTP&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> XMLHttpRequest ( ) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XHTML5<br>本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。</p>\n<h4 id=\"CSS-DOM\"><a href=\"#CSS-DOM\" class=\"headerlink\" title=\"CSS-DOM\"></a>CSS-DOM</h4><p>1、三位一体的网页<br>(1)结构层<br>网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建<br>(2)表示层<br>表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现<br>(3)行为层<br>行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域<br>(4)分离<br>-使用(X)HTML去搭建文档的结构<br>-使用CSS去设置文档的呈现效果<br>-使用DOM脚本去实现文档的行为<br>2、style属性<br>在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此<br>style对象只包含在HTML代码里用style属性声明的样式<br>3、何时该使用DOM脚本设置样式<br>(1)根据元素在节点树里的位置来设置样式<br>(2)根据某种条件反复设置某种样式<br>(3)响应事件<br>4、className属性</p>\n<h4 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h4><p>1、canvas<br>2、video和audio</p>\n<p>疑问点：<br>1、遇到的知识点觉得掌握了，没有记录，后面又忘了<br>重要的知识点都记录，不管有没有掌握<br>2、任务拆分评估时间不准<br>更深入的了解项目代码和业务逻辑<br>3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？<br>先记录继续阅读，看后面是否有解答<br>4、原型链<br>不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承<br>理解知识的时候，不要添加太多概念，避免混乱</p>\n</script></p>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JavaScript简史\"><a href=\"#JavaScript简史\" class=\"headerlink\" title=\"JavaScript简史\"></a>JavaScript简史</h4><p>1、DOM<br>DOM是一套对文档的内容进行抽象和概念化的方法。</p>\n<p>第0级DOM(DOM Level 0)<br>试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。</p>\n<p>第1级DMO(DOM Level 1)<br>Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。</p>\n<p>2、浏览器战争<br>2.1 DHTML<br>DHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:<br>(1)利用HTML把网页标记为各种元素;<br>(2)利用CSS设置元素样式和它们的显示位置;<br>(3)利用JavaScript实时地操控页面和改变样式。</p>\n<h4 id=\"JavaScript语法\"><a href=\"#JavaScript语法\" class=\"headerlink\" title=\"JavaScript语法\"></a>JavaScript语法</h4><p>循环语句<br>1、while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>do…while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (condition);</span><br></pre></td></tr></table></figure>\n<p>  2、for循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (initial condition; test condition; alter condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数<br>1、变量的作用域<br>全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。<br>局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。</p>\n<p>对象<br>对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :<br>-属性是隶属于某个特定对象的变量<br>-方法是只有某个特定对象才能调用的函数<br>对象就是由一些属性和方法组合在一起而构成的一个数据实体</p>\n<p>1、用户定义对象(user-defined object)<br>由程序员自行创建的对象</p>\n<p>2、内建对象(native object)<br>JavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object)<br>Array、Math、Date等</p>\n<p>3、宿主对象(host object)<br>由浏览器提供的预定义对象被称为宿主对象(host object )<br>宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息</p>\n<h4 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h4><p>1、文档:DOM中的’D’<br>如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象</p>\n<p>2、对象:DOM中的’O’<br>如上对象</p>\n<p>3、模型:DOM中的’M’<br>DOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图</p>\n<p>4、节点<br>(1)元素节点<br>(2)文本节点<br>(3)属性节点<br>(4)CSS<br>(5)获取元素<br>-getElementById 返回一个对象<br>-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>) ;</span><br><span class=\"line\"><span class=\"keyword\">var</span> items = shopping.getElementsByTagName(<span class=\"string\">&quot;*&quot;</span>) ;</span><br></pre></td></tr></table></figure>\n<p>-getElementsByClassName 返回一个对象数组<br>使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可<br>注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sales = shopping.getElementsByClassName(<span class=\"string\">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>5、获取和设置属性<br>(1)getAttribute 只能通过元素节点调用<br>(2)setAttribute 只能通过元素节点调用，修改属性值<br>细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。</p>\n<h4 id=\"案例研究：JavaScript图片库\"><a href=\"#案例研究：JavaScript图片库\" class=\"headerlink\" title=\"案例研究：JavaScript图片库\"></a>案例研究：JavaScript图片库</h4><p>DOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。<br>1、childNodes属性 用来获取任何一个元素的所有子元素<br>2、nodeType属性 共有12中可取值<br>以下3种具有实用价值：<br>-元素节点的nodeType属性值是1<br>-属性节点的nodeType属性值是2<br>-文本节点的nodeType属性值是3<br>3、nodeValue属性 得到和设置节点的值<br>4、firstChild和lastChild</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>1、平稳退化<br>平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成<br>2、“javascript:”伪协议<br>“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议<br>“javascript:”伪协议让我们通过一个链接来调用JavaScript函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;javascript:popUp(&#x27;http://www.example.com/&#x27;);&quot;</span>&gt;Example&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>3、CSS<br>结构与样式分离<br>渐进增强，用一些额外的信息层去包裹原始数据<br>4、分离javascript<br>5、向后兼容<br>(1)对象检测：检测浏览器对JavaScript的支持程度<br>(2)浏览器嗅探技术<br>通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。<br>首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息<br>其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长<br>最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本<br>6、性能考虑<br>(1)尽量少访问DOM和尽量减少标记<br>(2)合并和放置脚本<br>多个脚本合并，减少请求次数<br>把所有/<script>标签都放到文档的末尾，/&lt;/body/&gt;标记之前，就可以让页面变得更快<br>(3)压缩脚本<br>压缩工具：<br>-Douglas Crockford的JSMin (<a href=\"http://www.crockford.com/javascript/jsmin.html\">http://www.crockford.com/javascript/jsmin.html</a>)<br>-雅虎的YUI Compressor (<a href=\"http://developer.yahoo.com/yui/compressor\">http://developer.yahoo.com/yui/compressor</a>)<br>-谷歌的Closure Compiler (<a href=\"http://closure-compiler.appspot.com/home\">http://closure-compiler.appspot.com/home</a>)</p>\n<h4 id=\"动态创建标记\"><a href=\"#动态创建标记\" class=\"headerlink\" title=\"动态创建标记\"></a>动态创建标记</h4><p>1、document.write &amp; innerHTML属性<br>2、DOM方法<br>(1)createElement<br>(1)appendChild<br>(1)createTextNode<br>(1)insertBefore<br>3、Ajax<br>(1)XMLHttpRequest对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHTTPObject</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> XMLHttpRequest == <span class=\"string\">&quot;undefined&quot;</span>) xMLHttpRequest =<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Activexobject ( <span class=\"string\">&quot;Msxm12.XMLHTTP.6.0&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject (<span class=\"string\">&quot;Msxm12.XMLHTTP.3.0&quot;</span>);)<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject ( <span class=\"string\">&quot;Msxm12.XMLHTTP&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> XMLHttpRequest ( ) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XHTML5<br>本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。</p>\n<h4 id=\"CSS-DOM\"><a href=\"#CSS-DOM\" class=\"headerlink\" title=\"CSS-DOM\"></a>CSS-DOM</h4><p>1、三位一体的网页<br>(1)结构层<br>网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建<br>(2)表示层<br>表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现<br>(3)行为层<br>行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域<br>(4)分离<br>-使用(X)HTML去搭建文档的结构<br>-使用CSS去设置文档的呈现效果<br>-使用DOM脚本去实现文档的行为<br>2、style属性<br>在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此<br>style对象只包含在HTML代码里用style属性声明的样式<br>3、何时该使用DOM脚本设置样式<br>(1)根据元素在节点树里的位置来设置样式<br>(2)根据某种条件反复设置某种样式<br>(3)响应事件<br>4、className属性</p>\n<h4 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h4><p>1、canvas<br>2、video和audio</p>\n<p>疑问点：<br>1、遇到的知识点觉得掌握了，没有记录，后面又忘了<br>重要的知识点都记录，不管有没有掌握<br>2、任务拆分评估时间不准<br>更深入的了解项目代码和业务逻辑<br>3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？<br>先记录继续阅读，看后面是否有解答<br>4、原型链<br>不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承<br>理解知识的时候，不要添加太多概念，避免混乱</p>\n</script></p>"},{"title":"伪数组","date":"2022-08-04T02:57:14.000Z","_content":"\n#### 概念\nArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。\n\n#### 特征\n1、具有length属性\n2、按照索引方式存储数据\n3、不具有数组的方法，如push、pop等\n![document获取的伪数组](document.png)\n\n#### 有哪些常见的伪数组\n1、function的arguments对象\n2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象\n3、上传文件是选择的file对象\n4、自定义的某些对象\n\n#### 判断一个数组是不是伪数组的方法\n1、Array.isArray\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nArray.isArray(fakeArray); // false\nArray.isArray(array); // true\n```\n2、instanceof\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nfakeArray instanceof Array; // false\narray instanceof Array; // true\n```\n\n#### 将数组转为真正数组的方法\n1、使用Array.prototype.slice.call()\n![Array.prototype.slice.call转换](prototype_call.png)\n2、使用[].slice.call()\n![slice.call转换](slice_call.png)\n3、使用Array.from()\n![array.from转换](array_from.png)\n","source":"_posts/18-fake-array.md","raw":"---\ntitle: 伪数组\ndate: 2022-08-04 10:57:14\ntags:\n---\n\n#### 概念\nArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。\n\n#### 特征\n1、具有length属性\n2、按照索引方式存储数据\n3、不具有数组的方法，如push、pop等\n![document获取的伪数组](document.png)\n\n#### 有哪些常见的伪数组\n1、function的arguments对象\n2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象\n3、上传文件是选择的file对象\n4、自定义的某些对象\n\n#### 判断一个数组是不是伪数组的方法\n1、Array.isArray\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nArray.isArray(fakeArray); // false\nArray.isArray(array); // true\n```\n2、instanceof\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nfakeArray instanceof Array; // false\narray instanceof Array; // true\n```\n\n#### 将数组转为真正数组的方法\n1、使用Array.prototype.slice.call()\n![Array.prototype.slice.call转换](prototype_call.png)\n2、使用[].slice.call()\n![slice.call转换](slice_call.png)\n3、使用Array.from()\n![array.from转换](array_from.png)\n","slug":"18-fake-array","published":1,"updated":"2022-08-04T07:17:36.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pq000ek4tt962wb6sv","content":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>ArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。</p>\n<h4 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h4><p>1、具有length属性<br>2、按照索引方式存储数据<br>3、不具有数组的方法，如push、pop等<br><img src=\"/2022/08/04/18-fake-array/document.png\" alt=\"document获取的伪数组\"></p>\n<h4 id=\"有哪些常见的伪数组\"><a href=\"#有哪些常见的伪数组\" class=\"headerlink\" title=\"有哪些常见的伪数组\"></a>有哪些常见的伪数组</h4><p>1、function的arguments对象<br>2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象<br>3、上传文件是选择的file对象<br>4、自定义的某些对象</p>\n<h4 id=\"判断一个数组是不是伪数组的方法\"><a href=\"#判断一个数组是不是伪数组的方法\" class=\"headerlink\" title=\"判断一个数组是不是伪数组的方法\"></a>判断一个数组是不是伪数组的方法</h4><p>1、Array.isArray</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(fakeArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(array); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>2、instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\">fakeArray <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">array <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将数组转为真正数组的方法\"><a href=\"#将数组转为真正数组的方法\" class=\"headerlink\" title=\"将数组转为真正数组的方法\"></a>将数组转为真正数组的方法</h4><p>1、使用Array.prototype.slice.call()<br><img src=\"/2022/08/04/18-fake-array/prototype_call.png\" alt=\"Array.prototype.slice.call转换\"><br>2、使用[].slice.call()<br><img src=\"/2022/08/04/18-fake-array/slice_call.png\" alt=\"slice.call转换\"><br>3、使用Array.from()<br><img src=\"/2022/08/04/18-fake-array/array_from.png\" alt=\"array.from转换\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>ArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。</p>\n<h4 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h4><p>1、具有length属性<br>2、按照索引方式存储数据<br>3、不具有数组的方法，如push、pop等<br><img src=\"/2022/08/04/18-fake-array/document.png\" alt=\"document获取的伪数组\"></p>\n<h4 id=\"有哪些常见的伪数组\"><a href=\"#有哪些常见的伪数组\" class=\"headerlink\" title=\"有哪些常见的伪数组\"></a>有哪些常见的伪数组</h4><p>1、function的arguments对象<br>2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象<br>3、上传文件是选择的file对象<br>4、自定义的某些对象</p>\n<h4 id=\"判断一个数组是不是伪数组的方法\"><a href=\"#判断一个数组是不是伪数组的方法\" class=\"headerlink\" title=\"判断一个数组是不是伪数组的方法\"></a>判断一个数组是不是伪数组的方法</h4><p>1、Array.isArray</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(fakeArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(array); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>2、instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\">fakeArray <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">array <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将数组转为真正数组的方法\"><a href=\"#将数组转为真正数组的方法\" class=\"headerlink\" title=\"将数组转为真正数组的方法\"></a>将数组转为真正数组的方法</h4><p>1、使用Array.prototype.slice.call()<br><img src=\"/2022/08/04/18-fake-array/prototype_call.png\" alt=\"Array.prototype.slice.call转换\"><br>2、使用[].slice.call()<br><img src=\"/2022/08/04/18-fake-array/slice_call.png\" alt=\"slice.call转换\"><br>3、使用Array.from()<br><img src=\"/2022/08/04/18-fake-array/array_from.png\" alt=\"array.from转换\"></p>\n"},{"title":"Map 结构","date":"2022-08-04T06:07:12.000Z","_content":"\n#### 什么是Map?\n由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。\n\n#### 怎么创建map？\n```javascript\nconst map = new Map();\n```\nmap可以使用一个对象作为键\n```javascript\nconst map = new Map();\nconst o = { p: 'string' };\n\nmap.set(o, 'text');\nmap.get(o); // text\n\nmap.has(o); // true\nmap.delete(o);\n```\nmap还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组\n```javascript\nconst map = new Map([['name', 'Tom'], ['age', 12]]);\nmap.size; // 2\nmap.has('name'); // true\nmap.get('age'); // 12\n```\n\n##### 注意点\n如果对同一个键多次赋值，后面的值将覆盖前面的值\n```javascript\nmap.set(1, 'qw').set(1, 'sdf');\nmap.get(1); // sdf\n```\n\n#### map的实例属性和方法\n1、size\n用法：map.size\n作用：获取map结构的大小\n返回：map结构的长度大小\n```javascript\nconst map = new Map();\nmap.size; // 0\nmap.set(1, 12);\nmap.size; // 1\n```\n\n2、set()\n用法：map.set(key, value)\n作用：向map中添加或修改map的数据\n返回：修改后的map\n```javascript\nconst map = new Map();\nmap.set(1, 12);\n```\n\n3、get()\n用法：map.get(key)\n作用：获取对应key的value值\n返回：map结构中key对应的值，不存在对应key时，返回undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.get(1); // 12\nmap.get(2); // undefined\n```\n\n4、has()\n用法：map.has(key)\n作用：判断map中是否有对应的key\n返回：true/false，依据map中是否有对应的key，返回true或false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.has(1); // true\nmap.has(2); // has\n```\n\n5、delete()\n用法：map.delete(key)\n作用：删除map中对应的key及value\n返回：true/false，删除成功返回true，删除失败返回false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.delete(1); // true\nmap.delete(2); // false\n```\n\n6、clear()\n用法：map.clear()\n作用：清空map中的数据\n返回：undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.clear(); // undefined\n```\n\n#### map的遍历方法\n1、keys()\n2、values()\n3、entries()\n4、forEach()\n\n参考：https://www.jianshu.com/p/93b5a5940de8","source":"_posts/19-about-map.md","raw":"---\ntitle: Map 结构\ndate: 2022-08-04 14:07:12\ntags:\n---\n\n#### 什么是Map?\n由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。\n\n#### 怎么创建map？\n```javascript\nconst map = new Map();\n```\nmap可以使用一个对象作为键\n```javascript\nconst map = new Map();\nconst o = { p: 'string' };\n\nmap.set(o, 'text');\nmap.get(o); // text\n\nmap.has(o); // true\nmap.delete(o);\n```\nmap还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组\n```javascript\nconst map = new Map([['name', 'Tom'], ['age', 12]]);\nmap.size; // 2\nmap.has('name'); // true\nmap.get('age'); // 12\n```\n\n##### 注意点\n如果对同一个键多次赋值，后面的值将覆盖前面的值\n```javascript\nmap.set(1, 'qw').set(1, 'sdf');\nmap.get(1); // sdf\n```\n\n#### map的实例属性和方法\n1、size\n用法：map.size\n作用：获取map结构的大小\n返回：map结构的长度大小\n```javascript\nconst map = new Map();\nmap.size; // 0\nmap.set(1, 12);\nmap.size; // 1\n```\n\n2、set()\n用法：map.set(key, value)\n作用：向map中添加或修改map的数据\n返回：修改后的map\n```javascript\nconst map = new Map();\nmap.set(1, 12);\n```\n\n3、get()\n用法：map.get(key)\n作用：获取对应key的value值\n返回：map结构中key对应的值，不存在对应key时，返回undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.get(1); // 12\nmap.get(2); // undefined\n```\n\n4、has()\n用法：map.has(key)\n作用：判断map中是否有对应的key\n返回：true/false，依据map中是否有对应的key，返回true或false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.has(1); // true\nmap.has(2); // has\n```\n\n5、delete()\n用法：map.delete(key)\n作用：删除map中对应的key及value\n返回：true/false，删除成功返回true，删除失败返回false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.delete(1); // true\nmap.delete(2); // false\n```\n\n6、clear()\n用法：map.clear()\n作用：清空map中的数据\n返回：undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.clear(); // undefined\n```\n\n#### map的遍历方法\n1、keys()\n2、values()\n3、entries()\n4、forEach()\n\n参考：https://www.jianshu.com/p/93b5a5940de8","slug":"19-about-map","published":1,"updated":"2022-08-04T07:31:23.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pr000fk4tt61gl9sad","content":"<h4 id=\"什么是Map\"><a href=\"#什么是Map\" class=\"headerlink\" title=\"什么是Map?\"></a>什么是Map?</h4><p>由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。</p>\n<h4 id=\"怎么创建map？\"><a href=\"#怎么创建map？\" class=\"headerlink\" title=\"怎么创建map？\"></a>怎么创建map？</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure>\n<p>map可以使用一个对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123; <span class=\"attr\">p</span>: <span class=\"string\">&#x27;string&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(o, <span class=\"string\">&#x27;text&#x27;</span>);</span><br><span class=\"line\">map.get(o); <span class=\"comment\">// text</span></span><br><span class=\"line\"></span><br><span class=\"line\">map.has(o); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(o);</span><br></pre></td></tr></table></figure>\n<p>map还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>], [<span class=\"string\">&#x27;age&#x27;</span>, <span class=\"number\">12</span>]]);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.has(<span class=\"string\">&#x27;name&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&#x27;age&#x27;</span>); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><p>如果对同一个键多次赋值，后面的值将覆盖前面的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;qw&#x27;</span>).set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;sdf&#x27;</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// sdf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的实例属性和方法\"><a href=\"#map的实例属性和方法\" class=\"headerlink\" title=\"map的实例属性和方法\"></a>map的实例属性和方法</h4><p>1、size<br>用法：map.size<br>作用：获取map结构的大小<br>返回：map结构的长度大小</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>2、set()<br>用法：map.set(key, value)<br>作用：向map中添加或修改map的数据<br>返回：修改后的map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>3、get()<br>用法：map.get(key)<br>作用：获取对应key的value值<br>返回：map结构中key对应的值，不存在对应key时，返回undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// 12</span></span><br><span class=\"line\">map.get(<span class=\"number\">2</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>4、has()<br>用法：map.has(key)<br>作用：判断map中是否有对应的key<br>返回：true/false，依据map中是否有对应的key，返回true或false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.has(<span class=\"number\">2</span>); <span class=\"comment\">// has</span></span><br></pre></td></tr></table></figure>\n\n<p>5、delete()<br>用法：map.delete(key)<br>作用：删除map中对应的key及value<br>返回：true/false，删除成功返回true，删除失败返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.delete(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(<span class=\"number\">2</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>6、clear()<br>用法：map.clear()<br>作用：清空map中的数据<br>返回：undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.clear(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的遍历方法\"><a href=\"#map的遍历方法\" class=\"headerlink\" title=\"map的遍历方法\"></a>map的遍历方法</h4><p>1、keys()<br>2、values()<br>3、entries()<br>4、forEach()</p>\n<p>参考：<a href=\"https://www.jianshu.com/p/93b5a5940de8\">https://www.jianshu.com/p/93b5a5940de8</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Map\"><a href=\"#什么是Map\" class=\"headerlink\" title=\"什么是Map?\"></a>什么是Map?</h4><p>由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。</p>\n<h4 id=\"怎么创建map？\"><a href=\"#怎么创建map？\" class=\"headerlink\" title=\"怎么创建map？\"></a>怎么创建map？</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure>\n<p>map可以使用一个对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123; <span class=\"attr\">p</span>: <span class=\"string\">&#x27;string&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(o, <span class=\"string\">&#x27;text&#x27;</span>);</span><br><span class=\"line\">map.get(o); <span class=\"comment\">// text</span></span><br><span class=\"line\"></span><br><span class=\"line\">map.has(o); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(o);</span><br></pre></td></tr></table></figure>\n<p>map还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>], [<span class=\"string\">&#x27;age&#x27;</span>, <span class=\"number\">12</span>]]);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.has(<span class=\"string\">&#x27;name&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&#x27;age&#x27;</span>); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><p>如果对同一个键多次赋值，后面的值将覆盖前面的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;qw&#x27;</span>).set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;sdf&#x27;</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// sdf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的实例属性和方法\"><a href=\"#map的实例属性和方法\" class=\"headerlink\" title=\"map的实例属性和方法\"></a>map的实例属性和方法</h4><p>1、size<br>用法：map.size<br>作用：获取map结构的大小<br>返回：map结构的长度大小</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>2、set()<br>用法：map.set(key, value)<br>作用：向map中添加或修改map的数据<br>返回：修改后的map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>3、get()<br>用法：map.get(key)<br>作用：获取对应key的value值<br>返回：map结构中key对应的值，不存在对应key时，返回undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// 12</span></span><br><span class=\"line\">map.get(<span class=\"number\">2</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>4、has()<br>用法：map.has(key)<br>作用：判断map中是否有对应的key<br>返回：true/false，依据map中是否有对应的key，返回true或false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.has(<span class=\"number\">2</span>); <span class=\"comment\">// has</span></span><br></pre></td></tr></table></figure>\n\n<p>5、delete()<br>用法：map.delete(key)<br>作用：删除map中对应的key及value<br>返回：true/false，删除成功返回true，删除失败返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.delete(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(<span class=\"number\">2</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>6、clear()<br>用法：map.clear()<br>作用：清空map中的数据<br>返回：undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.clear(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的遍历方法\"><a href=\"#map的遍历方法\" class=\"headerlink\" title=\"map的遍历方法\"></a>map的遍历方法</h4><p>1、keys()<br>2、values()<br>3、entries()<br>4、forEach()</p>\n<p>参考：<a href=\"https://www.jianshu.com/p/93b5a5940de8\">https://www.jianshu.com/p/93b5a5940de8</a></p>\n"},{"title":"var、const、let区别","date":"2022-03-26T13:04:12.000Z","_content":"\n#### 1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\n```javascript\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nlet声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章[let和const声明的变量到底去哪里了？](https://zhuanlan.zhihu.com/p/114128108)\n\n#### 2、","source":"_posts/2-var-const-let.md","raw":"---\ntitle: var、const、let区别\ndate: 2022-03-26 21:04:12\ntags:\n---\n\n#### 1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\n```javascript\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nlet声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章[let和const声明的变量到底去哪里了？](https://zhuanlan.zhihu.com/p/114128108)\n\n#### 2、","slug":"2-var-const-let","published":1,"updated":"2022-08-10T03:16:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8ps000gk4tt4q0w8s42","content":"<h4 id=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"><a href=\"#1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\" class=\"headerlink\" title=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"></a>1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,<span class=\"built_in\">window</span>.a);    <span class=\"comment\">// 100 100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b,<span class=\"built_in\">window</span>.b);    <span class=\"comment\">// 10 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c,<span class=\"built_in\">window</span>.c);    <span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure>\n<p>let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章<a href=\"https://zhuanlan.zhihu.com/p/114128108\">let和const声明的变量到底去哪里了？</a></p>\n<h4 id=\"2、\"><a href=\"#2、\" class=\"headerlink\" title=\"2、\"></a>2、</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"><a href=\"#1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\" class=\"headerlink\" title=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"></a>1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,<span class=\"built_in\">window</span>.a);    <span class=\"comment\">// 100 100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b,<span class=\"built_in\">window</span>.b);    <span class=\"comment\">// 10 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c,<span class=\"built_in\">window</span>.c);    <span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure>\n<p>let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章<a href=\"https://zhuanlan.zhihu.com/p/114128108\">let和const声明的变量到底去哪里了？</a></p>\n<h4 id=\"2、\"><a href=\"#2、\" class=\"headerlink\" title=\"2、\"></a>2、</h4>"},{"title":"开发一个vscode插件的流程","date":"2022-08-05T02:33:23.000Z","_content":"\n#### vscode中文手册\nhttps://www.bookstack.cn/read/CN-VScode-Docs/README.md\n\n#### vscode插件脚手架\n安装脚手架和代码生成器\n```javascript\nnpm install -g yo generator-code\n```\n生成vscode脚手架项目\n```javascript\nyo code\n```","source":"_posts/20-create-vscode-plugin.md","raw":"---\ntitle: 开发一个vscode插件的流程\ndate: 2022-08-05 10:33:23\ntags:\n---\n\n#### vscode中文手册\nhttps://www.bookstack.cn/read/CN-VScode-Docs/README.md\n\n#### vscode插件脚手架\n安装脚手架和代码生成器\n```javascript\nnpm install -g yo generator-code\n```\n生成vscode脚手架项目\n```javascript\nyo code\n```","slug":"20-create-vscode-plugin","published":1,"updated":"2022-08-05T06:08:56.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8ps000hk4tt9o7ha73b","content":"<h4 id=\"vscode中文手册\"><a href=\"#vscode中文手册\" class=\"headerlink\" title=\"vscode中文手册\"></a>vscode中文手册</h4><p><a href=\"https://www.bookstack.cn/read/CN-VScode-Docs/README.md\">https://www.bookstack.cn/read/CN-VScode-Docs/README.md</a></p>\n<h4 id=\"vscode插件脚手架\"><a href=\"#vscode插件脚手架\" class=\"headerlink\" title=\"vscode插件脚手架\"></a>vscode插件脚手架</h4><p>安装脚手架和代码生成器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g yo generator-code</span><br></pre></td></tr></table></figure>\n<p>生成vscode脚手架项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yo code</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"vscode中文手册\"><a href=\"#vscode中文手册\" class=\"headerlink\" title=\"vscode中文手册\"></a>vscode中文手册</h4><p><a href=\"https://www.bookstack.cn/read/CN-VScode-Docs/README.md\">https://www.bookstack.cn/read/CN-VScode-Docs/README.md</a></p>\n<h4 id=\"vscode插件脚手架\"><a href=\"#vscode插件脚手架\" class=\"headerlink\" title=\"vscode插件脚手架\"></a>vscode插件脚手架</h4><p>安装脚手架和代码生成器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g yo generator-code</span><br></pre></td></tr></table></figure>\n<p>生成vscode脚手架项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yo code</span><br></pre></td></tr></table></figure>"},{"title":"装箱拆箱操作","date":"2022-08-09T05:43:57.000Z","_content":"\n我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：'hello world'.length。这是由于浏览器在内部做了装箱和拆箱操作。\n\n#### 什么是装箱拆箱？\n装箱：把基本数据类型转化为对应的引用类型的操作\n拆箱：把引用类型转化为基本数据类型的操作\n\n基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol\n引用数据类型：对象(Object)、数组(Array)、函数(Function)\n四个基本的包装类型 String、Number、Boolean、Symbol\n\n什么是包装类型？\n在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型\n\n#### 装箱\n装箱分为显式装箱和隐式装箱\n\n###### 显式装箱\n通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据\n```JavaScript\nvar string = new String('test_string');\nvar number = new Number(1);\n```\n显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中\n```JavaScript\nvar string = new String('test_string');\nstring.name = 'for test';\nstring.sayHi = function(){\n    console.log('this is test string');\n}\nconsole.log(string.name); // for test\nstring.sayHi(); // this is test string\n```\n\n###### 隐式装箱\n隐式装箱是引擎自动执行的\n基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：'test_string'.substring()、'test_string'.indexOf()等，这是由于浏览器在内部做了隐式装箱。\n\n下面以一个例子进行说明：\n```JavaScript\n// 第一步\nvar string = 'test_string';\n// 第二步\nvar result = string.substring(4);\nconsole.log(result); // _string\n```\n在上面这段代码里面实际的执行步骤是：\n1、先创建一个String类型的一个实例\n2、在实例中调用方法\n3、销毁这个实例\n```JavaScript\nvar string = 'test_string';\n// 1\nvar newString = new String(string);\n// 2\nvar result = newString.substring(4);\n// 3\nnewString = null;\n```\n基于以上的隐式装箱操作，我们可以在基本类型上使用方法\n隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了\n\n\n显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法\n\n引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。\n#### 拆箱\n拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。\n需要注意的是，toString() 和 valueOf() 返回的值有一定差别\n```JavaScript\nvar numberObj = new Number(64);\nvar stringObj = new String('64');\nconsole.log(typeof numberObj); // object\nconsole.log(typeof stringObj); // object\n// 拆箱\nconsole.log(numberObj.valueOf()); // 64\nconsole.log(typeof numberObj.valueOf()); // number 基本的数字类型\nconsole.log(numberObj.toString()); // '64'\nconsole.log(typeof numberObj.toString()); // string 基本的字符类型\n\nconsole.log(stringObj.valueOf()); // '64'\nconsole.log(typeof stringObj.valueOf()); // string 基本的数据类型\nconsole.log(stringObj.toString()); // '64'\nconsole.log(typeof stringObj.toString()); // string 基本的数据类型\n```\n在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。\n\n这里简单介绍一下Symbol，感兴趣的可以自己去学习。\n\n###### Symbol\nSymbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突\n创建Symbol\n```JavaScript\nlet sym1 = Symbol();\nlet sym2 = Symbol('sym');\n```\n注意：\n1、每次调用Symbol都会创建新的symbol\n2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）\n3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身\n4、创建Symbol包装器对象，可以使用Object()函数\n```JavaScript\n// 1\nSymbol('sym') === Symbol('sym'); // false\n// 2\nlet sym = new Symbol(); // TypeError: Symbol is not a constructor\n// 4\nlet sym2 = Symbol('sym');\ntypeof sym2; // 'symbol'\nlet sym2Obj = Object(sym2);\ntypeof sym2Obj; // 'object'\n```\n在[symbol的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)中，有一个属性[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)。文档中关于它的介绍是：\n\nSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 \"number\"、\"string\" 和 \"default\" 中的任意一个。\n\n我们看一下这个属性是怎么干扰一个对象转换为原始值的\n```JavaScript\n// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果\nvar obj1 = {};\nconsole.log(+obj1);     // NaN\nconsole.log(`${obj1}`); // \"[object Object]\"\nconsole.log(obj1 + \"\"); // \"[object Object]\"\n\n// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果\nvar obj2 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint == \"number\") {\n      return 10;\n    }\n    if (hint == \"string\") {\n      return \"hello\";\n    }\n    return true;\n  }\n};\nconsole.log(+obj2);     // 10      -- hint 参数值是 \"number\"\nconsole.log(`${obj2}`); // \"hello\" -- hint 参数值是 \"string\"\nconsole.log(obj2 + \"\"); // \"true\"  -- hint 参数值是 \"default\"\n```\n注意：\nhint 取值为：\n'number':该场合需要转成数值，\n'string':该场合需要转成字符串，\n'default':该场合可以转成数值，也可以转成字符串。\n\n#### 对象转换成原始值的方法及执行顺序\n以下优先级从上到下依次降低\n1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法\n2、如果预期被转化成字符串类型时，则优先执行toString()方法\n3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法\n注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法\n```JavaScript\nvar obj = {\n  [Symbol.toPrimitive](hint) {\n    console.log(hint);\n    return 'symbol';\n  },\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj)); // string symbol\nconsole.log(Number(obj)); // number NaN\n\nvar obj1 = {\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj1)); // string\nconsole.log(Number(obj1)); // NaN\n\nvar obj2 = {\n  toString() {\n    return '1';\n  },\n};\nconsole.log(String(obj2)); // '1'\nconsole.log(Number(obj2)); // 1\n\nvar obj3 = {\n  valueOf() {\n    return '2';\n  }\n};\nconsole.log(Number(obj3)); // 2\nconsole.log(String(obj3)); // [object Object]\n```","source":"_posts/21-devan-operation.md","raw":"---\ntitle: 装箱拆箱操作\ndate: 2022-08-09 13:43:57\ntags:\n---\n\n我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：'hello world'.length。这是由于浏览器在内部做了装箱和拆箱操作。\n\n#### 什么是装箱拆箱？\n装箱：把基本数据类型转化为对应的引用类型的操作\n拆箱：把引用类型转化为基本数据类型的操作\n\n基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol\n引用数据类型：对象(Object)、数组(Array)、函数(Function)\n四个基本的包装类型 String、Number、Boolean、Symbol\n\n什么是包装类型？\n在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型\n\n#### 装箱\n装箱分为显式装箱和隐式装箱\n\n###### 显式装箱\n通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据\n```JavaScript\nvar string = new String('test_string');\nvar number = new Number(1);\n```\n显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中\n```JavaScript\nvar string = new String('test_string');\nstring.name = 'for test';\nstring.sayHi = function(){\n    console.log('this is test string');\n}\nconsole.log(string.name); // for test\nstring.sayHi(); // this is test string\n```\n\n###### 隐式装箱\n隐式装箱是引擎自动执行的\n基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：'test_string'.substring()、'test_string'.indexOf()等，这是由于浏览器在内部做了隐式装箱。\n\n下面以一个例子进行说明：\n```JavaScript\n// 第一步\nvar string = 'test_string';\n// 第二步\nvar result = string.substring(4);\nconsole.log(result); // _string\n```\n在上面这段代码里面实际的执行步骤是：\n1、先创建一个String类型的一个实例\n2、在实例中调用方法\n3、销毁这个实例\n```JavaScript\nvar string = 'test_string';\n// 1\nvar newString = new String(string);\n// 2\nvar result = newString.substring(4);\n// 3\nnewString = null;\n```\n基于以上的隐式装箱操作，我们可以在基本类型上使用方法\n隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了\n\n\n显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法\n\n引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。\n#### 拆箱\n拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。\n需要注意的是，toString() 和 valueOf() 返回的值有一定差别\n```JavaScript\nvar numberObj = new Number(64);\nvar stringObj = new String('64');\nconsole.log(typeof numberObj); // object\nconsole.log(typeof stringObj); // object\n// 拆箱\nconsole.log(numberObj.valueOf()); // 64\nconsole.log(typeof numberObj.valueOf()); // number 基本的数字类型\nconsole.log(numberObj.toString()); // '64'\nconsole.log(typeof numberObj.toString()); // string 基本的字符类型\n\nconsole.log(stringObj.valueOf()); // '64'\nconsole.log(typeof stringObj.valueOf()); // string 基本的数据类型\nconsole.log(stringObj.toString()); // '64'\nconsole.log(typeof stringObj.toString()); // string 基本的数据类型\n```\n在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。\n\n这里简单介绍一下Symbol，感兴趣的可以自己去学习。\n\n###### Symbol\nSymbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突\n创建Symbol\n```JavaScript\nlet sym1 = Symbol();\nlet sym2 = Symbol('sym');\n```\n注意：\n1、每次调用Symbol都会创建新的symbol\n2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）\n3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身\n4、创建Symbol包装器对象，可以使用Object()函数\n```JavaScript\n// 1\nSymbol('sym') === Symbol('sym'); // false\n// 2\nlet sym = new Symbol(); // TypeError: Symbol is not a constructor\n// 4\nlet sym2 = Symbol('sym');\ntypeof sym2; // 'symbol'\nlet sym2Obj = Object(sym2);\ntypeof sym2Obj; // 'object'\n```\n在[symbol的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)中，有一个属性[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)。文档中关于它的介绍是：\n\nSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 \"number\"、\"string\" 和 \"default\" 中的任意一个。\n\n我们看一下这个属性是怎么干扰一个对象转换为原始值的\n```JavaScript\n// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果\nvar obj1 = {};\nconsole.log(+obj1);     // NaN\nconsole.log(`${obj1}`); // \"[object Object]\"\nconsole.log(obj1 + \"\"); // \"[object Object]\"\n\n// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果\nvar obj2 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint == \"number\") {\n      return 10;\n    }\n    if (hint == \"string\") {\n      return \"hello\";\n    }\n    return true;\n  }\n};\nconsole.log(+obj2);     // 10      -- hint 参数值是 \"number\"\nconsole.log(`${obj2}`); // \"hello\" -- hint 参数值是 \"string\"\nconsole.log(obj2 + \"\"); // \"true\"  -- hint 参数值是 \"default\"\n```\n注意：\nhint 取值为：\n'number':该场合需要转成数值，\n'string':该场合需要转成字符串，\n'default':该场合可以转成数值，也可以转成字符串。\n\n#### 对象转换成原始值的方法及执行顺序\n以下优先级从上到下依次降低\n1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法\n2、如果预期被转化成字符串类型时，则优先执行toString()方法\n3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法\n注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法\n```JavaScript\nvar obj = {\n  [Symbol.toPrimitive](hint) {\n    console.log(hint);\n    return 'symbol';\n  },\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj)); // string symbol\nconsole.log(Number(obj)); // number NaN\n\nvar obj1 = {\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj1)); // string\nconsole.log(Number(obj1)); // NaN\n\nvar obj2 = {\n  toString() {\n    return '1';\n  },\n};\nconsole.log(String(obj2)); // '1'\nconsole.log(Number(obj2)); // 1\n\nvar obj3 = {\n  valueOf() {\n    return '2';\n  }\n};\nconsole.log(Number(obj3)); // 2\nconsole.log(String(obj3)); // [object Object]\n```","slug":"21-devan-operation","published":1,"updated":"2022-08-18T07:29:53.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pt000ik4tt27l580pc","content":"<p>我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。</p>\n<h4 id=\"什么是装箱拆箱？\"><a href=\"#什么是装箱拆箱？\" class=\"headerlink\" title=\"什么是装箱拆箱？\"></a>什么是装箱拆箱？</h4><p>装箱：把基本数据类型转化为对应的引用类型的操作<br>拆箱：把引用类型转化为基本数据类型的操作</p>\n<p>基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)<br>四个基本的包装类型 String、Number、Boolean、Symbol</p>\n<p>什么是包装类型？<br>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型</p>\n<h4 id=\"装箱\"><a href=\"#装箱\" class=\"headerlink\" title=\"装箱\"></a>装箱</h4><p>装箱分为显式装箱和隐式装箱</p>\n<h6 id=\"显式装箱\"><a href=\"#显式装箱\" class=\"headerlink\" title=\"显式装箱\"></a>显式装箱</h6><p>通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\">string.name = <span class=\"string\">&#x27;for test&#x27;</span>;</span><br><span class=\"line\">string.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;this is test string&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.name); <span class=\"comment\">// for test</span></span><br><span class=\"line\">string.sayHi(); <span class=\"comment\">// this is test string</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"隐式装箱\"><a href=\"#隐式装箱\" class=\"headerlink\" title=\"隐式装箱\"></a>隐式装箱</h6><p>隐式装箱是引擎自动执行的<br>基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：’test_string’.substring()、’test_string’.indexOf()等，这是由于浏览器在内部做了隐式装箱。</p>\n<p>下面以一个例子进行说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = string.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// _string</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码里面实际的执行步骤是：<br>1、先创建一个String类型的一个实例<br>2、在实例中调用方法<br>3、销毁这个实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(string);</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = newString.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">newString = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>基于以上的隐式装箱操作，我们可以在基本类型上使用方法<br>隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了</p>\n<p>显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法</p>\n<p>引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。</p>\n<h4 id=\"拆箱\"><a href=\"#拆箱\" class=\"headerlink\" title=\"拆箱\"></a>拆箱</h4><p>拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。<br>需要注意的是，toString() 和 valueOf() 返回的值有一定差别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numberObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">64</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> stringObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;64&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"comment\">// 拆箱</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.valueOf()); <span class=\"comment\">// 64</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.valueOf()); <span class=\"comment\">// number 基本的数字类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.toString()); <span class=\"comment\">// string 基本的字符类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.valueOf()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.valueOf()); <span class=\"comment\">// string 基本的数据类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.toString()); <span class=\"comment\">// string 基本的数据类型</span></span><br></pre></td></tr></table></figure>\n<p>在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。</p>\n<p>这里简单介绍一下Symbol，感兴趣的可以自己去学习。</p>\n<h6 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h6><p>Symbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突<br>创建Symbol</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：<br>1、每次调用Symbol都会创建新的symbol<br>2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）<br>3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身<br>4、创建Symbol包装器对象，可以使用Object()函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">// TypeError: Symbol is not a constructor</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2; <span class=\"comment\">// &#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2Obj = <span class=\"built_in\">Object</span>(sym2);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2Obj; <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">symbol的文档</a>中，有一个属性<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\">Symbol.toPrimitive</a>。文档中关于它的介绍是：</p>\n<p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 “number”、”string” 和 “default” 中的任意一个。</p>\n<p>我们看一下这个属性是怎么干扰一个对象转换为原始值的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj1);     <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj1&#125;</span>`</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj2);     <span class=\"comment\">// 10      -- hint 参数值是 &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj2&#125;</span>`</span>); <span class=\"comment\">// &quot;hello&quot; -- hint 参数值是 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;true&quot;  -- hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure>\n<p>注意：<br>hint 取值为：<br>‘number’:该场合需要转成数值，<br>‘string’:该场合需要转成字符串，<br>‘default’:该场合可以转成数值，也可以转成字符串。</p>\n<h4 id=\"对象转换成原始值的方法及执行顺序\"><a href=\"#对象转换成原始值的方法及执行顺序\" class=\"headerlink\" title=\"对象转换成原始值的方法及执行顺序\"></a>对象转换成原始值的方法及执行顺序</h4><p>以下优先级从上到下依次降低<br>1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法<br>2、如果预期被转化成字符串类型时，则优先执行toString()方法<br>3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法<br>注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(hint);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;symbol&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj)); <span class=\"comment\">// string symbol</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj)); <span class=\"comment\">// number NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj1)); <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj1)); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj2)); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj2)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj3)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj3)); <span class=\"comment\">// [object Object]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。</p>\n<h4 id=\"什么是装箱拆箱？\"><a href=\"#什么是装箱拆箱？\" class=\"headerlink\" title=\"什么是装箱拆箱？\"></a>什么是装箱拆箱？</h4><p>装箱：把基本数据类型转化为对应的引用类型的操作<br>拆箱：把引用类型转化为基本数据类型的操作</p>\n<p>基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)<br>四个基本的包装类型 String、Number、Boolean、Symbol</p>\n<p>什么是包装类型？<br>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型</p>\n<h4 id=\"装箱\"><a href=\"#装箱\" class=\"headerlink\" title=\"装箱\"></a>装箱</h4><p>装箱分为显式装箱和隐式装箱</p>\n<h6 id=\"显式装箱\"><a href=\"#显式装箱\" class=\"headerlink\" title=\"显式装箱\"></a>显式装箱</h6><p>通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\">string.name = <span class=\"string\">&#x27;for test&#x27;</span>;</span><br><span class=\"line\">string.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;this is test string&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.name); <span class=\"comment\">// for test</span></span><br><span class=\"line\">string.sayHi(); <span class=\"comment\">// this is test string</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"隐式装箱\"><a href=\"#隐式装箱\" class=\"headerlink\" title=\"隐式装箱\"></a>隐式装箱</h6><p>隐式装箱是引擎自动执行的<br>基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：’test_string’.substring()、’test_string’.indexOf()等，这是由于浏览器在内部做了隐式装箱。</p>\n<p>下面以一个例子进行说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = string.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// _string</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码里面实际的执行步骤是：<br>1、先创建一个String类型的一个实例<br>2、在实例中调用方法<br>3、销毁这个实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(string);</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = newString.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">newString = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>基于以上的隐式装箱操作，我们可以在基本类型上使用方法<br>隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了</p>\n<p>显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法</p>\n<p>引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。</p>\n<h4 id=\"拆箱\"><a href=\"#拆箱\" class=\"headerlink\" title=\"拆箱\"></a>拆箱</h4><p>拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。<br>需要注意的是，toString() 和 valueOf() 返回的值有一定差别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numberObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">64</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> stringObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;64&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"comment\">// 拆箱</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.valueOf()); <span class=\"comment\">// 64</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.valueOf()); <span class=\"comment\">// number 基本的数字类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.toString()); <span class=\"comment\">// string 基本的字符类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.valueOf()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.valueOf()); <span class=\"comment\">// string 基本的数据类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.toString()); <span class=\"comment\">// string 基本的数据类型</span></span><br></pre></td></tr></table></figure>\n<p>在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。</p>\n<p>这里简单介绍一下Symbol，感兴趣的可以自己去学习。</p>\n<h6 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h6><p>Symbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突<br>创建Symbol</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：<br>1、每次调用Symbol都会创建新的symbol<br>2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）<br>3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身<br>4、创建Symbol包装器对象，可以使用Object()函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">// TypeError: Symbol is not a constructor</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2; <span class=\"comment\">// &#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2Obj = <span class=\"built_in\">Object</span>(sym2);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2Obj; <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">symbol的文档</a>中，有一个属性<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\">Symbol.toPrimitive</a>。文档中关于它的介绍是：</p>\n<p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 “number”、”string” 和 “default” 中的任意一个。</p>\n<p>我们看一下这个属性是怎么干扰一个对象转换为原始值的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj1);     <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj1&#125;</span>`</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj2);     <span class=\"comment\">// 10      -- hint 参数值是 &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj2&#125;</span>`</span>); <span class=\"comment\">// &quot;hello&quot; -- hint 参数值是 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;true&quot;  -- hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure>\n<p>注意：<br>hint 取值为：<br>‘number’:该场合需要转成数值，<br>‘string’:该场合需要转成字符串，<br>‘default’:该场合可以转成数值，也可以转成字符串。</p>\n<h4 id=\"对象转换成原始值的方法及执行顺序\"><a href=\"#对象转换成原始值的方法及执行顺序\" class=\"headerlink\" title=\"对象转换成原始值的方法及执行顺序\"></a>对象转换成原始值的方法及执行顺序</h4><p>以下优先级从上到下依次降低<br>1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法<br>2、如果预期被转化成字符串类型时，则优先执行toString()方法<br>3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法<br>注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(hint);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;symbol&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj)); <span class=\"comment\">// string symbol</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj)); <span class=\"comment\">// number NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj1)); <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj1)); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj2)); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj2)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj3)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj3)); <span class=\"comment\">// [object Object]</span></span><br></pre></td></tr></table></figure>"},{"title":"基本数据类型-Symbol","date":"2022-08-19T05:37:24.000Z","_content":"\n#### 什么是Symbol?\n\n\n\n#### 有什么用处？\n\n#### Symbol的属性\n\n#### Symbol的方法\n","source":"_posts/22-about-symbol.md","raw":"---\ntitle: 基本数据类型-Symbol\ndate: 2022-08-19 13:37:24\ntags:\n---\n\n#### 什么是Symbol?\n\n\n\n#### 有什么用处？\n\n#### Symbol的属性\n\n#### Symbol的方法\n","slug":"22-about-symbol","published":1,"updated":"2022-08-19T05:42:42.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pt000jk4tt7ep43knm","content":"<h4 id=\"什么是Symbol\"><a href=\"#什么是Symbol\" class=\"headerlink\" title=\"什么是Symbol?\"></a>什么是Symbol?</h4><h4 id=\"有什么用处？\"><a href=\"#有什么用处？\" class=\"headerlink\" title=\"有什么用处？\"></a>有什么用处？</h4><h4 id=\"Symbol的属性\"><a href=\"#Symbol的属性\" class=\"headerlink\" title=\"Symbol的属性\"></a>Symbol的属性</h4><h4 id=\"Symbol的方法\"><a href=\"#Symbol的方法\" class=\"headerlink\" title=\"Symbol的方法\"></a>Symbol的方法</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Symbol\"><a href=\"#什么是Symbol\" class=\"headerlink\" title=\"什么是Symbol?\"></a>什么是Symbol?</h4><h4 id=\"有什么用处？\"><a href=\"#有什么用处？\" class=\"headerlink\" title=\"有什么用处？\"></a>有什么用处？</h4><h4 id=\"Symbol的属性\"><a href=\"#Symbol的属性\" class=\"headerlink\" title=\"Symbol的属性\"></a>Symbol的属性</h4><h4 id=\"Symbol的方法\"><a href=\"#Symbol的方法\" class=\"headerlink\" title=\"Symbol的方法\"></a>Symbol的方法</h4>"},{"title":"JavaScript设计模式读书笔记(1)","date":"2022-08-20T06:47:46.000Z","_content":"\n#### 面向对象\n一、面向过程与面向对象\n面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里\n二、封装\n1、使用原型(prototype)为类添加属性和方法的两种方式(**注意两种不能混用**)：\n(1)为原型对象属性赋值\n```javascript\nBook.prototype.display = function() {\n  // ....\n}\n```\n(2)将一个对象赋值给类的原型对象\n```javascript\nBook.prototype = {\n  display = function() {}\n}\n```\n\n2、使用this和原型(prototype)为类添加属性和方法的区别：\n(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建\n(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法\n\n3、constructor是什么？\nconstructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。\n![prototype](prototype.png)\n\n4、属性与方法的封装\n(1)私有属性与私有方法\n由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法\n(2)共有属性和共有方法\n在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法\n(3)特权方法(类的构造器)\n通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器\n![public-and-private](public-and-private.png)\n\n5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用\n(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法\n(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法\n![static-and-public](static-and-public.png)\n通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。\n\n6、闭包\n闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量\n\n7、创建对象的安全模式\nnew关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量\n![safe-model](safe-model.png)\n\n三、继承\n1、子类的原型对象 - 类式继承\n![class-inherit](class-inherit.png)\n声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型\n类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。\n新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理\n\n(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类\n注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n**instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass**\n\n(2)类式继承的缺点\n其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化\n\n2、创建即继承 - 构造函数继承\n![constructor-inherit](constructor-inherit.png)\nSuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则\n\n3、将优点为我所用 - 组合继承\n(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的\n![combination-inherit](combination-inherit.png)\n在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式\n(2)缺点\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍\n\n4、洁净的继承者 - 原型式继承\n![prototype-inherit](prototype-inherit.png)\n对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象\n![test-prototype-inherit](test-prototype-inherit.png)\n\n5、如虎添翼 - 寄生式继承\n![parasitic-inherit](parasitic-inherit.png)\n寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法\n\n6、终极继承者 - 寄生组合式继承\n寄生式继承和构造函数继承\n\n寄生式继承的改造\n![parasitic-inherit-change](parasitic-inherit-change.png)\n\n![parasitic-combination-inherit](parasitic-combination-inherit.png)\n\n![how-to-inherit](how-to-inherit.png)\n\n**子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象**\n\n四、多继承\n单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性\n![multiple-inherit](multiple-inherit.png)\n\n五、多态\n同一个方法多种调用方式\n![multiple-status](multiple-status.png)","source":"_posts/23-about-design-model.md","raw":"---\ntitle: JavaScript设计模式读书笔记(1)\ndate: 2022-08-20 14:47:46\ntags:\n---\n\n#### 面向对象\n一、面向过程与面向对象\n面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里\n二、封装\n1、使用原型(prototype)为类添加属性和方法的两种方式(**注意两种不能混用**)：\n(1)为原型对象属性赋值\n```javascript\nBook.prototype.display = function() {\n  // ....\n}\n```\n(2)将一个对象赋值给类的原型对象\n```javascript\nBook.prototype = {\n  display = function() {}\n}\n```\n\n2、使用this和原型(prototype)为类添加属性和方法的区别：\n(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建\n(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法\n\n3、constructor是什么？\nconstructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。\n![prototype](prototype.png)\n\n4、属性与方法的封装\n(1)私有属性与私有方法\n由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法\n(2)共有属性和共有方法\n在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法\n(3)特权方法(类的构造器)\n通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器\n![public-and-private](public-and-private.png)\n\n5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用\n(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法\n(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法\n![static-and-public](static-and-public.png)\n通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。\n\n6、闭包\n闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量\n\n7、创建对象的安全模式\nnew关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量\n![safe-model](safe-model.png)\n\n三、继承\n1、子类的原型对象 - 类式继承\n![class-inherit](class-inherit.png)\n声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型\n类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。\n新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理\n\n(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类\n注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n**instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass**\n\n(2)类式继承的缺点\n其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化\n\n2、创建即继承 - 构造函数继承\n![constructor-inherit](constructor-inherit.png)\nSuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则\n\n3、将优点为我所用 - 组合继承\n(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的\n![combination-inherit](combination-inherit.png)\n在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式\n(2)缺点\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍\n\n4、洁净的继承者 - 原型式继承\n![prototype-inherit](prototype-inherit.png)\n对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象\n![test-prototype-inherit](test-prototype-inherit.png)\n\n5、如虎添翼 - 寄生式继承\n![parasitic-inherit](parasitic-inherit.png)\n寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法\n\n6、终极继承者 - 寄生组合式继承\n寄生式继承和构造函数继承\n\n寄生式继承的改造\n![parasitic-inherit-change](parasitic-inherit-change.png)\n\n![parasitic-combination-inherit](parasitic-combination-inherit.png)\n\n![how-to-inherit](how-to-inherit.png)\n\n**子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象**\n\n四、多继承\n单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性\n![multiple-inherit](multiple-inherit.png)\n\n五、多态\n同一个方法多种调用方式\n![multiple-status](multiple-status.png)","slug":"23-about-design-model","published":1,"updated":"2022-09-22T09:15:58.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pt000kk4tth8kd5gio","content":"<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>一、面向过程与面向对象<br>面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里<br>二、封装<br>1、使用原型(prototype)为类添加属性和方法的两种方式(<strong>注意两种不能混用</strong>)：<br>(1)为原型对象属性赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype.display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)将一个对象赋值给类的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">  display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、使用this和原型(prototype)为类添加属性和方法的区别：<br>(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建<br>(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法</p>\n<p>3、constructor是什么？<br>constructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。<br><img src=\"/2022/08/20/23-about-design-model/prototype.png\" alt=\"prototype\"></p>\n<p>4、属性与方法的封装<br>(1)私有属性与私有方法<br>由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法<br>(2)共有属性和共有方法<br>在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法<br>(3)特权方法(类的构造器)<br>通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器<br><img src=\"/2022/08/20/23-about-design-model/public-and-private.png\" alt=\"public-and-private\"></p>\n<p>5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用<br>(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法<br>(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法<br><img src=\"/2022/08/20/23-about-design-model/static-and-public.png\" alt=\"static-and-public\"><br>通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。</p>\n<p>6、闭包<br>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量</p>\n<p>7、创建对象的安全模式<br>new关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量<br><img src=\"/2022/08/20/23-about-design-model/safe-model.png\" alt=\"safe-model\"></p>\n<p>三、继承<br>1、子类的原型对象 - 类式继承<br><img src=\"/2022/08/20/23-about-design-model/class-inherit.png\" alt=\"class-inherit\"><br>声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型<br>类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。<br>新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理</p>\n<p>(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类<br>注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构<br><strong>instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass</strong></p>\n<p>(2)类式继承的缺点<br>其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类<br>其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</p>\n<p>2、创建即继承 - 构造函数继承<br><img src=\"/2022/08/20/23-about-design-model/constructor-inherit.png\" alt=\"constructor-inherit\"><br>SuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则</p>\n<p>3、将优点为我所用 - 组合继承<br>(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的<br><img src=\"/2022/08/20/23-about-design-model/combination-inherit.png\" alt=\"combination-inherit\"><br>在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式<br>(2)缺点<br>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍</p>\n<p>4、洁净的继承者 - 原型式继承<br><img src=\"/2022/08/20/23-about-design-model/prototype-inherit.png\" alt=\"prototype-inherit\"><br>对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象<br><img src=\"/2022/08/20/23-about-design-model/test-prototype-inherit.png\" alt=\"test-prototype-inherit\"></p>\n<p>5、如虎添翼 - 寄生式继承<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit.png\" alt=\"parasitic-inherit\"><br>寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法</p>\n<p>6、终极继承者 - 寄生组合式继承<br>寄生式继承和构造函数继承</p>\n<p>寄生式继承的改造<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit-change.png\" alt=\"parasitic-inherit-change\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/parasitic-combination-inherit.png\" alt=\"parasitic-combination-inherit\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/how-to-inherit.png\" alt=\"how-to-inherit\"></p>\n<p><strong>子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象</strong></p>\n<p>四、多继承<br>单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性<br><img src=\"/2022/08/20/23-about-design-model/multiple-inherit.png\" alt=\"multiple-inherit\"></p>\n<p>五、多态<br>同一个方法多种调用方式<br><img src=\"/2022/08/20/23-about-design-model/multiple-status.png\" alt=\"multiple-status\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>一、面向过程与面向对象<br>面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里<br>二、封装<br>1、使用原型(prototype)为类添加属性和方法的两种方式(<strong>注意两种不能混用</strong>)：<br>(1)为原型对象属性赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype.display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)将一个对象赋值给类的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">  display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、使用this和原型(prototype)为类添加属性和方法的区别：<br>(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建<br>(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法</p>\n<p>3、constructor是什么？<br>constructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。<br><img src=\"/2022/08/20/23-about-design-model/prototype.png\" alt=\"prototype\"></p>\n<p>4、属性与方法的封装<br>(1)私有属性与私有方法<br>由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法<br>(2)共有属性和共有方法<br>在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法<br>(3)特权方法(类的构造器)<br>通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器<br><img src=\"/2022/08/20/23-about-design-model/public-and-private.png\" alt=\"public-and-private\"></p>\n<p>5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用<br>(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法<br>(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法<br><img src=\"/2022/08/20/23-about-design-model/static-and-public.png\" alt=\"static-and-public\"><br>通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。</p>\n<p>6、闭包<br>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量</p>\n<p>7、创建对象的安全模式<br>new关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量<br><img src=\"/2022/08/20/23-about-design-model/safe-model.png\" alt=\"safe-model\"></p>\n<p>三、继承<br>1、子类的原型对象 - 类式继承<br><img src=\"/2022/08/20/23-about-design-model/class-inherit.png\" alt=\"class-inherit\"><br>声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型<br>类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。<br>新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理</p>\n<p>(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类<br>注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构<br><strong>instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass</strong></p>\n<p>(2)类式继承的缺点<br>其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类<br>其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</p>\n<p>2、创建即继承 - 构造函数继承<br><img src=\"/2022/08/20/23-about-design-model/constructor-inherit.png\" alt=\"constructor-inherit\"><br>SuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则</p>\n<p>3、将优点为我所用 - 组合继承<br>(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的<br><img src=\"/2022/08/20/23-about-design-model/combination-inherit.png\" alt=\"combination-inherit\"><br>在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式<br>(2)缺点<br>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍</p>\n<p>4、洁净的继承者 - 原型式继承<br><img src=\"/2022/08/20/23-about-design-model/prototype-inherit.png\" alt=\"prototype-inherit\"><br>对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象<br><img src=\"/2022/08/20/23-about-design-model/test-prototype-inherit.png\" alt=\"test-prototype-inherit\"></p>\n<p>5、如虎添翼 - 寄生式继承<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit.png\" alt=\"parasitic-inherit\"><br>寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法</p>\n<p>6、终极继承者 - 寄生组合式继承<br>寄生式继承和构造函数继承</p>\n<p>寄生式继承的改造<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit-change.png\" alt=\"parasitic-inherit-change\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/parasitic-combination-inherit.png\" alt=\"parasitic-combination-inherit\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/how-to-inherit.png\" alt=\"how-to-inherit\"></p>\n<p><strong>子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象</strong></p>\n<p>四、多继承<br>单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性<br><img src=\"/2022/08/20/23-about-design-model/multiple-inherit.png\" alt=\"multiple-inherit\"></p>\n<p>五、多态<br>同一个方法多种调用方式<br><img src=\"/2022/08/20/23-about-design-model/multiple-status.png\" alt=\"multiple-status\"></p>\n"},{"title":"JavaScript设计模式读书笔记(2)","date":"2022-09-04T13:29:09.000Z","_content":"\n#### 创建型设计模式\n创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度\n\n###### 简单工厂模式\n(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。\n![simple-factory1](simple-factory1.png)\n![simple-factory2](simple-factory2.png)\n\n(2)一个对象有时也可代替许多类\n![create-pop](create-pop.png)\n\n第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了\n\n###### 工厂方法模式\n安全模式类：可以屏蔽使用这对类的错误使用造成的错误\n![safe-model-class](safe-model-class.png)\n![safe-factory-model](safe-factory-model.png)\n\n###### 抽象工厂模式\n抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例\n\n(1)抽象类\n抽象类是一种声明但不能使用的类\n![abstract-car](abstract-car.png)\n创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类\n中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。\n\n(2)抽象工厂模式：一般用它来作为父类创建一些子类\n![abstract-factory1](abstract-factory1.png)\n![abstract-factory2](abstract-factory2.png)\n抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck\n![abstract-factory3](abstract-factory3.png)\n\n###### 建造者模式\n建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示\n\n工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。\n建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节\n![human](human.png)\n![name](name.png)\n![work](work.png)\n![person](person.png)\n\n工厂模式创建出来的是一个对象，它追求的是创建的结果\n建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象\n\n**注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象**\n\n###### 原型模式\n原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法\n\n原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法\n![prototype-model](prototype-model.png)\n原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法\n\n(1)原型继承\n原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法\n![prototype-inherit1](prototype-inherit1.png)\n![prototype-inherit2](prototype-inherit2.png)\n\n**原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现**\n\n###### 单例模式\n单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法\n\n(1)命名空间\n命名空间就是人们所说的namespace，有人也叫它名称空间。\n它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题\n\n(2)静态变量\n![static-param](static-param.png)\n\n(3)惰性单例\n![lazy-single-instance](lazy-single-instance.png)","source":"_posts/24-about-design-model1.md","raw":"---\ntitle: JavaScript设计模式读书笔记(2)\ndate: 2022-09-04 21:29:09\ntags:\n---\n\n#### 创建型设计模式\n创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度\n\n###### 简单工厂模式\n(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。\n![simple-factory1](simple-factory1.png)\n![simple-factory2](simple-factory2.png)\n\n(2)一个对象有时也可代替许多类\n![create-pop](create-pop.png)\n\n第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了\n\n###### 工厂方法模式\n安全模式类：可以屏蔽使用这对类的错误使用造成的错误\n![safe-model-class](safe-model-class.png)\n![safe-factory-model](safe-factory-model.png)\n\n###### 抽象工厂模式\n抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例\n\n(1)抽象类\n抽象类是一种声明但不能使用的类\n![abstract-car](abstract-car.png)\n创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类\n中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。\n\n(2)抽象工厂模式：一般用它来作为父类创建一些子类\n![abstract-factory1](abstract-factory1.png)\n![abstract-factory2](abstract-factory2.png)\n抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck\n![abstract-factory3](abstract-factory3.png)\n\n###### 建造者模式\n建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示\n\n工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。\n建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节\n![human](human.png)\n![name](name.png)\n![work](work.png)\n![person](person.png)\n\n工厂模式创建出来的是一个对象，它追求的是创建的结果\n建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象\n\n**注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象**\n\n###### 原型模式\n原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法\n\n原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法\n![prototype-model](prototype-model.png)\n原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法\n\n(1)原型继承\n原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法\n![prototype-inherit1](prototype-inherit1.png)\n![prototype-inherit2](prototype-inherit2.png)\n\n**原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现**\n\n###### 单例模式\n单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法\n\n(1)命名空间\n命名空间就是人们所说的namespace，有人也叫它名称空间。\n它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题\n\n(2)静态变量\n![static-param](static-param.png)\n\n(3)惰性单例\n![lazy-single-instance](lazy-single-instance.png)","slug":"24-about-design-model1","published":1,"updated":"2022-09-22T09:16:30.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pu000lk4ttai5p9t2y","content":"<h4 id=\"创建型设计模式\"><a href=\"#创建型设计模式\" class=\"headerlink\" title=\"创建型设计模式\"></a>创建型设计模式</h4><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度</p>\n<h6 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h6><p>(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。<br><img src=\"/2022/09/04/24-about-design-model1/simple-factory1.png\" alt=\"simple-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/simple-factory2.png\" alt=\"simple-factory2\"></p>\n<p>(2)一个对象有时也可代替许多类<br><img src=\"/2022/09/04/24-about-design-model1/create-pop.png\" alt=\"create-pop\"></p>\n<p>第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了</p>\n<h6 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h6><p>安全模式类：可以屏蔽使用这对类的错误使用造成的错误<br><img src=\"/2022/09/04/24-about-design-model1/safe-model-class.png\" alt=\"safe-model-class\"><br><img src=\"/2022/09/04/24-about-design-model1/safe-factory-model.png\" alt=\"safe-factory-model\"></p>\n<h6 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h6><p>抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例</p>\n<p>(1)抽象类<br>抽象类是一种声明但不能使用的类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-car.png\" alt=\"abstract-car\"><br>创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类<br>中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。</p>\n<p>(2)抽象工厂模式：一般用它来作为父类创建一些子类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory1.png\" alt=\"abstract-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory2.png\" alt=\"abstract-factory2\"><br>抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory3.png\" alt=\"abstract-factory3\"></p>\n<h6 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h6><p>建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示</p>\n<p>工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。<br>建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节<br><img src=\"/2022/09/04/24-about-design-model1/human.png\" alt=\"human\"><br><img src=\"/2022/09/04/24-about-design-model1/name.png\" alt=\"name\"><br><img src=\"/2022/09/04/24-about-design-model1/work.png\" alt=\"work\"><br><img src=\"/2022/09/04/24-about-design-model1/person.png\" alt=\"person\"></p>\n<p>工厂模式创建出来的是一个对象，它追求的是创建的结果<br>建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象</p>\n<p><strong>注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象</strong></p>\n<h6 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h6><p>原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法</p>\n<p>原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-model.png\" alt=\"prototype-model\"><br>原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法</p>\n<p>(1)原型继承<br>原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit1.png\" alt=\"prototype-inherit1\"><br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit2.png\" alt=\"prototype-inherit2\"></p>\n<p><strong>原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现</strong></p>\n<h6 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h6><p>单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法</p>\n<p>(1)命名空间<br>命名空间就是人们所说的namespace，有人也叫它名称空间。<br>它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题</p>\n<p>(2)静态变量<br><img src=\"/2022/09/04/24-about-design-model1/static-param.png\" alt=\"static-param\"></p>\n<p>(3)惰性单例<br><img src=\"/2022/09/04/24-about-design-model1/lazy-single-instance.png\" alt=\"lazy-single-instance\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"创建型设计模式\"><a href=\"#创建型设计模式\" class=\"headerlink\" title=\"创建型设计模式\"></a>创建型设计模式</h4><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度</p>\n<h6 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h6><p>(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。<br><img src=\"/2022/09/04/24-about-design-model1/simple-factory1.png\" alt=\"simple-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/simple-factory2.png\" alt=\"simple-factory2\"></p>\n<p>(2)一个对象有时也可代替许多类<br><img src=\"/2022/09/04/24-about-design-model1/create-pop.png\" alt=\"create-pop\"></p>\n<p>第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了</p>\n<h6 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h6><p>安全模式类：可以屏蔽使用这对类的错误使用造成的错误<br><img src=\"/2022/09/04/24-about-design-model1/safe-model-class.png\" alt=\"safe-model-class\"><br><img src=\"/2022/09/04/24-about-design-model1/safe-factory-model.png\" alt=\"safe-factory-model\"></p>\n<h6 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h6><p>抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例</p>\n<p>(1)抽象类<br>抽象类是一种声明但不能使用的类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-car.png\" alt=\"abstract-car\"><br>创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类<br>中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。</p>\n<p>(2)抽象工厂模式：一般用它来作为父类创建一些子类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory1.png\" alt=\"abstract-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory2.png\" alt=\"abstract-factory2\"><br>抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory3.png\" alt=\"abstract-factory3\"></p>\n<h6 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h6><p>建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示</p>\n<p>工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。<br>建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节<br><img src=\"/2022/09/04/24-about-design-model1/human.png\" alt=\"human\"><br><img src=\"/2022/09/04/24-about-design-model1/name.png\" alt=\"name\"><br><img src=\"/2022/09/04/24-about-design-model1/work.png\" alt=\"work\"><br><img src=\"/2022/09/04/24-about-design-model1/person.png\" alt=\"person\"></p>\n<p>工厂模式创建出来的是一个对象，它追求的是创建的结果<br>建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象</p>\n<p><strong>注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象</strong></p>\n<h6 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h6><p>原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法</p>\n<p>原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-model.png\" alt=\"prototype-model\"><br>原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法</p>\n<p>(1)原型继承<br>原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit1.png\" alt=\"prototype-inherit1\"><br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit2.png\" alt=\"prototype-inherit2\"></p>\n<p><strong>原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现</strong></p>\n<h6 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h6><p>单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法</p>\n<p>(1)命名空间<br>命名空间就是人们所说的namespace，有人也叫它名称空间。<br>它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题</p>\n<p>(2)静态变量<br><img src=\"/2022/09/04/24-about-design-model1/static-param.png\" alt=\"static-param\"></p>\n<p>(3)惰性单例<br><img src=\"/2022/09/04/24-about-design-model1/lazy-single-instance.png\" alt=\"lazy-single-instance\"></p>\n"},{"title":"JavaScript设计模式读书笔记(3)","date":"2022-09-06T07:11:48.000Z","_content":"\n#### 结构型设计模式\n结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计\n\n###### 外观模式\n外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用\n\n多用于兼容模式\n![out-look](out-look.png)\n\n###### 适配器模式\n适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决\n\n(1)适配异类框架\n(2)参数适配器：通常是以一个参数对象方式传入\n(3)数据适配\n比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等\n(4)服务端数据适配\n获取接口的数据，先做一个适配，再使用统一的处理方法\n\n###### 代理模式\n代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用\n\n**代理对象**\n(1)img之类的标签通过src属性可以向其他域下的服务器发送请求\n缺点：请求是get请求，且是单向的，不会有响应数据\n示例：站长统计\n![station-culculate](station-culculate.png)\n\n(2)JSONP\n通过script标签\n需要其他域下的服务端配合前端做出针对处理\n\n(3)代理模板\n不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A\n\n###### 装修者模式\n装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求\n![decorator](decorator.png)\n\n**适配器与装修者的区别**\n适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节\n装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用\n\n###### 桥接模式\n桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦\n\n先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用\n\n![bridge1](bridge1.png)\n![bridge2](bridge2.png)\n![bridge3](bridge3.png)\n\n桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化\n\n###### 组合模式\n组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n组合模式常用语创建表单。\n\n###### 享元模式\n享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。\n\n享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。\n\n在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。","source":"_posts/25-about-design-model2.md","raw":"---\ntitle: JavaScript设计模式读书笔记(3)\ndate: 2022-09-06 15:11:48\ntags:\n---\n\n#### 结构型设计模式\n结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计\n\n###### 外观模式\n外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用\n\n多用于兼容模式\n![out-look](out-look.png)\n\n###### 适配器模式\n适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决\n\n(1)适配异类框架\n(2)参数适配器：通常是以一个参数对象方式传入\n(3)数据适配\n比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等\n(4)服务端数据适配\n获取接口的数据，先做一个适配，再使用统一的处理方法\n\n###### 代理模式\n代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用\n\n**代理对象**\n(1)img之类的标签通过src属性可以向其他域下的服务器发送请求\n缺点：请求是get请求，且是单向的，不会有响应数据\n示例：站长统计\n![station-culculate](station-culculate.png)\n\n(2)JSONP\n通过script标签\n需要其他域下的服务端配合前端做出针对处理\n\n(3)代理模板\n不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A\n\n###### 装修者模式\n装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求\n![decorator](decorator.png)\n\n**适配器与装修者的区别**\n适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节\n装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用\n\n###### 桥接模式\n桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦\n\n先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用\n\n![bridge1](bridge1.png)\n![bridge2](bridge2.png)\n![bridge3](bridge3.png)\n\n桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化\n\n###### 组合模式\n组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n组合模式常用语创建表单。\n\n###### 享元模式\n享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。\n\n享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。\n\n在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。","slug":"25-about-design-model2","published":1,"updated":"2022-09-22T09:16:44.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pu000mk4tt42nha5ly","content":"<h4 id=\"结构型设计模式\"><a href=\"#结构型设计模式\" class=\"headerlink\" title=\"结构型设计模式\"></a>结构型设计模式</h4><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计</p>\n<h6 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h6><p>外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用</p>\n<p>多用于兼容模式<br><img src=\"/2022/09/06/25-about-design-model2/out-look.png\" alt=\"out-look\"></p>\n<h6 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h6><p>适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决</p>\n<p>(1)适配异类框架<br>(2)参数适配器：通常是以一个参数对象方式传入<br>(3)数据适配<br>比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等<br>(4)服务端数据适配<br>获取接口的数据，先做一个适配，再使用统一的处理方法</p>\n<h6 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h6><p>代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用</p>\n<p><strong>代理对象</strong><br>(1)img之类的标签通过src属性可以向其他域下的服务器发送请求<br>缺点：请求是get请求，且是单向的，不会有响应数据<br>示例：站长统计<br><img src=\"/2022/09/06/25-about-design-model2/station-culculate.png\" alt=\"station-culculate\"></p>\n<p>(2)JSONP<br>通过script标签<br>需要其他域下的服务端配合前端做出针对处理</p>\n<p>(3)代理模板<br>不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A</p>\n<h6 id=\"装修者模式\"><a href=\"#装修者模式\" class=\"headerlink\" title=\"装修者模式\"></a>装修者模式</h6><p>装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求<br><img src=\"/2022/09/06/25-about-design-model2/decorator.png\" alt=\"decorator\"></p>\n<p><strong>适配器与装修者的区别</strong><br>适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节<br>装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用</p>\n<h6 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h6><p>桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦</p>\n<p>先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用</p>\n<p><img src=\"/2022/09/06/25-about-design-model2/bridge1.png\" alt=\"bridge1\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge2.png\" alt=\"bridge2\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge3.png\" alt=\"bridge3\"></p>\n<p>桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化</p>\n<h6 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h6><p>组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p>组合模式常用语创建表单。</p>\n<h6 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h6><p>享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>\n<p>享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。</p>\n<p>在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"结构型设计模式\"><a href=\"#结构型设计模式\" class=\"headerlink\" title=\"结构型设计模式\"></a>结构型设计模式</h4><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计</p>\n<h6 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h6><p>外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用</p>\n<p>多用于兼容模式<br><img src=\"/2022/09/06/25-about-design-model2/out-look.png\" alt=\"out-look\"></p>\n<h6 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h6><p>适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决</p>\n<p>(1)适配异类框架<br>(2)参数适配器：通常是以一个参数对象方式传入<br>(3)数据适配<br>比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等<br>(4)服务端数据适配<br>获取接口的数据，先做一个适配，再使用统一的处理方法</p>\n<h6 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h6><p>代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用</p>\n<p><strong>代理对象</strong><br>(1)img之类的标签通过src属性可以向其他域下的服务器发送请求<br>缺点：请求是get请求，且是单向的，不会有响应数据<br>示例：站长统计<br><img src=\"/2022/09/06/25-about-design-model2/station-culculate.png\" alt=\"station-culculate\"></p>\n<p>(2)JSONP<br>通过script标签<br>需要其他域下的服务端配合前端做出针对处理</p>\n<p>(3)代理模板<br>不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A</p>\n<h6 id=\"装修者模式\"><a href=\"#装修者模式\" class=\"headerlink\" title=\"装修者模式\"></a>装修者模式</h6><p>装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求<br><img src=\"/2022/09/06/25-about-design-model2/decorator.png\" alt=\"decorator\"></p>\n<p><strong>适配器与装修者的区别</strong><br>适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节<br>装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用</p>\n<h6 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h6><p>桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦</p>\n<p>先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用</p>\n<p><img src=\"/2022/09/06/25-about-design-model2/bridge1.png\" alt=\"bridge1\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge2.png\" alt=\"bridge2\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge3.png\" alt=\"bridge3\"></p>\n<p>桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化</p>\n<h6 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h6><p>组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p>组合模式常用语创建表单。</p>\n<h6 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h6><p>享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>\n<p>享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。</p>\n<p>在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。</p>\n"},{"title":"JavaScript设计模式读书笔记(4)","date":"2022-09-07T09:40:43.000Z","_content":"\n#### 行为型设计模式\n行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现\n\n###### 模板方法模式\n模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。\n\n多用于归一化组件\n\n![basic-model](basic-model.png)\n![inherit-model](inherit-model.png)\n![inherit-as-basic-model](inherit-as-basic-model.png)\n\n###### 观察者模式\n观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。\n\n观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法\n\n![observer](observer.png)\n![observer-regist](observer-regist.png)\n![observer-fire](observer-fire.png)\n![observer-remove](observer-remove.png)\n\n![regist-message](regist-message.png)\n![regist-change-num](regist-change-num.png)\n![add-message](add-message.png)\n\n###### 状态模式\n状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。\n\n状态模式简化了分支判断遍历逻辑\n\n![vote-status](vote-status.png)\n\n示例\n思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用\n![marry-state](marry-state.png)\n![marry-state1](marry-state1.png)\n\n###### 策略模式\n策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。\n\n**与状态模式异同点**\n相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用\n不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法\n\n![price-strategy](price-strategy.png)\n\n**策略模式的优点**\n第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。\n第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。\n第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。\n\n**策略模式的缺点**\n由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。\n由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费\n\n**优化分支语句的模式**\n工厂方法模式，状态模式与策略模式\n工厂方法模式：一种创建型模式，最终目的是创建对象。\n状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。\n策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。\n\n###### 职责链模式\n职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。\n\n示例\n![send-data](send-data.png)\n![deal-data](deal-data.png)\n![create-component](create-component.png)\n\n**缺点**\n职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费\n多个对象参与请求的传递，在代码调试时增加了调试成本\n\n###### 命令模式\n命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。\n命令模式常用于解耦\n![command-model-1](command-model-1.png)\n![command-model-2](command-model-2.png)\n![command-model-3](command-model-3.png)\n\n命令模式的优点:\n解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。\n命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。\n\n命令模式的缺点:\n命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。\n\n###### 访问者模式\n访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。\n\n![visitor-model](visitor-model.png)\n\n###### 中介者模式\n中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。\n\n(1)观察者模式与中介者模式的区别\n相同点\n都是通过消息的收发机制实现的\n差异点\n在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统\n中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者\n\n![mediator-model](mediator-model.png)\n\n###### 备忘录模式\n备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。\n\n![cache-model](cache-model.png)\n\n###### 迭代器模式\n迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。\n\n![iterator-model](iterator-model.png)\n\n###### 解释器模式\n解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。\n\n![explain-model-1](explain-model-1.png)\n![explain-model-2](explain-model-2.png)\n![explain-model-3](explain-model-3.png)\n\n解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是**能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的**。因为解释器要按照这套规则才能实现相应的功能。","source":"_posts/26-about-design-model3.md","raw":"---\ntitle: JavaScript设计模式读书笔记(4)\ndate: 2022-09-07 17:40:43\ntags:\n---\n\n#### 行为型设计模式\n行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现\n\n###### 模板方法模式\n模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。\n\n多用于归一化组件\n\n![basic-model](basic-model.png)\n![inherit-model](inherit-model.png)\n![inherit-as-basic-model](inherit-as-basic-model.png)\n\n###### 观察者模式\n观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。\n\n观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法\n\n![observer](observer.png)\n![observer-regist](observer-regist.png)\n![observer-fire](observer-fire.png)\n![observer-remove](observer-remove.png)\n\n![regist-message](regist-message.png)\n![regist-change-num](regist-change-num.png)\n![add-message](add-message.png)\n\n###### 状态模式\n状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。\n\n状态模式简化了分支判断遍历逻辑\n\n![vote-status](vote-status.png)\n\n示例\n思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用\n![marry-state](marry-state.png)\n![marry-state1](marry-state1.png)\n\n###### 策略模式\n策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。\n\n**与状态模式异同点**\n相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用\n不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法\n\n![price-strategy](price-strategy.png)\n\n**策略模式的优点**\n第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。\n第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。\n第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。\n\n**策略模式的缺点**\n由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。\n由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费\n\n**优化分支语句的模式**\n工厂方法模式，状态模式与策略模式\n工厂方法模式：一种创建型模式，最终目的是创建对象。\n状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。\n策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。\n\n###### 职责链模式\n职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。\n\n示例\n![send-data](send-data.png)\n![deal-data](deal-data.png)\n![create-component](create-component.png)\n\n**缺点**\n职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费\n多个对象参与请求的传递，在代码调试时增加了调试成本\n\n###### 命令模式\n命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。\n命令模式常用于解耦\n![command-model-1](command-model-1.png)\n![command-model-2](command-model-2.png)\n![command-model-3](command-model-3.png)\n\n命令模式的优点:\n解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。\n命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。\n\n命令模式的缺点:\n命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。\n\n###### 访问者模式\n访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。\n\n![visitor-model](visitor-model.png)\n\n###### 中介者模式\n中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。\n\n(1)观察者模式与中介者模式的区别\n相同点\n都是通过消息的收发机制实现的\n差异点\n在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统\n中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者\n\n![mediator-model](mediator-model.png)\n\n###### 备忘录模式\n备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。\n\n![cache-model](cache-model.png)\n\n###### 迭代器模式\n迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。\n\n![iterator-model](iterator-model.png)\n\n###### 解释器模式\n解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。\n\n![explain-model-1](explain-model-1.png)\n![explain-model-2](explain-model-2.png)\n![explain-model-3](explain-model-3.png)\n\n解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是**能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的**。因为解释器要按照这套规则才能实现相应的功能。","slug":"26-about-design-model3","published":1,"updated":"2022-09-22T09:17:06.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pv000nk4tt0fqs7x6a","content":"<h4 id=\"行为型设计模式\"><a href=\"#行为型设计模式\" class=\"headerlink\" title=\"行为型设计模式\"></a>行为型设计模式</h4><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现</p>\n<h6 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h6><p>模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。</p>\n<p>多用于归一化组件</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/basic-model.png\" alt=\"basic-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-model.png\" alt=\"inherit-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-as-basic-model.png\" alt=\"inherit-as-basic-model\"></p>\n<h6 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h6><p>观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>\n<p>观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/observer.png\" alt=\"observer\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-regist.png\" alt=\"observer-regist\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-fire.png\" alt=\"observer-fire\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-remove.png\" alt=\"observer-remove\"></p>\n<p><img src=\"/2022/09/07/26-about-design-model3/regist-message.png\" alt=\"regist-message\"><br><img src=\"/2022/09/07/26-about-design-model3/regist-change-num.png\" alt=\"regist-change-num\"><br><img src=\"/2022/09/07/26-about-design-model3/add-message.png\" alt=\"add-message\"></p>\n<h6 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h6><p>状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>\n<p>状态模式简化了分支判断遍历逻辑</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/vote-status.png\" alt=\"vote-status\"></p>\n<p>示例<br>思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用<br><img src=\"/2022/09/07/26-about-design-model3/marry-state.png\" alt=\"marry-state\"><br><img src=\"/2022/09/07/26-about-design-model3/marry-state1.png\" alt=\"marry-state1\"></p>\n<h6 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h6><p>策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>\n<p><strong>与状态模式异同点</strong><br>相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用<br>不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/price-strategy.png\" alt=\"price-strategy\"></p>\n<p><strong>策略模式的优点</strong><br>第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。<br>第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。<br>第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。</p>\n<p><strong>策略模式的缺点</strong><br>由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。<br>由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费</p>\n<p><strong>优化分支语句的模式</strong><br>工厂方法模式，状态模式与策略模式<br>工厂方法模式：一种创建型模式，最终目的是创建对象。<br>状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。<br>策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。</p>\n<h6 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h6><p>职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。</p>\n<p>示例<br><img src=\"/2022/09/07/26-about-design-model3/send-data.png\" alt=\"send-data\"><br><img src=\"/2022/09/07/26-about-design-model3/deal-data.png\" alt=\"deal-data\"><br><img src=\"/2022/09/07/26-about-design-model3/create-component.png\" alt=\"create-component\"></p>\n<p><strong>缺点</strong><br>职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费<br>多个对象参与请求的传递，在代码调试时增加了调试成本</p>\n<h6 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h6><p>命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。<br>命令模式常用于解耦<br><img src=\"/2022/09/07/26-about-design-model3/command-model-1.png\" alt=\"command-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-2.png\" alt=\"command-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-3.png\" alt=\"command-model-3\"></p>\n<p>命令模式的优点:<br>解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。<br>命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。</p>\n<p>命令模式的缺点:<br>命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。</p>\n<h6 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h6><p>访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/visitor-model.png\" alt=\"visitor-model\"></p>\n<h6 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h6><p>中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。</p>\n<p>(1)观察者模式与中介者模式的区别<br>相同点<br>都是通过消息的收发机制实现的<br>差异点<br>在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统<br>中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/mediator-model.png\" alt=\"mediator-model\"></p>\n<h6 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h6><p>备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/cache-model.png\" alt=\"cache-model\"></p>\n<h6 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h6><p>迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/iterator-model.png\" alt=\"iterator-model\"></p>\n<h6 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h6><p>解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/explain-model-1.png\" alt=\"explain-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-2.png\" alt=\"explain-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-3.png\" alt=\"explain-model-3\"></p>\n<p>解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是<strong>能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的</strong>。因为解释器要按照这套规则才能实现相应的功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"行为型设计模式\"><a href=\"#行为型设计模式\" class=\"headerlink\" title=\"行为型设计模式\"></a>行为型设计模式</h4><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现</p>\n<h6 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h6><p>模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。</p>\n<p>多用于归一化组件</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/basic-model.png\" alt=\"basic-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-model.png\" alt=\"inherit-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-as-basic-model.png\" alt=\"inherit-as-basic-model\"></p>\n<h6 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h6><p>观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>\n<p>观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/observer.png\" alt=\"observer\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-regist.png\" alt=\"observer-regist\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-fire.png\" alt=\"observer-fire\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-remove.png\" alt=\"observer-remove\"></p>\n<p><img src=\"/2022/09/07/26-about-design-model3/regist-message.png\" alt=\"regist-message\"><br><img src=\"/2022/09/07/26-about-design-model3/regist-change-num.png\" alt=\"regist-change-num\"><br><img src=\"/2022/09/07/26-about-design-model3/add-message.png\" alt=\"add-message\"></p>\n<h6 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h6><p>状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>\n<p>状态模式简化了分支判断遍历逻辑</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/vote-status.png\" alt=\"vote-status\"></p>\n<p>示例<br>思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用<br><img src=\"/2022/09/07/26-about-design-model3/marry-state.png\" alt=\"marry-state\"><br><img src=\"/2022/09/07/26-about-design-model3/marry-state1.png\" alt=\"marry-state1\"></p>\n<h6 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h6><p>策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>\n<p><strong>与状态模式异同点</strong><br>相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用<br>不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/price-strategy.png\" alt=\"price-strategy\"></p>\n<p><strong>策略模式的优点</strong><br>第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。<br>第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。<br>第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。</p>\n<p><strong>策略模式的缺点</strong><br>由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。<br>由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费</p>\n<p><strong>优化分支语句的模式</strong><br>工厂方法模式，状态模式与策略模式<br>工厂方法模式：一种创建型模式，最终目的是创建对象。<br>状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。<br>策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。</p>\n<h6 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h6><p>职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。</p>\n<p>示例<br><img src=\"/2022/09/07/26-about-design-model3/send-data.png\" alt=\"send-data\"><br><img src=\"/2022/09/07/26-about-design-model3/deal-data.png\" alt=\"deal-data\"><br><img src=\"/2022/09/07/26-about-design-model3/create-component.png\" alt=\"create-component\"></p>\n<p><strong>缺点</strong><br>职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费<br>多个对象参与请求的传递，在代码调试时增加了调试成本</p>\n<h6 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h6><p>命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。<br>命令模式常用于解耦<br><img src=\"/2022/09/07/26-about-design-model3/command-model-1.png\" alt=\"command-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-2.png\" alt=\"command-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-3.png\" alt=\"command-model-3\"></p>\n<p>命令模式的优点:<br>解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。<br>命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。</p>\n<p>命令模式的缺点:<br>命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。</p>\n<h6 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h6><p>访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/visitor-model.png\" alt=\"visitor-model\"></p>\n<h6 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h6><p>中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。</p>\n<p>(1)观察者模式与中介者模式的区别<br>相同点<br>都是通过消息的收发机制实现的<br>差异点<br>在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统<br>中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/mediator-model.png\" alt=\"mediator-model\"></p>\n<h6 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h6><p>备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/cache-model.png\" alt=\"cache-model\"></p>\n<h6 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h6><p>迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/iterator-model.png\" alt=\"iterator-model\"></p>\n<h6 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h6><p>解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/explain-model-1.png\" alt=\"explain-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-2.png\" alt=\"explain-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-3.png\" alt=\"explain-model-3\"></p>\n<p>解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是<strong>能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的</strong>。因为解释器要按照这套规则才能实现相应的功能。</p>\n"},{"title":"JavaScript设计模式读书笔记(5)","date":"2022-09-19T09:51:10.000Z","_content":"\n#### 技巧型设计模式\n技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。\n\n###### 链模式\n链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。\n\n![chain-model-1](chain-model-1.png)\n![chain-model-2](chain-model-2.png)\n![chain-model-3](chain-model-3.png)\n\njOuery获取的元素更像一个数组，上面框架返回的更像是一个对象\n原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了\n![chain-model-4](chain-model-4.png)\n\n![chain-model-5](chain-model-5.png)\n![chain-model-6](chain-model-6.png)\n\n###### 委托模式\n委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。\n\n委托模式可以优化页面中事件的数量。\n\n事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑\n\n![entrust-model-1](entrust-model-1.png)\n![entrust-model-2](entrust-model-2.png)\n\n###### 数据访问对象模式\n数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。\n\n![localstorage-model-1](localstorage-model-1.png)\n![localstorage-model-2](localstorage-model-2.png)\n![localstorage-model-3](localstorage-model-3.png)\n![localstorage-model-4](localstorage-model-4.png)\n![localstorage-model-5](localstorage-model-5.png)\n![localstorage-model-6](localstorage-model-6.png)\n\n###### 节流模式\n节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。\n\n![throttle-model-1](throttle-model-1.png)\n![throttle-model-2](throttle-model-2.png)\n![throttle-model-3](throttle-model-3.png)\n\n节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。\n\n节流模式优势\n(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行\n(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。\n\n###### 简单模板模式\n简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。\n\n![template-model-1](template-model-1.png)\n![template-model-2](template-model-2.png)\n![template-model-3](template-model-3.png)\n![template-model-4](template-model-4.png)\n![template-model-5](template-model-5.png)\n![template-model-6](template-model-6.png)\n\n###### 惰性模式\n惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。\n\n两种实现方式\n(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。\n(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗\n\n![lazy-model-1](lazy-model-1.png)\n![lazy-model-2](lazy-model-2.png)\n![lazy-model-3](lazy-model-3.png)\n![lazy-model-4](lazy-model-4.png)\n![lazy-model-5](lazy-model-5.png)\n![lazy-model-6](lazy-model-6.png)\n\n###### 参与者模式\n参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。\n\n![participate-model-1](participate-model-1.png)\n![participate-model-2](participate-model-2.png)\n\n函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能\n\n![participate-model-3](participate-model-3.png)\n![participate-model-4](participate-model-4.png)\n![participate-model-5](participate-model-5.png)\n\n参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化\n(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。\n(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。\n\n随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用\n![participate-model-6](participate-model-6.png)\n\n###### 等待者模式\n等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。\n\n![waiter-model-1](waiter-model-1.png)\n![waiter-model-2](waiter-model-2.png)\n![waiter-model-3](waiter-model-3.png)\n![waiter-model-4](waiter-model-4.png)\n![waiter-model-5](waiter-model-5.png)\n![waiter-model-6](waiter-model-6.png)\n![waiter-model-7](waiter-model-7.png)\n![waiter-model-8](waiter-model-8.png)\n\n","source":"_posts/27-about-design-model4.md","raw":"---\ntitle: JavaScript设计模式读书笔记(5)\ndate: 2022-09-19 17:51:10\ntags:\n---\n\n#### 技巧型设计模式\n技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。\n\n###### 链模式\n链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。\n\n![chain-model-1](chain-model-1.png)\n![chain-model-2](chain-model-2.png)\n![chain-model-3](chain-model-3.png)\n\njOuery获取的元素更像一个数组，上面框架返回的更像是一个对象\n原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了\n![chain-model-4](chain-model-4.png)\n\n![chain-model-5](chain-model-5.png)\n![chain-model-6](chain-model-6.png)\n\n###### 委托模式\n委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。\n\n委托模式可以优化页面中事件的数量。\n\n事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑\n\n![entrust-model-1](entrust-model-1.png)\n![entrust-model-2](entrust-model-2.png)\n\n###### 数据访问对象模式\n数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。\n\n![localstorage-model-1](localstorage-model-1.png)\n![localstorage-model-2](localstorage-model-2.png)\n![localstorage-model-3](localstorage-model-3.png)\n![localstorage-model-4](localstorage-model-4.png)\n![localstorage-model-5](localstorage-model-5.png)\n![localstorage-model-6](localstorage-model-6.png)\n\n###### 节流模式\n节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。\n\n![throttle-model-1](throttle-model-1.png)\n![throttle-model-2](throttle-model-2.png)\n![throttle-model-3](throttle-model-3.png)\n\n节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。\n\n节流模式优势\n(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行\n(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。\n\n###### 简单模板模式\n简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。\n\n![template-model-1](template-model-1.png)\n![template-model-2](template-model-2.png)\n![template-model-3](template-model-3.png)\n![template-model-4](template-model-4.png)\n![template-model-5](template-model-5.png)\n![template-model-6](template-model-6.png)\n\n###### 惰性模式\n惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。\n\n两种实现方式\n(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。\n(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗\n\n![lazy-model-1](lazy-model-1.png)\n![lazy-model-2](lazy-model-2.png)\n![lazy-model-3](lazy-model-3.png)\n![lazy-model-4](lazy-model-4.png)\n![lazy-model-5](lazy-model-5.png)\n![lazy-model-6](lazy-model-6.png)\n\n###### 参与者模式\n参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。\n\n![participate-model-1](participate-model-1.png)\n![participate-model-2](participate-model-2.png)\n\n函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能\n\n![participate-model-3](participate-model-3.png)\n![participate-model-4](participate-model-4.png)\n![participate-model-5](participate-model-5.png)\n\n参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化\n(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。\n(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。\n\n随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用\n![participate-model-6](participate-model-6.png)\n\n###### 等待者模式\n等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。\n\n![waiter-model-1](waiter-model-1.png)\n![waiter-model-2](waiter-model-2.png)\n![waiter-model-3](waiter-model-3.png)\n![waiter-model-4](waiter-model-4.png)\n![waiter-model-5](waiter-model-5.png)\n![waiter-model-6](waiter-model-6.png)\n![waiter-model-7](waiter-model-7.png)\n![waiter-model-8](waiter-model-8.png)\n\n","slug":"27-about-design-model4","published":1,"updated":"2022-09-23T06:51:25.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pv000ok4ttc0g75m9t","content":"<h4 id=\"技巧型设计模式\"><a href=\"#技巧型设计模式\" class=\"headerlink\" title=\"技巧型设计模式\"></a>技巧型设计模式</h4><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。</p>\n<h6 id=\"链模式\"><a href=\"#链模式\" class=\"headerlink\" title=\"链模式\"></a>链模式</h6><p>链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-1.png\" alt=\"chain-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-2.png\" alt=\"chain-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-3.png\" alt=\"chain-model-3\"></p>\n<p>jOuery获取的元素更像一个数组，上面框架返回的更像是一个对象<br>原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了<br><img src=\"/2022/09/19/27-about-design-model4/chain-model-4.png\" alt=\"chain-model-4\"></p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-5.png\" alt=\"chain-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-6.png\" alt=\"chain-model-6\"></p>\n<h6 id=\"委托模式\"><a href=\"#委托模式\" class=\"headerlink\" title=\"委托模式\"></a>委托模式</h6><p>委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。</p>\n<p>委托模式可以优化页面中事件的数量。</p>\n<p>事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/entrust-model-1.png\" alt=\"entrust-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/entrust-model-2.png\" alt=\"entrust-model-2\"></p>\n<h6 id=\"数据访问对象模式\"><a href=\"#数据访问对象模式\" class=\"headerlink\" title=\"数据访问对象模式\"></a>数据访问对象模式</h6><p>数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-1.png\" alt=\"localstorage-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-2.png\" alt=\"localstorage-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-3.png\" alt=\"localstorage-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-4.png\" alt=\"localstorage-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-5.png\" alt=\"localstorage-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-6.png\" alt=\"localstorage-model-6\"></p>\n<h6 id=\"节流模式\"><a href=\"#节流模式\" class=\"headerlink\" title=\"节流模式\"></a>节流模式</h6><p>节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/throttle-model-1.png\" alt=\"throttle-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-2.png\" alt=\"throttle-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-3.png\" alt=\"throttle-model-3\"></p>\n<p>节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。</p>\n<p>节流模式优势<br>(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行<br>(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。</p>\n<h6 id=\"简单模板模式\"><a href=\"#简单模板模式\" class=\"headerlink\" title=\"简单模板模式\"></a>简单模板模式</h6><p>简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/template-model-1.png\" alt=\"template-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-2.png\" alt=\"template-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-3.png\" alt=\"template-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-4.png\" alt=\"template-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-5.png\" alt=\"template-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-6.png\" alt=\"template-model-6\"></p>\n<h6 id=\"惰性模式\"><a href=\"#惰性模式\" class=\"headerlink\" title=\"惰性模式\"></a>惰性模式</h6><p>惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。</p>\n<p>两种实现方式<br>(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。<br>(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/lazy-model-1.png\" alt=\"lazy-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-2.png\" alt=\"lazy-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-3.png\" alt=\"lazy-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-4.png\" alt=\"lazy-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-5.png\" alt=\"lazy-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-6.png\" alt=\"lazy-model-6\"></p>\n<h6 id=\"参与者模式\"><a href=\"#参与者模式\" class=\"headerlink\" title=\"参与者模式\"></a>参与者模式</h6><p>参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-1.png\" alt=\"participate-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-2.png\" alt=\"participate-model-2\"></p>\n<p>函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-3.png\" alt=\"participate-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-4.png\" alt=\"participate-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-5.png\" alt=\"participate-model-5\"></p>\n<p>参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化<br>(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。<br>(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。</p>\n<p>随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用<br><img src=\"/2022/09/19/27-about-design-model4/participate-model-6.png\" alt=\"participate-model-6\"></p>\n<h6 id=\"等待者模式\"><a href=\"#等待者模式\" class=\"headerlink\" title=\"等待者模式\"></a>等待者模式</h6><p>等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/waiter-model-1.png\" alt=\"waiter-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-2.png\" alt=\"waiter-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-3.png\" alt=\"waiter-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-4.png\" alt=\"waiter-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-5.png\" alt=\"waiter-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-6.png\" alt=\"waiter-model-6\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-7.png\" alt=\"waiter-model-7\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-8.png\" alt=\"waiter-model-8\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"技巧型设计模式\"><a href=\"#技巧型设计模式\" class=\"headerlink\" title=\"技巧型设计模式\"></a>技巧型设计模式</h4><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。</p>\n<h6 id=\"链模式\"><a href=\"#链模式\" class=\"headerlink\" title=\"链模式\"></a>链模式</h6><p>链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-1.png\" alt=\"chain-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-2.png\" alt=\"chain-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-3.png\" alt=\"chain-model-3\"></p>\n<p>jOuery获取的元素更像一个数组，上面框架返回的更像是一个对象<br>原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了<br><img src=\"/2022/09/19/27-about-design-model4/chain-model-4.png\" alt=\"chain-model-4\"></p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-5.png\" alt=\"chain-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-6.png\" alt=\"chain-model-6\"></p>\n<h6 id=\"委托模式\"><a href=\"#委托模式\" class=\"headerlink\" title=\"委托模式\"></a>委托模式</h6><p>委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。</p>\n<p>委托模式可以优化页面中事件的数量。</p>\n<p>事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/entrust-model-1.png\" alt=\"entrust-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/entrust-model-2.png\" alt=\"entrust-model-2\"></p>\n<h6 id=\"数据访问对象模式\"><a href=\"#数据访问对象模式\" class=\"headerlink\" title=\"数据访问对象模式\"></a>数据访问对象模式</h6><p>数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-1.png\" alt=\"localstorage-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-2.png\" alt=\"localstorage-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-3.png\" alt=\"localstorage-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-4.png\" alt=\"localstorage-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-5.png\" alt=\"localstorage-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-6.png\" alt=\"localstorage-model-6\"></p>\n<h6 id=\"节流模式\"><a href=\"#节流模式\" class=\"headerlink\" title=\"节流模式\"></a>节流模式</h6><p>节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/throttle-model-1.png\" alt=\"throttle-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-2.png\" alt=\"throttle-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-3.png\" alt=\"throttle-model-3\"></p>\n<p>节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。</p>\n<p>节流模式优势<br>(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行<br>(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。</p>\n<h6 id=\"简单模板模式\"><a href=\"#简单模板模式\" class=\"headerlink\" title=\"简单模板模式\"></a>简单模板模式</h6><p>简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/template-model-1.png\" alt=\"template-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-2.png\" alt=\"template-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-3.png\" alt=\"template-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-4.png\" alt=\"template-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-5.png\" alt=\"template-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-6.png\" alt=\"template-model-6\"></p>\n<h6 id=\"惰性模式\"><a href=\"#惰性模式\" class=\"headerlink\" title=\"惰性模式\"></a>惰性模式</h6><p>惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。</p>\n<p>两种实现方式<br>(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。<br>(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/lazy-model-1.png\" alt=\"lazy-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-2.png\" alt=\"lazy-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-3.png\" alt=\"lazy-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-4.png\" alt=\"lazy-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-5.png\" alt=\"lazy-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-6.png\" alt=\"lazy-model-6\"></p>\n<h6 id=\"参与者模式\"><a href=\"#参与者模式\" class=\"headerlink\" title=\"参与者模式\"></a>参与者模式</h6><p>参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-1.png\" alt=\"participate-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-2.png\" alt=\"participate-model-2\"></p>\n<p>函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-3.png\" alt=\"participate-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-4.png\" alt=\"participate-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-5.png\" alt=\"participate-model-5\"></p>\n<p>参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化<br>(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。<br>(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。</p>\n<p>随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用<br><img src=\"/2022/09/19/27-about-design-model4/participate-model-6.png\" alt=\"participate-model-6\"></p>\n<h6 id=\"等待者模式\"><a href=\"#等待者模式\" class=\"headerlink\" title=\"等待者模式\"></a>等待者模式</h6><p>等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/waiter-model-1.png\" alt=\"waiter-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-2.png\" alt=\"waiter-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-3.png\" alt=\"waiter-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-4.png\" alt=\"waiter-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-5.png\" alt=\"waiter-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-6.png\" alt=\"waiter-model-6\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-7.png\" alt=\"waiter-model-7\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-8.png\" alt=\"waiter-model-8\"></p>\n"},{"title":"JavaScript设计模式读书笔记(6)","date":"2022-09-20T07:22:12.000Z","_content":"\n#### 架构型设计模式\n架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。\n\n###### 同步模块模式\n模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。\n同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。\n\n(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。\n\n![module-model-1](module-model-1.png)\n![module-model-2](module-model-2.png)\n![module-model-3](module-model-3.png)\n![module-model-4](module-model-4.png)\n![module-model-5](module-model-5.png)\n\n###### 异步模块模式\n异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。\n\n![async-module-model-1](async-module-model-1.png)\n![async-module-model-2](async-module-model-2.png)\n![async-module-model-3](async-module-model-3.png)\n![async-module-model-4](async-module-model-4.png)\n![async-module-model-5](async-module-model-5.png)\n![async-module-model-6](async-module-model-6.png)\n![async-module-model-7](async-module-model-7.png)\n![async-module-model-8](async-module-model-8.png)\n![async-module-model-9](async-module-model-9.png)\n\n###### Widget模式\nWidget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。\n\n![widget-model-1](widget-model-1.png)\n![widget-model-2](widget-model-2.png)\n![widget-model-3](widget-model-3.png)\n![widget-model-4](widget-model-4.png)\n![widget-model-5](widget-model-5.png)\n![widget-model-6](widget-model-6.png)\n\n###### MVC模式\nMVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。\n\n![mvc-model-1](mvc-model-1.png)\n\n**每个对象是一个自动执行的函数**\n**3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法**\n\n![mvc-model-2](mvc-model-2.png)\n![mvc-model-3](mvc-model-3.png)\n视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口\n\n![mvc-model-4](mvc-model-4.png)\n\n###### MVP模式\nMVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。\n\n![mvp-model-1](mvp-model-1.png)\n![mvp-model-2](mvp-model-2.png)\n![mvp-model-3](mvp-model-3.png)\n![mvp-model-4](mvp-model-4.png)\n![mvp-model-5](mvp-model-5.png)\n![mvp-model-6](mvp-model-6.png)\n![mvp-model-7](mvp-model-7.png)\n\nMVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。\n\n###### MVVM模式\nMVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。\n\n![mvvm-model-1](mvvm-model-1.png)\n![mvvm-model-2](mvvm-model-2.png)\n![mvvm-model-3](mvvm-model-3.png)\n![mvvm-model-4](mvvm-model-4.png)\n![mvvm-model-5](mvvm-model-5.png)\n![mvvm-model-6](mvvm-model-6.png)\n![mvvm-model-7](mvvm-model-7.png)\n![mvvm-model-8](mvvm-model-8.png)\n\n###### 附录\n![appendix-1](appendix-1.png)\n![appendix-2](appendix-2.png)\n![appendix-3](appendix-3.png)\n![appendix-4](appendix-4.png)\n![appendix-5](appendix-5.png)\n![appendix-6](appendix-6.png)\n![appendix-7](appendix-7.png)\n![appendix-8](appendix-8.png)\n![appendix-9](appendix-9.png)\n![appendix-10](appendix-10.png)\n\n\n疑问点：\n(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice\n编程方式区分，不要糅合在一起\n对性能影响可以忽略不计\n\n(2)有一些模式很像，一定需要做区分吗？\n从实际场景触发，贴合场景选择设计模式\n设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题\n\n(3)柯理化\n函数；\n接受多个参数（一个参数没必要用柯理化）；\n将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果\n调用方式不一样。普通函数：函数名(参数1, 参数2, ...);   柯理化：函数名(参数1)(参数2)...\n\n对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决","source":"_posts/28-about-design-model5.md","raw":"---\ntitle: JavaScript设计模式读书笔记(6)\ndate: 2022-09-20 15:22:12\ntags:\n---\n\n#### 架构型设计模式\n架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。\n\n###### 同步模块模式\n模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。\n同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。\n\n(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。\n\n![module-model-1](module-model-1.png)\n![module-model-2](module-model-2.png)\n![module-model-3](module-model-3.png)\n![module-model-4](module-model-4.png)\n![module-model-5](module-model-5.png)\n\n###### 异步模块模式\n异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。\n\n![async-module-model-1](async-module-model-1.png)\n![async-module-model-2](async-module-model-2.png)\n![async-module-model-3](async-module-model-3.png)\n![async-module-model-4](async-module-model-4.png)\n![async-module-model-5](async-module-model-5.png)\n![async-module-model-6](async-module-model-6.png)\n![async-module-model-7](async-module-model-7.png)\n![async-module-model-8](async-module-model-8.png)\n![async-module-model-9](async-module-model-9.png)\n\n###### Widget模式\nWidget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。\n\n![widget-model-1](widget-model-1.png)\n![widget-model-2](widget-model-2.png)\n![widget-model-3](widget-model-3.png)\n![widget-model-4](widget-model-4.png)\n![widget-model-5](widget-model-5.png)\n![widget-model-6](widget-model-6.png)\n\n###### MVC模式\nMVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。\n\n![mvc-model-1](mvc-model-1.png)\n\n**每个对象是一个自动执行的函数**\n**3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法**\n\n![mvc-model-2](mvc-model-2.png)\n![mvc-model-3](mvc-model-3.png)\n视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口\n\n![mvc-model-4](mvc-model-4.png)\n\n###### MVP模式\nMVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。\n\n![mvp-model-1](mvp-model-1.png)\n![mvp-model-2](mvp-model-2.png)\n![mvp-model-3](mvp-model-3.png)\n![mvp-model-4](mvp-model-4.png)\n![mvp-model-5](mvp-model-5.png)\n![mvp-model-6](mvp-model-6.png)\n![mvp-model-7](mvp-model-7.png)\n\nMVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。\n\n###### MVVM模式\nMVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。\n\n![mvvm-model-1](mvvm-model-1.png)\n![mvvm-model-2](mvvm-model-2.png)\n![mvvm-model-3](mvvm-model-3.png)\n![mvvm-model-4](mvvm-model-4.png)\n![mvvm-model-5](mvvm-model-5.png)\n![mvvm-model-6](mvvm-model-6.png)\n![mvvm-model-7](mvvm-model-7.png)\n![mvvm-model-8](mvvm-model-8.png)\n\n###### 附录\n![appendix-1](appendix-1.png)\n![appendix-2](appendix-2.png)\n![appendix-3](appendix-3.png)\n![appendix-4](appendix-4.png)\n![appendix-5](appendix-5.png)\n![appendix-6](appendix-6.png)\n![appendix-7](appendix-7.png)\n![appendix-8](appendix-8.png)\n![appendix-9](appendix-9.png)\n![appendix-10](appendix-10.png)\n\n\n疑问点：\n(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice\n编程方式区分，不要糅合在一起\n对性能影响可以忽略不计\n\n(2)有一些模式很像，一定需要做区分吗？\n从实际场景触发，贴合场景选择设计模式\n设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题\n\n(3)柯理化\n函数；\n接受多个参数（一个参数没必要用柯理化）；\n将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果\n调用方式不一样。普通函数：函数名(参数1, 参数2, ...);   柯理化：函数名(参数1)(参数2)...\n\n对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决","slug":"28-about-design-model5","published":1,"updated":"2022-09-23T06:59:38.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pw000pk4tt93xj8sk3","content":"<h4 id=\"架构型设计模式\"><a href=\"#架构型设计模式\" class=\"headerlink\" title=\"架构型设计模式\"></a>架构型设计模式</h4><p>架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。</p>\n<h6 id=\"同步模块模式\"><a href=\"#同步模块模式\" class=\"headerlink\" title=\"同步模块模式\"></a>同步模块模式</h6><p>模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。<br>同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。</p>\n<p>(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/module-model-1.png\" alt=\"module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-2.png\" alt=\"module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-3.png\" alt=\"module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-4.png\" alt=\"module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-5.png\" alt=\"module-model-5\"></p>\n<h6 id=\"异步模块模式\"><a href=\"#异步模块模式\" class=\"headerlink\" title=\"异步模块模式\"></a>异步模块模式</h6><p>异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/async-module-model-1.png\" alt=\"async-module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-2.png\" alt=\"async-module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-3.png\" alt=\"async-module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-4.png\" alt=\"async-module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-5.png\" alt=\"async-module-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-6.png\" alt=\"async-module-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-7.png\" alt=\"async-module-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-8.png\" alt=\"async-module-model-8\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-9.png\" alt=\"async-module-model-9\"></p>\n<h6 id=\"Widget模式\"><a href=\"#Widget模式\" class=\"headerlink\" title=\"Widget模式\"></a>Widget模式</h6><p>Widget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/widget-model-1.png\" alt=\"widget-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-2.png\" alt=\"widget-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-3.png\" alt=\"widget-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-4.png\" alt=\"widget-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-5.png\" alt=\"widget-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-6.png\" alt=\"widget-model-6\"></p>\n<h6 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h6><p>MVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-1.png\" alt=\"mvc-model-1\"></p>\n<p><strong>每个对象是一个自动执行的函数</strong><br><strong>3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法</strong></p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-2.png\" alt=\"mvc-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvc-model-3.png\" alt=\"mvc-model-3\"><br>视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-4.png\" alt=\"mvc-model-4\"></p>\n<h6 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h6><p>MVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvp-model-1.png\" alt=\"mvp-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-2.png\" alt=\"mvp-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-3.png\" alt=\"mvp-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-4.png\" alt=\"mvp-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-5.png\" alt=\"mvp-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-6.png\" alt=\"mvp-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-7.png\" alt=\"mvp-model-7\"></p>\n<p>MVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。</p>\n<h6 id=\"MVVM模式\"><a href=\"#MVVM模式\" class=\"headerlink\" title=\"MVVM模式\"></a>MVVM模式</h6><p>MVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-1.png\" alt=\"mvvm-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-2.png\" alt=\"mvvm-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-3.png\" alt=\"mvvm-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-4.png\" alt=\"mvvm-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-5.png\" alt=\"mvvm-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-6.png\" alt=\"mvvm-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-7.png\" alt=\"mvvm-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-8.png\" alt=\"mvvm-model-8\"></p>\n<h6 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h6><p><img src=\"/2022/09/20/28-about-design-model5/appendix-1.png\" alt=\"appendix-1\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-2.png\" alt=\"appendix-2\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-3.png\" alt=\"appendix-3\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-4.png\" alt=\"appendix-4\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-5.png\" alt=\"appendix-5\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-6.png\" alt=\"appendix-6\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-7.png\" alt=\"appendix-7\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-8.png\" alt=\"appendix-8\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-9.png\" alt=\"appendix-9\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-10.png\" alt=\"appendix-10\"></p>\n<p>疑问点：<br>(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice<br>编程方式区分，不要糅合在一起<br>对性能影响可以忽略不计</p>\n<p>(2)有一些模式很像，一定需要做区分吗？<br>从实际场景触发，贴合场景选择设计模式<br>设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题</p>\n<p>(3)柯理化<br>函数；<br>接受多个参数（一个参数没必要用柯理化）；<br>将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果<br>调用方式不一样。普通函数：函数名(参数1, 参数2, …);   柯理化：函数名(参数1)(参数2)…</p>\n<p>对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"架构型设计模式\"><a href=\"#架构型设计模式\" class=\"headerlink\" title=\"架构型设计模式\"></a>架构型设计模式</h4><p>架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。</p>\n<h6 id=\"同步模块模式\"><a href=\"#同步模块模式\" class=\"headerlink\" title=\"同步模块模式\"></a>同步模块模式</h6><p>模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。<br>同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。</p>\n<p>(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/module-model-1.png\" alt=\"module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-2.png\" alt=\"module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-3.png\" alt=\"module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-4.png\" alt=\"module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-5.png\" alt=\"module-model-5\"></p>\n<h6 id=\"异步模块模式\"><a href=\"#异步模块模式\" class=\"headerlink\" title=\"异步模块模式\"></a>异步模块模式</h6><p>异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/async-module-model-1.png\" alt=\"async-module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-2.png\" alt=\"async-module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-3.png\" alt=\"async-module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-4.png\" alt=\"async-module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-5.png\" alt=\"async-module-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-6.png\" alt=\"async-module-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-7.png\" alt=\"async-module-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-8.png\" alt=\"async-module-model-8\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-9.png\" alt=\"async-module-model-9\"></p>\n<h6 id=\"Widget模式\"><a href=\"#Widget模式\" class=\"headerlink\" title=\"Widget模式\"></a>Widget模式</h6><p>Widget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/widget-model-1.png\" alt=\"widget-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-2.png\" alt=\"widget-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-3.png\" alt=\"widget-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-4.png\" alt=\"widget-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-5.png\" alt=\"widget-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-6.png\" alt=\"widget-model-6\"></p>\n<h6 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h6><p>MVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-1.png\" alt=\"mvc-model-1\"></p>\n<p><strong>每个对象是一个自动执行的函数</strong><br><strong>3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法</strong></p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-2.png\" alt=\"mvc-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvc-model-3.png\" alt=\"mvc-model-3\"><br>视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-4.png\" alt=\"mvc-model-4\"></p>\n<h6 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h6><p>MVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvp-model-1.png\" alt=\"mvp-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-2.png\" alt=\"mvp-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-3.png\" alt=\"mvp-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-4.png\" alt=\"mvp-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-5.png\" alt=\"mvp-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-6.png\" alt=\"mvp-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-7.png\" alt=\"mvp-model-7\"></p>\n<p>MVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。</p>\n<h6 id=\"MVVM模式\"><a href=\"#MVVM模式\" class=\"headerlink\" title=\"MVVM模式\"></a>MVVM模式</h6><p>MVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-1.png\" alt=\"mvvm-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-2.png\" alt=\"mvvm-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-3.png\" alt=\"mvvm-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-4.png\" alt=\"mvvm-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-5.png\" alt=\"mvvm-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-6.png\" alt=\"mvvm-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-7.png\" alt=\"mvvm-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-8.png\" alt=\"mvvm-model-8\"></p>\n<h6 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h6><p><img src=\"/2022/09/20/28-about-design-model5/appendix-1.png\" alt=\"appendix-1\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-2.png\" alt=\"appendix-2\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-3.png\" alt=\"appendix-3\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-4.png\" alt=\"appendix-4\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-5.png\" alt=\"appendix-5\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-6.png\" alt=\"appendix-6\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-7.png\" alt=\"appendix-7\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-8.png\" alt=\"appendix-8\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-9.png\" alt=\"appendix-9\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-10.png\" alt=\"appendix-10\"></p>\n<p>疑问点：<br>(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice<br>编程方式区分，不要糅合在一起<br>对性能影响可以忽略不计</p>\n<p>(2)有一些模式很像，一定需要做区分吗？<br>从实际场景触发，贴合场景选择设计模式<br>设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题</p>\n<p>(3)柯理化<br>函数；<br>接受多个参数（一个参数没必要用柯理化）；<br>将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果<br>调用方式不一样。普通函数：函数名(参数1, 参数2, …);   柯理化：函数名(参数1)(参数2)…</p>\n<p>对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决</p>\n"},{"title":"es6对象增强","date":"2022-09-02T02:42:05.000Z","_content":"\n#### 对象字面量语法扩展\n\n(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。\n\n```javascript\nvar name = 'test';\nvar obj = {\n  name,\n};\nconsole.log(obj); // {name: 'test'}\n```\n\n(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法\n\n```javascript\n// ES5\nconst es5Obj = {\n  testFunction: function () {\n    console.log('es5');\n  },\n};\nconsole.log(es5Obj.testFunction()); // es5\n\n// es6\nconst es6Obj = {\n  testFunction() {\n    console.log('es6');\n  },\n};\nconsole.log(es6Obj.testFunction()); // es6\n\n// **注意：只有赋值的是匿名函数，才可以使用简介语法**\nconst es6Obj1 = {\n  testFunction: function Hello() {\n    console.log('hello');\n  },\n};\nconsole.log(es6Obj1.testFunction()); // hello\n```\n\n**常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位**\n\n(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来\n\n```javascript\nconst es6Obj = {\n  ['first' + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj['first' + 'second']); // hanmeimei\n\nconst first = 'first';\nconst es6Obj1 = {\n  [first + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj[first + 'second']); // hanmeimei\n```\n\n(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性\n\n```javascript\nconst es6Obj = {\n  name: 'first',\n  name: 'second',\n};\nconsole.log(es6Obj); // {name: 'second'}\n```\n\n#### 新方法\n\n(1)Object.is()\n作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN\n\n```javascript\nconsole.log(+0 == -0); // true\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n(2)Object.assign()\n作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象\n\n```javascript\n// Object.assign(target, ...sources);  target为目标对象  sources为源对象\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target); // Object { a: 1, b: 4, c: 5 }\nconsole.log(returnedTarget); // Object { a: 1, b: 4, c: 5 }\n```\n\n(3)Object.setPrototypeOf()\n作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象\n```javascript\n// Object.setPrototypeOf(object, prototypeObject);\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {};\n// obj 链接到person\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // hello\n// obj 链接到dog\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woof\n```\n当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // obj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // obj\n```\n在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: 'super' keyword unexpected here\n**为什么？？**\n```javascript\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下写法报错：Uncaught SyntaxError: 'super' keyword unexpected here\n greeting: function() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting());\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting());\n\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下方法可以正常运行\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n**在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。**","source":"_posts/29-es6-object-strong.md","raw":"---\ntitle: es6对象增强\ndate: 2022-09-02 10:42:05\ntags:\n---\n\n#### 对象字面量语法扩展\n\n(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。\n\n```javascript\nvar name = 'test';\nvar obj = {\n  name,\n};\nconsole.log(obj); // {name: 'test'}\n```\n\n(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法\n\n```javascript\n// ES5\nconst es5Obj = {\n  testFunction: function () {\n    console.log('es5');\n  },\n};\nconsole.log(es5Obj.testFunction()); // es5\n\n// es6\nconst es6Obj = {\n  testFunction() {\n    console.log('es6');\n  },\n};\nconsole.log(es6Obj.testFunction()); // es6\n\n// **注意：只有赋值的是匿名函数，才可以使用简介语法**\nconst es6Obj1 = {\n  testFunction: function Hello() {\n    console.log('hello');\n  },\n};\nconsole.log(es6Obj1.testFunction()); // hello\n```\n\n**常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位**\n\n(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来\n\n```javascript\nconst es6Obj = {\n  ['first' + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj['first' + 'second']); // hanmeimei\n\nconst first = 'first';\nconst es6Obj1 = {\n  [first + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj[first + 'second']); // hanmeimei\n```\n\n(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性\n\n```javascript\nconst es6Obj = {\n  name: 'first',\n  name: 'second',\n};\nconsole.log(es6Obj); // {name: 'second'}\n```\n\n#### 新方法\n\n(1)Object.is()\n作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN\n\n```javascript\nconsole.log(+0 == -0); // true\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n(2)Object.assign()\n作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象\n\n```javascript\n// Object.assign(target, ...sources);  target为目标对象  sources为源对象\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target); // Object { a: 1, b: 4, c: 5 }\nconsole.log(returnedTarget); // Object { a: 1, b: 4, c: 5 }\n```\n\n(3)Object.setPrototypeOf()\n作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象\n```javascript\n// Object.setPrototypeOf(object, prototypeObject);\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {};\n// obj 链接到person\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // hello\n// obj 链接到dog\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woof\n```\n当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // obj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // obj\n```\n在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: 'super' keyword unexpected here\n**为什么？？**\n```javascript\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下写法报错：Uncaught SyntaxError: 'super' keyword unexpected here\n greeting: function() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting());\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting());\n\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下方法可以正常运行\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n**在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。**","slug":"29-es6-object-strong","published":1,"updated":"2022-09-02T05:49:32.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8py000qk4tteaa4gwz1","content":"<h4 id=\"对象字面量语法扩展\"><a href=\"#对象字面量语法扩展\" class=\"headerlink\" title=\"对象字面量语法扩展\"></a>对象字面量语法扩展</h4><p>(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;test&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;name: &#x27;test&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es5Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es5&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es5Obj.testFunction()); <span class=\"comment\">// es5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">testFunction</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es6&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj.testFunction()); <span class=\"comment\">// es6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// **注意：只有赋值的是匿名函数，才可以使用简介语法**</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj1.testFunction()); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位</strong></p>\n<p>(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  [<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> first = <span class=\"string\">&#x27;first&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  [first + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[first + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;first&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;second&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj); <span class=\"comment\">// &#123;name: &#x27;second&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h4><p>(1)Object.is()<br>作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> == -<span class=\"number\">0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)Object.assign()<br>作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.assign(target, ...sources);  target为目标对象  sources为源对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source = &#123; <span class=\"attr\">b</span>: <span class=\"number\">4</span>, <span class=\"attr\">c</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> returnedTarget = <span class=\"built_in\">Object</span>.assign(target, source);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(returnedTarget); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)Object.setPrototypeOf()<br>作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.setPrototypeOf(object, prototypeObject);</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// obj 链接到person</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// obj 链接到dog</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woof</span></span><br></pre></td></tr></table></figure>\n<p>当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n<p>在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p>对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: ‘super’ keyword unexpected here<br><strong>为什么？？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下写法报错：Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class=\"line\"> <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下方法可以正常运行</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p><strong>在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"对象字面量语法扩展\"><a href=\"#对象字面量语法扩展\" class=\"headerlink\" title=\"对象字面量语法扩展\"></a>对象字面量语法扩展</h4><p>(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;test&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;name: &#x27;test&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es5Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es5&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es5Obj.testFunction()); <span class=\"comment\">// es5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">testFunction</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es6&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj.testFunction()); <span class=\"comment\">// es6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// **注意：只有赋值的是匿名函数，才可以使用简介语法**</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj1.testFunction()); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位</strong></p>\n<p>(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  [<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> first = <span class=\"string\">&#x27;first&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  [first + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[first + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;first&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;second&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj); <span class=\"comment\">// &#123;name: &#x27;second&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h4><p>(1)Object.is()<br>作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> == -<span class=\"number\">0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)Object.assign()<br>作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.assign(target, ...sources);  target为目标对象  sources为源对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source = &#123; <span class=\"attr\">b</span>: <span class=\"number\">4</span>, <span class=\"attr\">c</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> returnedTarget = <span class=\"built_in\">Object</span>.assign(target, source);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(returnedTarget); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)Object.setPrototypeOf()<br>作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.setPrototypeOf(object, prototypeObject);</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// obj 链接到person</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// obj 链接到dog</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woof</span></span><br></pre></td></tr></table></figure>\n<p>当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n<p>在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p>对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: ‘super’ keyword unexpected here<br><strong>为什么？？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下写法报错：Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class=\"line\"> <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下方法可以正常运行</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p><strong>在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。</strong></p>\n"},{"title":"使用hexo相关","date":"2022-03-26T13:14:29.000Z","_content":"\n## 一些使用hexo搭建博客时遇到的问题\n\n1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：'hexo' 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found\n解决办法：重新运行命令：npm install hexo-cli -g\n","source":"_posts/3-about-use-hexo.md","raw":"---\ntitle: 使用hexo相关\ndate: 2022-03-26 21:14:29\ntags:\n---\n\n## 一些使用hexo搭建博客时遇到的问题\n\n1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：'hexo' 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found\n解决办法：重新运行命令：npm install hexo-cli -g\n","slug":"3-about-use-hexo","published":1,"updated":"2022-08-10T03:11:53.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8py000rk4ttdlbuc2qt","content":"<h2 id=\"一些使用hexo搭建博客时遇到的问题\"><a href=\"#一些使用hexo搭建博客时遇到的问题\" class=\"headerlink\" title=\"一些使用hexo搭建博客时遇到的问题\"></a>一些使用hexo搭建博客时遇到的问题</h2><p>1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found<br>解决办法：重新运行命令：npm install hexo-cli -g</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一些使用hexo搭建博客时遇到的问题\"><a href=\"#一些使用hexo搭建博客时遇到的问题\" class=\"headerlink\" title=\"一些使用hexo搭建博客时遇到的问题\"></a>一些使用hexo搭建博客时遇到的问题</h2><p>1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found<br>解决办法：重新运行命令：npm install hexo-cli -g</p>\n"},{"title":"开发中使用的便捷代码","date":"2022-09-05T05:24:10.000Z","_content":"\n###### 基于条件设置对象属性\n```javascript\n// 空值\nconst name = '';\nconst obj = { ...name && {name}};\nconsole.log(obj); // {}\n// 非空值\nconst name = 'test_name';\nconst obj = { ...name && {name}};\nconsole.log(obj); // { name: 'test_name'}\n```\n\n###### 无中间变量交换变量值\n```javascript\nlet one = '12';\nlet two = '34';\n[one, two] = [two, one];\nconsole.log(one); // '34'\nconsole.log(two); // '12'\n```\n\n###### 过滤Boolean值为false的值\n```javascript\nconst array = [0, false, 12, true, '12', undefined, '', 8, null];\nconst result = array.filter(Boolean);\nconsole.log(result); // [12, true, '12', 8]\n```\n\n###### 转换元素类型\n```javascript\n// 将Number类型转换为String\nconst string = [1, 2, 3, 12].map(String);\nconsole.log(string); // ['1', '2', '3', '12']\n// 将String类型转换为Number\nconst string = ['1', '2', '3', '12'].map(Number);\nconsole.log(string); // [1, 2, 3, 12]\n```\n\n###### 数组去重\n```javascript\nconst repeatArray = [1,1,1,3,5,6,7,8,9,23,45,1,2,3,5,6];\nconst result = [...new Set(repeatArray)];\nconsole.log(result); // [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]\n```","source":"_posts/30-some-convenient-code.md","raw":"---\ntitle: 开发中使用的便捷代码\ndate: 2022-09-05 13:24:10\ntags:\n---\n\n###### 基于条件设置对象属性\n```javascript\n// 空值\nconst name = '';\nconst obj = { ...name && {name}};\nconsole.log(obj); // {}\n// 非空值\nconst name = 'test_name';\nconst obj = { ...name && {name}};\nconsole.log(obj); // { name: 'test_name'}\n```\n\n###### 无中间变量交换变量值\n```javascript\nlet one = '12';\nlet two = '34';\n[one, two] = [two, one];\nconsole.log(one); // '34'\nconsole.log(two); // '12'\n```\n\n###### 过滤Boolean值为false的值\n```javascript\nconst array = [0, false, 12, true, '12', undefined, '', 8, null];\nconst result = array.filter(Boolean);\nconsole.log(result); // [12, true, '12', 8]\n```\n\n###### 转换元素类型\n```javascript\n// 将Number类型转换为String\nconst string = [1, 2, 3, 12].map(String);\nconsole.log(string); // ['1', '2', '3', '12']\n// 将String类型转换为Number\nconst string = ['1', '2', '3', '12'].map(Number);\nconsole.log(string); // [1, 2, 3, 12]\n```\n\n###### 数组去重\n```javascript\nconst repeatArray = [1,1,1,3,5,6,7,8,9,23,45,1,2,3,5,6];\nconst result = [...new Set(repeatArray)];\nconsole.log(result); // [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]\n```","slug":"30-some-convenient-code","published":1,"updated":"2022-09-05T05:42:03.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pz000sk4ttfdxf9r1k","content":"<h6 id=\"基于条件设置对象属性\"><a href=\"#基于条件设置对象属性\" class=\"headerlink\" title=\"基于条件设置对象属性\"></a>基于条件设置对象属性</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 非空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;test_name&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; name: &#x27;test_name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无中间变量交换变量值\"><a href=\"#无中间变量交换变量值\" class=\"headerlink\" title=\"无中间变量交换变量值\"></a>无中间变量交换变量值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"string\">&#x27;12&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"string\">&#x27;34&#x27;</span>;</span><br><span class=\"line\">[one, two] = [two, one];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one); <span class=\"comment\">// &#x27;34&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two); <span class=\"comment\">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"过滤Boolean值为false的值\"><a href=\"#过滤Boolean值为false的值\" class=\"headerlink\" title=\"过滤Boolean值为false的值\"></a>过滤Boolean值为false的值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">0</span>, <span class=\"literal\">false</span>, <span class=\"number\">12</span>, <span class=\"literal\">true</span>, <span class=\"string\">&#x27;12&#x27;</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = array.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [12, true, &#x27;12&#x27;, 8]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"转换元素类型\"><a href=\"#转换元素类型\" class=\"headerlink\" title=\"转换元素类型\"></a>转换元素类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Number类型转换为String</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>].map(<span class=\"built_in\">String</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 将String类型转换为Number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;12&#x27;</span>].map(<span class=\"built_in\">Number</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [1, 2, 3, 12]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeatArray = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = [...new <span class=\"built_in\">Set</span>(repeatArray)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"基于条件设置对象属性\"><a href=\"#基于条件设置对象属性\" class=\"headerlink\" title=\"基于条件设置对象属性\"></a>基于条件设置对象属性</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 非空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;test_name&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; name: &#x27;test_name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无中间变量交换变量值\"><a href=\"#无中间变量交换变量值\" class=\"headerlink\" title=\"无中间变量交换变量值\"></a>无中间变量交换变量值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"string\">&#x27;12&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"string\">&#x27;34&#x27;</span>;</span><br><span class=\"line\">[one, two] = [two, one];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one); <span class=\"comment\">// &#x27;34&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two); <span class=\"comment\">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"过滤Boolean值为false的值\"><a href=\"#过滤Boolean值为false的值\" class=\"headerlink\" title=\"过滤Boolean值为false的值\"></a>过滤Boolean值为false的值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">0</span>, <span class=\"literal\">false</span>, <span class=\"number\">12</span>, <span class=\"literal\">true</span>, <span class=\"string\">&#x27;12&#x27;</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = array.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [12, true, &#x27;12&#x27;, 8]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"转换元素类型\"><a href=\"#转换元素类型\" class=\"headerlink\" title=\"转换元素类型\"></a>转换元素类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Number类型转换为String</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>].map(<span class=\"built_in\">String</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 将String类型转换为Number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;12&#x27;</span>].map(<span class=\"built_in\">Number</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [1, 2, 3, 12]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeatArray = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = [...new <span class=\"built_in\">Set</span>(repeatArray)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]</span></span><br></pre></td></tr></table></figure>"},{"title":"Object获取及设置原型对象","date":"2022-09-05T05:54:58.000Z","_content":"\n###### Object获取原型对象：Object.getPrototypeOf\nObject.getPrototypeOf用于获取指定对象的原型对象\n```javascript\nObject.getPrototypeOf(obj);\n```\n**参数**\nobj: 参数为要获取原型对象的对象\n**返回值**\n返回指定对象的原型对象或null\n注意：\nes5中，如果参数不是对象，会抛出TypeError错误\nes6中，如果参数不是对象，会强制类型转换为对象\n**示例**\n```javascript\nconsole.log(Object.getPrototypeOf('12') === String.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(12) === Number.prototype); // true\n//\nconsole.log(Object.getPrototypeOf({}) === Object.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(true) === Boolean.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(Symbol('test')) === Symbol.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(null)); // Uncaught TypeError: Cannot convert undefined or null to object\n// \nconsole.log(Object.getPrototypeOf(undefined)); // Uncaught TypeError: Cannot convert undefined or null to object\n\n// 对没有原型对象的对象进行操作\nconst obj = Object.create(null);\nconsole.log(Object.getPrototypeOf(obj)); // null\nconst obj = Object.create(undefined);\nconsole.log(Object.getPrototypeOf(obj)); // Uncaught TypeError: Object prototype may only be an Object or null: undefined\n```\n\n###### Object修改原型对象: Object.setPrototypeOf\nObject.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上\n```javascript\nObject.setPrototypeOf(obj, proto);\n```\n**参数**\nobj: 要设置原型对象的对象\nproto: 要设置的新原型对象或null，未设置时抛出TypeError错误\n\n**返回值**\n设置了新原型对象的对象\n\n注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象\n\n**示例**\n```javascript\nconst obj = { name: 'test' };\nconst newObj = Object.create(obj);\nObject.setPrototypeOf(newObj, obj);\nconsole.log(newObj.name); // 'test'\n\nconst otherObj = { age: 12};\nconsole.log(Object.getPrototypeOf(newObj) === obj); // true\nObject.setPrototypeOf(newObj, otherObj);\nconsole.log(Object.getPrototypeOf(newObj) === obj); // false\nconsole.log(Object.getPrototypeOf(newObj) === otherObj); // true\nconsole.log(newObj.name); // undefined\nconsole.log(newObj.age); // 12\n```","source":"_posts/31-get-and-set-prototypeof.md","raw":"---\ntitle: Object获取及设置原型对象\ndate: 2022-09-05 13:54:58\ntags:\n---\n\n###### Object获取原型对象：Object.getPrototypeOf\nObject.getPrototypeOf用于获取指定对象的原型对象\n```javascript\nObject.getPrototypeOf(obj);\n```\n**参数**\nobj: 参数为要获取原型对象的对象\n**返回值**\n返回指定对象的原型对象或null\n注意：\nes5中，如果参数不是对象，会抛出TypeError错误\nes6中，如果参数不是对象，会强制类型转换为对象\n**示例**\n```javascript\nconsole.log(Object.getPrototypeOf('12') === String.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(12) === Number.prototype); // true\n//\nconsole.log(Object.getPrototypeOf({}) === Object.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(true) === Boolean.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(Symbol('test')) === Symbol.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(null)); // Uncaught TypeError: Cannot convert undefined or null to object\n// \nconsole.log(Object.getPrototypeOf(undefined)); // Uncaught TypeError: Cannot convert undefined or null to object\n\n// 对没有原型对象的对象进行操作\nconst obj = Object.create(null);\nconsole.log(Object.getPrototypeOf(obj)); // null\nconst obj = Object.create(undefined);\nconsole.log(Object.getPrototypeOf(obj)); // Uncaught TypeError: Object prototype may only be an Object or null: undefined\n```\n\n###### Object修改原型对象: Object.setPrototypeOf\nObject.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上\n```javascript\nObject.setPrototypeOf(obj, proto);\n```\n**参数**\nobj: 要设置原型对象的对象\nproto: 要设置的新原型对象或null，未设置时抛出TypeError错误\n\n**返回值**\n设置了新原型对象的对象\n\n注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象\n\n**示例**\n```javascript\nconst obj = { name: 'test' };\nconst newObj = Object.create(obj);\nObject.setPrototypeOf(newObj, obj);\nconsole.log(newObj.name); // 'test'\n\nconst otherObj = { age: 12};\nconsole.log(Object.getPrototypeOf(newObj) === obj); // true\nObject.setPrototypeOf(newObj, otherObj);\nconsole.log(Object.getPrototypeOf(newObj) === obj); // false\nconsole.log(Object.getPrototypeOf(newObj) === otherObj); // true\nconsole.log(newObj.name); // undefined\nconsole.log(newObj.age); // 12\n```","slug":"31-get-and-set-prototypeof","published":1,"updated":"2022-09-05T06:42:22.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8pz000tk4ttapcp6f89","content":"<h6 id=\"Object获取原型对象：Object-getPrototypeOf\"><a href=\"#Object获取原型对象：Object-getPrototypeOf\" class=\"headerlink\" title=\"Object获取原型对象：Object.getPrototypeOf\"></a>Object获取原型对象：Object.getPrototypeOf</h6><p>Object.getPrototypeOf用于获取指定对象的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 参数为要获取原型对象的对象<br><strong>返回值</strong><br>返回指定对象的原型对象或null<br>注意：<br>es5中，如果参数不是对象，会抛出TypeError错误<br>es6中，如果参数不是对象，会强制类型转换为对象<br><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"string\">&#x27;12&#x27;</span>) === <span class=\"built_in\">String</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"number\">12</span>) === <span class=\"built_in\">Number</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(&#123;&#125;) === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">true</span>) === <span class=\"built_in\">Boolean</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;test&#x27;</span>)) === <span class=\"built_in\">Symbol</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">null</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">undefined</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对没有原型对象的对象进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// Uncaught TypeError: Object prototype may only be an Object or null: undefined</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Object修改原型对象-Object-setPrototypeOf\"><a href=\"#Object修改原型对象-Object-setPrototypeOf\" class=\"headerlink\" title=\"Object修改原型对象: Object.setPrototypeOf\"></a>Object修改原型对象: Object.setPrototypeOf</h6><p>Object.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 要设置原型对象的对象<br>proto: 要设置的新原型对象或null，未设置时抛出TypeError错误</p>\n<p><strong>返回值</strong><br>设置了新原型对象的对象</p>\n<p>注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">Object</span>.create(obj);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// &#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> otherObj = &#123; <span class=\"attr\">age</span>: <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, otherObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === otherObj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.age); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"Object获取原型对象：Object-getPrototypeOf\"><a href=\"#Object获取原型对象：Object-getPrototypeOf\" class=\"headerlink\" title=\"Object获取原型对象：Object.getPrototypeOf\"></a>Object获取原型对象：Object.getPrototypeOf</h6><p>Object.getPrototypeOf用于获取指定对象的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 参数为要获取原型对象的对象<br><strong>返回值</strong><br>返回指定对象的原型对象或null<br>注意：<br>es5中，如果参数不是对象，会抛出TypeError错误<br>es6中，如果参数不是对象，会强制类型转换为对象<br><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"string\">&#x27;12&#x27;</span>) === <span class=\"built_in\">String</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"number\">12</span>) === <span class=\"built_in\">Number</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(&#123;&#125;) === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">true</span>) === <span class=\"built_in\">Boolean</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;test&#x27;</span>)) === <span class=\"built_in\">Symbol</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">null</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">undefined</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对没有原型对象的对象进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// Uncaught TypeError: Object prototype may only be an Object or null: undefined</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Object修改原型对象-Object-setPrototypeOf\"><a href=\"#Object修改原型对象-Object-setPrototypeOf\" class=\"headerlink\" title=\"Object修改原型对象: Object.setPrototypeOf\"></a>Object修改原型对象: Object.setPrototypeOf</h6><p>Object.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 要设置原型对象的对象<br>proto: 要设置的新原型对象或null，未设置时抛出TypeError错误</p>\n<p><strong>返回值</strong><br>设置了新原型对象的对象</p>\n<p>注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">Object</span>.create(obj);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// &#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> otherObj = &#123; <span class=\"attr\">age</span>: <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, otherObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === otherObj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.age); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>"},{"title":"js中apply怎么把数组转化为参数？","date":"2022-09-21T09:07:53.000Z","_content":"\n###### apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(array);\n// [1, 10]\n// undefined\n\ntest.apply(null, array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(array);\n// [1, 10]\n// undefined\ntest.func.apply(test.func, array);\ntest.func.apply(null, array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(array);\n// NaN\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max.apply(null, array);\n// 8\n```\n\n###### ES6中的扩展符\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(...array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(...array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(...array);\n// 8\n```\n\n###### 使用arguments对象（不建议使用）\n函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。\n```javascript\nfunction test() {\n for (let i = 0; i < arguments.length; i++) {\n  console.log(arguments[i]);\n }\n}\ntest(1,12,5);\n// 1 12 5\ntest(1,12,3,4,5);\n// 1 12 3 4 5\n```","source":"_posts/32-apply-array-to-params.md","raw":"---\ntitle: js中apply怎么把数组转化为参数？\ndate: 2022-09-21 17:07:53\ntags:\n---\n\n###### apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(array);\n// [1, 10]\n// undefined\n\ntest.apply(null, array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(array);\n// [1, 10]\n// undefined\ntest.func.apply(test.func, array);\ntest.func.apply(null, array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(array);\n// NaN\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max.apply(null, array);\n// 8\n```\n\n###### ES6中的扩展符\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(...array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(...array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(...array);\n// 8\n```\n\n###### 使用arguments对象（不建议使用）\n函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。\n```javascript\nfunction test() {\n for (let i = 0; i < arguments.length; i++) {\n  console.log(arguments[i]);\n }\n}\ntest(1,12,5);\n// 1 12 5\ntest(1,12,3,4,5);\n// 1 12 3 4 5\n```","slug":"32-apply-array-to-params","published":1,"updated":"2022-10-25T06:46:40.737Z","_id":"cl9nrr8pz000uk4tt705m8eqg","comments":1,"layout":"post","photos":[],"link":"","content":"<h6 id=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"><a href=\"#apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\" class=\"headerlink\" title=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"></a>apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">test.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\">test.func.apply(test.func, array);</span><br><span class=\"line\">test.func.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(array);</span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"ES6中的扩展符\"><a href=\"#ES6中的扩展符\" class=\"headerlink\" title=\"ES6中的扩展符\"></a>ES6中的扩展符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(...array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用arguments对象（不建议使用）\"><a href=\"#使用arguments对象（不建议使用）\" class=\"headerlink\" title=\"使用arguments对象（不建议使用）\"></a>使用arguments对象（不建议使用）</h6><p>函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 5</span></span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 3 4 5</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"><a href=\"#apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\" class=\"headerlink\" title=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"></a>apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">test.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\">test.func.apply(test.func, array);</span><br><span class=\"line\">test.func.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(array);</span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"ES6中的扩展符\"><a href=\"#ES6中的扩展符\" class=\"headerlink\" title=\"ES6中的扩展符\"></a>ES6中的扩展符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(...array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用arguments对象（不建议使用）\"><a href=\"#使用arguments对象（不建议使用）\" class=\"headerlink\" title=\"使用arguments对象（不建议使用）\"></a>使用arguments对象（不建议使用）</h6><p>函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 5</span></span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 3 4 5</span></span><br></pre></td></tr></table></figure>"},{"title":"数据结构与算法阅读笔记(1)","date":"2022-09-20T09:41:00.000Z","_content":"\nECMAScript 和 javascript 的关系\nECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。\n\nES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别\n\n(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)\n\n(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性\n一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)\n\n(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)\n\n(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)\n\n(5)ES.Next 用来指代下一个版本的 ECMAScript\n\nES6 兼容性：http://kangax.github.io/compat-table/es6/\nES7 兼容性：http://kangax.github.io/compat-table/es2016plus/\n\nES5 中 class 类，使用属性存取器\n(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字\n(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的\n\n```javascript\nclass Person {\n  constructor(name) {\n    this._name = name; // {1}\n  }\n  get name() {\n    // {2}\n    return this._name;\n  }\n  set name(value) {\n    // {3}\n    this._name = value;\n  }\n}\nlet lotrChar = new Person('Frodo');\nconsole.log(lotrChar.name); // {4} // Frodo\nlotrChar.name = 'Gandalf'; // {5}\nconsole.log(lotrChar.name); // Gandalf\nlotrChar._name = 'Sam'; // {6}\nconsole.log(lotrChar.name); // Sam\n```\n\n乘方运算符\n\n```javascript\nconst area = 3.14 * r * r;\nconst area = 3.14 * Math.pow(r, 2);\n// ES2016 中引入了**运算符，用来进行指数运算\nconst area = 3.14 * r ** 2;\n```\n\n[JavaScript 和 ECMAScript 的完整功能列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n###### TypeScript\n\nTypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.\n(1)接口\n\n```javascript\n// 第一种定义接口的方式\ninterface Person {\n  name: string;\n  age: number;\n}\nfunction printName(person: Person) {\n  console.log(person.name);\n}\n/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，\n并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/\ninterface Comparable {\n  compareTo(b): number;\n}\nclass MyObject implements Comparable {\n  age: number;\n  compareTo(b): number {\n    if (this.age === b.age) {\n      return 0;\n    }\n    return this.age > b.age ? 1 : -1;\n  }\n}\n```\n\n**JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check**\n\n###### 数组\n\n数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组\n\n(1)使用@@iterator 对象\nES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet iterator = numbers[Symbol.iterator]();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\nconsole.log(iterator.next().value); // 4\nconsole.log(iterator.next().value); // 5\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\niterator = numbers[Symbol.iterator]();\nfor (const n of iterator) {\n  console.log(n);\n}\n\n// 复制已有数组\nlet numbers2 = Array.from(numbers);\nlet numbers3 = Array.of(...numbers);\n```\n\n(2)copyWithin\ncopyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置\n\n```javascript\ncopyArray = [1, 2, 3, 4, 5, 6];\ncopyArray.copyWithin(1, 3, 5);\n// copyWithin(起始位置，开始位置，结束位置)\n// [1, 4, 5, 4, 5, 6]\n```\n\n(3)排序\n\n```javascript\n// 自定义排序\nconst friends = [\n  { name: 'John', age: 30 },\n  { name: 'Ana', age: 20 },\n  { name: 'Chris', age: 25 }, // ES2017 允许存在尾逗号\n];\nfunction comparePerson(a, b) {\n  if (a.age < b.age) {\n    return -1;\n  }\n  if (a.age > b.age) {\n    return 1;\n  }\n  return 0;\n}\nconsole.log(friends.sort(comparePerson));\n/**\n[ \n { name: 'Ana', age: 20 }, \n { name: 'Chris', age: 25 },\n { name: 'John', age: 30 }, \n]\n*/\n// 忽略大小写的比较\nconst names = ['Ana', 'ana', 'john', 'John']; // 重置数组的初始状态\nconsole.log(\n  names.sort((a, b) => {\n    if (a.toLowerCase() < b.toLowerCase()) {\n      return -1;\n    }\n    if (a.toLowerCase() > b.toLowerCase()) {\n      return 1;\n    }\n    return 0;\n  })\n);\n// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法\nconst names = ['Ana', 'ana', 'john', 'John'];\nnames.sort((a, b) => a.localeCompare(b));\n// ['ana', 'Ana', 'john', 'John']\n\nconst names2 = ['Maève', 'Maeve'];\nconsole.log(names2.sort((a, b) => a.localeCompare(b)));\n// [\"Maeve\", \"Maève\"]\n```\n\n###### 类型数组\n\n| 类型数组          | 数据类型            |\n| ----------------- | ------------------- |\n| Int8Array         | 8 位二进制补码整数  |\n| Uint8Array        | 8 位无符号整数      |\n| Uint8ClampedArray | 8 位无符号整数      |\n| Int16Array        | 16 位二进制补码整数 |\n| Uint16Array       | 16 位无符号整数     |\n| Int32Array        | 32 位二进制补码整数 |\n| Uint32Array       | 32 位无符号整数     |\n| Float32Array      | 32 位 IEEE 浮点数   |\n| Float64Array      | 64 位 IEEE 浮点数   |\n\n```javascript\nlet length = 5;\nlet int16 = new Int16Array(length);\nlet array16 = [];\narray16.length = length;\nfor (let i = 0; i < length; i++) {\n  int16[i] = i + 1;\n}\nconsole.log(int16);\n```\n\n类型数组作用：WebGL API、位操作、处理文件和图像\n\n[类型数组文档](https://web.dev/webgl-typed-arrays/)\n\n###### 栈\n\n栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底\n\n栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）\n\n(1)创建一个基于数组的栈\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  // 添加一个（或几个）新元素到栈顶\n  push(element) {\n    this.items.push(element);\n  }\n  // 移除栈顶的元素，同时返回被移除的元素\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  // 如果栈里没有任何元素就返回 true，否则返回 false\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 返回栈里的元素个数。该方法和数组的 length 属性很类似\n  size() {\n    return this.items.length;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = [];\n  }\n}\n```\n\n**在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。**\n(2)创建一个基于 JavaScript 对象的 Stack 类\n\n```javascript\nclass Stack {\n  constructor() {\n    this.count = 0; // count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素\n    this.items = {};\n  }\n  // 向栈中插入元素,只允许一次插入一个元素\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 验证一个栈的大小\n  size() {\n    return this.count;\n  }\n  // 获取栈是否为空\n  isEmpty() {\n    return this.count === 0;\n  }\n  // 从栈中弹出元素\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  // 查看栈顶的值\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  // 清空栈\n  clear() {\n    this.items = {};\n    this.count = 0;\n    //  while (!this.isEmpty()) {\n    //  this.pop();\n    // }\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[0]}`; // {1}\n    for (let i = 1; i < this.count; i++) {\n      // {2}\n      objString = `${objString},${this.items[i]}`; // {3}\n    }\n    return objString;\n  }\n}\n```\n\n**javascript 实现私有属性的方法**\n下划线命名约定\n\n```javascript\n// 中使用下划线命名约定来标记一个属性为私有属性\nclass Stack {\n  constructor() {\n    this._count = 0;\n    this._items = {};\n  }\n}\n```\n\n_下划线命名约定就是在属性名称之前加上一个下划线（\\_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识_\n\n**用 ES2015 的限定作用域 Symbol 实现类**\n\n```javascript\nconst _items = Symbol('stackItems');\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n  // 栈的方法\n}\n\nconst stack = new Stack();\nstack.push(5);\nstack.push(8);\nlet objectSymbols = Object.getOwnPropertySymbols(stack);\nconsole.log(objectSymbols.length); // 输出 1\nconsole.log(objectSymbols); // [Symbol()]\nconsole.log(objectSymbols[0]); // Symbol()\nstack[objectSymbols[0]].push(1);\nstack.print(); // 输出 5, 8, 1\n```\n\n_访问 stack[objectSymbols[0]]得到\\_items,并且，\\_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求_\n\n**用 ES2015 的 WeakMap 实现类**\nWeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型\n\n```javascript\nconst items = new WeakMap(); // {1}\nclass Stack {\n  constructor() {\n    items.set(this, []); // {2}\n  }\n  push(element) {\n    const s = items.get(this); // {3}\n    s.push(element);\n  }\n  pop() {\n    const s = items.get(this);\n    const r = s.pop();\n    return r;\n  }\n  // 其他方法\n}\n```\n\n_代码的可读性不强，而且在扩展该类时无法继承私有属性_\n\n**ECMAScript 类属性提案**\n\n```javascript\nclass Stack {\n  #count = 0;\n  #items = 0;\n  // 栈的方法\n}\n```\n\n**从十进制转二进制**\n\n```javascript\nfunction decimalToBinary(decNumber) {\n  const remStack = new Stack();\n  let number = decNumber;\n  let rem;\n  let binaryString = '';\n  while (number > 0) {\n    rem = Math.floor(number % 2);\n    remStack.push(rem);\n    number = Math.floor(number / 2);\n  }\n  while (!remStack.isEmpty()) {\n    binaryString += remStack.pop().toString();\n  }\n  return binaryString;\n}\n```\n\n**进制转换算法**\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const remStack = new Stack();\n  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6}\n  let number = decNumber;\n  let rem;\n  let baseString = '';\n  if (!(base >= 2 && base <= 36)) {\n    return '';\n  }\n  while (number > 0) {\n    rem = Math.floor(number % base);\n    remStack.push(rem);\n    number = Math.floor(number / base);\n  }\n  while (!remStack.isEmpty()) {\n    baseString += digits[remStack.pop()]; // {7}\n  }\n  return baseString;\n}\n```\n","source":"_posts/33-data-structure1.md","raw":"---\ntitle: 数据结构与算法阅读笔记(1)\ndate: 2022-09-20 17:41:00\ntags:\n---\n\nECMAScript 和 javascript 的关系\nECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。\n\nES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别\n\n(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)\n\n(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性\n一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)\n\n(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)\n\n(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)\n\n(5)ES.Next 用来指代下一个版本的 ECMAScript\n\nES6 兼容性：http://kangax.github.io/compat-table/es6/\nES7 兼容性：http://kangax.github.io/compat-table/es2016plus/\n\nES5 中 class 类，使用属性存取器\n(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字\n(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的\n\n```javascript\nclass Person {\n  constructor(name) {\n    this._name = name; // {1}\n  }\n  get name() {\n    // {2}\n    return this._name;\n  }\n  set name(value) {\n    // {3}\n    this._name = value;\n  }\n}\nlet lotrChar = new Person('Frodo');\nconsole.log(lotrChar.name); // {4} // Frodo\nlotrChar.name = 'Gandalf'; // {5}\nconsole.log(lotrChar.name); // Gandalf\nlotrChar._name = 'Sam'; // {6}\nconsole.log(lotrChar.name); // Sam\n```\n\n乘方运算符\n\n```javascript\nconst area = 3.14 * r * r;\nconst area = 3.14 * Math.pow(r, 2);\n// ES2016 中引入了**运算符，用来进行指数运算\nconst area = 3.14 * r ** 2;\n```\n\n[JavaScript 和 ECMAScript 的完整功能列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n###### TypeScript\n\nTypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.\n(1)接口\n\n```javascript\n// 第一种定义接口的方式\ninterface Person {\n  name: string;\n  age: number;\n}\nfunction printName(person: Person) {\n  console.log(person.name);\n}\n/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，\n并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/\ninterface Comparable {\n  compareTo(b): number;\n}\nclass MyObject implements Comparable {\n  age: number;\n  compareTo(b): number {\n    if (this.age === b.age) {\n      return 0;\n    }\n    return this.age > b.age ? 1 : -1;\n  }\n}\n```\n\n**JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check**\n\n###### 数组\n\n数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组\n\n(1)使用@@iterator 对象\nES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet iterator = numbers[Symbol.iterator]();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\nconsole.log(iterator.next().value); // 4\nconsole.log(iterator.next().value); // 5\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\niterator = numbers[Symbol.iterator]();\nfor (const n of iterator) {\n  console.log(n);\n}\n\n// 复制已有数组\nlet numbers2 = Array.from(numbers);\nlet numbers3 = Array.of(...numbers);\n```\n\n(2)copyWithin\ncopyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置\n\n```javascript\ncopyArray = [1, 2, 3, 4, 5, 6];\ncopyArray.copyWithin(1, 3, 5);\n// copyWithin(起始位置，开始位置，结束位置)\n// [1, 4, 5, 4, 5, 6]\n```\n\n(3)排序\n\n```javascript\n// 自定义排序\nconst friends = [\n  { name: 'John', age: 30 },\n  { name: 'Ana', age: 20 },\n  { name: 'Chris', age: 25 }, // ES2017 允许存在尾逗号\n];\nfunction comparePerson(a, b) {\n  if (a.age < b.age) {\n    return -1;\n  }\n  if (a.age > b.age) {\n    return 1;\n  }\n  return 0;\n}\nconsole.log(friends.sort(comparePerson));\n/**\n[ \n { name: 'Ana', age: 20 }, \n { name: 'Chris', age: 25 },\n { name: 'John', age: 30 }, \n]\n*/\n// 忽略大小写的比较\nconst names = ['Ana', 'ana', 'john', 'John']; // 重置数组的初始状态\nconsole.log(\n  names.sort((a, b) => {\n    if (a.toLowerCase() < b.toLowerCase()) {\n      return -1;\n    }\n    if (a.toLowerCase() > b.toLowerCase()) {\n      return 1;\n    }\n    return 0;\n  })\n);\n// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法\nconst names = ['Ana', 'ana', 'john', 'John'];\nnames.sort((a, b) => a.localeCompare(b));\n// ['ana', 'Ana', 'john', 'John']\n\nconst names2 = ['Maève', 'Maeve'];\nconsole.log(names2.sort((a, b) => a.localeCompare(b)));\n// [\"Maeve\", \"Maève\"]\n```\n\n###### 类型数组\n\n| 类型数组          | 数据类型            |\n| ----------------- | ------------------- |\n| Int8Array         | 8 位二进制补码整数  |\n| Uint8Array        | 8 位无符号整数      |\n| Uint8ClampedArray | 8 位无符号整数      |\n| Int16Array        | 16 位二进制补码整数 |\n| Uint16Array       | 16 位无符号整数     |\n| Int32Array        | 32 位二进制补码整数 |\n| Uint32Array       | 32 位无符号整数     |\n| Float32Array      | 32 位 IEEE 浮点数   |\n| Float64Array      | 64 位 IEEE 浮点数   |\n\n```javascript\nlet length = 5;\nlet int16 = new Int16Array(length);\nlet array16 = [];\narray16.length = length;\nfor (let i = 0; i < length; i++) {\n  int16[i] = i + 1;\n}\nconsole.log(int16);\n```\n\n类型数组作用：WebGL API、位操作、处理文件和图像\n\n[类型数组文档](https://web.dev/webgl-typed-arrays/)\n\n###### 栈\n\n栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底\n\n栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）\n\n(1)创建一个基于数组的栈\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  // 添加一个（或几个）新元素到栈顶\n  push(element) {\n    this.items.push(element);\n  }\n  // 移除栈顶的元素，同时返回被移除的元素\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  // 如果栈里没有任何元素就返回 true，否则返回 false\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 返回栈里的元素个数。该方法和数组的 length 属性很类似\n  size() {\n    return this.items.length;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = [];\n  }\n}\n```\n\n**在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。**\n(2)创建一个基于 JavaScript 对象的 Stack 类\n\n```javascript\nclass Stack {\n  constructor() {\n    this.count = 0; // count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素\n    this.items = {};\n  }\n  // 向栈中插入元素,只允许一次插入一个元素\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 验证一个栈的大小\n  size() {\n    return this.count;\n  }\n  // 获取栈是否为空\n  isEmpty() {\n    return this.count === 0;\n  }\n  // 从栈中弹出元素\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  // 查看栈顶的值\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  // 清空栈\n  clear() {\n    this.items = {};\n    this.count = 0;\n    //  while (!this.isEmpty()) {\n    //  this.pop();\n    // }\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[0]}`; // {1}\n    for (let i = 1; i < this.count; i++) {\n      // {2}\n      objString = `${objString},${this.items[i]}`; // {3}\n    }\n    return objString;\n  }\n}\n```\n\n**javascript 实现私有属性的方法**\n下划线命名约定\n\n```javascript\n// 中使用下划线命名约定来标记一个属性为私有属性\nclass Stack {\n  constructor() {\n    this._count = 0;\n    this._items = {};\n  }\n}\n```\n\n_下划线命名约定就是在属性名称之前加上一个下划线（\\_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识_\n\n**用 ES2015 的限定作用域 Symbol 实现类**\n\n```javascript\nconst _items = Symbol('stackItems');\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n  // 栈的方法\n}\n\nconst stack = new Stack();\nstack.push(5);\nstack.push(8);\nlet objectSymbols = Object.getOwnPropertySymbols(stack);\nconsole.log(objectSymbols.length); // 输出 1\nconsole.log(objectSymbols); // [Symbol()]\nconsole.log(objectSymbols[0]); // Symbol()\nstack[objectSymbols[0]].push(1);\nstack.print(); // 输出 5, 8, 1\n```\n\n_访问 stack[objectSymbols[0]]得到\\_items,并且，\\_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求_\n\n**用 ES2015 的 WeakMap 实现类**\nWeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型\n\n```javascript\nconst items = new WeakMap(); // {1}\nclass Stack {\n  constructor() {\n    items.set(this, []); // {2}\n  }\n  push(element) {\n    const s = items.get(this); // {3}\n    s.push(element);\n  }\n  pop() {\n    const s = items.get(this);\n    const r = s.pop();\n    return r;\n  }\n  // 其他方法\n}\n```\n\n_代码的可读性不强，而且在扩展该类时无法继承私有属性_\n\n**ECMAScript 类属性提案**\n\n```javascript\nclass Stack {\n  #count = 0;\n  #items = 0;\n  // 栈的方法\n}\n```\n\n**从十进制转二进制**\n\n```javascript\nfunction decimalToBinary(decNumber) {\n  const remStack = new Stack();\n  let number = decNumber;\n  let rem;\n  let binaryString = '';\n  while (number > 0) {\n    rem = Math.floor(number % 2);\n    remStack.push(rem);\n    number = Math.floor(number / 2);\n  }\n  while (!remStack.isEmpty()) {\n    binaryString += remStack.pop().toString();\n  }\n  return binaryString;\n}\n```\n\n**进制转换算法**\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const remStack = new Stack();\n  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6}\n  let number = decNumber;\n  let rem;\n  let baseString = '';\n  if (!(base >= 2 && base <= 36)) {\n    return '';\n  }\n  while (number > 0) {\n    rem = Math.floor(number % base);\n    remStack.push(rem);\n    number = Math.floor(number / base);\n  }\n  while (!remStack.isEmpty()) {\n    baseString += digits[remStack.pop()]; // {7}\n  }\n  return baseString;\n}\n```\n","slug":"33-data-structure1","published":1,"updated":"2022-09-23T07:51:52.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q0000vk4tt6jlr5l35","content":"<p>ECMAScript 和 javascript 的关系<br>ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。</p>\n<p>ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别</p>\n<p>(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)</p>\n<p>(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性<br>一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)</p>\n<p>(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)</p>\n<p>(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)</p>\n<p>(5)ES.Next 用来指代下一个版本的 ECMAScript</p>\n<p>ES6 兼容性：<a href=\"http://kangax.github.io/compat-table/es6/\">http://kangax.github.io/compat-table/es6/</a><br>ES7 兼容性：<a href=\"http://kangax.github.io/compat-table/es2016plus/\">http://kangax.github.io/compat-table/es2016plus/</a></p>\n<p>ES5 中 class 类，使用属性存取器<br>(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字<br>(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = name; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">name</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">name</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lotrChar = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Frodo&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// &#123;4&#125; // Frodo</span></span><br><span class=\"line\">lotrChar.name = <span class=\"string\">&#x27;Gandalf&#x27;</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Gandalf</span></span><br><span class=\"line\">lotrChar._name = <span class=\"string\">&#x27;Sam&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Sam</span></span><br></pre></td></tr></table></figure>\n\n<p>乘方运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r * r;</span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * <span class=\"built_in\">Math</span>.pow(r, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// ES2016 中引入了**运算符，用来进行指数运算</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r ** <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript 和 ECMAScript 的完整功能列表</a></p>\n<h6 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h6><p>TypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.<br>(1)接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种定义接口的方式</span></span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(person.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，</span></span><br><span class=\"line\"><span class=\"comment\">并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/</span></span><br><span class=\"line\">interface Comparable &#123;</span><br><span class=\"line\">  compareTo(b): number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> <span class=\"title\">implements</span> <span class=\"title\">Comparable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">  compareTo(b): number &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.age === b.age) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age &gt; b.age ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check</strong></p>\n<h6 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h6><p>数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组</p>\n<p>(1)使用@@iterator 对象<br>ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\">iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> iterator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制已有数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers2 = <span class=\"built_in\">Array</span>.from(numbers);</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers3 = <span class=\"built_in\">Array</span>.of(...numbers);</span><br></pre></td></tr></table></figure>\n\n<p>(2)copyWithin<br>copyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">copyArray.copyWithin(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// copyWithin(起始位置，开始位置，结束位置)</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 4, 5, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义排序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> friends = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">20</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Chris&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;, <span class=\"comment\">// ES2017 允许存在尾逗号</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">comparePerson</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &lt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &gt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friends.sort(comparePerson));</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">[ </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Chris&#x27;, age: 25 &#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;John&#x27;, age: 30 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 忽略大小写的比较</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>]; <span class=\"comment\">// 重置数组的初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &lt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &gt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>];</span><br><span class=\"line\">names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class=\"line\"><span class=\"comment\">// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names2 = [<span class=\"string\">&#x27;Maève&#x27;</span>, <span class=\"string\">&#x27;Maeve&#x27;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names2.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b)));</span><br><span class=\"line\"><span class=\"comment\">// [&quot;Maeve&quot;, &quot;Maève&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"类型数组\"><a href=\"#类型数组\" class=\"headerlink\" title=\"类型数组\"></a>类型数组</h6><table>\n<thead>\n<tr>\n<th>类型数组</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>8 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint8Array</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Uint8ClampedArray</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>16 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>16 位无符号整数</td>\n</tr>\n<tr>\n<td>Int32Array</td>\n<td>32 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint32Array</td>\n<td>32 位无符号整数</td>\n</tr>\n<tr>\n<td>Float32Array</td>\n<td>32 位 IEEE 浮点数</td>\n</tr>\n<tr>\n<td>Float64Array</td>\n<td>64 位 IEEE 浮点数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> length = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> int16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(length);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array16 = [];</span><br><span class=\"line\">array16.length = length;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">  int16[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int16);</span><br></pre></td></tr></table></figure>\n\n<p>类型数组作用：WebGL API、位操作、处理文件和图像</p>\n<p><a href=\"https://web.dev/webgl-typed-arrays/\">类型数组文档</a></p>\n<h6 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h6><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底</p>\n<p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）</p>\n<p>(1)创建一个基于数组的栈</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个（或几个）新元素到栈顶</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.items.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈里的元素个数。该方法和数组的 length 属性很类似</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈里的所有元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。</strong><br>(2)创建一个基于 JavaScript 对象的 Stack 类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向栈中插入元素,只允许一次插入一个元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 验证一个栈的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取栈是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从栈中弹出元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看栈顶的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空栈</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  while (!this.isEmpty()) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//  this.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>]&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>javascript 实现私有属性的方法</strong><br>下划线命名约定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中使用下划线命名约定来标记一个属性为私有属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识</em></p>\n<p><strong>用 ES2015 的限定作用域 Symbol 实现类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _items = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;stackItems&#x27;</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(stack);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols.length); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols); <span class=\"comment\">// [Symbol()]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols[<span class=\"number\">0</span>]); <span class=\"comment\">// Symbol()</span></span><br><span class=\"line\">stack[objectSymbols[<span class=\"number\">0</span>]].push(<span class=\"number\">1</span>);</span><br><span class=\"line\">stack.print(); <span class=\"comment\">// 输出 5, 8, 1</span></span><br></pre></td></tr></table></figure>\n\n<p><em>访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求</em></p>\n<p><strong>用 ES2015 的 WeakMap 实现类</strong><br>WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    items.set(<span class=\"built_in\">this</span>, []); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    s.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = s.pop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>代码的可读性不强，而且在扩展该类时无法继承私有属性</em></p>\n<p><strong>ECMAScript 类属性提案</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  #count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  #items = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>从十进制转二进制</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decimalToBinary</span>(<span class=\"params\">decNumber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> binaryString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % <span class=\"number\">2</span>);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    binaryString += remStack.pop().toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binaryString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进制转换算法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> baseString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(base &gt;= <span class=\"number\">2</span> &amp;&amp; base &lt;= <span class=\"number\">36</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % base);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    baseString += digits[remStack.pop()]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>ECMAScript 和 javascript 的关系<br>ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。</p>\n<p>ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别</p>\n<p>(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)</p>\n<p>(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性<br>一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)</p>\n<p>(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)</p>\n<p>(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)</p>\n<p>(5)ES.Next 用来指代下一个版本的 ECMAScript</p>\n<p>ES6 兼容性：<a href=\"http://kangax.github.io/compat-table/es6/\">http://kangax.github.io/compat-table/es6/</a><br>ES7 兼容性：<a href=\"http://kangax.github.io/compat-table/es2016plus/\">http://kangax.github.io/compat-table/es2016plus/</a></p>\n<p>ES5 中 class 类，使用属性存取器<br>(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字<br>(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = name; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">name</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">name</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lotrChar = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Frodo&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// &#123;4&#125; // Frodo</span></span><br><span class=\"line\">lotrChar.name = <span class=\"string\">&#x27;Gandalf&#x27;</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Gandalf</span></span><br><span class=\"line\">lotrChar._name = <span class=\"string\">&#x27;Sam&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Sam</span></span><br></pre></td></tr></table></figure>\n\n<p>乘方运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r * r;</span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * <span class=\"built_in\">Math</span>.pow(r, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// ES2016 中引入了**运算符，用来进行指数运算</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r ** <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript 和 ECMAScript 的完整功能列表</a></p>\n<h6 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h6><p>TypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.<br>(1)接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种定义接口的方式</span></span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(person.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，</span></span><br><span class=\"line\"><span class=\"comment\">并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/</span></span><br><span class=\"line\">interface Comparable &#123;</span><br><span class=\"line\">  compareTo(b): number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> <span class=\"title\">implements</span> <span class=\"title\">Comparable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">  compareTo(b): number &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.age === b.age) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age &gt; b.age ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check</strong></p>\n<h6 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h6><p>数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组</p>\n<p>(1)使用@@iterator 对象<br>ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\">iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> iterator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制已有数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers2 = <span class=\"built_in\">Array</span>.from(numbers);</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers3 = <span class=\"built_in\">Array</span>.of(...numbers);</span><br></pre></td></tr></table></figure>\n\n<p>(2)copyWithin<br>copyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">copyArray.copyWithin(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// copyWithin(起始位置，开始位置，结束位置)</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 4, 5, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义排序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> friends = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">20</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Chris&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;, <span class=\"comment\">// ES2017 允许存在尾逗号</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">comparePerson</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &lt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &gt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friends.sort(comparePerson));</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">[ </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Chris&#x27;, age: 25 &#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;John&#x27;, age: 30 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 忽略大小写的比较</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>]; <span class=\"comment\">// 重置数组的初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &lt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &gt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>];</span><br><span class=\"line\">names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class=\"line\"><span class=\"comment\">// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names2 = [<span class=\"string\">&#x27;Maève&#x27;</span>, <span class=\"string\">&#x27;Maeve&#x27;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names2.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b)));</span><br><span class=\"line\"><span class=\"comment\">// [&quot;Maeve&quot;, &quot;Maève&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"类型数组\"><a href=\"#类型数组\" class=\"headerlink\" title=\"类型数组\"></a>类型数组</h6><table>\n<thead>\n<tr>\n<th>类型数组</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>8 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint8Array</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Uint8ClampedArray</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>16 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>16 位无符号整数</td>\n</tr>\n<tr>\n<td>Int32Array</td>\n<td>32 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint32Array</td>\n<td>32 位无符号整数</td>\n</tr>\n<tr>\n<td>Float32Array</td>\n<td>32 位 IEEE 浮点数</td>\n</tr>\n<tr>\n<td>Float64Array</td>\n<td>64 位 IEEE 浮点数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> length = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> int16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(length);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array16 = [];</span><br><span class=\"line\">array16.length = length;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">  int16[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int16);</span><br></pre></td></tr></table></figure>\n\n<p>类型数组作用：WebGL API、位操作、处理文件和图像</p>\n<p><a href=\"https://web.dev/webgl-typed-arrays/\">类型数组文档</a></p>\n<h6 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h6><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底</p>\n<p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）</p>\n<p>(1)创建一个基于数组的栈</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个（或几个）新元素到栈顶</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.items.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈里的元素个数。该方法和数组的 length 属性很类似</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈里的所有元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。</strong><br>(2)创建一个基于 JavaScript 对象的 Stack 类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向栈中插入元素,只允许一次插入一个元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 验证一个栈的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取栈是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从栈中弹出元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看栈顶的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空栈</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  while (!this.isEmpty()) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//  this.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>]&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>javascript 实现私有属性的方法</strong><br>下划线命名约定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中使用下划线命名约定来标记一个属性为私有属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识</em></p>\n<p><strong>用 ES2015 的限定作用域 Symbol 实现类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _items = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;stackItems&#x27;</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(stack);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols.length); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols); <span class=\"comment\">// [Symbol()]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols[<span class=\"number\">0</span>]); <span class=\"comment\">// Symbol()</span></span><br><span class=\"line\">stack[objectSymbols[<span class=\"number\">0</span>]].push(<span class=\"number\">1</span>);</span><br><span class=\"line\">stack.print(); <span class=\"comment\">// 输出 5, 8, 1</span></span><br></pre></td></tr></table></figure>\n\n<p><em>访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求</em></p>\n<p><strong>用 ES2015 的 WeakMap 实现类</strong><br>WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    items.set(<span class=\"built_in\">this</span>, []); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    s.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = s.pop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>代码的可读性不强，而且在扩展该类时无法继承私有属性</em></p>\n<p><strong>ECMAScript 类属性提案</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  #count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  #items = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>从十进制转二进制</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decimalToBinary</span>(<span class=\"params\">decNumber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> binaryString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % <span class=\"number\">2</span>);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    binaryString += remStack.pop().toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binaryString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进制转换算法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> baseString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(base &gt;= <span class=\"number\">2</span> &amp;&amp; base &lt;= <span class=\"number\">36</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % base);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    baseString += digits[remStack.pop()]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构与算法阅读笔记(2)","date":"2022-09-23T07:52:54.000Z","_content":"\n#### 队列\n\n队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾\n\n```javascript\nclass Queue {\n  constructor() {\n    this.count = 0; // {1}\n    this.lowestCount = 0; // {2}\n    this.items = {}; // {3}\n  }\n  // 向队列添加元素\n  enqueue(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 从队列移除元素\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  // 查看队列头元素\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  // 获取队列的长度\n  size() {\n    return this.count - this.lowestCount;\n  }\n  // 清空队列\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n```\n\n###### 双端队列\n\n双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列\n\n由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构\n\n```javascript\nclass Deque {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n // 向双端队列的前端添加元素\n  addFront(element) {\n    if (this.isEmpty()) { // {1}\n      this.addBack(element);\n    } else if (this.lowestCount > 0) { // {2}\n      this.lowestCount--;\n      this.items[this.lowestCount] = element;\n    } else {\n      for (let i = this.count; i > 0; i--) { // {3}\n        this.items[i] = this.items[i - 1];\n      }\n      this.count++;\n      this.lowestCount = 0;\n      this.items[0] = element; // {4}\n    }\n  }\n  addBack(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  removeFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  removeBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  peekFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  peekBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  clear() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n}\n```\n\n###### 循环队列 - 击鼓传花\n场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）\n```javascript\nfunction hotPotato(elementsList, num) { \n  const queue = new Queue(); // {1} \n  const elimitatedList = [];\n  // 把名单的名字全都加入队列\n  for (let i = 0; i < elementsList.length; i++) { \n    queue.enqueue(elementsList[i]); // {2} \n  }\n  // 迭代队列\n  while (queue.size() > 1) { \n    for (let i = 0; i < num; i++) { \n      // 将队列开头一项移除，添加到队列末尾\n      queue.enqueue(queue.dequeue()); // {3} \n    } \n    // 将超出限制的队列开头一项移除，作为淘汰项\n    elimitatedList.push(queue.dequeue()); // {4} \n  } \n  return { \n    eliminated: elimitatedList, \n    winner: queue.dequeue() // {5} \n  };\n}\n\nconst names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; \nconst result = hotPotato(names, 7);\nresult.eliminated.forEach(name => { \n console.log(`${name}在击鼓传花游戏中被淘汰。`); \n}); \nconsole.log(`胜利者： ${result.winner}`);\n```\n\n###### 回文检查器\n回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。\n```javascript\nfunction palindromeChecker(aString) {\n  // 检查传入的字符串参数是否合法\n  if (aString === undefined || aString === null || (aString !== null && aString.length === 0)) { // {1} \n    return false;\n  } \n  const deque = new Deque(); // {2}\n  // 将所有字母转化为小写，同时移除所有的空格\n  const lowerString = aString.toLocaleLowerCase().split(' ').join(''); // {3} \n  let isEqual = true; \n  let firstChar, lastChar;\n  // 将所有字符串加入队列中\n  for (let i = 0; i < lowerString.length; i++) { // {4} \n    deque.addBack(lowerString.charAt(i)); \n  }\n\n  while (deque.size() > 1 && isEqual) { // {5} \n    firstChar = deque.removeFront(); // {6} \n    lastChar = deque.removeBack(); // {7}\n\n    if (firstChar !== lastChar) { \n      isEqual = false; // {8} \n    }\n  } \n  return isEqual;\n}\n```\n\n[javascript事件循环](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n\n#### 链表\n\n###### 链表数据结构\n![链表](chain-table-1.png)\n链表的好处：添加或移除元素的时候不需要移动其他元素\n要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素\n```javascript\n// util.js\nexport function defaultEquals(a, b) { \n  return a === b; \n}\n// models/linked-list-models\nexport class Node {\n  constructor(element) {\n    this.element = element; \n    this.next = undefined; \n  }\n} \n\nimport { defaultEquals } from '../util'; \nimport { Node } from './models/linked-list-models'; // {1} \nexport default class LinkedList { \n  constructor(equalsFn = defaultEquals) { \n    this.count = 0; // {2} \n    this.head = undefined; // {3}\n    this.equalsFn = equalsFn; // {4} \n  }\n  // 向链表尾部添加元素\n  push(element) { \n    const node = new Node(element); // {1} \n    let current; // {2} \n\n    if (this.head == null) { // {3} \n      this.head = node;\n    } else {\n      current = this.head; // {4} \n      while (current.next != null) { // {5} 获得最后一项\n        current = current.next; \n      }\n      // 将其 next 赋为新元素，建立链接\n      current.next = node; // {6} \n    } \n    this.count++; // {7} \n  }\n  // 从链表中移除元素\n  removeAt(index) { \n    // 检查越界值\n    if (index >= 0 && index < this.count) { // {1} \n      let current = this.head; // {2} \n      // 移除第一项\n      if (index === 0) { // {3} \n        this.head = current.next; \n      } else {\n        // 获取当前index的前一个节点\n        const previous = this.getElementAt(index - 1);\n        current = previous.next;\n        // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它\n        previous.next = current.next; // {8} \n      }\n      this.count--; // {9} \n      return current.element; \n    } \n    return undefined; // {10} \n  }\n  // 循环迭代链表直到目标位置\n  getElementAt(index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      let node = this.head; // {2} \n      for (let i = 0; i < index && node != null; i++) { // {3} \n        node = node.next;\n      } \n      return node; // {4} \n    } \n    return undefined; // {5} \n  }\n  // 在任意位置插入元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      const node = new Node(element);\n\n      if (index === 0) { // 在第一个位置添加\n        const current = this.head; \n        node.next = current; // {2} \n        this.head = node; \n      } else { \n        const previous = this.getElementAt(index - 1); // {3} \n        const current = previous.next; // {4} \n        node.next = current; // {5} \n        previous.next = node; // {6} \n      } \n      this.count++; // 更新链表的长度\n      return true; \n    } \n    return false; // {7} \n  }\n  //  indexOf 方法：返回一个元素的位置\n  indexOf(element) { \n    let current = this.head; // {1} \n    for (let i = 0; i < this.count && current != null; i++) { // {2} \n      if (this.equalsFn(element, current.element)) { // {3} \n        return i; // {4} \n      }\n      current = current.next; // {5} \n    } \n    return -1; // {6} \n  }\n  // 从链表中移除元素\n  remove(element) { \n    const index = this.indexOf(element); \n    return this.removeAt(index); \n  }\n  size() { \n    return this.count; \n  }\n  isEmpty() { \n    return this.count === 0; \n  }\n  getHead() {\n    return this.head; \n  }\n  toString() { \n    if (this.head == null) { // {1} \n      return ''; \n    } \n    let objString = `${this.head.element}`; // {2} \n    let current = this.head.next; // {3} \n\n    for (let i = 1; i < this.size() && current != null; i++) { // {4} \n      objString = `${objString},${current.element}`; \n      current = current.next;\n    } \n    return objString; // {5} \n  }\n}\n```\n[javascript垃圾回收器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)\n\n###### 双向链表\n在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素\n![双向链表](chain-table-2.png)\n```javascript\nclass DoublyNode extends Node { // {1} \n constructor(element, next, prev) { \n  super(element, next); // {2} \n  this.prev = prev; // {3} 新增的\n } \n}\n\nclass DoublyLinkedList extends LinkedList { // {4} \n  constructor(equalsFn = defaultEquals) { \n    super(equalsFn); // {5} \n    this.tail = undefined; // {6} 新增的\n  }\n  //  在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new DoublyNode(element); \n      let current = this.head;\n\n      if (index === 0) { \n          if (this.head == null) { // {1} 新增的\n            this.head = node; \n            this.tail = node; \n          } else { \n            node.next = this.head; // {2} \n            current.prev = node; // {3} 新增的\n            this.head = node; // {4} \n          } \n      } else if (index === this.count) { // 最后一项 // 新增的\n        current = this.tail; // {5} \n        current.next = node; // {6} \n        node.prev = current; // {7} \n        this.tail = node; // {8} \n      } else { \n        const previous = this.getElementAt(index - 1); // {9} \n        current = previous.next; // {10} \n        node.next = current; // {11} \n        previous.next = node; // {12} \n        current.prev = node; // {13} 新增的\n        node.prev = previous; // {14} 新增的\n      }\n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        this.head = current.next; // {1} \n        // 如果只有一项，更新 tail // 新增的\n        if (this.count === 1) { // {2} \n          this.tail = undefined; \n        } else { \n          this.head.prev = undefined; // {3} \n        } \n      } else if (index === this.count - 1) { // 最后一项 //新增的\n        current = this.tail; // {4} \n        this.tail = current.prev; // {5} \n        this.tail.next = undefined; // {6} \n      } else { \n        current = this.getElementAt(index); // {7} \n        const previous = current.prev; // {8} \n        // 将 previous 与 current 的下一项链接起来——跳过 current \n        previous.next = current.next; // {9} \n        current.next.prev = previous; // {10} 新增的\n      }\n      this.count--; \n      return current.element; \n    } \n    return undefined; \n  }\n}\n// 源码：https://github.com/loiane/javascript-datastructures-algorithms\n```\n\n###### 循环链表\n循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）\n双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev\n![循环链表](chain-table-3.png)\n![双向循环链表](chain-table-4.png)\n\n```javascript\nclass CircularLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals) {\n    super(equalsFn); \n  }\n  // 在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new Node(element); \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.head == null) { \n          this.head = node; // {1} \n          node.next = this.head; // {2} 新增的\n        } else { \n          node.next = current; // {3} \n          current = this.getElementAt(this.size()); // {4} \n          // 更新最后一个元素\n          this.head = node; // {5} \n          current.next = this.head; // {6} 新增的\n        }\n      } else { // 这种场景没有变化\n        const previous = this.getElementAt(index - 1); \n        node.next = previous.next; \n        previous.next = node; \n      } \n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.size() === 1) { \n          this.head = undefined; \n        } else { \n          const removed = this.head; // {1} \n          current = this.getElementAt(this.size()); // {2} 新增的\n          this.head = this.head.next; // {3} \n          current.next = this.head; // {4} \n          current = removed; // {5}\n        }\n      } else { \n        // 不需要修改循环链表最后一个元素\n        const previous = this.getElementAt(index - 1); \n        current = previous.next; \n        previous.next = current.next; \n      }\n      this.count--; \n      return current.element; // {6} \n    } \n    return undefined; \n  }\n}\n```\n\n###### 有序链表\n有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。\n```javascript\nconst Compare = { \n  LESS_THAN: -1, \n  BIGGER_THAN: 1 \n}; \nfunction defaultCompare(a, b) { \n  if (a === b) { // {1} \n    return 0; \n  } \n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN; // {2} \n} \nclass SortedLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals, compareFn = defaultCompare) { \n    super(equalsFn); \n    this.compareFn = compareFn; // {3} \n  }\n  // 有序插入元素\n  insert(element, index = 0) { // {1} \n    if (this.isEmpty()) { \n      return super.insert(element, 0); // {2} \n    } \n    const pos = this.getIndexNextSortedElement(element); // {3} \n    return super.insert(element, pos); // {4} \n  } \n  getIndexNextSortedElement(element) { \n    let current = this.head; \n    let i = 0; \n    for (; i < this.size() && current; i++) { \n      const comp = this.compareFn(element, current.element); // {5} \n      if (comp === Compare.LESS_THAN) { // {6} \n        return i; \n      } \n      current = current.next; \n    } \n    return i; // {7} \n  }\n}\n```\n\n###### 创建 StackLinkedList 类\n```javascript\nclass StackLinkedList { \n  constructor() { \n    this.items = new DoublyLinkedList(); // {1} \n  } \n  push(element) { \n    this.items.push(element); // {2} \n  } \n  pop() { \n    if (this.isEmpty()) { \n      return undefined; \n    } \n    return this.items.removeAt(this.size() - 1); // {3} \n  } \n}\n```","source":"_posts/34-data-structure2.md","raw":"---\ntitle: 数据结构与算法阅读笔记(2)\ndate: 2022-09-23 15:52:54\ntags:\n---\n\n#### 队列\n\n队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾\n\n```javascript\nclass Queue {\n  constructor() {\n    this.count = 0; // {1}\n    this.lowestCount = 0; // {2}\n    this.items = {}; // {3}\n  }\n  // 向队列添加元素\n  enqueue(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 从队列移除元素\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  // 查看队列头元素\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  // 获取队列的长度\n  size() {\n    return this.count - this.lowestCount;\n  }\n  // 清空队列\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n```\n\n###### 双端队列\n\n双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列\n\n由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构\n\n```javascript\nclass Deque {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n // 向双端队列的前端添加元素\n  addFront(element) {\n    if (this.isEmpty()) { // {1}\n      this.addBack(element);\n    } else if (this.lowestCount > 0) { // {2}\n      this.lowestCount--;\n      this.items[this.lowestCount] = element;\n    } else {\n      for (let i = this.count; i > 0; i--) { // {3}\n        this.items[i] = this.items[i - 1];\n      }\n      this.count++;\n      this.lowestCount = 0;\n      this.items[0] = element; // {4}\n    }\n  }\n  addBack(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  removeFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  removeBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  peekFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  peekBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  clear() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n}\n```\n\n###### 循环队列 - 击鼓传花\n场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）\n```javascript\nfunction hotPotato(elementsList, num) { \n  const queue = new Queue(); // {1} \n  const elimitatedList = [];\n  // 把名单的名字全都加入队列\n  for (let i = 0; i < elementsList.length; i++) { \n    queue.enqueue(elementsList[i]); // {2} \n  }\n  // 迭代队列\n  while (queue.size() > 1) { \n    for (let i = 0; i < num; i++) { \n      // 将队列开头一项移除，添加到队列末尾\n      queue.enqueue(queue.dequeue()); // {3} \n    } \n    // 将超出限制的队列开头一项移除，作为淘汰项\n    elimitatedList.push(queue.dequeue()); // {4} \n  } \n  return { \n    eliminated: elimitatedList, \n    winner: queue.dequeue() // {5} \n  };\n}\n\nconst names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; \nconst result = hotPotato(names, 7);\nresult.eliminated.forEach(name => { \n console.log(`${name}在击鼓传花游戏中被淘汰。`); \n}); \nconsole.log(`胜利者： ${result.winner}`);\n```\n\n###### 回文检查器\n回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。\n```javascript\nfunction palindromeChecker(aString) {\n  // 检查传入的字符串参数是否合法\n  if (aString === undefined || aString === null || (aString !== null && aString.length === 0)) { // {1} \n    return false;\n  } \n  const deque = new Deque(); // {2}\n  // 将所有字母转化为小写，同时移除所有的空格\n  const lowerString = aString.toLocaleLowerCase().split(' ').join(''); // {3} \n  let isEqual = true; \n  let firstChar, lastChar;\n  // 将所有字符串加入队列中\n  for (let i = 0; i < lowerString.length; i++) { // {4} \n    deque.addBack(lowerString.charAt(i)); \n  }\n\n  while (deque.size() > 1 && isEqual) { // {5} \n    firstChar = deque.removeFront(); // {6} \n    lastChar = deque.removeBack(); // {7}\n\n    if (firstChar !== lastChar) { \n      isEqual = false; // {8} \n    }\n  } \n  return isEqual;\n}\n```\n\n[javascript事件循环](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n\n#### 链表\n\n###### 链表数据结构\n![链表](chain-table-1.png)\n链表的好处：添加或移除元素的时候不需要移动其他元素\n要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素\n```javascript\n// util.js\nexport function defaultEquals(a, b) { \n  return a === b; \n}\n// models/linked-list-models\nexport class Node {\n  constructor(element) {\n    this.element = element; \n    this.next = undefined; \n  }\n} \n\nimport { defaultEquals } from '../util'; \nimport { Node } from './models/linked-list-models'; // {1} \nexport default class LinkedList { \n  constructor(equalsFn = defaultEquals) { \n    this.count = 0; // {2} \n    this.head = undefined; // {3}\n    this.equalsFn = equalsFn; // {4} \n  }\n  // 向链表尾部添加元素\n  push(element) { \n    const node = new Node(element); // {1} \n    let current; // {2} \n\n    if (this.head == null) { // {3} \n      this.head = node;\n    } else {\n      current = this.head; // {4} \n      while (current.next != null) { // {5} 获得最后一项\n        current = current.next; \n      }\n      // 将其 next 赋为新元素，建立链接\n      current.next = node; // {6} \n    } \n    this.count++; // {7} \n  }\n  // 从链表中移除元素\n  removeAt(index) { \n    // 检查越界值\n    if (index >= 0 && index < this.count) { // {1} \n      let current = this.head; // {2} \n      // 移除第一项\n      if (index === 0) { // {3} \n        this.head = current.next; \n      } else {\n        // 获取当前index的前一个节点\n        const previous = this.getElementAt(index - 1);\n        current = previous.next;\n        // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它\n        previous.next = current.next; // {8} \n      }\n      this.count--; // {9} \n      return current.element; \n    } \n    return undefined; // {10} \n  }\n  // 循环迭代链表直到目标位置\n  getElementAt(index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      let node = this.head; // {2} \n      for (let i = 0; i < index && node != null; i++) { // {3} \n        node = node.next;\n      } \n      return node; // {4} \n    } \n    return undefined; // {5} \n  }\n  // 在任意位置插入元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      const node = new Node(element);\n\n      if (index === 0) { // 在第一个位置添加\n        const current = this.head; \n        node.next = current; // {2} \n        this.head = node; \n      } else { \n        const previous = this.getElementAt(index - 1); // {3} \n        const current = previous.next; // {4} \n        node.next = current; // {5} \n        previous.next = node; // {6} \n      } \n      this.count++; // 更新链表的长度\n      return true; \n    } \n    return false; // {7} \n  }\n  //  indexOf 方法：返回一个元素的位置\n  indexOf(element) { \n    let current = this.head; // {1} \n    for (let i = 0; i < this.count && current != null; i++) { // {2} \n      if (this.equalsFn(element, current.element)) { // {3} \n        return i; // {4} \n      }\n      current = current.next; // {5} \n    } \n    return -1; // {6} \n  }\n  // 从链表中移除元素\n  remove(element) { \n    const index = this.indexOf(element); \n    return this.removeAt(index); \n  }\n  size() { \n    return this.count; \n  }\n  isEmpty() { \n    return this.count === 0; \n  }\n  getHead() {\n    return this.head; \n  }\n  toString() { \n    if (this.head == null) { // {1} \n      return ''; \n    } \n    let objString = `${this.head.element}`; // {2} \n    let current = this.head.next; // {3} \n\n    for (let i = 1; i < this.size() && current != null; i++) { // {4} \n      objString = `${objString},${current.element}`; \n      current = current.next;\n    } \n    return objString; // {5} \n  }\n}\n```\n[javascript垃圾回收器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)\n\n###### 双向链表\n在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素\n![双向链表](chain-table-2.png)\n```javascript\nclass DoublyNode extends Node { // {1} \n constructor(element, next, prev) { \n  super(element, next); // {2} \n  this.prev = prev; // {3} 新增的\n } \n}\n\nclass DoublyLinkedList extends LinkedList { // {4} \n  constructor(equalsFn = defaultEquals) { \n    super(equalsFn); // {5} \n    this.tail = undefined; // {6} 新增的\n  }\n  //  在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new DoublyNode(element); \n      let current = this.head;\n\n      if (index === 0) { \n          if (this.head == null) { // {1} 新增的\n            this.head = node; \n            this.tail = node; \n          } else { \n            node.next = this.head; // {2} \n            current.prev = node; // {3} 新增的\n            this.head = node; // {4} \n          } \n      } else if (index === this.count) { // 最后一项 // 新增的\n        current = this.tail; // {5} \n        current.next = node; // {6} \n        node.prev = current; // {7} \n        this.tail = node; // {8} \n      } else { \n        const previous = this.getElementAt(index - 1); // {9} \n        current = previous.next; // {10} \n        node.next = current; // {11} \n        previous.next = node; // {12} \n        current.prev = node; // {13} 新增的\n        node.prev = previous; // {14} 新增的\n      }\n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        this.head = current.next; // {1} \n        // 如果只有一项，更新 tail // 新增的\n        if (this.count === 1) { // {2} \n          this.tail = undefined; \n        } else { \n          this.head.prev = undefined; // {3} \n        } \n      } else if (index === this.count - 1) { // 最后一项 //新增的\n        current = this.tail; // {4} \n        this.tail = current.prev; // {5} \n        this.tail.next = undefined; // {6} \n      } else { \n        current = this.getElementAt(index); // {7} \n        const previous = current.prev; // {8} \n        // 将 previous 与 current 的下一项链接起来——跳过 current \n        previous.next = current.next; // {9} \n        current.next.prev = previous; // {10} 新增的\n      }\n      this.count--; \n      return current.element; \n    } \n    return undefined; \n  }\n}\n// 源码：https://github.com/loiane/javascript-datastructures-algorithms\n```\n\n###### 循环链表\n循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）\n双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev\n![循环链表](chain-table-3.png)\n![双向循环链表](chain-table-4.png)\n\n```javascript\nclass CircularLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals) {\n    super(equalsFn); \n  }\n  // 在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new Node(element); \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.head == null) { \n          this.head = node; // {1} \n          node.next = this.head; // {2} 新增的\n        } else { \n          node.next = current; // {3} \n          current = this.getElementAt(this.size()); // {4} \n          // 更新最后一个元素\n          this.head = node; // {5} \n          current.next = this.head; // {6} 新增的\n        }\n      } else { // 这种场景没有变化\n        const previous = this.getElementAt(index - 1); \n        node.next = previous.next; \n        previous.next = node; \n      } \n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.size() === 1) { \n          this.head = undefined; \n        } else { \n          const removed = this.head; // {1} \n          current = this.getElementAt(this.size()); // {2} 新增的\n          this.head = this.head.next; // {3} \n          current.next = this.head; // {4} \n          current = removed; // {5}\n        }\n      } else { \n        // 不需要修改循环链表最后一个元素\n        const previous = this.getElementAt(index - 1); \n        current = previous.next; \n        previous.next = current.next; \n      }\n      this.count--; \n      return current.element; // {6} \n    } \n    return undefined; \n  }\n}\n```\n\n###### 有序链表\n有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。\n```javascript\nconst Compare = { \n  LESS_THAN: -1, \n  BIGGER_THAN: 1 \n}; \nfunction defaultCompare(a, b) { \n  if (a === b) { // {1} \n    return 0; \n  } \n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN; // {2} \n} \nclass SortedLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals, compareFn = defaultCompare) { \n    super(equalsFn); \n    this.compareFn = compareFn; // {3} \n  }\n  // 有序插入元素\n  insert(element, index = 0) { // {1} \n    if (this.isEmpty()) { \n      return super.insert(element, 0); // {2} \n    } \n    const pos = this.getIndexNextSortedElement(element); // {3} \n    return super.insert(element, pos); // {4} \n  } \n  getIndexNextSortedElement(element) { \n    let current = this.head; \n    let i = 0; \n    for (; i < this.size() && current; i++) { \n      const comp = this.compareFn(element, current.element); // {5} \n      if (comp === Compare.LESS_THAN) { // {6} \n        return i; \n      } \n      current = current.next; \n    } \n    return i; // {7} \n  }\n}\n```\n\n###### 创建 StackLinkedList 类\n```javascript\nclass StackLinkedList { \n  constructor() { \n    this.items = new DoublyLinkedList(); // {1} \n  } \n  push(element) { \n    this.items.push(element); // {2} \n  } \n  pop() { \n    if (this.isEmpty()) { \n      return undefined; \n    } \n    return this.items.removeAt(this.size() - 1); // {3} \n  } \n}\n```","slug":"34-data-structure2","published":1,"updated":"2022-09-27T09:21:29.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q0000wk4ttbiee43b5","content":"<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向队列添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">enqueue</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从队列移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dequeue</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列头元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检查队列是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取队列的长度</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空队列</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.lowestCount + <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h6><p>双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列</p>\n<p>由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deque</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 向双端队列的前端添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addFront</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addBack(element);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.lowestCount &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount--;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount] = element;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.count; i &gt; <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.items[i] = <span class=\"built_in\">this</span>.items[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>] = element; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addBack</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环队列-击鼓传花\"><a href=\"#循环队列-击鼓传花\" class=\"headerlink\" title=\"循环队列 - 击鼓传花\"></a>循环队列 - 击鼓传花</h6><p>场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">elementsList, num</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elimitatedList = [];</span><br><span class=\"line\">  <span class=\"comment\">// 把名单的名字全都加入队列</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; elementsList.length; i++) &#123; </span><br><span class=\"line\">    queue.enqueue(elementsList[i]); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代队列</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (queue.size() &gt; <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 将队列开头一项移除，添加到队列末尾</span></span><br><span class=\"line\">      queue.enqueue(queue.dequeue()); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 将超出限制的队列开头一项移除，作为淘汰项</span></span><br><span class=\"line\">    elimitatedList.push(queue.dequeue()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; </span><br><span class=\"line\">    <span class=\"attr\">eliminated</span>: elimitatedList, </span><br><span class=\"line\">    <span class=\"attr\">winner</span>: queue.dequeue() <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Camila&#x27;</span>, <span class=\"string\">&#x27;Ingrid&#x27;</span>, <span class=\"string\">&#x27;Carl&#x27;</span>]; </span><br><span class=\"line\"><span class=\"keyword\">const</span> result = hotPotato(names, <span class=\"number\">7</span>);</span><br><span class=\"line\">result.eliminated.forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`胜利者： <span class=\"subst\">$&#123;result.winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回文检查器\"><a href=\"#回文检查器\" class=\"headerlink\" title=\"回文检查器\"></a>回文检查器</h6><p>回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">palindromeChecker</span>(<span class=\"params\">aString</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 检查传入的字符串参数是否合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (aString === <span class=\"literal\">undefined</span> || aString === <span class=\"literal\">null</span> || (aString !== <span class=\"literal\">null</span> &amp;&amp; aString.length === <span class=\"number\">0</span>)) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> deque = <span class=\"keyword\">new</span> Deque(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> lowerString = aString.toLocaleLowerCase().split(<span class=\"string\">&#x27; &#x27;</span>).join(<span class=\"string\">&#x27;&#x27;</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isEqual = <span class=\"literal\">true</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstChar, lastChar;</span><br><span class=\"line\">  <span class=\"comment\">// 将所有字符串加入队列中</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; lowerString.length; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    deque.addBack(lowerString.charAt(i)); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deque.size() &gt; <span class=\"number\">1</span> &amp;&amp; isEqual) &#123; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    firstChar = deque.removeFront(); <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    lastChar = deque.removeBack(); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (firstChar !== lastChar) &#123; </span><br><span class=\"line\">      isEqual = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> isEqual;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">javascript事件循环</a></p>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><h6 id=\"链表数据结构\"><a href=\"#链表数据结构\" class=\"headerlink\" title=\"链表数据结构\"></a>链表数据结构</h6><p><img src=\"/2022/09/23/34-data-structure2/chain-table-1.png\" alt=\"链表\"><br>链表的好处：添加或移除元素的时候不需要移动其他元素<br>要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultEquals</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// models/linked-list-models</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.element = element; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.next = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultEquals &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>; </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/linked-list-models&#x27;</span>; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.equalsFn = equalsFn; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向链表尾部添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current.next != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;5&#125; 获得最后一项</span></span><br><span class=\"line\">        current = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 将其 next 赋为新元素，建立链接</span></span><br><span class=\"line\">      current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 检查越界值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"comment\">// 移除第一项</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前index的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        current = previous.next;</span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环迭代链表直到目标位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getElementAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> node = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; index &amp;&amp; node != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        node = node.next;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 在第一个位置添加</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = previous.next; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// 更新链表的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  indexOf 方法：返回一个元素的位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">indexOf</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.count &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.equalsFn(element, current.element)) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"built_in\">this</span>.indexOf(element); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.removeAt(index); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getHead</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.head.element&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;current.element&#125;</span>`</span>; </span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management\">javascript垃圾回收器</a></p>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素<br><img src=\"/2022/09/23/34-data-structure2/chain-table-2.png\" alt=\"双向链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element, next, prev</span>)</span> &#123; </span><br><span class=\"line\">  <span class=\"built_in\">super</span>(element, next); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.prev = prev; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> DoublyNode(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.tail = node; </span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">            current.prev = node; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// 最后一项 // 新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        node.prev = current; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = node; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current = previous.next; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;11&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;12&#125; </span></span><br><span class=\"line\">        current.prev = node; <span class=\"comment\">// &#123;13&#125; 新增的</span></span><br><span class=\"line\">        node.prev = previous; <span class=\"comment\">// &#123;14&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 如果只有一项，更新 tail // 新增的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.count === <span class=\"number\">1</span>) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head.prev = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 最后一项 //新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = current.prev; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail.next = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.getElementAt(index); <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = current.prev; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来——跳过 current </span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current.next.prev = previous; <span class=\"comment\">// &#123;10&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 源码：https://github.com/loiane/javascript-datastructures-algorithms</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h6><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）<br>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev<br><img src=\"/2022/09/23/34-data-structure2/chain-table-3.png\" alt=\"循环链表\"><br><img src=\"/2022/09/23/34-data-structure2/chain-table-4.png\" alt=\"双向循环链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircularLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          node.next = current; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          <span class=\"comment\">// 更新最后一个元素</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 这种场景没有变化</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        node.next = previous.next; </span><br><span class=\"line\">        previous.next = node; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"keyword\">const</span> removed = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          current = removed; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 不需要修改循环链表最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        current = previous.next; </span><br><span class=\"line\">        previous.next = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h6><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Compare = &#123; </span><br><span class=\"line\">  <span class=\"attr\">LESS_THAN</span>: -<span class=\"number\">1</span>, </span><br><span class=\"line\">  <span class=\"attr\">BIGGER_THAN</span>: <span class=\"number\">1</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a === b) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals, compareFn = defaultCompare</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 有序插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index = <span class=\"number\">0</span></span>)</span> &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, <span class=\"number\">0</span>); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> pos = <span class=\"built_in\">this</span>.getIndexNextSortedElement(element); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, pos); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getIndexNextSortedElement</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current; i++) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> comp = <span class=\"built_in\">this</span>.compareFn(element, current.element); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (comp === Compare.LESS_THAN) &#123; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      current = current.next; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"创建-StackLinkedList-类\"><a href=\"#创建-StackLinkedList-类\" class=\"headerlink\" title=\"创建 StackLinkedList 类\"></a>创建 StackLinkedList 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackLinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = <span class=\"keyword\">new</span> DoublyLinkedList(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.removeAt(<span class=\"built_in\">this</span>.size() - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向队列添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">enqueue</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从队列移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dequeue</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列头元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检查队列是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取队列的长度</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空队列</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.lowestCount + <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h6><p>双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列</p>\n<p>由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deque</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 向双端队列的前端添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addFront</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addBack(element);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.lowestCount &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount--;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount] = element;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.count; i &gt; <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.items[i] = <span class=\"built_in\">this</span>.items[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>] = element; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addBack</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环队列-击鼓传花\"><a href=\"#循环队列-击鼓传花\" class=\"headerlink\" title=\"循环队列 - 击鼓传花\"></a>循环队列 - 击鼓传花</h6><p>场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">elementsList, num</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elimitatedList = [];</span><br><span class=\"line\">  <span class=\"comment\">// 把名单的名字全都加入队列</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; elementsList.length; i++) &#123; </span><br><span class=\"line\">    queue.enqueue(elementsList[i]); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代队列</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (queue.size() &gt; <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 将队列开头一项移除，添加到队列末尾</span></span><br><span class=\"line\">      queue.enqueue(queue.dequeue()); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 将超出限制的队列开头一项移除，作为淘汰项</span></span><br><span class=\"line\">    elimitatedList.push(queue.dequeue()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; </span><br><span class=\"line\">    <span class=\"attr\">eliminated</span>: elimitatedList, </span><br><span class=\"line\">    <span class=\"attr\">winner</span>: queue.dequeue() <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Camila&#x27;</span>, <span class=\"string\">&#x27;Ingrid&#x27;</span>, <span class=\"string\">&#x27;Carl&#x27;</span>]; </span><br><span class=\"line\"><span class=\"keyword\">const</span> result = hotPotato(names, <span class=\"number\">7</span>);</span><br><span class=\"line\">result.eliminated.forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`胜利者： <span class=\"subst\">$&#123;result.winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回文检查器\"><a href=\"#回文检查器\" class=\"headerlink\" title=\"回文检查器\"></a>回文检查器</h6><p>回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">palindromeChecker</span>(<span class=\"params\">aString</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 检查传入的字符串参数是否合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (aString === <span class=\"literal\">undefined</span> || aString === <span class=\"literal\">null</span> || (aString !== <span class=\"literal\">null</span> &amp;&amp; aString.length === <span class=\"number\">0</span>)) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> deque = <span class=\"keyword\">new</span> Deque(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> lowerString = aString.toLocaleLowerCase().split(<span class=\"string\">&#x27; &#x27;</span>).join(<span class=\"string\">&#x27;&#x27;</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isEqual = <span class=\"literal\">true</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstChar, lastChar;</span><br><span class=\"line\">  <span class=\"comment\">// 将所有字符串加入队列中</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; lowerString.length; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    deque.addBack(lowerString.charAt(i)); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deque.size() &gt; <span class=\"number\">1</span> &amp;&amp; isEqual) &#123; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    firstChar = deque.removeFront(); <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    lastChar = deque.removeBack(); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (firstChar !== lastChar) &#123; </span><br><span class=\"line\">      isEqual = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> isEqual;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">javascript事件循环</a></p>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><h6 id=\"链表数据结构\"><a href=\"#链表数据结构\" class=\"headerlink\" title=\"链表数据结构\"></a>链表数据结构</h6><p><img src=\"/2022/09/23/34-data-structure2/chain-table-1.png\" alt=\"链表\"><br>链表的好处：添加或移除元素的时候不需要移动其他元素<br>要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultEquals</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// models/linked-list-models</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.element = element; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.next = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultEquals &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>; </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/linked-list-models&#x27;</span>; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.equalsFn = equalsFn; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向链表尾部添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current.next != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;5&#125; 获得最后一项</span></span><br><span class=\"line\">        current = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 将其 next 赋为新元素，建立链接</span></span><br><span class=\"line\">      current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 检查越界值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"comment\">// 移除第一项</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前index的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        current = previous.next;</span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环迭代链表直到目标位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getElementAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> node = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; index &amp;&amp; node != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        node = node.next;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 在第一个位置添加</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = previous.next; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// 更新链表的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  indexOf 方法：返回一个元素的位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">indexOf</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.count &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.equalsFn(element, current.element)) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"built_in\">this</span>.indexOf(element); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.removeAt(index); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getHead</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.head.element&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;current.element&#125;</span>`</span>; </span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management\">javascript垃圾回收器</a></p>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素<br><img src=\"/2022/09/23/34-data-structure2/chain-table-2.png\" alt=\"双向链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element, next, prev</span>)</span> &#123; </span><br><span class=\"line\">  <span class=\"built_in\">super</span>(element, next); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.prev = prev; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> DoublyNode(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.tail = node; </span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">            current.prev = node; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// 最后一项 // 新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        node.prev = current; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = node; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current = previous.next; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;11&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;12&#125; </span></span><br><span class=\"line\">        current.prev = node; <span class=\"comment\">// &#123;13&#125; 新增的</span></span><br><span class=\"line\">        node.prev = previous; <span class=\"comment\">// &#123;14&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 如果只有一项，更新 tail // 新增的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.count === <span class=\"number\">1</span>) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head.prev = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 最后一项 //新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = current.prev; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail.next = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.getElementAt(index); <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = current.prev; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来——跳过 current </span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current.next.prev = previous; <span class=\"comment\">// &#123;10&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 源码：https://github.com/loiane/javascript-datastructures-algorithms</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h6><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）<br>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev<br><img src=\"/2022/09/23/34-data-structure2/chain-table-3.png\" alt=\"循环链表\"><br><img src=\"/2022/09/23/34-data-structure2/chain-table-4.png\" alt=\"双向循环链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircularLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          node.next = current; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          <span class=\"comment\">// 更新最后一个元素</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 这种场景没有变化</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        node.next = previous.next; </span><br><span class=\"line\">        previous.next = node; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"keyword\">const</span> removed = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          current = removed; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 不需要修改循环链表最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        current = previous.next; </span><br><span class=\"line\">        previous.next = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h6><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Compare = &#123; </span><br><span class=\"line\">  <span class=\"attr\">LESS_THAN</span>: -<span class=\"number\">1</span>, </span><br><span class=\"line\">  <span class=\"attr\">BIGGER_THAN</span>: <span class=\"number\">1</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a === b) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals, compareFn = defaultCompare</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 有序插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index = <span class=\"number\">0</span></span>)</span> &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, <span class=\"number\">0</span>); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> pos = <span class=\"built_in\">this</span>.getIndexNextSortedElement(element); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, pos); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getIndexNextSortedElement</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current; i++) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> comp = <span class=\"built_in\">this</span>.compareFn(element, current.element); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (comp === Compare.LESS_THAN) &#123; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      current = current.next; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"创建-StackLinkedList-类\"><a href=\"#创建-StackLinkedList-类\" class=\"headerlink\" title=\"创建 StackLinkedList 类\"></a>创建 StackLinkedList 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackLinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = <span class=\"keyword\">new</span> DoublyLinkedList(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.removeAt(<span class=\"built_in\">this</span>.size() - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数据结构与算法阅读笔记(3)","date":"2022-09-29T02:49:51.000Z","_content":"\n#### 集合\n\n集合是由一组无序且唯一（即不能重复）的项组成的\n\n###### 创建集合类\n\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n  has(element) {\n    return element in items;\n  }\n  // Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。\n  // in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。\n  // has(element) {\n  //   return Object.prototype.hasOwnProperty.call(this.items, element);\n  // }\n  add(element) {\n    if (!this.has(element)) {\n      this.items[element] = element; // {1}\n      return true;\n    }\n    return false;\n  }\n  delete(element) {\n    if (this.has(element)) {\n      delete this.items[element]; // {1}\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    this.items = {}; // {2}\n  }\n  size() {\n    return Object.keys(this.items).length; // {1}\n  }\n  // sizeLegacy() {\n  //  let count = 0;\n  //  for(let key in this.items) { // {2}\n  // 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量\n  // 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原\n  // 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对\n  // 象自身、未用于数据结构的）\n  //  if(this.items.hasOwnProperty(key)) { // {3}\n  //  count++; // {4}\n  //  }\n  //  return count;\n  // }\n  values() {\n    return Object.values(this.items);\n  }\n  // valuesLegacy() {\n  //  let values = [];\n  //  for(let key in this.items) { // {1}\n  //    if(this.items.hasOwnProperty(key)) {\n  //       values.push(key); // {2}\n  //    }\n  //  }\n  //  return values;\n  // }\n}\n```\n\n###### 集合运算\n\n(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n\n```javascript\n// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果\nunion(otherSet) {\n  const unionSet = new Set(); // {1}\n  // 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中\n  this.values().forEach(value => unionSet.add(value)); // {2}\n  otherSet.values().forEach(value => unionSet.add(value)); // {3}\n  return unionSet;\n}\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(3);\nsetB.add(4);\nsetB.add(5);\nsetB.add(6);\nconst unionAB = setA.union(setB);\nconsole.log(unionAB.values());\n// [1,2,3,4,5,6]\n```\n\n(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n\n```javascript\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values();\n for (let i = 0; i < values.length; i++) { // {2}\n   if (otherSet.has(values[i])) { // {3}\n     intersectionSet.add(values[i]); // {4}\n   }\n }\n return intersectionSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst intersectionAB = setA.intersection(setB);\nconsole.log(intersectionAB.values());\n// [2,3]\n\n// 优化\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values(); // {2}\n const otherValues = otherSet.values(); // {3}\n let biggerSet = values; // {4}\n let smallerSet = otherValues; // {5}\n\n if (otherValues.length - values.length > 0) { // {6}\n   biggerSet = otherValues;\n   smallerSet = values;\n }\n smallerSet.forEach(value => { // {7}\n   if (biggerSet.includes(value)) {\n     intersectionSet.add(value);\n   }\n });\n return intersectionSet;\n}\n```\n\n(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n\n```javascript\ndifference(otherSet) {\n  const differenceSet = new Set(); // {1}\n  this.values().forEach(value => { // {2}\n    if (!otherSet.has(value)) { // {3}\n      differenceSet.add(value); // {4}\n    }\n  });\n  return differenceSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst differenceAB = setA.difference(setB);\nconsole.log(differenceAB.values());\n// [1]\n```\n\n(4)子集：验证一个给定集合是否是另一集合的子集\n\n```javascript\nisSubsetOf(otherSet) {\n  if (this.size() > otherSet.size()) { // {1}\n    return false;\n  }\n  let isSubset = true; // {2}\n  // 只要回调函数返回 true，every 方法就会被调用（行{6}）。如果回调函数返回 false，循环会停止\n  this.values().every(value => { // {3}\n    if (!otherSet.has(value)) { // {4}\n      isSubset = false; // {5}\n      return false;\n    }\n    return true; // {6}\n  });\n  return isSubset; // {7}\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nconst setB = new Set();\nsetB.add(1);\nsetB.add(2);\nsetB.add(3);\nconst setC = new Set();\nsetC.add(2);\nsetC.add(3);\nsetC.add(4);\nconsole.log(setA.isSubsetOf(setB));\n// true\nconsole.log(setA.isSubsetOf(setC));\n// false\n```\n\n###### 使用扩展运算符\n\n```javascript\n// 并集\nconsole.log(new Set([...setA, ...setB]));\n\n// 交集\nconsole.log(new Set([...setA].filter((x) => setB.has(x))));\n\n// 差集\nconsole.log(new Set([...setA].filter((x) => !setB.has(x))));\n```\n\n#### 字典和散列表\n\n###### 字典\n\n在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。\n字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。\n字典也称作映射、符号表或关联数组\n\n```javascript\n// util.js\nexport function defaultToString(item) {\n  if (item === null) {\n    return 'NULL';\n  } else if (item === undefined) {\n    return 'UNDEFINED';\n  } else if (typeof item === 'string' || item instanceof String) {\n    return `${item}`;\n  }\n  return item.toString(); // {1}\n}\n\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  toString() {\n    return `[#${this.key}: ${this.value}]`;\n  }\n}\n\nimport { defaultToString } from '../util';\nexport default class Dictionary {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn; // {1}\n    this.table = {}; // {2}\n  }\n  // 检测一个键是否存在于字典中\n  hasKey(key) {\n    return this.table[this.toStrFn(key)] != null;\n  }\n  // 在字典和 ValuePair 类中设置键和值\n  set(key, value) {\n    if (key != null && value != null) {\n      const tableKey = this.toStrFn(key); // {1}\n      this.table[tableKey] = new ValuePair(key, value); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 从字典中移除一个值\n  remove(key) {\n    if (this.hasKey(key)) {\n      delete this.table[this.toStrFn(key)];\n      return true;\n    }\n    return false;\n  }\n  // 从字典中检索一个值\n  get(key) {\n    const valuePair = this.table[this.toStrFn(key)]; // {1}\n    return valuePair == null ? undefined : valuePair.value; // {2}\n  }\n  keyValues() {\n    return Object.values(this.table);\n  }\n  keys() {\n    return this.keyValues().map((valuePair) => valuePair.key);\n  }\n  values() {\n    return this.keyValues().map((valuePair) => valuePair.value);\n  }\n  forEach(callbackFn) {\n    const valuePairs = this.keyValues(); // {1}\n    for (let i = 0; i < valuePairs.length; i++) {\n      // {2}\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value); // {3}\n      if (result === false) {\n        break; // {4}\n      }\n    }\n  }\n  size() {\n    return Object.keys(this.table).length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  clear() {\n    this.table = {};\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const valuePairs = this.keyValues();\n    let objString = `${valuePairs[0].toString()}`; // {1}\n    for (let i = 1; i < valuePairs.length; i++) {\n      objString = `${objString},${valuePairs[i].toString()}`; // {2}\n    }\n    return objString; // {3}\n  }\n}\n```\n\n###### 散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值\n\n散列函数的作用是给定一个键值，然后返回值在表中的地址\n\n散列表有一些在计算机科学中应用的例子:\n(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用\n(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。\n\n散列函数 ---- lose lose 散列函数\n![lose-lose](lose-lose.png)\n\nHashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我\n们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而\n在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存\n在 hash 位置（或属性）\n\n```javascript\nclass HashTable {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  // 创建散列函数\n  loseloseHashCode(key) {\n    if (typeof key === 'number') {\n      // {1}\n      return key;\n    }\n    const tableKey = this.toStrFn(key); // {2}\n    // 根据组成 key 的每个字符的 ASCII 码值的和得到一个数\n    let hash = 0; // {3}\n    for (let i = 0; i < tableKey.length; i++) {\n      hash += tableKey.charCodeAt(i); // {4}\n    }\n    // 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行{5}）\n    // 这可以规避操作数超过数值变量最大表示范围的风险\n    return hash % 37; // {5}\n  }\n  hashCode(key) {\n    return this.loseloseHashCode(key);\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      // {1}\n      const position = this.hashCode(key); // {2}\n      this.table[position] = new ValuePair(key, value); // {3}\n      return true;\n    }\n    return false;\n  }\n  get(key) {\n    const valuePair = this.table[this.hashCode(key)];\n    return valuePair == null ? undefined : valuePair.value;\n  }\n  remove(key) {\n    const hash = this.hashCode(key); // {1}\n    const valuePair = this.table[hash]; // {2}\n    if (valuePair != null) {\n      delete this.table[hash]; // {3}\n      return true;\n    }\n    return false;\n  }\n}\n\nconst hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\nconsole.log(hash.hashCode('Gandalf') + ' - Gandalf');\nconsole.log(hash.hashCode('John') + ' - John');\nconsole.log(hash.hashCode('Tyrion') + ' - Tyrion');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion\n```\n\n**散列集合**\n散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数\n散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。\n\n**散列表中的冲突**\n有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n(1)分离链接\n分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。\n它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间\n![sperate-chain](sperate-chain.png)\n\n```javascript\nclass HashTableSeparateChaining {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      //  将验证要加入新元素的位置是否已经被占据\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new LinkedList(); // {2}\n      }\n      this.table[position].push(new ValuePair(key, value)); // {3}\n      return true;\n    }\n    return false;\n  }\n  // 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化\n  // LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key\n  // 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较\n  // 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要\n  // 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。\n  // 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。\n  get(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position]; // {1}\n    if (linkedList != null && !linkedList.isEmpty()) {\n      // {2}\n      let current = linkedList.getHead(); // {3}\n      while (current != null) {\n        // {4}\n        if (current.element.key === key) {\n          // {5}\n          return current.element.value; // {6}\n        }\n        current = current.next; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position];\n    if (linkedList != null && !linkedList.isEmpty()) {\n      let current = linkedList.getHead();\n      while (current != null) {\n        if (current.element.key === key) {\n          // {1}\n          linkedList.remove(current.element); // {2}\n          if (linkedList.isEmpty()) {\n            // {3}\n            delete this.table[position]; // {4}\n          }\n          return true; // {5}\n        }\n        current = current.next; // {6}\n      }\n    }\n    return false; // {7}\n  }\n}\n```\n\n(2)线性探查\n它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中\n当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置\n![linear-probing](linear-probing.png)\n\n线性探查技术分为两种。\n\n第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因\n![soft-delete](soft-delete.png)\n[源代码](http://github.com/loiane/javascript-datastructures-algorithms)\n\n第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。\n![move-key](move-key.png)\n\n```javascript\n// move-key\nclass HashTableSeparateChainingMoveKey {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new ValuePair(key, value); // {2}\n      } else {\n        let index = position + 1; // {3}\n        while (this.table[index] != null) {\n          // {4}\n          index++; // {5}\n        }\n        this.table[index] = new ValuePair(key, value); // {6}\n      }\n      return true;\n    }\n    return false;\n  }\n  // 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注\n  // 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需\n  // 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数\n  // 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需\n  // 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一\n  // 个功能\n  get(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      // {1}\n      if (this.table[position].key === key) {\n        // {2}\n        return this.table[position].value; // {3}\n      }\n      let index = position + 1; // {4}\n      while (this.table[index] != null && this.table[index].key !== key) {\n        // {5}\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        // {6}\n        return this.table[position].value; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      if (this.table[position].key === key) {\n        delete this.table[position]; // {1}\n        this.verifyRemoveSideEffect(key, position); // {2}\n        return true;\n      }\n      let index = position + 1;\n      while (this.table[index] != null && this.table[index].key !== key) {\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        delete this.table[index]; // {3}\n        this.verifyRemoveSideEffect(key, index); // {4}\n        return true;\n      }\n    }\n    return false;\n  }\n  verifyRemoveSideEffect(key, removedPosition) {\n    const hash = this.hashCode(key); // {1}\n    let index = removedPosition + 1; // {2}\n    while (this.table[index] != null) {\n      // {3}\n      const posHash = this.hashCode(this.table[index].key); // {4}\n      if (posHash <= hash || posHash <= removedPosition) {\n        // {5}\n        this.table[removedPosition] = this.table[index]; // {6}\n        delete this.table[index];\n        removedPosition = index;\n      }\n      index++;\n    }\n  }\n}\n```\n\n**更好的散列函数**\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。\n\n```javascript\ndjb2HashCode(key) {\n const tableKey = this.toStrFn(key); // {1}\n//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381\n let hash = 5381; // {2}\n for (let i = 0; i < tableKey.length; i++) { // {3}\n//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加\n hash = (hash * 33) + tableKey.charCodeAt(i); // {4}\n }\n//  将使用相加的和与另一个随机质数相除的余数\n return hash % 1013; // {5}\n}\n// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0\n```\n\n**ES2015 Map 类**\n\n```javascript\nconst map = new Map();\nmap.set('Gandalf', 'gandalf@email.com');\nmap.set('John', 'johnsnow@email.com');\nmap.set('Tyrion', 'tyrion@email.com');\nconsole.log(map.has('Gandalf')); // true\nconsole.log(map.size); // 3\nconsole.log(map.keys()); // 输出{\"Gandalf\", \"John\", \"Tyrion\"}\nconsole.log(map.values()); // 输出{\"gandalf@email.com\", \"johnsnow@email.com\",\n\"tyrion@email.com\"}\nconsole.log(map.get('Tyrion')); // tyrion@email.com\nmap.delete('John');\n```\n\n**ES2105 WeakMap 类和 WeakSet 类**\nMap 和 Set 与其弱化版本之间仅有的区别是:\n(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法\n(2)WeakSet 和 WeakMap 只能用对象作为键\n\n```javascript\nconst map = new WeakMap();\nconst ob1 = { name: 'Gandalf' }; // {1}\nconst ob2 = { name: 'John' };\nconst ob3 = { name: 'Tyrion' };\nmap.set(ob1, 'gandalf@email.com'); // {2}\nmap.set(ob2, 'johnsnow@email.com');\nmap.set(ob3, 'tyrion@email.com');\nconsole.log(map.has(ob1)); // true {3}\nconsole.log(map.get(ob3)); // tyrion@email.com {4}\nmap.delete(ob2); // {5}\n```\n\n注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象\n","source":"_posts/35-data-structure3.md","raw":"---\ntitle: 数据结构与算法阅读笔记(3)\ndate: 2022-09-29 10:49:51\ntags:\n---\n\n#### 集合\n\n集合是由一组无序且唯一（即不能重复）的项组成的\n\n###### 创建集合类\n\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n  has(element) {\n    return element in items;\n  }\n  // Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。\n  // in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。\n  // has(element) {\n  //   return Object.prototype.hasOwnProperty.call(this.items, element);\n  // }\n  add(element) {\n    if (!this.has(element)) {\n      this.items[element] = element; // {1}\n      return true;\n    }\n    return false;\n  }\n  delete(element) {\n    if (this.has(element)) {\n      delete this.items[element]; // {1}\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    this.items = {}; // {2}\n  }\n  size() {\n    return Object.keys(this.items).length; // {1}\n  }\n  // sizeLegacy() {\n  //  let count = 0;\n  //  for(let key in this.items) { // {2}\n  // 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量\n  // 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原\n  // 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对\n  // 象自身、未用于数据结构的）\n  //  if(this.items.hasOwnProperty(key)) { // {3}\n  //  count++; // {4}\n  //  }\n  //  return count;\n  // }\n  values() {\n    return Object.values(this.items);\n  }\n  // valuesLegacy() {\n  //  let values = [];\n  //  for(let key in this.items) { // {1}\n  //    if(this.items.hasOwnProperty(key)) {\n  //       values.push(key); // {2}\n  //    }\n  //  }\n  //  return values;\n  // }\n}\n```\n\n###### 集合运算\n\n(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n\n```javascript\n// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果\nunion(otherSet) {\n  const unionSet = new Set(); // {1}\n  // 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中\n  this.values().forEach(value => unionSet.add(value)); // {2}\n  otherSet.values().forEach(value => unionSet.add(value)); // {3}\n  return unionSet;\n}\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(3);\nsetB.add(4);\nsetB.add(5);\nsetB.add(6);\nconst unionAB = setA.union(setB);\nconsole.log(unionAB.values());\n// [1,2,3,4,5,6]\n```\n\n(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n\n```javascript\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values();\n for (let i = 0; i < values.length; i++) { // {2}\n   if (otherSet.has(values[i])) { // {3}\n     intersectionSet.add(values[i]); // {4}\n   }\n }\n return intersectionSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst intersectionAB = setA.intersection(setB);\nconsole.log(intersectionAB.values());\n// [2,3]\n\n// 优化\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values(); // {2}\n const otherValues = otherSet.values(); // {3}\n let biggerSet = values; // {4}\n let smallerSet = otherValues; // {5}\n\n if (otherValues.length - values.length > 0) { // {6}\n   biggerSet = otherValues;\n   smallerSet = values;\n }\n smallerSet.forEach(value => { // {7}\n   if (biggerSet.includes(value)) {\n     intersectionSet.add(value);\n   }\n });\n return intersectionSet;\n}\n```\n\n(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n\n```javascript\ndifference(otherSet) {\n  const differenceSet = new Set(); // {1}\n  this.values().forEach(value => { // {2}\n    if (!otherSet.has(value)) { // {3}\n      differenceSet.add(value); // {4}\n    }\n  });\n  return differenceSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst differenceAB = setA.difference(setB);\nconsole.log(differenceAB.values());\n// [1]\n```\n\n(4)子集：验证一个给定集合是否是另一集合的子集\n\n```javascript\nisSubsetOf(otherSet) {\n  if (this.size() > otherSet.size()) { // {1}\n    return false;\n  }\n  let isSubset = true; // {2}\n  // 只要回调函数返回 true，every 方法就会被调用（行{6}）。如果回调函数返回 false，循环会停止\n  this.values().every(value => { // {3}\n    if (!otherSet.has(value)) { // {4}\n      isSubset = false; // {5}\n      return false;\n    }\n    return true; // {6}\n  });\n  return isSubset; // {7}\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nconst setB = new Set();\nsetB.add(1);\nsetB.add(2);\nsetB.add(3);\nconst setC = new Set();\nsetC.add(2);\nsetC.add(3);\nsetC.add(4);\nconsole.log(setA.isSubsetOf(setB));\n// true\nconsole.log(setA.isSubsetOf(setC));\n// false\n```\n\n###### 使用扩展运算符\n\n```javascript\n// 并集\nconsole.log(new Set([...setA, ...setB]));\n\n// 交集\nconsole.log(new Set([...setA].filter((x) => setB.has(x))));\n\n// 差集\nconsole.log(new Set([...setA].filter((x) => !setB.has(x))));\n```\n\n#### 字典和散列表\n\n###### 字典\n\n在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。\n字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。\n字典也称作映射、符号表或关联数组\n\n```javascript\n// util.js\nexport function defaultToString(item) {\n  if (item === null) {\n    return 'NULL';\n  } else if (item === undefined) {\n    return 'UNDEFINED';\n  } else if (typeof item === 'string' || item instanceof String) {\n    return `${item}`;\n  }\n  return item.toString(); // {1}\n}\n\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  toString() {\n    return `[#${this.key}: ${this.value}]`;\n  }\n}\n\nimport { defaultToString } from '../util';\nexport default class Dictionary {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn; // {1}\n    this.table = {}; // {2}\n  }\n  // 检测一个键是否存在于字典中\n  hasKey(key) {\n    return this.table[this.toStrFn(key)] != null;\n  }\n  // 在字典和 ValuePair 类中设置键和值\n  set(key, value) {\n    if (key != null && value != null) {\n      const tableKey = this.toStrFn(key); // {1}\n      this.table[tableKey] = new ValuePair(key, value); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 从字典中移除一个值\n  remove(key) {\n    if (this.hasKey(key)) {\n      delete this.table[this.toStrFn(key)];\n      return true;\n    }\n    return false;\n  }\n  // 从字典中检索一个值\n  get(key) {\n    const valuePair = this.table[this.toStrFn(key)]; // {1}\n    return valuePair == null ? undefined : valuePair.value; // {2}\n  }\n  keyValues() {\n    return Object.values(this.table);\n  }\n  keys() {\n    return this.keyValues().map((valuePair) => valuePair.key);\n  }\n  values() {\n    return this.keyValues().map((valuePair) => valuePair.value);\n  }\n  forEach(callbackFn) {\n    const valuePairs = this.keyValues(); // {1}\n    for (let i = 0; i < valuePairs.length; i++) {\n      // {2}\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value); // {3}\n      if (result === false) {\n        break; // {4}\n      }\n    }\n  }\n  size() {\n    return Object.keys(this.table).length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  clear() {\n    this.table = {};\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const valuePairs = this.keyValues();\n    let objString = `${valuePairs[0].toString()}`; // {1}\n    for (let i = 1; i < valuePairs.length; i++) {\n      objString = `${objString},${valuePairs[i].toString()}`; // {2}\n    }\n    return objString; // {3}\n  }\n}\n```\n\n###### 散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值\n\n散列函数的作用是给定一个键值，然后返回值在表中的地址\n\n散列表有一些在计算机科学中应用的例子:\n(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用\n(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。\n\n散列函数 ---- lose lose 散列函数\n![lose-lose](lose-lose.png)\n\nHashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我\n们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而\n在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存\n在 hash 位置（或属性）\n\n```javascript\nclass HashTable {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  // 创建散列函数\n  loseloseHashCode(key) {\n    if (typeof key === 'number') {\n      // {1}\n      return key;\n    }\n    const tableKey = this.toStrFn(key); // {2}\n    // 根据组成 key 的每个字符的 ASCII 码值的和得到一个数\n    let hash = 0; // {3}\n    for (let i = 0; i < tableKey.length; i++) {\n      hash += tableKey.charCodeAt(i); // {4}\n    }\n    // 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行{5}）\n    // 这可以规避操作数超过数值变量最大表示范围的风险\n    return hash % 37; // {5}\n  }\n  hashCode(key) {\n    return this.loseloseHashCode(key);\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      // {1}\n      const position = this.hashCode(key); // {2}\n      this.table[position] = new ValuePair(key, value); // {3}\n      return true;\n    }\n    return false;\n  }\n  get(key) {\n    const valuePair = this.table[this.hashCode(key)];\n    return valuePair == null ? undefined : valuePair.value;\n  }\n  remove(key) {\n    const hash = this.hashCode(key); // {1}\n    const valuePair = this.table[hash]; // {2}\n    if (valuePair != null) {\n      delete this.table[hash]; // {3}\n      return true;\n    }\n    return false;\n  }\n}\n\nconst hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\nconsole.log(hash.hashCode('Gandalf') + ' - Gandalf');\nconsole.log(hash.hashCode('John') + ' - John');\nconsole.log(hash.hashCode('Tyrion') + ' - Tyrion');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion\n```\n\n**散列集合**\n散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数\n散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。\n\n**散列表中的冲突**\n有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n(1)分离链接\n分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。\n它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间\n![sperate-chain](sperate-chain.png)\n\n```javascript\nclass HashTableSeparateChaining {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      //  将验证要加入新元素的位置是否已经被占据\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new LinkedList(); // {2}\n      }\n      this.table[position].push(new ValuePair(key, value)); // {3}\n      return true;\n    }\n    return false;\n  }\n  // 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化\n  // LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key\n  // 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较\n  // 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要\n  // 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。\n  // 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。\n  get(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position]; // {1}\n    if (linkedList != null && !linkedList.isEmpty()) {\n      // {2}\n      let current = linkedList.getHead(); // {3}\n      while (current != null) {\n        // {4}\n        if (current.element.key === key) {\n          // {5}\n          return current.element.value; // {6}\n        }\n        current = current.next; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position];\n    if (linkedList != null && !linkedList.isEmpty()) {\n      let current = linkedList.getHead();\n      while (current != null) {\n        if (current.element.key === key) {\n          // {1}\n          linkedList.remove(current.element); // {2}\n          if (linkedList.isEmpty()) {\n            // {3}\n            delete this.table[position]; // {4}\n          }\n          return true; // {5}\n        }\n        current = current.next; // {6}\n      }\n    }\n    return false; // {7}\n  }\n}\n```\n\n(2)线性探查\n它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中\n当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置\n![linear-probing](linear-probing.png)\n\n线性探查技术分为两种。\n\n第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因\n![soft-delete](soft-delete.png)\n[源代码](http://github.com/loiane/javascript-datastructures-algorithms)\n\n第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。\n![move-key](move-key.png)\n\n```javascript\n// move-key\nclass HashTableSeparateChainingMoveKey {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new ValuePair(key, value); // {2}\n      } else {\n        let index = position + 1; // {3}\n        while (this.table[index] != null) {\n          // {4}\n          index++; // {5}\n        }\n        this.table[index] = new ValuePair(key, value); // {6}\n      }\n      return true;\n    }\n    return false;\n  }\n  // 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注\n  // 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需\n  // 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数\n  // 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需\n  // 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一\n  // 个功能\n  get(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      // {1}\n      if (this.table[position].key === key) {\n        // {2}\n        return this.table[position].value; // {3}\n      }\n      let index = position + 1; // {4}\n      while (this.table[index] != null && this.table[index].key !== key) {\n        // {5}\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        // {6}\n        return this.table[position].value; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      if (this.table[position].key === key) {\n        delete this.table[position]; // {1}\n        this.verifyRemoveSideEffect(key, position); // {2}\n        return true;\n      }\n      let index = position + 1;\n      while (this.table[index] != null && this.table[index].key !== key) {\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        delete this.table[index]; // {3}\n        this.verifyRemoveSideEffect(key, index); // {4}\n        return true;\n      }\n    }\n    return false;\n  }\n  verifyRemoveSideEffect(key, removedPosition) {\n    const hash = this.hashCode(key); // {1}\n    let index = removedPosition + 1; // {2}\n    while (this.table[index] != null) {\n      // {3}\n      const posHash = this.hashCode(this.table[index].key); // {4}\n      if (posHash <= hash || posHash <= removedPosition) {\n        // {5}\n        this.table[removedPosition] = this.table[index]; // {6}\n        delete this.table[index];\n        removedPosition = index;\n      }\n      index++;\n    }\n  }\n}\n```\n\n**更好的散列函数**\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。\n\n```javascript\ndjb2HashCode(key) {\n const tableKey = this.toStrFn(key); // {1}\n//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381\n let hash = 5381; // {2}\n for (let i = 0; i < tableKey.length; i++) { // {3}\n//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加\n hash = (hash * 33) + tableKey.charCodeAt(i); // {4}\n }\n//  将使用相加的和与另一个随机质数相除的余数\n return hash % 1013; // {5}\n}\n// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0\n```\n\n**ES2015 Map 类**\n\n```javascript\nconst map = new Map();\nmap.set('Gandalf', 'gandalf@email.com');\nmap.set('John', 'johnsnow@email.com');\nmap.set('Tyrion', 'tyrion@email.com');\nconsole.log(map.has('Gandalf')); // true\nconsole.log(map.size); // 3\nconsole.log(map.keys()); // 输出{\"Gandalf\", \"John\", \"Tyrion\"}\nconsole.log(map.values()); // 输出{\"gandalf@email.com\", \"johnsnow@email.com\",\n\"tyrion@email.com\"}\nconsole.log(map.get('Tyrion')); // tyrion@email.com\nmap.delete('John');\n```\n\n**ES2105 WeakMap 类和 WeakSet 类**\nMap 和 Set 与其弱化版本之间仅有的区别是:\n(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法\n(2)WeakSet 和 WeakMap 只能用对象作为键\n\n```javascript\nconst map = new WeakMap();\nconst ob1 = { name: 'Gandalf' }; // {1}\nconst ob2 = { name: 'John' };\nconst ob3 = { name: 'Tyrion' };\nmap.set(ob1, 'gandalf@email.com'); // {2}\nmap.set(ob2, 'johnsnow@email.com');\nmap.set(ob3, 'tyrion@email.com');\nconsole.log(map.has(ob1)); // true {3}\nconsole.log(map.get(ob3)); // tyrion@email.com {4}\nmap.delete(ob2); // {5}\n```\n\n注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象\n","slug":"35-data-structure3","published":1,"updated":"2022-10-08T05:24:51.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q1000xk4tt2l1c228i","content":"<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>集合是由一组无序且唯一（即不能重复）的项组成的</p>\n<h6 id=\"创建集合类\"><a href=\"#创建集合类\" class=\"headerlink\" title=\"创建集合类\"></a>创建集合类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// has(element) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   return Object.prototype.hasOwnProperty.call(this.items, element);</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[element] = element; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[element]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.items).length; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// sizeLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let count = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原</span></span><br><span class=\"line\">  <span class=\"comment\">// 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对</span></span><br><span class=\"line\">  <span class=\"comment\">// 象自身、未用于数据结构的）</span></span><br><span class=\"line\">  <span class=\"comment\">//  if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  count++; // &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return count;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.items);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// valuesLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let values = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if(this.items.hasOwnProperty(key)) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       values.push(key); // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return values;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h6><p>(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">union</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> unionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  otherSet.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> unionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> unionAB = setA.union(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values();</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (otherSet.has(values[i])) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">     intersectionSet.add(values[i]); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> intersectionAB = setA.intersection(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(intersectionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> otherValues = otherSet.values(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> biggerSet = values; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> smallerSet = otherValues; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (otherValues.length - values.length &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">   biggerSet = otherValues;</span><br><span class=\"line\">   smallerSet = values;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> smallerSet.forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (biggerSet.includes(value)) &#123;</span><br><span class=\"line\">     intersectionSet.add(value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">difference</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> differenceSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      differenceSet.add(value); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> differenceSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> differenceAB = setA.difference(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(differenceAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)子集：验证一个给定集合是否是另一集合的子集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">isSubsetOf</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() &gt; otherSet.size()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isSubset = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().every(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      isSubset = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isSubset; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setC = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setC.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setB));</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setC));</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用扩展运算符\"><a href=\"#使用扩展运算符\" class=\"headerlink\" title=\"使用扩展运算符\"></a>使用扩展运算符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA, ...setB]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> setB.has(x))));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> !setB.has(x))));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字典和散列表\"><a href=\"#字典和散列表\" class=\"headerlink\" title=\"字典和散列表\"></a>字典和散列表</h4><h6 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h6><p>在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。<br>字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。<br>字典也称作映射、符号表或关联数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultToString</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NULL&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;UNDEFINED&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item === <span class=\"string\">&#x27;string&#x27;</span> || item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;item&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item.toString(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`[#<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.key&#125;</span>: <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.value&#125;</span>]`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultToString &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检测一个键是否存在于字典中</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hasKey</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)] != <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在字典和 ValuePair 类中设置键和值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[tableKey] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中移除一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.hasKey(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中检索一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keyValues</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.table);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keys</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">forEach</span>(<span class=\"params\">callbackFn</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.table).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;valuePairs[<span class=\"number\">0</span>].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h6><p>散列算法的作用是尽可能快地在数据结构中找到一个值</p>\n<p>散列函数的作用是给定一个键值，然后返回值在表中的地址</p>\n<p>散列表有一些在计算机科学中应用的例子:<br>(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用<br>(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。</p>\n<p>散列函数 —- lose lose 散列函数<br><img src=\"/2022/09/29/35-data-structure3/lose-lose.png\" alt=\"lose-lose\"></p>\n<p>HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我<br>们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而<br>在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存<br>在 hash 位置（或属性）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建散列函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">loseloseHashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> key === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据组成 key 的每个字符的 ASCII 码值的和得到一个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class=\"line\">      hash += tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;）</span></span><br><span class=\"line\">    <span class=\"comment\">// 这可以规避操作数超过数值变量最大表示范围的风险</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash % <span class=\"number\">37</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.loseloseHashCode(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.hashCode(key)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valuePair != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hash = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Gandalf&#x27;</span>) + <span class=\"string\">&#x27; - Gandalf&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;John&#x27;</span>) + <span class=\"string\">&#x27; - John&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Tyrion&#x27;</span>) + <span class=\"string\">&#x27; - Tyrion&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 19 - Gandalf</span></span><br><span class=\"line\"><span class=\"comment\">// 29 - John</span></span><br><span class=\"line\"><span class=\"comment\">// 16 - Tyrion</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>散列集合</strong><br>散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数<br>散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。</p>\n<p><strong>散列表中的冲突</strong><br>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<p>(1)分离链接<br>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间<br><img src=\"/2022/09/29/35-data-structure3/sperate-chain.png\" alt=\"sperate-chain\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChaining</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"comment\">//  将验证要加入新元素的位置是否已经被占据</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> LinkedList(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position].push(<span class=\"keyword\">new</span> ValuePair(key, value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化</span></span><br><span class=\"line\">  <span class=\"comment\">// LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key</span></span><br><span class=\"line\">  <span class=\"comment\">// 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较</span></span><br><span class=\"line\">  <span class=\"comment\">// 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。</span></span><br><span class=\"line\">  <span class=\"comment\">// 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> current.element.value; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">          linkedList.remove(current.element); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (linkedList.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(2)线性探查<br>它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中<br>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置<br><img src=\"/2022/09/29/35-data-structure3/linear-probing.png\" alt=\"linear-probing\"></p>\n<p>线性探查技术分为两种。</p>\n<p>第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因<br><img src=\"/2022/09/29/35-data-structure3/soft-delete.png\" alt=\"soft-delete\"><br><a href=\"http://github.com/loiane/javascript-datastructures-algorithms\">源代码</a></p>\n<p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。<br><img src=\"/2022/09/29/35-data-structure3/move-key.png\" alt=\"move-key\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move-key</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChainingMoveKey</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          index++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[index] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注</span></span><br><span class=\"line\">  <span class=\"comment\">// 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数</span></span><br><span class=\"line\">  <span class=\"comment\">// 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一</span></span><br><span class=\"line\">  <span class=\"comment\">// 个功能</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, position); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">verifyRemoveSideEffect</span>(<span class=\"params\">key, removedPosition</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = removedPosition + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> posHash = <span class=\"built_in\">this</span>.hashCode(<span class=\"built_in\">this</span>.table[index].key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[removedPosition] = <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index];</span><br><span class=\"line\">        removedPosition = index;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更好的散列函数</strong><br>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加</span></span><br><span class=\"line\"> hash = (hash * <span class=\"number\">33</span>) + tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//  将使用相加的和与另一个随机质数相除的余数</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2015 Map 类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(<span class=\"string\">&#x27;Gandalf&#x27;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.size); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.keys()); <span class=\"comment\">// 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.values()); <span class=\"comment\">// 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tyrion@email.com&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">&#x27;Tyrion&#x27;</span>)); <span class=\"comment\">// tyrion@email.com</span></span><br><span class=\"line\">map.delete(<span class=\"string\">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2105 WeakMap 类和 WeakSet 类</strong><br>Map 和 Set 与其弱化版本之间仅有的区别是:<br>(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法<br>(2)WeakSet 和 WeakMap 只能用对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Gandalf&#x27;</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ob2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tyrion&#x27;</span> &#125;;</span><br><span class=\"line\">map.set(ob1, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">map.set(ob2, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(ob3, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(ob1)); <span class=\"comment\">// true &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(ob3)); <span class=\"comment\">// tyrion@email.com &#123;4&#125;</span></span><br><span class=\"line\">map.delete(ob2); <span class=\"comment\">// &#123;5&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>集合是由一组无序且唯一（即不能重复）的项组成的</p>\n<h6 id=\"创建集合类\"><a href=\"#创建集合类\" class=\"headerlink\" title=\"创建集合类\"></a>创建集合类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// has(element) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   return Object.prototype.hasOwnProperty.call(this.items, element);</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[element] = element; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[element]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.items).length; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// sizeLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let count = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原</span></span><br><span class=\"line\">  <span class=\"comment\">// 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对</span></span><br><span class=\"line\">  <span class=\"comment\">// 象自身、未用于数据结构的）</span></span><br><span class=\"line\">  <span class=\"comment\">//  if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  count++; // &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return count;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.items);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// valuesLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let values = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if(this.items.hasOwnProperty(key)) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       values.push(key); // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return values;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h6><p>(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">union</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> unionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  otherSet.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> unionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> unionAB = setA.union(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values();</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (otherSet.has(values[i])) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">     intersectionSet.add(values[i]); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> intersectionAB = setA.intersection(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(intersectionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> otherValues = otherSet.values(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> biggerSet = values; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> smallerSet = otherValues; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (otherValues.length - values.length &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">   biggerSet = otherValues;</span><br><span class=\"line\">   smallerSet = values;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> smallerSet.forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (biggerSet.includes(value)) &#123;</span><br><span class=\"line\">     intersectionSet.add(value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">difference</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> differenceSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      differenceSet.add(value); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> differenceSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> differenceAB = setA.difference(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(differenceAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)子集：验证一个给定集合是否是另一集合的子集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">isSubsetOf</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() &gt; otherSet.size()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isSubset = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().every(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      isSubset = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isSubset; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setC = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setC.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setB));</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setC));</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用扩展运算符\"><a href=\"#使用扩展运算符\" class=\"headerlink\" title=\"使用扩展运算符\"></a>使用扩展运算符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA, ...setB]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> setB.has(x))));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> !setB.has(x))));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字典和散列表\"><a href=\"#字典和散列表\" class=\"headerlink\" title=\"字典和散列表\"></a>字典和散列表</h4><h6 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h6><p>在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。<br>字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。<br>字典也称作映射、符号表或关联数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultToString</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NULL&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;UNDEFINED&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item === <span class=\"string\">&#x27;string&#x27;</span> || item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;item&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item.toString(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`[#<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.key&#125;</span>: <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.value&#125;</span>]`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultToString &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检测一个键是否存在于字典中</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hasKey</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)] != <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在字典和 ValuePair 类中设置键和值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[tableKey] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中移除一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.hasKey(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中检索一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keyValues</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.table);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keys</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">forEach</span>(<span class=\"params\">callbackFn</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.table).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;valuePairs[<span class=\"number\">0</span>].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h6><p>散列算法的作用是尽可能快地在数据结构中找到一个值</p>\n<p>散列函数的作用是给定一个键值，然后返回值在表中的地址</p>\n<p>散列表有一些在计算机科学中应用的例子:<br>(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用<br>(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。</p>\n<p>散列函数 —- lose lose 散列函数<br><img src=\"/2022/09/29/35-data-structure3/lose-lose.png\" alt=\"lose-lose\"></p>\n<p>HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我<br>们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而<br>在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存<br>在 hash 位置（或属性）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建散列函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">loseloseHashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> key === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据组成 key 的每个字符的 ASCII 码值的和得到一个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class=\"line\">      hash += tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;）</span></span><br><span class=\"line\">    <span class=\"comment\">// 这可以规避操作数超过数值变量最大表示范围的风险</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash % <span class=\"number\">37</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.loseloseHashCode(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.hashCode(key)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valuePair != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hash = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Gandalf&#x27;</span>) + <span class=\"string\">&#x27; - Gandalf&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;John&#x27;</span>) + <span class=\"string\">&#x27; - John&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Tyrion&#x27;</span>) + <span class=\"string\">&#x27; - Tyrion&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 19 - Gandalf</span></span><br><span class=\"line\"><span class=\"comment\">// 29 - John</span></span><br><span class=\"line\"><span class=\"comment\">// 16 - Tyrion</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>散列集合</strong><br>散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数<br>散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。</p>\n<p><strong>散列表中的冲突</strong><br>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<p>(1)分离链接<br>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间<br><img src=\"/2022/09/29/35-data-structure3/sperate-chain.png\" alt=\"sperate-chain\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChaining</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"comment\">//  将验证要加入新元素的位置是否已经被占据</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> LinkedList(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position].push(<span class=\"keyword\">new</span> ValuePair(key, value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化</span></span><br><span class=\"line\">  <span class=\"comment\">// LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key</span></span><br><span class=\"line\">  <span class=\"comment\">// 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较</span></span><br><span class=\"line\">  <span class=\"comment\">// 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。</span></span><br><span class=\"line\">  <span class=\"comment\">// 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> current.element.value; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">          linkedList.remove(current.element); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (linkedList.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(2)线性探查<br>它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中<br>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置<br><img src=\"/2022/09/29/35-data-structure3/linear-probing.png\" alt=\"linear-probing\"></p>\n<p>线性探查技术分为两种。</p>\n<p>第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因<br><img src=\"/2022/09/29/35-data-structure3/soft-delete.png\" alt=\"soft-delete\"><br><a href=\"http://github.com/loiane/javascript-datastructures-algorithms\">源代码</a></p>\n<p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。<br><img src=\"/2022/09/29/35-data-structure3/move-key.png\" alt=\"move-key\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move-key</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChainingMoveKey</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          index++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[index] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注</span></span><br><span class=\"line\">  <span class=\"comment\">// 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数</span></span><br><span class=\"line\">  <span class=\"comment\">// 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一</span></span><br><span class=\"line\">  <span class=\"comment\">// 个功能</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, position); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">verifyRemoveSideEffect</span>(<span class=\"params\">key, removedPosition</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = removedPosition + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> posHash = <span class=\"built_in\">this</span>.hashCode(<span class=\"built_in\">this</span>.table[index].key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[removedPosition] = <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index];</span><br><span class=\"line\">        removedPosition = index;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更好的散列函数</strong><br>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加</span></span><br><span class=\"line\"> hash = (hash * <span class=\"number\">33</span>) + tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//  将使用相加的和与另一个随机质数相除的余数</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2015 Map 类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(<span class=\"string\">&#x27;Gandalf&#x27;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.size); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.keys()); <span class=\"comment\">// 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.values()); <span class=\"comment\">// 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tyrion@email.com&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">&#x27;Tyrion&#x27;</span>)); <span class=\"comment\">// tyrion@email.com</span></span><br><span class=\"line\">map.delete(<span class=\"string\">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2105 WeakMap 类和 WeakSet 类</strong><br>Map 和 Set 与其弱化版本之间仅有的区别是:<br>(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法<br>(2)WeakSet 和 WeakMap 只能用对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Gandalf&#x27;</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ob2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tyrion&#x27;</span> &#125;;</span><br><span class=\"line\">map.set(ob1, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">map.set(ob2, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(ob3, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(ob1)); <span class=\"comment\">// true &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(ob3)); <span class=\"comment\">// tyrion@email.com &#123;4&#125;</span></span><br><span class=\"line\">map.delete(ob2); <span class=\"comment\">// &#123;5&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象</p>\n"},{"title":"数据结构与算法阅读笔记(4)","date":"2022-10-08T05:25:18.000Z","_content":"\n#### 递归\n\n递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。\n\n每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。\n\n```javascript\nfunction understandRecursion(doIunderstandRecursion) {\n  const recursionAnswer = confirm('Do you understand recursion?');\n  if (recursionAnswer === true) {\n    // 基线条件或停止点\n    return true;\n  }\n  understandRecursion(recursionAnswer); // 递归调用\n}\n```\n\n###### 计算一个数的阶乘\n\n数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。\n5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120\n(1)迭代阶乘\n(n) _ (n - 1) _ (n - 2) _ (n - 3) _ ... \\* 1\n\n```javascript\nfunction factorialIterative(number) {\n  if (number < 0) return undefined;\n  let total = 1;\n  for (let n = number; n > 1; n--) {\n    total = total * n;\n  }\n  return total;\n}\nconsole.log(factorialIterative(5)); // 120\n```\n\n(2)递归阶乘\n\n```javascript\nfunction factorial(n) {\n  if (n === 1 || n === 0) {\n    // 基线条件\n    return 1;\n  }\n  return n * factorial(n - 1); // 递归调用\n}\nconsole.log(factorial(5)); // 120\n```\n\n![factorial](factorial.png)\n\n如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）\n\n**测试浏览器最大调用栈大小**\n\n```javascript\nlet i = 0;\nfunction recursiveFn() {\n  i++;\n  recursiveFn();\n}\ntry {\n  recursiveFn();\n} catch (ex) {\n  console.log('i = ' + i + ' error: ' + ex);\n}\n```\n\n**ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。**\n有关尾调用优化的更多相关信息，请访问 https://www.chromestatus.com/feature/\n5516876633341952\n\n###### 斐波那契数列\n\n(1)位置 0 的斐波那契数是零\n(2)1 和 2 的斐波那契数是 1\n(3)n（此处 n > 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数\n\n**迭代求斐波那契数**\n\n```javascript\nfunction fibonacciIterative(n) {\n  if (n < 1) return 0;\n  if (n <= 2) return 1;\n  let fibNMinus2 = 0;\n  let fibNMinus1 = 1;\n  let fibN = n;\n  for (let i = 2; i <= n; i++) {\n    // n >= 2\n    fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2)\n    fibNMinus2 = fibNMinus1;\n    fibNMinus1 = fibN;\n  }\n  return fibN;\n}\nfibonacciIterative(9); // 34\n```\n\n**递归求斐波那契数**\n\n```javascript\nfunction fibonacci(n) {\n  if (n < 1) return 0; // {1}\n  if (n <= 2) return 1; // {2}\n  return fibonacci(n - 1) + fibonacci(n - 2); // {3}\n}\nfibonacci(9); // 34\n```\n\n**记忆化斐波那契数**\n\n```javascript\nfunction fibonacciMemoization(n) {\n  const memo = [0, 1]; // {1}\n  const fibonacci = (n) => {\n    if (memo[n] != null) return memo[n]; // {2}\n    return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // {3}\n  };\n  return fibonacci(n);\n}\nfibonacciMemoization(9); // 34\n```\n\n迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除\n\n#### 树数据结构\n\n###### 树的相关术语\n\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点\n\n位于树顶部的节点叫作根节点。它没有父节点。\n树中的每个元素都叫作节点，节点分为内部节点和外部节点。\n至少有一个子节点的节点称为内部节点。\n没有子元素的节点称为外部节点或叶节点。\n\n一个节点可以有祖先和后代。\n一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。\n一个节点的后代包括子节点、孙子节点、曾孙节点等。\n\n子树：子树由节点和它的后代构成。\n\n节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。\n\n树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。\n![tree](tree.png)\n\n###### 二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。\n\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。\n![binary-search-tree](binary-search-tree.png)\n\n通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）\n键是树相关的术语中对节点的称呼\n\n**中序遍历**\n![in-order-traverse](in-order-traverse.png)\n**先序遍历**\n![pre-order-traverse](pre-order-traverse.png)\n**后序遍历**\n![post-order-traverse](post-order-traverse.png)\n\n```javascript\nexport class Node {\n  constructor(key) {\n    this.key = key; // {1} 节点值\n    this.left = null; // 左侧子节点引用\n    this.right = null; // 右侧子节点引用\n  }\n}\n\nimport { Compare, defaultCompare } from '../util';\nimport { Node } from './models/node';\nexport default class BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // 用来比较节点值\n    this.root = null; // {1} Node 类型的根节点\n  }\n  // 向二叉搜索树中插入一个键\n  insert(key) {\n    if (this.root == null) {\n      // {1}\n      this.root = new Node(key); // {2}\n    } else {\n      this.insertNode(this.root, key); // {3}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {4}\n      if (node.left == null) {\n        // {5}\n        node.left = new Node(key); // {6}\n      } else {\n        this.insertNode(node.left, key); // {7}\n      }\n    } else {\n      if (node.right == null) {\n        // {8}\n        node.right = new Node(key); // {9}\n      } else {\n        this.insertNode(node.right, key); // {10}\n      }\n    }\n  }\n  // 中序遍历\n  // 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。\n  // 中序遍历的一种应用就是对树进行排序操作。\n  inOrderTraverse(callback) {\n    this.inOrderTraverseNode(this.root, callback); // {1}\n  }\n  inOrderTraverseNode(node, callback) {\n    if (node != null) {\n      // {2}\n      this.inOrderTraverseNode(node.left, callback); // {3}\n      callback(node.key); // {4}\n      this.inOrderTraverseNode(node.right, callback); // {5}\n    }\n  }\n  // 先序遍历\n  // 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档\n  preOrderTraverse(callback) {\n    this.preOrderTraverseNode(this.root, callback);\n  }\n  preOrderTraverseNode(node, callback) {\n    if (node != null) {\n      callback(node.key); // {1}\n      this.preOrderTraverseNode(node.left, callback); // {2}\n      this.preOrderTraverseNode(node.right, callback); // {3}\n    }\n  }\n  // 后序遍历\n  // 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小\n  postOrderTraverse(callback) {\n    this.postOrderTraverseNode(this.root, callback);\n  }\n  postOrderTraverseNode(node, callback) {\n    if (node != null) {\n      this.postOrderTraverseNode(node.left, callback); // {1}\n      this.postOrderTraverseNode(node.right, callback); // {2}\n      callback(node.key); // {3}\n    }\n  }\n  // 搜索最小值和最大值\n  min() {\n    return this.minNode(this.root); // {1}\n  }\n  minNode(node) {\n    let current = node;\n    while (current != null && current.left != null) {\n      // {2}\n      current = current.left; // {3}\n    }\n    return current; // {4}\n  }\n  max() {\n    return this.maxNode(this.root);\n  }\n  maxNode(node) {\n    let current = node;\n    while (current != null && current.right != null) {\n      // {5}\n      current = current.right;\n    }\n    return current;\n  }\n  // 搜索一个特定的值\n  search(key) {\n    return this.searchNode(this.root, key); // {1}\n  }\n  searchNode(node, key) {\n    if (node == null) {\n      // {2}\n      return false;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      return this.searchNode(node.left, key); // {4}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {5}\n      return this.searchNode(node.right, key); // {6}\n    } else {\n      return true; // {7}\n    }\n  }\n  // 移除一个节点\n  remove(key) {\n    this.root = this.removeNode(this.root, key); // {1}\n  }\n  removeNode(node, key) {\n    if (node == null) {\n      // {2}\n      return null;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      node.left = this.removeNode(node.left, key); // {4}\n      return node; // {5}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {6}\n      node.right = this.removeNode(node.right, key); // {7}\n      return node; // {8}\n    } else {\n      // 键等于 node.key\n      // 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点\n      if (node.left == null && node.right == null) {\n        // {9}\n        node = null; // {10}\n        return node; // {11}\n      }\n      // 第二种情况: 移除有一个左侧子节点或右侧子节点的节点\n      if (node.left == null) {\n        // {12}\n        node = node.right; // {13}\n        return node; // {14}\n      } else if (node.right == null) {\n        // {15}\n        node = node.left; // {16}\n        return node; // {17}\n      }\n      // 第三种情况: 具体流程可查看后续文章\n      const aux = this.minNode(node.right); // {18}\n      node.key = aux.key; // {19}\n      node.right = this.removeNode(node.right, aux.key); // {20}\n      return node; // {21}\n    }\n  }\n}\n```\n\n**移除有两个子节点的节点**\n要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。\n(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。\n(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们\n改变了这个节点的键，也就是说它被移除了。\n(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的\n最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。\n(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。\n![remove-left-right](remove-left-right.png)\n\n###### 自平衡树\n\nAdelson-Velskii-Landi 树（AVL 树）\nAVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。\n\n在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念\n\n```javascript\nconst BalanceFactor = {\n  UNBALANCED_RIGHT: 1,\n  SLIGHTLY_UNBALANCED_RIGHT: 2,\n  BALANCED: 3,\n  SLIGHTLY_UNBALANCED_LEFT: 4,\n  UNBALANCED_LEFT: 5,\n};\n\nclass AVLTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  // 节点的高度和平衡因子\n  getNodeHeight(node) {\n    if (node == null) {\n      return -1;\n    }\n    return (\n      Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) +\n      1\n    );\n  }\n  getBalanceFactor(node) {\n    const heightDifference =\n      this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\n    switch (heightDifference) {\n      case -2:\n        return BalanceFactor.UNBALANCED_RIGHT;\n      case -1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;\n      case 1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;\n      case 2:\n        return BalanceFactor.UNBALANCED_LEFT;\n      default:\n        return BalanceFactor.BALANCED;\n    }\n  }\n  rotationLL(node) {\n    const tmp = node.left; // {1}\n    node.left = tmp.right; // {2}\n    tmp.right = node; // {3}\n    return tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right; // {1}\n    node.right = tmp.left; // {2}\n    tmp.left = node; // {3}\n    return tmp;\n  }\n  rotationLR(node) {\n    node.left = this.rotationRR(node.left);\n    return this.rotationLL(node);\n  }\n  rotationRL(node) {\n    node.right = this.rotationLL(node.right);\n    return this.rotationRR(node);\n  }\n  //  向 AVL 树插入节点\n  insert(key) {\n    this.root = this.insertNode(this.root, key);\n  }\n  insertNode(node, key) {\n    // 像在 BST 树中一样插入节点\n    if (node == null) {\n      return new Node(key);\n    } else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      node.left = this.insertNode(node.left, key);\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      node.right = this.insertNode(node.right, key);\n    } else {\n      return node; // 重复的键\n    }\n    // 如果需要，将树进行平衡操作\n    const balanceFactor = this.getBalanceFactor(node); // {1}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {2}\n      if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {\n        // {3}\n        node = this.rotationLL(node); // {4}\n      } else {\n        return this.rotationLR(node); // {5}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {6}\n      if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {\n        // {7}\n        node = this.rotationRR(node); // {8}\n      } else {\n        return this.rotationRL(node); // {9}\n      }\n    }\n    return node;\n  }\n  // 从 AVL 树中移除节点\n  removeNode(node, key) {\n    node = super.removeNode(node, key); // {1}\n    if (node == null) {\n      return node; // null，不需要进行平衡\n    }\n    // 检测树是否平衡\n    const balanceFactor = this.getBalanceFactor(node); // {2}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {3}\n      const balanceFactorLeft = this.getBalanceFactor(node.left); // {4}\n      if (\n        balanceFactorLeft === BalanceFactor.BALANCED ||\n        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT\n      ) {\n        // {5}\n        return this.rotationLL(node); // {6}\n      }\n      if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\n        // {7}\n        return this.rotationLR(node.left); // {8}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {9}\n      const balanceFactorRight = this.getBalanceFactor(node.right); // {10}\n      if (\n        balanceFactorRight === BalanceFactor.BALANCED ||\n        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT\n      ) {\n        // {11}\n        return this.rotationRR(node); // {12}\n      }\n      if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\n        // {13}\n        return this.rotationRL(node.right); // {14}\n      }\n    }\n    return node;\n  }\n}\n```\n\n**平衡操作——AVL 旋转**\n(1)左-左（LL）：向右的单旋转\n这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的\n![left-left-1](left-left-1.png)\n![left-left-2](left-left-2.png)\n\nrotationLL 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；\n节点 X 的左子树保持不变；\n将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；\n将节点 X 的右子节点置为节点 Y（行{3}）\n\n(2)右-右（RR）：向左的单旋转\n右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的\n![right-right-1](right-right-1.png)\n![right-right-2](right-right-2.png)\n\nrotationRR 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；\n节点 X 的右子树保持不变；\n将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；\n将节点 X 的左子节点置为节点 Y（行{3}）\n\n(3)左-右（LR）：向右的双旋转\n这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复\n![left-right-1](left-right-1.png)\n![left-right-2](left-right-2.png)\n\nrotationLR 方法\n将节点 X 置于节点 Y（平衡因子为 2）所在的位置；\n将节点 Z 的左子节点置为节点 X 的右子节点；\n将节点 Y 的右子节点置为节点 X 的左子节点；\n将节点 X 的右子节点置为节点 Y；\n将节点 X 的左子节点置为节点 Z\n\n(4)右-左（RL）：向左的双旋转\n右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复\n![right-left-1](right-left-1.png)\n![right-left-2](right-left-2.png)\n\nrotationRL 方法\n将节点 X 置于节点 Y（平衡因子为+2）所在的位置；\n将节点 Y 的左子节点置为节点 X 的右子节点；\n将节点 Z 的右子节点置为节点 X 的左子节点；\n将节点 X 的左子节点置为节点 Y；\n将节点 X 的右子节点置为节点 Z\n\n###### 红黑树\n\n包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好\n\n在红黑树中，每个节点都遵循以下规则：\n(1) 顾名思义，每个节点不是红的就是黑的；\n(2) 树的根节点是黑的；\n(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；\n(4) 如果一个节点是红的，那么它的两个子节点都是黑的；\n(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；\n(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。\n\n```javascript\nclass RedBlackNode extends Node {\n  constructor(key) {\n    super(key);\n    this.key = key;\n    this.color = Colors.RED; // {6}\n    this.parent = null; // {7}\n  }\n  isRed() {\n    return this.color === Colors.RED;\n  }\n}\n\nclass RedBlackTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  insert(key: T) {\n    if (this.root == null) {\n      // {1}\n      this.root = new RedBlackNode(key); // {2}\n      this.root.color = Colors.BLACK; // {3}\n    } else {\n      const newNode = this.insertNode(this.root, key); // {4}\n      this.fixTreeProperties(newNode); // {5}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      if (node.left == null) {\n        node.left = new RedBlackNode(key);\n        node.left.parent = node; // {8}\n        return node.left; // {9}\n      } else {\n        return this.insertNode(node.left, key);\n      }\n    } else if (node.right == null) {\n      node.right = new RedBlackNode(key);\n      node.right.parent = node; // {10}\n      return node.right; // {11}\n    } else {\n      return this.insertNode(node.right, key);\n    }\n  }\n  fixTreeProperties(node) {\n    while (\n      node &&\n      node.parent &&\n      node.parent.color.isRed() && // {1}\n      node.color !== Colors.BLACK\n    ) {\n      // {2}\n      let parent = node.parent; // {3}\n      const grandParent = parent.parent; // {4}\n      // 情形 A：父节点是左侧子节点\n      if (grandParent && grandParent.left === parent) {\n        // {5}\n        const uncle = grandParent.right; // {6}\n        // 情形 1A：叔节点也是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {7}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent; // {8}\n        } else {\n          // 情形 2A：节点是右侧子节点——左旋转\n          if (node === parent.right) {\n            this.rotationRR(parent); // {12}\n            node = parent; // {13}\n            parent = node.parent; // {14}\n          }\n          // 情形 3A：节点是左侧子节点——右旋转\n          this.rotationLL(grandParent); // {15}\n          parent.color = Colors.BLACK; // {16}\n          grandParent.color = Colors.RED; // {17}\n          node = parent; // {18}\n        }\n      } else {\n        // 情形 B：父节点是右侧子节点\n        const uncle = grandParent.left; // {9}\n        // 情形 1B：叔节点是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {10}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent;\n        } else {\n          // 情形 2B：节点是左侧子节点——左旋转\n          if (node === parent.left) {\n            this.rotationLL(parent); // {19}\n            node = parent;\n            parent = node.parent;\n          }\n          // 情形 3B：节点是右侧子节点——左旋转\n          this.rotationRR(grandParent); // {20}\n          parent.color = Colors.BLACK;\n          grandParent.color = Colors.RED;\n          node = parent;\n        }\n      }\n    }\n    this.root.color = Colors.BLACK; // {11}\n  }\n  rotationLL(node) {\n    const tmp = node.left;\n    node.left = tmp.right;\n    if (tmp.right && tmp.right.key) {\n      tmp.right.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.right = node;\n    node.parent = tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right;\n    node.right = tmp.left;\n    if (tmp.left && tmp.left.key) {\n      tmp.left.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.left = node;\n    node.parent = tmp;\n  }\n}\n```\n\n左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。\n左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。\n![red-black-2a](red-black-2a.png)\n![red-black-3a](red-black-3a.png)\n![red-black-2b](red-black-2b.png)\n![red-black-3b](red-black-3b.png)\n","source":"_posts/36-data-structure4.md","raw":"---\ntitle: 数据结构与算法阅读笔记(4)\ndate: 2022-10-08 13:25:18\ntags:\n---\n\n#### 递归\n\n递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。\n\n每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。\n\n```javascript\nfunction understandRecursion(doIunderstandRecursion) {\n  const recursionAnswer = confirm('Do you understand recursion?');\n  if (recursionAnswer === true) {\n    // 基线条件或停止点\n    return true;\n  }\n  understandRecursion(recursionAnswer); // 递归调用\n}\n```\n\n###### 计算一个数的阶乘\n\n数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。\n5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120\n(1)迭代阶乘\n(n) _ (n - 1) _ (n - 2) _ (n - 3) _ ... \\* 1\n\n```javascript\nfunction factorialIterative(number) {\n  if (number < 0) return undefined;\n  let total = 1;\n  for (let n = number; n > 1; n--) {\n    total = total * n;\n  }\n  return total;\n}\nconsole.log(factorialIterative(5)); // 120\n```\n\n(2)递归阶乘\n\n```javascript\nfunction factorial(n) {\n  if (n === 1 || n === 0) {\n    // 基线条件\n    return 1;\n  }\n  return n * factorial(n - 1); // 递归调用\n}\nconsole.log(factorial(5)); // 120\n```\n\n![factorial](factorial.png)\n\n如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）\n\n**测试浏览器最大调用栈大小**\n\n```javascript\nlet i = 0;\nfunction recursiveFn() {\n  i++;\n  recursiveFn();\n}\ntry {\n  recursiveFn();\n} catch (ex) {\n  console.log('i = ' + i + ' error: ' + ex);\n}\n```\n\n**ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。**\n有关尾调用优化的更多相关信息，请访问 https://www.chromestatus.com/feature/\n5516876633341952\n\n###### 斐波那契数列\n\n(1)位置 0 的斐波那契数是零\n(2)1 和 2 的斐波那契数是 1\n(3)n（此处 n > 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数\n\n**迭代求斐波那契数**\n\n```javascript\nfunction fibonacciIterative(n) {\n  if (n < 1) return 0;\n  if (n <= 2) return 1;\n  let fibNMinus2 = 0;\n  let fibNMinus1 = 1;\n  let fibN = n;\n  for (let i = 2; i <= n; i++) {\n    // n >= 2\n    fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2)\n    fibNMinus2 = fibNMinus1;\n    fibNMinus1 = fibN;\n  }\n  return fibN;\n}\nfibonacciIterative(9); // 34\n```\n\n**递归求斐波那契数**\n\n```javascript\nfunction fibonacci(n) {\n  if (n < 1) return 0; // {1}\n  if (n <= 2) return 1; // {2}\n  return fibonacci(n - 1) + fibonacci(n - 2); // {3}\n}\nfibonacci(9); // 34\n```\n\n**记忆化斐波那契数**\n\n```javascript\nfunction fibonacciMemoization(n) {\n  const memo = [0, 1]; // {1}\n  const fibonacci = (n) => {\n    if (memo[n] != null) return memo[n]; // {2}\n    return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // {3}\n  };\n  return fibonacci(n);\n}\nfibonacciMemoization(9); // 34\n```\n\n迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除\n\n#### 树数据结构\n\n###### 树的相关术语\n\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点\n\n位于树顶部的节点叫作根节点。它没有父节点。\n树中的每个元素都叫作节点，节点分为内部节点和外部节点。\n至少有一个子节点的节点称为内部节点。\n没有子元素的节点称为外部节点或叶节点。\n\n一个节点可以有祖先和后代。\n一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。\n一个节点的后代包括子节点、孙子节点、曾孙节点等。\n\n子树：子树由节点和它的后代构成。\n\n节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。\n\n树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。\n![tree](tree.png)\n\n###### 二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。\n\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。\n![binary-search-tree](binary-search-tree.png)\n\n通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）\n键是树相关的术语中对节点的称呼\n\n**中序遍历**\n![in-order-traverse](in-order-traverse.png)\n**先序遍历**\n![pre-order-traverse](pre-order-traverse.png)\n**后序遍历**\n![post-order-traverse](post-order-traverse.png)\n\n```javascript\nexport class Node {\n  constructor(key) {\n    this.key = key; // {1} 节点值\n    this.left = null; // 左侧子节点引用\n    this.right = null; // 右侧子节点引用\n  }\n}\n\nimport { Compare, defaultCompare } from '../util';\nimport { Node } from './models/node';\nexport default class BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // 用来比较节点值\n    this.root = null; // {1} Node 类型的根节点\n  }\n  // 向二叉搜索树中插入一个键\n  insert(key) {\n    if (this.root == null) {\n      // {1}\n      this.root = new Node(key); // {2}\n    } else {\n      this.insertNode(this.root, key); // {3}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {4}\n      if (node.left == null) {\n        // {5}\n        node.left = new Node(key); // {6}\n      } else {\n        this.insertNode(node.left, key); // {7}\n      }\n    } else {\n      if (node.right == null) {\n        // {8}\n        node.right = new Node(key); // {9}\n      } else {\n        this.insertNode(node.right, key); // {10}\n      }\n    }\n  }\n  // 中序遍历\n  // 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。\n  // 中序遍历的一种应用就是对树进行排序操作。\n  inOrderTraverse(callback) {\n    this.inOrderTraverseNode(this.root, callback); // {1}\n  }\n  inOrderTraverseNode(node, callback) {\n    if (node != null) {\n      // {2}\n      this.inOrderTraverseNode(node.left, callback); // {3}\n      callback(node.key); // {4}\n      this.inOrderTraverseNode(node.right, callback); // {5}\n    }\n  }\n  // 先序遍历\n  // 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档\n  preOrderTraverse(callback) {\n    this.preOrderTraverseNode(this.root, callback);\n  }\n  preOrderTraverseNode(node, callback) {\n    if (node != null) {\n      callback(node.key); // {1}\n      this.preOrderTraverseNode(node.left, callback); // {2}\n      this.preOrderTraverseNode(node.right, callback); // {3}\n    }\n  }\n  // 后序遍历\n  // 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小\n  postOrderTraverse(callback) {\n    this.postOrderTraverseNode(this.root, callback);\n  }\n  postOrderTraverseNode(node, callback) {\n    if (node != null) {\n      this.postOrderTraverseNode(node.left, callback); // {1}\n      this.postOrderTraverseNode(node.right, callback); // {2}\n      callback(node.key); // {3}\n    }\n  }\n  // 搜索最小值和最大值\n  min() {\n    return this.minNode(this.root); // {1}\n  }\n  minNode(node) {\n    let current = node;\n    while (current != null && current.left != null) {\n      // {2}\n      current = current.left; // {3}\n    }\n    return current; // {4}\n  }\n  max() {\n    return this.maxNode(this.root);\n  }\n  maxNode(node) {\n    let current = node;\n    while (current != null && current.right != null) {\n      // {5}\n      current = current.right;\n    }\n    return current;\n  }\n  // 搜索一个特定的值\n  search(key) {\n    return this.searchNode(this.root, key); // {1}\n  }\n  searchNode(node, key) {\n    if (node == null) {\n      // {2}\n      return false;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      return this.searchNode(node.left, key); // {4}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {5}\n      return this.searchNode(node.right, key); // {6}\n    } else {\n      return true; // {7}\n    }\n  }\n  // 移除一个节点\n  remove(key) {\n    this.root = this.removeNode(this.root, key); // {1}\n  }\n  removeNode(node, key) {\n    if (node == null) {\n      // {2}\n      return null;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      node.left = this.removeNode(node.left, key); // {4}\n      return node; // {5}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {6}\n      node.right = this.removeNode(node.right, key); // {7}\n      return node; // {8}\n    } else {\n      // 键等于 node.key\n      // 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点\n      if (node.left == null && node.right == null) {\n        // {9}\n        node = null; // {10}\n        return node; // {11}\n      }\n      // 第二种情况: 移除有一个左侧子节点或右侧子节点的节点\n      if (node.left == null) {\n        // {12}\n        node = node.right; // {13}\n        return node; // {14}\n      } else if (node.right == null) {\n        // {15}\n        node = node.left; // {16}\n        return node; // {17}\n      }\n      // 第三种情况: 具体流程可查看后续文章\n      const aux = this.minNode(node.right); // {18}\n      node.key = aux.key; // {19}\n      node.right = this.removeNode(node.right, aux.key); // {20}\n      return node; // {21}\n    }\n  }\n}\n```\n\n**移除有两个子节点的节点**\n要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。\n(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。\n(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们\n改变了这个节点的键，也就是说它被移除了。\n(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的\n最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。\n(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。\n![remove-left-right](remove-left-right.png)\n\n###### 自平衡树\n\nAdelson-Velskii-Landi 树（AVL 树）\nAVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。\n\n在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念\n\n```javascript\nconst BalanceFactor = {\n  UNBALANCED_RIGHT: 1,\n  SLIGHTLY_UNBALANCED_RIGHT: 2,\n  BALANCED: 3,\n  SLIGHTLY_UNBALANCED_LEFT: 4,\n  UNBALANCED_LEFT: 5,\n};\n\nclass AVLTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  // 节点的高度和平衡因子\n  getNodeHeight(node) {\n    if (node == null) {\n      return -1;\n    }\n    return (\n      Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) +\n      1\n    );\n  }\n  getBalanceFactor(node) {\n    const heightDifference =\n      this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\n    switch (heightDifference) {\n      case -2:\n        return BalanceFactor.UNBALANCED_RIGHT;\n      case -1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;\n      case 1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;\n      case 2:\n        return BalanceFactor.UNBALANCED_LEFT;\n      default:\n        return BalanceFactor.BALANCED;\n    }\n  }\n  rotationLL(node) {\n    const tmp = node.left; // {1}\n    node.left = tmp.right; // {2}\n    tmp.right = node; // {3}\n    return tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right; // {1}\n    node.right = tmp.left; // {2}\n    tmp.left = node; // {3}\n    return tmp;\n  }\n  rotationLR(node) {\n    node.left = this.rotationRR(node.left);\n    return this.rotationLL(node);\n  }\n  rotationRL(node) {\n    node.right = this.rotationLL(node.right);\n    return this.rotationRR(node);\n  }\n  //  向 AVL 树插入节点\n  insert(key) {\n    this.root = this.insertNode(this.root, key);\n  }\n  insertNode(node, key) {\n    // 像在 BST 树中一样插入节点\n    if (node == null) {\n      return new Node(key);\n    } else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      node.left = this.insertNode(node.left, key);\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      node.right = this.insertNode(node.right, key);\n    } else {\n      return node; // 重复的键\n    }\n    // 如果需要，将树进行平衡操作\n    const balanceFactor = this.getBalanceFactor(node); // {1}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {2}\n      if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {\n        // {3}\n        node = this.rotationLL(node); // {4}\n      } else {\n        return this.rotationLR(node); // {5}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {6}\n      if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {\n        // {7}\n        node = this.rotationRR(node); // {8}\n      } else {\n        return this.rotationRL(node); // {9}\n      }\n    }\n    return node;\n  }\n  // 从 AVL 树中移除节点\n  removeNode(node, key) {\n    node = super.removeNode(node, key); // {1}\n    if (node == null) {\n      return node; // null，不需要进行平衡\n    }\n    // 检测树是否平衡\n    const balanceFactor = this.getBalanceFactor(node); // {2}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {3}\n      const balanceFactorLeft = this.getBalanceFactor(node.left); // {4}\n      if (\n        balanceFactorLeft === BalanceFactor.BALANCED ||\n        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT\n      ) {\n        // {5}\n        return this.rotationLL(node); // {6}\n      }\n      if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\n        // {7}\n        return this.rotationLR(node.left); // {8}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {9}\n      const balanceFactorRight = this.getBalanceFactor(node.right); // {10}\n      if (\n        balanceFactorRight === BalanceFactor.BALANCED ||\n        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT\n      ) {\n        // {11}\n        return this.rotationRR(node); // {12}\n      }\n      if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\n        // {13}\n        return this.rotationRL(node.right); // {14}\n      }\n    }\n    return node;\n  }\n}\n```\n\n**平衡操作——AVL 旋转**\n(1)左-左（LL）：向右的单旋转\n这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的\n![left-left-1](left-left-1.png)\n![left-left-2](left-left-2.png)\n\nrotationLL 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；\n节点 X 的左子树保持不变；\n将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；\n将节点 X 的右子节点置为节点 Y（行{3}）\n\n(2)右-右（RR）：向左的单旋转\n右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的\n![right-right-1](right-right-1.png)\n![right-right-2](right-right-2.png)\n\nrotationRR 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；\n节点 X 的右子树保持不变；\n将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；\n将节点 X 的左子节点置为节点 Y（行{3}）\n\n(3)左-右（LR）：向右的双旋转\n这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复\n![left-right-1](left-right-1.png)\n![left-right-2](left-right-2.png)\n\nrotationLR 方法\n将节点 X 置于节点 Y（平衡因子为 2）所在的位置；\n将节点 Z 的左子节点置为节点 X 的右子节点；\n将节点 Y 的右子节点置为节点 X 的左子节点；\n将节点 X 的右子节点置为节点 Y；\n将节点 X 的左子节点置为节点 Z\n\n(4)右-左（RL）：向左的双旋转\n右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复\n![right-left-1](right-left-1.png)\n![right-left-2](right-left-2.png)\n\nrotationRL 方法\n将节点 X 置于节点 Y（平衡因子为+2）所在的位置；\n将节点 Y 的左子节点置为节点 X 的右子节点；\n将节点 Z 的右子节点置为节点 X 的左子节点；\n将节点 X 的左子节点置为节点 Y；\n将节点 X 的右子节点置为节点 Z\n\n###### 红黑树\n\n包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好\n\n在红黑树中，每个节点都遵循以下规则：\n(1) 顾名思义，每个节点不是红的就是黑的；\n(2) 树的根节点是黑的；\n(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；\n(4) 如果一个节点是红的，那么它的两个子节点都是黑的；\n(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；\n(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。\n\n```javascript\nclass RedBlackNode extends Node {\n  constructor(key) {\n    super(key);\n    this.key = key;\n    this.color = Colors.RED; // {6}\n    this.parent = null; // {7}\n  }\n  isRed() {\n    return this.color === Colors.RED;\n  }\n}\n\nclass RedBlackTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  insert(key: T) {\n    if (this.root == null) {\n      // {1}\n      this.root = new RedBlackNode(key); // {2}\n      this.root.color = Colors.BLACK; // {3}\n    } else {\n      const newNode = this.insertNode(this.root, key); // {4}\n      this.fixTreeProperties(newNode); // {5}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      if (node.left == null) {\n        node.left = new RedBlackNode(key);\n        node.left.parent = node; // {8}\n        return node.left; // {9}\n      } else {\n        return this.insertNode(node.left, key);\n      }\n    } else if (node.right == null) {\n      node.right = new RedBlackNode(key);\n      node.right.parent = node; // {10}\n      return node.right; // {11}\n    } else {\n      return this.insertNode(node.right, key);\n    }\n  }\n  fixTreeProperties(node) {\n    while (\n      node &&\n      node.parent &&\n      node.parent.color.isRed() && // {1}\n      node.color !== Colors.BLACK\n    ) {\n      // {2}\n      let parent = node.parent; // {3}\n      const grandParent = parent.parent; // {4}\n      // 情形 A：父节点是左侧子节点\n      if (grandParent && grandParent.left === parent) {\n        // {5}\n        const uncle = grandParent.right; // {6}\n        // 情形 1A：叔节点也是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {7}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent; // {8}\n        } else {\n          // 情形 2A：节点是右侧子节点——左旋转\n          if (node === parent.right) {\n            this.rotationRR(parent); // {12}\n            node = parent; // {13}\n            parent = node.parent; // {14}\n          }\n          // 情形 3A：节点是左侧子节点——右旋转\n          this.rotationLL(grandParent); // {15}\n          parent.color = Colors.BLACK; // {16}\n          grandParent.color = Colors.RED; // {17}\n          node = parent; // {18}\n        }\n      } else {\n        // 情形 B：父节点是右侧子节点\n        const uncle = grandParent.left; // {9}\n        // 情形 1B：叔节点是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {10}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent;\n        } else {\n          // 情形 2B：节点是左侧子节点——左旋转\n          if (node === parent.left) {\n            this.rotationLL(parent); // {19}\n            node = parent;\n            parent = node.parent;\n          }\n          // 情形 3B：节点是右侧子节点——左旋转\n          this.rotationRR(grandParent); // {20}\n          parent.color = Colors.BLACK;\n          grandParent.color = Colors.RED;\n          node = parent;\n        }\n      }\n    }\n    this.root.color = Colors.BLACK; // {11}\n  }\n  rotationLL(node) {\n    const tmp = node.left;\n    node.left = tmp.right;\n    if (tmp.right && tmp.right.key) {\n      tmp.right.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.right = node;\n    node.parent = tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right;\n    node.right = tmp.left;\n    if (tmp.left && tmp.left.key) {\n      tmp.left.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.left = node;\n    node.parent = tmp;\n  }\n}\n```\n\n左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。\n左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。\n![red-black-2a](red-black-2a.png)\n![red-black-3a](red-black-3a.png)\n![red-black-2b](red-black-2b.png)\n![red-black-3b](red-black-3b.png)\n","slug":"36-data-structure4","published":1,"updated":"2022-10-08T08:25:03.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q1000yk4tt8bav964a","content":"<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。</p>\n<p>每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">understandRecursion</span>(<span class=\"params\">doIunderstandRecursion</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> recursionAnswer = confirm(<span class=\"string\">&#x27;Do you understand recursion?&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (recursionAnswer === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件或停止点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  understandRecursion(recursionAnswer); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"计算一个数的阶乘\"><a href=\"#计算一个数的阶乘\" class=\"headerlink\" title=\"计算一个数的阶乘\"></a>计算一个数的阶乘</h6><p>数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。<br>5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120<br>(1)迭代阶乘<br>(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorialIterative</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (number &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n = number; n &gt; <span class=\"number\">1</span>; n--) &#123;</span><br><span class=\"line\">    total = total * n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorialIterative(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)递归阶乘</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorial(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/36-data-structure4/factorial.png\" alt=\"factorial\"></p>\n<p>如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）</p>\n<p><strong>测试浏览器最大调用栈大小</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursiveFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;i = &#x27;</span> + i + <span class=\"string\">&#x27; error: &#x27;</span> + ex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。</strong><br>有关尾调用优化的更多相关信息，请访问 <a href=\"https://www.chromestatus.com/feature/\">https://www.chromestatus.com/feature/</a><br>5516876633341952</p>\n<h6 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h6><p>(1)位置 0 的斐波那契数是零<br>(2)1 和 2 的斐波那契数是 1<br>(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数</p>\n<p><strong>迭代求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciIterative</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibN = n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n &gt;= 2</span></span><br><span class=\"line\">    fibN = fibNMinus1 + fibNMinus2; <span class=\"comment\">// f(n-1) + f(n-2)</span></span><br><span class=\"line\">    fibNMinus2 = fibNMinus1;</span><br><span class=\"line\">    fibNMinus1 = fibN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciIterative(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>递归求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacci(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>记忆化斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciMemoization</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> memo = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fibonacci = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[n] != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> memo[n]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (memo[n] = fibonacci(n - <span class=\"number\">1</span>, memo) + fibonacci(n - <span class=\"number\">2</span>, memo)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciMemoization(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除</p>\n<h4 id=\"树数据结构\"><a href=\"#树数据结构\" class=\"headerlink\" title=\"树数据结构\"></a>树数据结构</h4><h6 id=\"树的相关术语\"><a href=\"#树的相关术语\" class=\"headerlink\" title=\"树的相关术语\"></a>树的相关术语</h6><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点</p>\n<p>位于树顶部的节点叫作根节点。它没有父节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。</p>\n<p>一个节点可以有祖先和后代。<br>一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。<br>一个节点的后代包括子节点、孙子节点、曾孙节点等。</p>\n<p>子树：子树由节点和它的后代构成。</p>\n<p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p>\n<p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。<br><img src=\"/2022/10/08/36-data-structure4/tree.png\" alt=\"tree\"></p>\n<h6 id=\"二叉树和二叉搜索树\"><a href=\"#二叉树和二叉搜索树\" class=\"headerlink\" title=\"二叉树和二叉搜索树\"></a>二叉树和二叉搜索树</h6><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p>\n<p>二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。<br><img src=\"/2022/10/08/36-data-structure4/binary-search-tree.png\" alt=\"binary-search-tree\"></p>\n<p>通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）<br>键是树相关的术语中对节点的称呼</p>\n<p><strong>中序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/in-order-traverse.png\" alt=\"in-order-traverse\"><br><strong>先序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/pre-order-traverse.png\" alt=\"pre-order-traverse\"><br><strong>后序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/post-order-traverse.png\" alt=\"post-order-traverse\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key; <span class=\"comment\">// &#123;1&#125; 节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.left = <span class=\"literal\">null</span>; <span class=\"comment\">// 左侧子节点引用</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.right = <span class=\"literal\">null</span>; <span class=\"comment\">// 右侧子节点引用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Compare, defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/node&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// 用来比较节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;1&#125; Node 类型的根节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向二叉搜索树中插入一个键</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.left, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        node.right = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.right, key); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历的一种应用就是对树进行排序操作。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.inOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.preOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.postOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索最小值和最大值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">min</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.minNode(<span class=\"built_in\">this</span>.root); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">minNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      current = current.left; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">max</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.maxNode(<span class=\"built_in\">this</span>.root);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">maxNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      current = current.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索一个特定的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">search</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">searchNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.right, key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除一个节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.removeNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.removeNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 键等于 node.key</span></span><br><span class=\"line\">      <span class=\"comment\">// 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        node = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第二种情况: 移除有一个左侧子节点或右侧子节点的节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">        node = node.right; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">        node = node.left; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第三种情况: 具体流程可查看后续文章</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> aux = <span class=\"built_in\">this</span>.minNode(node.right); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">      node.key = aux.key; <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, aux.key); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;21&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>移除有两个子节点的节点</strong><br>要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。<br>(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们<br>改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的<br>最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。<br><img src=\"/2022/10/08/36-data-structure4/remove-left-right.png\" alt=\"remove-left-right\"></p>\n<h6 id=\"自平衡树\"><a href=\"#自平衡树\" class=\"headerlink\" title=\"自平衡树\"></a>自平衡树</h6><p>Adelson-Velskii-Landi 树（AVL 树）<br>AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。</p>\n<p>在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BalanceFactor = &#123;</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_RIGHT</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">BALANCED</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_LEFT</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_LEFT</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 节点的高度和平衡因子</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getNodeHeight</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">this</span>.getNodeHeight(node.left), <span class=\"built_in\">this</span>.getNodeHeight(node.right)) +</span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getBalanceFactor</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> heightDifference =</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.getNodeHeight(node.left) - <span class=\"built_in\">this</span>.getNodeHeight(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (heightDifference) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.BALANCED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.left = tmp.right; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.right = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.right = tmp.left; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.left = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.left = <span class=\"built_in\">this</span>.rotationRR(node.left);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.right = <span class=\"built_in\">this</span>.rotationLL(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  向 AVL 树插入节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 像在 BST 树中一样插入节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Node(key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// 重复的键</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果需要，将树进行平衡操作</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从 AVL 树中移除节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    node = <span class=\"built_in\">super</span>.removeNode(node, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// null，不需要进行平衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检测树是否平衡</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorLeft = <span class=\"built_in\">this</span>.getBalanceFactor(node.left); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node.left); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorRight = <span class=\"built_in\">this</span>.getBalanceFactor(node.right); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node.right); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>平衡操作——AVL 旋转</strong><br>(1)左-左（LL）：向右的单旋转<br>这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的<br><img src=\"/2022/10/08/36-data-structure4/left-left-1.png\" alt=\"left-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-left-2.png\" alt=\"left-left-2\"></p>\n<p>rotationLL 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；<br>节点 X 的左子树保持不变；<br>将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；<br>将节点 X 的右子节点置为节点 Y（行{3}）</p>\n<p>(2)右-右（RR）：向左的单旋转<br>右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的<br><img src=\"/2022/10/08/36-data-structure4/right-right-1.png\" alt=\"right-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-right-2.png\" alt=\"right-right-2\"></p>\n<p>rotationRR 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；<br>节点 X 的右子树保持不变；<br>将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；<br>将节点 X 的左子节点置为节点 Y（行{3}）</p>\n<p>(3)左-右（LR）：向右的双旋转<br>这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/left-right-1.png\" alt=\"left-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-right-2.png\" alt=\"left-right-2\"></p>\n<p>rotationLR 方法<br>将节点 X 置于节点 Y（平衡因子为 2）所在的位置；<br>将节点 Z 的左子节点置为节点 X 的右子节点；<br>将节点 Y 的右子节点置为节点 X 的左子节点；<br>将节点 X 的右子节点置为节点 Y；<br>将节点 X 的左子节点置为节点 Z</p>\n<p>(4)右-左（RL）：向左的双旋转<br>右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/right-left-1.png\" alt=\"right-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-left-2.png\" alt=\"right-left-2\"></p>\n<p>rotationRL 方法<br>将节点 X 置于节点 Y（平衡因子为+2）所在的位置；<br>将节点 Y 的左子节点置为节点 X 的右子节点；<br>将节点 Z 的右子节点置为节点 X 的左子节点；<br>将节点 X 的左子节点置为节点 Y；<br>将节点 X 的右子节点置为节点 Z</p>\n<h6 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h6><p>包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好</p>\n<p>在红黑树中，每个节点都遵循以下规则：<br>(1) 顾名思义，每个节点不是红的就是黑的；<br>(2) 树的根节点是黑的；<br>(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；<br>(4) 如果一个节点是红的，那么它的两个子节点都是黑的；<br>(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；<br>(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(key);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = Colors.RED; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.parent = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isRed</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.color === Colors.RED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key: T</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> RedBlackNode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newNode = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.fixTreeProperties(newNode); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">        node.left.parent = node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.right = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">      node.right.parent = node; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node.right; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">fixTreeProperties</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      node &amp;&amp;</span><br><span class=\"line\">      node.parent &amp;&amp;</span><br><span class=\"line\">      node.parent.color.isRed() &amp;&amp; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      node.color !== Colors.BLACK</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> parent = node.parent; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> grandParent = parent.parent; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 情形 A：父节点是左侧子节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1A：叔节点也是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2A：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationRR(parent); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">            node = parent; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">            parent = node.parent; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3A：节点是左侧子节点——右旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationLL(grandParent); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">          node = parent; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情形 B：父节点是右侧子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1B：叔节点是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2B：节点是左侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.left) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationLL(parent); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">            node = parent;</span><br><span class=\"line\">            parent = node.parent;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3B：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationRR(grandParent); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          node = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left;</span><br><span class=\"line\">    node.left = tmp.right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class=\"line\">      tmp.right.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.right = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right;</span><br><span class=\"line\">    node.right = tmp.left;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class=\"line\">      tmp.left.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.left = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。<br>左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。<br><img src=\"/2022/10/08/36-data-structure4/red-black-2a.png\" alt=\"red-black-2a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3a.png\" alt=\"red-black-3a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-2b.png\" alt=\"red-black-2b\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3b.png\" alt=\"red-black-3b\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。</p>\n<p>每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">understandRecursion</span>(<span class=\"params\">doIunderstandRecursion</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> recursionAnswer = confirm(<span class=\"string\">&#x27;Do you understand recursion?&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (recursionAnswer === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件或停止点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  understandRecursion(recursionAnswer); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"计算一个数的阶乘\"><a href=\"#计算一个数的阶乘\" class=\"headerlink\" title=\"计算一个数的阶乘\"></a>计算一个数的阶乘</h6><p>数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。<br>5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120<br>(1)迭代阶乘<br>(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorialIterative</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (number &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n = number; n &gt; <span class=\"number\">1</span>; n--) &#123;</span><br><span class=\"line\">    total = total * n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorialIterative(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)递归阶乘</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorial(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/36-data-structure4/factorial.png\" alt=\"factorial\"></p>\n<p>如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）</p>\n<p><strong>测试浏览器最大调用栈大小</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursiveFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;i = &#x27;</span> + i + <span class=\"string\">&#x27; error: &#x27;</span> + ex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。</strong><br>有关尾调用优化的更多相关信息，请访问 <a href=\"https://www.chromestatus.com/feature/\">https://www.chromestatus.com/feature/</a><br>5516876633341952</p>\n<h6 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h6><p>(1)位置 0 的斐波那契数是零<br>(2)1 和 2 的斐波那契数是 1<br>(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数</p>\n<p><strong>迭代求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciIterative</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibN = n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n &gt;= 2</span></span><br><span class=\"line\">    fibN = fibNMinus1 + fibNMinus2; <span class=\"comment\">// f(n-1) + f(n-2)</span></span><br><span class=\"line\">    fibNMinus2 = fibNMinus1;</span><br><span class=\"line\">    fibNMinus1 = fibN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciIterative(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>递归求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacci(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>记忆化斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciMemoization</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> memo = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fibonacci = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[n] != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> memo[n]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (memo[n] = fibonacci(n - <span class=\"number\">1</span>, memo) + fibonacci(n - <span class=\"number\">2</span>, memo)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciMemoization(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除</p>\n<h4 id=\"树数据结构\"><a href=\"#树数据结构\" class=\"headerlink\" title=\"树数据结构\"></a>树数据结构</h4><h6 id=\"树的相关术语\"><a href=\"#树的相关术语\" class=\"headerlink\" title=\"树的相关术语\"></a>树的相关术语</h6><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点</p>\n<p>位于树顶部的节点叫作根节点。它没有父节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。</p>\n<p>一个节点可以有祖先和后代。<br>一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。<br>一个节点的后代包括子节点、孙子节点、曾孙节点等。</p>\n<p>子树：子树由节点和它的后代构成。</p>\n<p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p>\n<p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。<br><img src=\"/2022/10/08/36-data-structure4/tree.png\" alt=\"tree\"></p>\n<h6 id=\"二叉树和二叉搜索树\"><a href=\"#二叉树和二叉搜索树\" class=\"headerlink\" title=\"二叉树和二叉搜索树\"></a>二叉树和二叉搜索树</h6><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p>\n<p>二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。<br><img src=\"/2022/10/08/36-data-structure4/binary-search-tree.png\" alt=\"binary-search-tree\"></p>\n<p>通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）<br>键是树相关的术语中对节点的称呼</p>\n<p><strong>中序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/in-order-traverse.png\" alt=\"in-order-traverse\"><br><strong>先序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/pre-order-traverse.png\" alt=\"pre-order-traverse\"><br><strong>后序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/post-order-traverse.png\" alt=\"post-order-traverse\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key; <span class=\"comment\">// &#123;1&#125; 节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.left = <span class=\"literal\">null</span>; <span class=\"comment\">// 左侧子节点引用</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.right = <span class=\"literal\">null</span>; <span class=\"comment\">// 右侧子节点引用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Compare, defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/node&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// 用来比较节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;1&#125; Node 类型的根节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向二叉搜索树中插入一个键</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.left, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        node.right = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.right, key); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历的一种应用就是对树进行排序操作。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.inOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.preOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.postOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索最小值和最大值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">min</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.minNode(<span class=\"built_in\">this</span>.root); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">minNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      current = current.left; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">max</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.maxNode(<span class=\"built_in\">this</span>.root);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">maxNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      current = current.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索一个特定的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">search</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">searchNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.right, key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除一个节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.removeNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.removeNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 键等于 node.key</span></span><br><span class=\"line\">      <span class=\"comment\">// 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        node = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第二种情况: 移除有一个左侧子节点或右侧子节点的节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">        node = node.right; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">        node = node.left; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第三种情况: 具体流程可查看后续文章</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> aux = <span class=\"built_in\">this</span>.minNode(node.right); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">      node.key = aux.key; <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, aux.key); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;21&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>移除有两个子节点的节点</strong><br>要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。<br>(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们<br>改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的<br>最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。<br><img src=\"/2022/10/08/36-data-structure4/remove-left-right.png\" alt=\"remove-left-right\"></p>\n<h6 id=\"自平衡树\"><a href=\"#自平衡树\" class=\"headerlink\" title=\"自平衡树\"></a>自平衡树</h6><p>Adelson-Velskii-Landi 树（AVL 树）<br>AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。</p>\n<p>在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BalanceFactor = &#123;</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_RIGHT</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">BALANCED</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_LEFT</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_LEFT</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 节点的高度和平衡因子</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getNodeHeight</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">this</span>.getNodeHeight(node.left), <span class=\"built_in\">this</span>.getNodeHeight(node.right)) +</span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getBalanceFactor</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> heightDifference =</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.getNodeHeight(node.left) - <span class=\"built_in\">this</span>.getNodeHeight(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (heightDifference) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.BALANCED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.left = tmp.right; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.right = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.right = tmp.left; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.left = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.left = <span class=\"built_in\">this</span>.rotationRR(node.left);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.right = <span class=\"built_in\">this</span>.rotationLL(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  向 AVL 树插入节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 像在 BST 树中一样插入节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Node(key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// 重复的键</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果需要，将树进行平衡操作</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从 AVL 树中移除节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    node = <span class=\"built_in\">super</span>.removeNode(node, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// null，不需要进行平衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检测树是否平衡</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorLeft = <span class=\"built_in\">this</span>.getBalanceFactor(node.left); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node.left); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorRight = <span class=\"built_in\">this</span>.getBalanceFactor(node.right); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node.right); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>平衡操作——AVL 旋转</strong><br>(1)左-左（LL）：向右的单旋转<br>这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的<br><img src=\"/2022/10/08/36-data-structure4/left-left-1.png\" alt=\"left-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-left-2.png\" alt=\"left-left-2\"></p>\n<p>rotationLL 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；<br>节点 X 的左子树保持不变；<br>将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；<br>将节点 X 的右子节点置为节点 Y（行{3}）</p>\n<p>(2)右-右（RR）：向左的单旋转<br>右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的<br><img src=\"/2022/10/08/36-data-structure4/right-right-1.png\" alt=\"right-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-right-2.png\" alt=\"right-right-2\"></p>\n<p>rotationRR 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；<br>节点 X 的右子树保持不变；<br>将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；<br>将节点 X 的左子节点置为节点 Y（行{3}）</p>\n<p>(3)左-右（LR）：向右的双旋转<br>这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/left-right-1.png\" alt=\"left-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-right-2.png\" alt=\"left-right-2\"></p>\n<p>rotationLR 方法<br>将节点 X 置于节点 Y（平衡因子为 2）所在的位置；<br>将节点 Z 的左子节点置为节点 X 的右子节点；<br>将节点 Y 的右子节点置为节点 X 的左子节点；<br>将节点 X 的右子节点置为节点 Y；<br>将节点 X 的左子节点置为节点 Z</p>\n<p>(4)右-左（RL）：向左的双旋转<br>右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/right-left-1.png\" alt=\"right-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-left-2.png\" alt=\"right-left-2\"></p>\n<p>rotationRL 方法<br>将节点 X 置于节点 Y（平衡因子为+2）所在的位置；<br>将节点 Y 的左子节点置为节点 X 的右子节点；<br>将节点 Z 的右子节点置为节点 X 的左子节点；<br>将节点 X 的左子节点置为节点 Y；<br>将节点 X 的右子节点置为节点 Z</p>\n<h6 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h6><p>包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好</p>\n<p>在红黑树中，每个节点都遵循以下规则：<br>(1) 顾名思义，每个节点不是红的就是黑的；<br>(2) 树的根节点是黑的；<br>(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；<br>(4) 如果一个节点是红的，那么它的两个子节点都是黑的；<br>(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；<br>(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(key);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = Colors.RED; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.parent = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isRed</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.color === Colors.RED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key: T</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> RedBlackNode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newNode = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.fixTreeProperties(newNode); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">        node.left.parent = node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.right = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">      node.right.parent = node; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node.right; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">fixTreeProperties</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      node &amp;&amp;</span><br><span class=\"line\">      node.parent &amp;&amp;</span><br><span class=\"line\">      node.parent.color.isRed() &amp;&amp; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      node.color !== Colors.BLACK</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> parent = node.parent; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> grandParent = parent.parent; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 情形 A：父节点是左侧子节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1A：叔节点也是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2A：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationRR(parent); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">            node = parent; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">            parent = node.parent; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3A：节点是左侧子节点——右旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationLL(grandParent); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">          node = parent; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情形 B：父节点是右侧子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1B：叔节点是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2B：节点是左侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.left) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationLL(parent); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">            node = parent;</span><br><span class=\"line\">            parent = node.parent;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3B：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationRR(grandParent); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          node = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left;</span><br><span class=\"line\">    node.left = tmp.right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class=\"line\">      tmp.right.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.right = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right;</span><br><span class=\"line\">    node.right = tmp.left;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class=\"line\">      tmp.left.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.left = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。<br>左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。<br><img src=\"/2022/10/08/36-data-structure4/red-black-2a.png\" alt=\"red-black-2a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3a.png\" alt=\"red-black-3a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-2b.png\" alt=\"red-black-2b\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3b.png\" alt=\"red-black-3b\"></p>\n"},{"title":"数据结构与算法阅读笔记(6)","date":"2022-10-13T06:15:28.000Z","_content":"\n#### 排序和搜索算法\n\n###### 排序算法\n\n**冒泡排序**\n冒泡排序(_复杂度是 O(n2)_)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。\n\n```javascript\nfunction defaultCompare(a, b) {\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  for (let i = 0; i < length; i++) {\n    // {2}\n    for (let j = 0; j < length - 1; j++) {\n      // {3}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        // {4}\n        swap(array, j, j + 1); // {5}\n      }\n    }\n  }\n  return array;\n}\n\nfunction swap(array, a, b) {\n  /* const temp = array[a]; \n array[a] = array[b]; \n array[b] = temp; */ // 经典方式\n  [array[a], array[b]] = [array[b], array[a]]; // ES2015 的方式\n}\n```\n\n![sort-1](sort-1.png)\n_改进后的冒泡排序_\n\n```javascript\nfunction modifiedBubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1 - i; j++) {\n      // {1}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n```\n\n![sort-2](sort-2.png)\n\n**选择排序**\n选择排序算法(_复杂度为 O(n2)_)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.\n\n```javascript\nfunction selectionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let indexMin;\n  for (let i = 0; i < length - 1; i++) {\n    // {2}\n    indexMin = i; // {3}\n    for (let j = i; j < length; j++) {\n      // {4}\n      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {\n        // {5}\n        indexMin = j; // {6}\n      }\n    }\n    if (i !== indexMin) {\n      // {7}\n      swap(array, i, indexMin);\n    }\n  }\n  return array;\n}\n```\n\n![sort-3](sort-3.png)\n\n**插入排序**\n插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.\n\n```javascript\nfunction insertionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let temp;\n  for (let i = 1; i < length; i++) {\n    // {2}\n    let j = i; // {3}\n    temp = array[i]; // {4}\n    while (j > 0 && compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) {\n      // {5}\n      array[j] = array[j - 1]; // {6}\n      j--;\n    }\n    array[j] = temp; // {7}\n  }\n  return array;\n}\n```\n\n![sort-4](sort-4.png)\n_排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。_\n\n**归并排序**\n归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。\n\n_JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。_\n\n归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。\n\n由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。\n\n```javascript\nfunction mergeSort(array, compareFn = defaultCompare) {\n  if (array.length > 1) {\n    // {1}\n    const { length } = array;\n    const middle = Math.floor(length / 2); // {2}\n    const left = mergeSort(array.slice(0, middle), compareFn); // {3}\n    const right = mergeSort(array.slice(middle, length), compareFn); // {4}\n    array = merge(left, right, compareFn); // {5}\n  }\n  return array;\n}\n\nfunction merge(left, right, compareFn) {\n  let i = 0; // {6}\n  let j = 0;\n  const result = [];\n  while (i < left.length && j < right.length) {\n    // {7}\n    result.push(\n      compareFn(left[i], right[j]) === Compare.LESS_THAN\n        ? left[i++]\n        : right[j++]\n    ); // {8}\n  }\n  return result.concat(i < left.length ? left.slice(i) : right.slice(j)); // {9}\n}\n```\n\n![sort-5](sort-5.png)\n\n**快速排序**\n快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）\n\n(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。\n(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。\n(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。\n\n```javascript\nfunction quickSort(array, compareFn = defaultCompare) {\n  return quick(array, 0, array.length - 1, compareFn);\n}\n\nfunction quick(array, left, right, compareFn) {\n  let index; // {1}\n  if (array.length > 1) {\n    // {2}\n    index = partition(array, left, right, compareFn); // {3}\n    if (left < index - 1) {\n      // {4}\n      quick(array, left, index - 1, compareFn); // {5}\n    }\n    if (index < right) {\n      // {6}\n      quick(array, index, right, compareFn); // {7}\n    }\n  }\n  return array;\n}\n\nfunction partition(array, left, right, compareFn) {\n  // 选择中间值作为主元\n  const pivot = array[Math.floor((right + left) / 2)]; // {8}\n  let i = left; // {9}\n  let j = right; // {10}\n  while (i <= j) {\n    // {11}\n    while (compareFn(array[i], pivot) === Compare.LESS_THAN) {\n      // {12}\n      i++;\n    }\n    while (compareFn(array[j], pivot) === Compare.BIGGER_THAN) {\n      // {13}\n      j--;\n    }\n    if (i <= j) {\n      // {14}\n      swap(array, i, j); // {15}\n      i++;\n      j--;\n    }\n  }\n  return i; // {16}\n}\n```\n\n划分操作的第一次执行\n![sort-6](sort-6.png)\n对有较小值的子数组执行的划分操作\n![sort-7](sort-7.png)\n针对有较大值的子数组\n![sort-8](sort-8.png)\n![sort-9](sort-9.png)\n![sort-10](sort-10.png)\n\n**计数排序**\n计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组\n\n它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。\n\n```javascript\nfunction countingSort(array) {\n  if (array.length < 2) {\n    // {1}\n    return array;\n  }\n  const maxValue = findMaxValue(array); // {2}\n  const counts = new Array(maxValue + 1); // {3}\n  array.forEach((element) => {\n    if (!counts[element]) {\n      // {4}\n      counts[element] = 0;\n    }\n    counts[element]++; // {5}\n  });\n  let sortedIndex = 0;\n  counts.forEach((count, i) => {\n    while (count > 0) {\n      // {6}\n      array[sortedIndex++] = i; // {7}\n      count--; // {8}\n    }\n  });\n  return array;\n}\n\nfunction findMaxValue(array) {\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}\n```\n\n**桶排序**\n桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。\n\n_默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。_\n\n```javascript\nfunction bucketSort(array, bucketSize = 5) {\n  // {1}\n  if (array.length < 2) {\n    return array;\n  }\n  // 创建桶并将元素分布到不同的桶中\n  const buckets = createBuckets(array, bucketSize); // {2}\n  // 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组\n  return sortBuckets(buckets); // {3}\n}\n\nfunction createBuckets(array, bucketSize) {\n  let minValue = array[0];\n  let maxValue = array[0];\n  for (let i = 1; i < array.length; i++) {\n    // {4}\n    if (array[i] < minValue) {\n      minValue = array[i];\n    } else if (array[i] > maxValue) {\n      maxValue = array[i];\n    }\n  }\n  // 计算每个桶中需要分布的元素个数\n  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // {5}\n  const buckets = [];\n  for (let i = 0; i < bucketCount; i++) {\n    // 初始化每个桶\n    buckets[i] = [];\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {7}\n    const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); // {8}\n    buckets[bucketIndex].push(array[i]);\n  }\n  return buckets;\n}\n\nfunction sortBuckets(buckets) {\n  const sortedArray = []; // {9}\n  for (let i = 0; i < buckets.length; i++) {\n    // {10}\n    if (buckets[i] != null) {\n      insertionSort(buckets[i]); // {11}\n      sortedArray.push(...buckets[i]); // {12}\n    }\n  }\n  return sortedArray;\n}\n```\n\n![sort-11](sort-11.png)\n\n**基数排序**\n基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。\n\n```javascript\nfunction radixSort(array, radixBase = 10) {\n  if (array.length < 2) {\n    return array;\n  }\n  const minValue = findMinValue(array);\n  const maxValue = findMaxValue(array);\n  let significantDigit = 1; // {1}\n  while ((maxValue - minValue) / significantDigit >= 1) {\n    // {2}\n    array = countingSortForRadix(array, radixBase, significantDigit, minValue); // {3}\n    significantDigit *= radixBase; // {4}\n  }\n  return array;\n}\n\nfunction countingSortForRadix(array, radixBase, significantDigit, minValue) {\n  let bucketsIndex;\n  const buckets = [];\n  const aux = [];\n  for (let i = 0; i < radixBase; i++) {\n    // {5}\n    buckets[i] = 0;\n  }\n  for (let i = 0; i < array.length; i++) {\n    // 基于数组中数的有效位（行{7}）进行计数排序\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {7}\n    buckets[bucketsIndex]++; // {8}\n  }\n  for (let i = 1; i < radixBase; i++) {\n    // 计算累积结果来得到正确的计数值\n    buckets[i] += buckets[i - 1];\n  }\n  for (let i = array.length - 1; i >= 0; i--) {\n    // {10}\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {11}\n    aux[--buckets[bucketsIndex]] = array[i]; // {12}\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {13}\n    array[i] = aux[i];\n  }\n  return array;\n}\n```\n\n![sort-12](sort-12.png)\n\n###### 搜索算法\n\n**顺序搜索**\n顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法\n\n```javascript\nconst DOES_NOT_EXIST = -1;\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    // {1}\n    if (equalsFn(value, array[i])) {\n      // {2}\n      return i; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\n```\n\n![search-1](search-1.png)\n\n**二分搜索**\n个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。\n(1) 选择数组的中间值。\n(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array); // {1}\n  let low = 0; // {2}\n  let high = sortedArray.length - 1; // {3}\n  while (lesserOrEquals(low, high, compareFn)) {\n    // {4}\n    const mid = Math.floor((low + high) / 2); // {5}\n    const element = sortedArray[mid]; // {6}\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {7}\n      low = mid + 1; // {8}\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {9}\n      high = mid - 1; // {10}\n    } else {\n      return mid; // {11}\n    }\n  }\n  return DOES_NOT_EXIST; // {12}\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-2](search-2.png)\n\n**内插搜索**\n内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。\n\n算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤\n\n(1) 使用 position 公式选中一个值；\n(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction interpolationSearch(\n  array,\n  value,\n  compareFn = defaultCompare,\n  equalsFn = defaultEquals,\n  diffFn = defaultDiff\n) {\n  const { length } = array;\n  let low = 0;\n  let high = length - 1;\n  let position = -1;\n  let delta = -1;\n  while (\n    low <= high &&\n    biggerOrEquals(value, array[low], compareFn) &&\n    lesserOrEquals(value, array[high], compareFn)\n  ) {\n    /** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */\n    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);\n    position = low + Math.floor((high - low) * delta); // {2}\n    if (equalsFn(array[position], value)) {\n      // {3}\n      return position;\n    }\n    if (compareFn(array[position], value) === Compare.LESS_THAN) {\n      // {4}\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n  }\n  return DOES_NOT_EXIST;\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\nfunction biggerOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-3](search-3.png)\n\n###### 随机算法\n\n**Fisher-Yates 随机**\n它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）\n\n```javascript\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n    swap(array, i, randomIndex);\n  }\n  return array;\n}\n```\n\n![search-4](search-4.png)\n","source":"_posts/38-data-structure6.md","raw":"---\ntitle: 数据结构与算法阅读笔记(6)\ndate: 2022-10-13 14:15:28\ntags:\n---\n\n#### 排序和搜索算法\n\n###### 排序算法\n\n**冒泡排序**\n冒泡排序(_复杂度是 O(n2)_)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。\n\n```javascript\nfunction defaultCompare(a, b) {\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  for (let i = 0; i < length; i++) {\n    // {2}\n    for (let j = 0; j < length - 1; j++) {\n      // {3}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        // {4}\n        swap(array, j, j + 1); // {5}\n      }\n    }\n  }\n  return array;\n}\n\nfunction swap(array, a, b) {\n  /* const temp = array[a]; \n array[a] = array[b]; \n array[b] = temp; */ // 经典方式\n  [array[a], array[b]] = [array[b], array[a]]; // ES2015 的方式\n}\n```\n\n![sort-1](sort-1.png)\n_改进后的冒泡排序_\n\n```javascript\nfunction modifiedBubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1 - i; j++) {\n      // {1}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n```\n\n![sort-2](sort-2.png)\n\n**选择排序**\n选择排序算法(_复杂度为 O(n2)_)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.\n\n```javascript\nfunction selectionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let indexMin;\n  for (let i = 0; i < length - 1; i++) {\n    // {2}\n    indexMin = i; // {3}\n    for (let j = i; j < length; j++) {\n      // {4}\n      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {\n        // {5}\n        indexMin = j; // {6}\n      }\n    }\n    if (i !== indexMin) {\n      // {7}\n      swap(array, i, indexMin);\n    }\n  }\n  return array;\n}\n```\n\n![sort-3](sort-3.png)\n\n**插入排序**\n插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.\n\n```javascript\nfunction insertionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let temp;\n  for (let i = 1; i < length; i++) {\n    // {2}\n    let j = i; // {3}\n    temp = array[i]; // {4}\n    while (j > 0 && compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) {\n      // {5}\n      array[j] = array[j - 1]; // {6}\n      j--;\n    }\n    array[j] = temp; // {7}\n  }\n  return array;\n}\n```\n\n![sort-4](sort-4.png)\n_排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。_\n\n**归并排序**\n归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。\n\n_JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。_\n\n归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。\n\n由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。\n\n```javascript\nfunction mergeSort(array, compareFn = defaultCompare) {\n  if (array.length > 1) {\n    // {1}\n    const { length } = array;\n    const middle = Math.floor(length / 2); // {2}\n    const left = mergeSort(array.slice(0, middle), compareFn); // {3}\n    const right = mergeSort(array.slice(middle, length), compareFn); // {4}\n    array = merge(left, right, compareFn); // {5}\n  }\n  return array;\n}\n\nfunction merge(left, right, compareFn) {\n  let i = 0; // {6}\n  let j = 0;\n  const result = [];\n  while (i < left.length && j < right.length) {\n    // {7}\n    result.push(\n      compareFn(left[i], right[j]) === Compare.LESS_THAN\n        ? left[i++]\n        : right[j++]\n    ); // {8}\n  }\n  return result.concat(i < left.length ? left.slice(i) : right.slice(j)); // {9}\n}\n```\n\n![sort-5](sort-5.png)\n\n**快速排序**\n快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）\n\n(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。\n(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。\n(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。\n\n```javascript\nfunction quickSort(array, compareFn = defaultCompare) {\n  return quick(array, 0, array.length - 1, compareFn);\n}\n\nfunction quick(array, left, right, compareFn) {\n  let index; // {1}\n  if (array.length > 1) {\n    // {2}\n    index = partition(array, left, right, compareFn); // {3}\n    if (left < index - 1) {\n      // {4}\n      quick(array, left, index - 1, compareFn); // {5}\n    }\n    if (index < right) {\n      // {6}\n      quick(array, index, right, compareFn); // {7}\n    }\n  }\n  return array;\n}\n\nfunction partition(array, left, right, compareFn) {\n  // 选择中间值作为主元\n  const pivot = array[Math.floor((right + left) / 2)]; // {8}\n  let i = left; // {9}\n  let j = right; // {10}\n  while (i <= j) {\n    // {11}\n    while (compareFn(array[i], pivot) === Compare.LESS_THAN) {\n      // {12}\n      i++;\n    }\n    while (compareFn(array[j], pivot) === Compare.BIGGER_THAN) {\n      // {13}\n      j--;\n    }\n    if (i <= j) {\n      // {14}\n      swap(array, i, j); // {15}\n      i++;\n      j--;\n    }\n  }\n  return i; // {16}\n}\n```\n\n划分操作的第一次执行\n![sort-6](sort-6.png)\n对有较小值的子数组执行的划分操作\n![sort-7](sort-7.png)\n针对有较大值的子数组\n![sort-8](sort-8.png)\n![sort-9](sort-9.png)\n![sort-10](sort-10.png)\n\n**计数排序**\n计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组\n\n它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。\n\n```javascript\nfunction countingSort(array) {\n  if (array.length < 2) {\n    // {1}\n    return array;\n  }\n  const maxValue = findMaxValue(array); // {2}\n  const counts = new Array(maxValue + 1); // {3}\n  array.forEach((element) => {\n    if (!counts[element]) {\n      // {4}\n      counts[element] = 0;\n    }\n    counts[element]++; // {5}\n  });\n  let sortedIndex = 0;\n  counts.forEach((count, i) => {\n    while (count > 0) {\n      // {6}\n      array[sortedIndex++] = i; // {7}\n      count--; // {8}\n    }\n  });\n  return array;\n}\n\nfunction findMaxValue(array) {\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}\n```\n\n**桶排序**\n桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。\n\n_默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。_\n\n```javascript\nfunction bucketSort(array, bucketSize = 5) {\n  // {1}\n  if (array.length < 2) {\n    return array;\n  }\n  // 创建桶并将元素分布到不同的桶中\n  const buckets = createBuckets(array, bucketSize); // {2}\n  // 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组\n  return sortBuckets(buckets); // {3}\n}\n\nfunction createBuckets(array, bucketSize) {\n  let minValue = array[0];\n  let maxValue = array[0];\n  for (let i = 1; i < array.length; i++) {\n    // {4}\n    if (array[i] < minValue) {\n      minValue = array[i];\n    } else if (array[i] > maxValue) {\n      maxValue = array[i];\n    }\n  }\n  // 计算每个桶中需要分布的元素个数\n  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // {5}\n  const buckets = [];\n  for (let i = 0; i < bucketCount; i++) {\n    // 初始化每个桶\n    buckets[i] = [];\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {7}\n    const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); // {8}\n    buckets[bucketIndex].push(array[i]);\n  }\n  return buckets;\n}\n\nfunction sortBuckets(buckets) {\n  const sortedArray = []; // {9}\n  for (let i = 0; i < buckets.length; i++) {\n    // {10}\n    if (buckets[i] != null) {\n      insertionSort(buckets[i]); // {11}\n      sortedArray.push(...buckets[i]); // {12}\n    }\n  }\n  return sortedArray;\n}\n```\n\n![sort-11](sort-11.png)\n\n**基数排序**\n基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。\n\n```javascript\nfunction radixSort(array, radixBase = 10) {\n  if (array.length < 2) {\n    return array;\n  }\n  const minValue = findMinValue(array);\n  const maxValue = findMaxValue(array);\n  let significantDigit = 1; // {1}\n  while ((maxValue - minValue) / significantDigit >= 1) {\n    // {2}\n    array = countingSortForRadix(array, radixBase, significantDigit, minValue); // {3}\n    significantDigit *= radixBase; // {4}\n  }\n  return array;\n}\n\nfunction countingSortForRadix(array, radixBase, significantDigit, minValue) {\n  let bucketsIndex;\n  const buckets = [];\n  const aux = [];\n  for (let i = 0; i < radixBase; i++) {\n    // {5}\n    buckets[i] = 0;\n  }\n  for (let i = 0; i < array.length; i++) {\n    // 基于数组中数的有效位（行{7}）进行计数排序\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {7}\n    buckets[bucketsIndex]++; // {8}\n  }\n  for (let i = 1; i < radixBase; i++) {\n    // 计算累积结果来得到正确的计数值\n    buckets[i] += buckets[i - 1];\n  }\n  for (let i = array.length - 1; i >= 0; i--) {\n    // {10}\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {11}\n    aux[--buckets[bucketsIndex]] = array[i]; // {12}\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {13}\n    array[i] = aux[i];\n  }\n  return array;\n}\n```\n\n![sort-12](sort-12.png)\n\n###### 搜索算法\n\n**顺序搜索**\n顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法\n\n```javascript\nconst DOES_NOT_EXIST = -1;\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    // {1}\n    if (equalsFn(value, array[i])) {\n      // {2}\n      return i; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\n```\n\n![search-1](search-1.png)\n\n**二分搜索**\n个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。\n(1) 选择数组的中间值。\n(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array); // {1}\n  let low = 0; // {2}\n  let high = sortedArray.length - 1; // {3}\n  while (lesserOrEquals(low, high, compareFn)) {\n    // {4}\n    const mid = Math.floor((low + high) / 2); // {5}\n    const element = sortedArray[mid]; // {6}\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {7}\n      low = mid + 1; // {8}\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {9}\n      high = mid - 1; // {10}\n    } else {\n      return mid; // {11}\n    }\n  }\n  return DOES_NOT_EXIST; // {12}\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-2](search-2.png)\n\n**内插搜索**\n内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。\n\n算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤\n\n(1) 使用 position 公式选中一个值；\n(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction interpolationSearch(\n  array,\n  value,\n  compareFn = defaultCompare,\n  equalsFn = defaultEquals,\n  diffFn = defaultDiff\n) {\n  const { length } = array;\n  let low = 0;\n  let high = length - 1;\n  let position = -1;\n  let delta = -1;\n  while (\n    low <= high &&\n    biggerOrEquals(value, array[low], compareFn) &&\n    lesserOrEquals(value, array[high], compareFn)\n  ) {\n    /** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */\n    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);\n    position = low + Math.floor((high - low) * delta); // {2}\n    if (equalsFn(array[position], value)) {\n      // {3}\n      return position;\n    }\n    if (compareFn(array[position], value) === Compare.LESS_THAN) {\n      // {4}\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n  }\n  return DOES_NOT_EXIST;\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\nfunction biggerOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-3](search-3.png)\n\n###### 随机算法\n\n**Fisher-Yates 随机**\n它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）\n\n```javascript\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n    swap(array, i, randomIndex);\n  }\n  return array;\n}\n```\n\n![search-4](search-4.png)\n","slug":"38-data-structure6","published":1,"updated":"2022-10-13T08:12:54.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q2000zk4tt41ox8w40","content":"<h4 id=\"排序和搜索算法\"><a href=\"#排序和搜索算法\" class=\"headerlink\" title=\"排序和搜索算法\"></a>排序和搜索算法</h4><h6 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h6><p><strong>冒泡排序</strong><br>冒泡排序(<em>复杂度是 O(n2)</em>)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* const temp = array[a]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[a] = array[b]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[b] = temp; */</span> <span class=\"comment\">// 经典方式</span></span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]]; <span class=\"comment\">// ES2015 的方式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-1.png\" alt=\"sort-1\"><br><em>改进后的冒泡排序</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">modifiedBubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-2.png\" alt=\"sort-2\"></p>\n<p><strong>选择排序</strong><br>选择排序算法(<em>复杂度为 O(n2)</em>)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> indexMin;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    indexMin = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        indexMin = j; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== indexMin) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(array, i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-3.png\" alt=\"sort-3\"></p>\n<p><strong>插入排序</strong><br>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    temp = array[i]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; compareFn(array[j - <span class=\"number\">1</span>], temp) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[j] = array[j - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[j] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-4.png\" alt=\"sort-4\"><br><em>排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。</em></p>\n<p><strong>归并排序</strong><br>归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。</p>\n<p><em>JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。</em></p>\n<p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>\n<p>由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> middle = <span class=\"built_in\">Math</span>.floor(length / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = mergeSort(array.slice(<span class=\"number\">0</span>, middle), compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = mergeSort(array.slice(middle, length), compareFn); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    array = merge(left, right, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    result.push(</span><br><span class=\"line\">      compareFn(left[i], right[j]) === Compare.LESS_THAN</span><br><span class=\"line\">        ? left[i++]</span><br><span class=\"line\">        : right[j++]</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(i &lt; left.length ? left.slice(i) : right.slice(j)); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-5.png\" alt=\"sort-5\"></p>\n<p><strong>快速排序</strong><br>快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）</p>\n<p>(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。<br>(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。<br>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quick</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    index = partition(array, left, right, compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; index - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      quick(array, left, index - <span class=\"number\">1</span>, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      quick(array, index, right, compareFn); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 选择中间值作为主元</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> pivot = array[<span class=\"built_in\">Math</span>.floor((right + left) / <span class=\"number\">2</span>)]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = right; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      swap(array, i, j); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>划分操作的第一次执行<br><img src=\"/2022/10/13/38-data-structure6/sort-6.png\" alt=\"sort-6\"><br>对有较小值的子数组执行的划分操作<br><img src=\"/2022/10/13/38-data-structure6/sort-7.png\" alt=\"sort-7\"><br>针对有较大值的子数组<br><img src=\"/2022/10/13/38-data-structure6/sort-8.png\" alt=\"sort-8\"><br><img src=\"/2022/10/13/38-data-structure6/sort-9.png\" alt=\"sort-9\"><br><img src=\"/2022/10/13/38-data-structure6/sort-10.png\" alt=\"sort-10\"></p>\n<p><strong>计数排序</strong><br>计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组</p>\n<p>它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counts = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxValue + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  array.forEach(<span class=\"function\">(<span class=\"params\">element</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!counts[element]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      counts[element] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    counts[element]++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  counts.forEach(<span class=\"function\">(<span class=\"params\">count, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[sortedIndex++] = i; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      count--; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxValue</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &gt; max) &#123;</span><br><span class=\"line\">      max = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>桶排序</strong><br>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。</p>\n<p><em>默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, bucketSize = <span class=\"number\">5</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建桶并将元素分布到不同的桶中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = createBuckets(array, bucketSize); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortBuckets(buckets); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createBuckets</span>(<span class=\"params\">array, bucketSize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; minValue) &#123;</span><br><span class=\"line\">      minValue = array[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[i] &gt; maxValue) &#123;</span><br><span class=\"line\">      maxValue = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 计算每个桶中需要分布的元素个数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> bucketCount = <span class=\"built_in\">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化每个桶</span></span><br><span class=\"line\">    buckets[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> bucketIndex = <span class=\"built_in\">Math</span>.floor((array[i] - minValue) / bucketSize); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    buckets[bucketIndex].push(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buckets;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortBuckets</span>(<span class=\"params\">buckets</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = []; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buckets[i] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      insertionSort(buckets[i]); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      sortedArray.push(...buckets[i]); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-11.png\" alt=\"sort-11\"></p>\n<p><strong>基数排序</strong><br>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">array, radixBase = <span class=\"number\">10</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> minValue = findMinValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> significantDigit = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((maxValue - minValue) / significantDigit &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    array = countingSortForRadix(array, radixBase, significantDigit, minValue); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    significantDigit *= radixBase; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSortForRadix</span>(<span class=\"params\">array, radixBase, significantDigit, minValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bucketsIndex;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> aux = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    buckets[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于数组中数的有效位（行&#123;7&#125;）进行计数排序</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    buckets[bucketsIndex]++; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算累积结果来得到正确的计数值</span></span><br><span class=\"line\">    buckets[i] += buckets[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    aux[--buckets[bucketsIndex]] = array[i]; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    array[i] = aux[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-12.png\" alt=\"sort-12\"></p>\n<h6 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h6><p><strong>顺序搜索</strong><br>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DOES_NOT_EXIST = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-1.png\" alt=\"search-1\"></p>\n<p><strong>二分搜索</strong><br>个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。<br>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = sortedArray.length - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lesserOrEquals(low, high, compareFn)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = sortedArray[mid]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      low = mid + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      high = mid - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-2.png\" alt=\"search-2\"></p>\n<p><strong>内插搜索</strong><br>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。</p>\n<p>算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤</p>\n<p>(1) 使用 position 公式选中一个值；<br>(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interpolationSearch</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  equalsFn = defaultEquals,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  diffFn = defaultDiff</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> position = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> delta = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    low &lt;= high &amp;&amp;</span><br><span class=\"line\">    biggerOrEquals(value, array[low], compareFn) &amp;&amp;</span><br><span class=\"line\">    lesserOrEquals(value, array[high], compareFn)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */</span></span><br><span class=\"line\">    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);</span><br><span class=\"line\">    position = low + <span class=\"built_in\">Math</span>.floor((high - low) * delta); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(array[position], value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(array[position], value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      low = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      high = position - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">biggerOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-3.png\" alt=\"search-3\"></p>\n<h6 id=\"随机算法\"><a href=\"#随机算法\" class=\"headerlink\" title=\"随机算法\"></a>随机算法</h6><p><strong>Fisher-Yates 随机</strong><br>它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> randomIndex = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">    swap(array, i, randomIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-4.png\" alt=\"search-4\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"排序和搜索算法\"><a href=\"#排序和搜索算法\" class=\"headerlink\" title=\"排序和搜索算法\"></a>排序和搜索算法</h4><h6 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h6><p><strong>冒泡排序</strong><br>冒泡排序(<em>复杂度是 O(n2)</em>)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* const temp = array[a]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[a] = array[b]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[b] = temp; */</span> <span class=\"comment\">// 经典方式</span></span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]]; <span class=\"comment\">// ES2015 的方式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-1.png\" alt=\"sort-1\"><br><em>改进后的冒泡排序</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">modifiedBubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-2.png\" alt=\"sort-2\"></p>\n<p><strong>选择排序</strong><br>选择排序算法(<em>复杂度为 O(n2)</em>)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> indexMin;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    indexMin = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        indexMin = j; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== indexMin) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(array, i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-3.png\" alt=\"sort-3\"></p>\n<p><strong>插入排序</strong><br>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    temp = array[i]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; compareFn(array[j - <span class=\"number\">1</span>], temp) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[j] = array[j - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[j] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-4.png\" alt=\"sort-4\"><br><em>排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。</em></p>\n<p><strong>归并排序</strong><br>归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。</p>\n<p><em>JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。</em></p>\n<p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>\n<p>由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> middle = <span class=\"built_in\">Math</span>.floor(length / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = mergeSort(array.slice(<span class=\"number\">0</span>, middle), compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = mergeSort(array.slice(middle, length), compareFn); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    array = merge(left, right, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    result.push(</span><br><span class=\"line\">      compareFn(left[i], right[j]) === Compare.LESS_THAN</span><br><span class=\"line\">        ? left[i++]</span><br><span class=\"line\">        : right[j++]</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(i &lt; left.length ? left.slice(i) : right.slice(j)); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-5.png\" alt=\"sort-5\"></p>\n<p><strong>快速排序</strong><br>快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）</p>\n<p>(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。<br>(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。<br>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quick</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    index = partition(array, left, right, compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; index - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      quick(array, left, index - <span class=\"number\">1</span>, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      quick(array, index, right, compareFn); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 选择中间值作为主元</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> pivot = array[<span class=\"built_in\">Math</span>.floor((right + left) / <span class=\"number\">2</span>)]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = right; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      swap(array, i, j); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>划分操作的第一次执行<br><img src=\"/2022/10/13/38-data-structure6/sort-6.png\" alt=\"sort-6\"><br>对有较小值的子数组执行的划分操作<br><img src=\"/2022/10/13/38-data-structure6/sort-7.png\" alt=\"sort-7\"><br>针对有较大值的子数组<br><img src=\"/2022/10/13/38-data-structure6/sort-8.png\" alt=\"sort-8\"><br><img src=\"/2022/10/13/38-data-structure6/sort-9.png\" alt=\"sort-9\"><br><img src=\"/2022/10/13/38-data-structure6/sort-10.png\" alt=\"sort-10\"></p>\n<p><strong>计数排序</strong><br>计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组</p>\n<p>它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counts = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxValue + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  array.forEach(<span class=\"function\">(<span class=\"params\">element</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!counts[element]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      counts[element] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    counts[element]++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  counts.forEach(<span class=\"function\">(<span class=\"params\">count, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[sortedIndex++] = i; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      count--; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxValue</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &gt; max) &#123;</span><br><span class=\"line\">      max = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>桶排序</strong><br>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。</p>\n<p><em>默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, bucketSize = <span class=\"number\">5</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建桶并将元素分布到不同的桶中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = createBuckets(array, bucketSize); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortBuckets(buckets); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createBuckets</span>(<span class=\"params\">array, bucketSize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; minValue) &#123;</span><br><span class=\"line\">      minValue = array[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[i] &gt; maxValue) &#123;</span><br><span class=\"line\">      maxValue = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 计算每个桶中需要分布的元素个数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> bucketCount = <span class=\"built_in\">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化每个桶</span></span><br><span class=\"line\">    buckets[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> bucketIndex = <span class=\"built_in\">Math</span>.floor((array[i] - minValue) / bucketSize); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    buckets[bucketIndex].push(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buckets;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortBuckets</span>(<span class=\"params\">buckets</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = []; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buckets[i] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      insertionSort(buckets[i]); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      sortedArray.push(...buckets[i]); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-11.png\" alt=\"sort-11\"></p>\n<p><strong>基数排序</strong><br>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">array, radixBase = <span class=\"number\">10</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> minValue = findMinValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> significantDigit = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((maxValue - minValue) / significantDigit &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    array = countingSortForRadix(array, radixBase, significantDigit, minValue); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    significantDigit *= radixBase; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSortForRadix</span>(<span class=\"params\">array, radixBase, significantDigit, minValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bucketsIndex;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> aux = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    buckets[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于数组中数的有效位（行&#123;7&#125;）进行计数排序</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    buckets[bucketsIndex]++; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算累积结果来得到正确的计数值</span></span><br><span class=\"line\">    buckets[i] += buckets[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    aux[--buckets[bucketsIndex]] = array[i]; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    array[i] = aux[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-12.png\" alt=\"sort-12\"></p>\n<h6 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h6><p><strong>顺序搜索</strong><br>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DOES_NOT_EXIST = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-1.png\" alt=\"search-1\"></p>\n<p><strong>二分搜索</strong><br>个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。<br>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = sortedArray.length - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lesserOrEquals(low, high, compareFn)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = sortedArray[mid]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      low = mid + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      high = mid - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-2.png\" alt=\"search-2\"></p>\n<p><strong>内插搜索</strong><br>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。</p>\n<p>算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤</p>\n<p>(1) 使用 position 公式选中一个值；<br>(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interpolationSearch</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  equalsFn = defaultEquals,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  diffFn = defaultDiff</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> position = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> delta = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    low &lt;= high &amp;&amp;</span><br><span class=\"line\">    biggerOrEquals(value, array[low], compareFn) &amp;&amp;</span><br><span class=\"line\">    lesserOrEquals(value, array[high], compareFn)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */</span></span><br><span class=\"line\">    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);</span><br><span class=\"line\">    position = low + <span class=\"built_in\">Math</span>.floor((high - low) * delta); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(array[position], value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(array[position], value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      low = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      high = position - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">biggerOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-3.png\" alt=\"search-3\"></p>\n<h6 id=\"随机算法\"><a href=\"#随机算法\" class=\"headerlink\" title=\"随机算法\"></a>随机算法</h6><p><strong>Fisher-Yates 随机</strong><br>它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> randomIndex = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">    swap(array, i, randomIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-4.png\" alt=\"search-4\"></p>\n"},{"title":"数据结构与算法阅读笔记(5)","date":"2022-10-08T08:33:37.000Z","_content":"\n#### 二叉堆和堆排序\n\n###### 二叉堆数据结构\n\n(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。\n(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性\n![heat](heat.png)\n\n二叉树有两种表示方式\n第一种是使用一个动态的表示方式，也就是指针（用节点表示）\n第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。\n![min-heat](min-heat.png)\n\n访问使用普通数组的二叉树节点:\n它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；\n它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；\n它的父节点位置是 index / 2（如果位置可用）\n\n```javascript\nimport { defaultCompare } from '../util';\n\nexport class MinHeap {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // {1}\n    this.heap = []; // {2}\n  }\n  getLeftIndex(index) {\n    return 2 * index + 1;\n  }\n  getRightIndex(index) {\n    return 2 * index + 2;\n  }\n  getParentIndex(index) {\n    if (index === 0) {\n      return undefined;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n  insert(value) {\n    if (value != null) {\n      this.heap.push(value); // {1}\n      this.siftUp(this.heap.length - 1); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 上移操作\n  siftUp(index) {\n    let parent = this.getParentIndex(index); // {1}\n    while (\n      index > 0 &&\n      this.compareFn(this.heap[parent], this.heap[index]) > Compare.BIGGER_THAN\n    ) {\n      // {2}\n      swap(this.heap, parent, index); // {3}\n      index = parent;\n      parent = this.getParentIndex(index); // {4}\n    }\n    function swap(array, a, b) {\n      const temp = array[a]; // {5}\n      array[a] = array[b]; // {6}\n      array[b] = temp; // {7}\n    }\n  }\n  size() {\n    return this.heap.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  findMinimum() {\n    return this.isEmpty() ? undefined : this.heap[0]; // {1}\n  }\n  extract() {\n    if (this.isEmpty()) {\n      return undefined; // {1}\n    }\n    if (this.size() === 1) {\n      return this.heap.shift(); // {2}\n    }\n    const removedValue = this.heap.shift(); // {3}\n    this.siftDown(0); // {4}\n    return removedValue; // {5}\n  }\n  siftDown(index) {\n    let element = index;\n    const left = this.getLeftIndex(index); // {1}\n    const right = this.getRightIndex(index); // {2}\n    const size = this.size();\n    if (\n      left < size &&\n      this.compareFn(this.heap[element], this.heap[left]) > Compare.BIGGER_THAN\n    ) {\n      // {3}\n      element = left; // {4}\n    }\n    if (\n      right < size &&\n      this.compareFn(this.heap[element], this.heap[right]) > Compare.BIGGER_THAN\n    ) {\n      // {5}\n      element = right; // {6}\n    }\n    if (index !== element) {\n      // {7}\n      swap(this.heap, index, element); // {8}\n      this.siftDown(element); // {9}\n    }\n  }\n}\n```\n\n![min-heat-pic](min-heat-pic.png)\n\n**创建最大堆类**\nMaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有>（大于）的比较换成<（小于）的比较。\n\n```javascript\nfunction reverseCompare(compareFn) {\n  return (a, b) => compareFn(b, a);\n}\n\nexport class MaxHeap extends MinHeap {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = reverseCompare(compareFn); // {1}\n  }\n}\n```\n\n**堆排序算法**\n(1) 用数组创建一个最大堆用作源数据。\n(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。\n(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1\n\n```javascript\nfunction heapSort(array, compareFn = defaultCompare) {\n  let heapSize = array.length;\n  buildMaxHeap(array, compareFn); // 步骤 1\n  while (heapSize > 1) {\n    swap(array, 0, --heapSize); // 步骤 2\n    heapify(array, 0, heapSize, compareFn); // 步骤 3\n  }\n  return array;\n}\nfunction buildMaxHeap(array, compareFn) {\n  for (let i = Math.floor(array.length / 2); i >= 0; i -= 1) {\n    heapify(array, i, array.length, compareFn);\n  }\n  return array;\n}\n```\n\nheapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法\n![heap-sort](heap-sort.png)\n\n**堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。**\n\n#### 图\n\n###### 图的相关术语\n\n图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）\nG = (V, E)\nV: 一组顶点\nE: 一组边，连接 V 中的顶点\n![graph-1](graph-1.png)\n\n由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。\n一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。\n路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。\n简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。\n如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。\n\n**有向图和无向图**\n图可以是无向的（边没有方向）或是有向的（有向图）。\n如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。\n![graph-2](graph-2.png)\n图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。\n![graph-3](graph-3.png)\n\n###### 图的表示\n\n**邻接矩阵**\n每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0\n![graph-4](graph-4.png)\n_缺点：_\n(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。\n(2)顶点的数量可能会改变，而二维数组不太灵活\n\n**邻接表**\n邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。\n可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表\n![graph-5](graph-5.png)\n\n**关联矩阵**\n在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0\n![graph-6](graph-6.png)\n_关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存_\n\n###### 创建 Graph 类\n\n```javascript\nclass Graph {\n  constructor(isDirected = false) {\n    // 表示图是否有向\n    this.isDirected = isDirected; // {1}\n    //  所有顶点的名字\n    this.vertices = []; // {2}\n    //  字典将会使用顶点的名字作为键，邻接顶点列表作为值\n    this.adjList = new Dictionary(); // {3}\n  }\n  //  一个用来向图中添加一个新的顶点\n  addVertex(v) {\n    if (!this.vertices.includes(v)) {\n      // {5}\n      this.vertices.push(v); // {6}\n      this.adjList.set(v, []); // {7}\n    }\n  }\n  // 来添加顶点之间的边\n  addEdge(v, w) {\n    if (!this.adjList.get(v)) {\n      this.addVertex(v); // {8}\n    }\n    if (!this.adjList.get(w)) {\n      this.addVertex(w); // {9}\n    }\n    this.adjList.get(v).push(w); // {10}\n    if (!this.isDirected) {\n      this.adjList.get(w).push(v); // {11}\n    }\n  }\n  // 获取顶点列表\n  getVertices() {\n    return this.vertices;\n  }\n  // 获取邻接表\n  getAdjList() {\n    return this.adjList;\n  }\n  toString() {\n    let s = '';\n    for (let i = 0; i < this.vertices.length; i++) {\n      // {15}\n      s += `${this.vertices[i]} -> `;\n      const neighbors = this.adjList.get(this.vertices[i]); // {16}\n      for (let j = 0; j < neighbors.length; j++) {\n        // {17}\n        s += `${neighbors[j]} `;\n      }\n      s += '\\n'; // {18}\n    }\n    return s;\n  }\n}\n```\n\n###### 图的遍历\n\n*作用：*图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等\n图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。\n完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。\n为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。\n\n**广度优先搜索（breadth-first search，BFS）**\n**深度优先搜索（depth-first search，DFS）**\n*不同点：*待访问顶点列表的数据结构\n| 算 法        | 数据结构 | 描 述                                                          |\n| ------------ | -------- | -------------------------------------------------------------- |\n| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |\n| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |\n\n```javascript\n// 白色：表示该顶点还没有被访问。\n// 灰色：表示该顶点被访问过，但并未被探索过。\n// 黑色：表示该顶点被访问过且被完全探索过\nconst Colors = {\n  WHITE: 0,\n  GREY: 1,\n  BLACK: 2,\n};\n// 初始化每个顶点的颜色\nconst initializeColor = (vertices) => {\n  const color = {};\n  for (let i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = Colors.WHITE;\n  }\n  return color;\n};\n```\n\n**广度优先搜索**\n从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点\n![graph-7](graph-7.png)\n_步骤_\n(1) 创建一个队列 Q。\n(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。\n(3) 如果 Q 非空，则运行以下步骤：\n\n- (a) 将 u 从 Q 中出队列；\n- (b) 标注 u 为被发现的（灰色）；\n- (c) 将 u 所有未被访问过的邻点（白色）入队列；\n- (d) 标注 u 为已被探索的（黑色）\n\n```javascript\nexport const breadthFirstSearch = (graph, startVertex, callback) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices); // {1}\n  const queue = new Queue(); // {2}\n  queue.enqueue(startVertex); // {3}\n  while (!queue.isEmpty()) {\n    // {4}\n    const u = queue.dequeue(); // {5}\n    const neighbors = adjList.get(u); // {6}\n    // 发现了节点，但尚未完成探索\n    color[u] = Colors.GREY; // {7}\n    for (let i = 0; i < neighbors.length; i++) {\n      // {8}\n      const w = neighbors[i]; // {9}\n      if (color[w] === Colors.WHITE) {\n        // {10}\n        color[w] = Colors.GREY; // {11}\n        queue.enqueue(w); // {12}\n      }\n    }\n    color[u] = Colors.BLACK; // {13}\n    // 可选回调函数\n    if (callback) {\n      // {14}\n      callback(u);\n    }\n  }\n};\n\nconst printVertex = (value) => console.log('Visited vertex: ' + value); // {15}\nbreadthFirstSearch(graph, myVertices[0], printVertex);\n```\n\n_使用 BFS 寻找最短路径_\n给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）\n\n```javascript\nconst BFS = (graph, startVertex) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  // 创建一个队列\n  const queue = new Queue();\n  const distances = {}; // {1}\n  const predecessors = {}; // {2}\n  queue.enqueue(startVertex);\n  for (let i = 0; i < vertices.length; i++) {\n    // {3}\n    distances[vertices[i]] = 0; // {4}\n    predecessors[vertices[i]] = null; // {5}\n  }\n  while (!queue.isEmpty()) {\n    const u = queue.dequeue();\n    const neighbors = adjList.get(u);\n    color[u] = Colors.GREY;\n    for (let i = 0; i < neighbors.length; i++) {\n      const w = neighbors[i];\n      if (color[w] === Colors.WHITE) {\n        color[w] = Colors.GREY;\n        distances[w] = distances[u] + 1; // {6}\n        predecessors[w] = u; // {7}\n        queue.enqueue(w);\n      }\n    }\n    color[u] = Colors.BLACK;\n  }\n  return {\n    // {8}\n    distances, // 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]\n    predecessors, // 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径\n  };\n};\n\nconst shortestPathA = BFS(graph, myVertices[0]);\nconsole.log(shortestPathA);\n// distances: {A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3},\n// predecessors: {A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"}\n\nconst fromVertex = myVertices[0]; // {9}\n\nfor (i = 1; i < myVertices.length; i++) {\n  // {10}\n  const toVertex = myVertices[i]; // {11}\n  // 创建一个栈\n  const path = new Stack(); // {12}\n  // 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点\n  for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) {\n    // {13}\n    path.push(v); // {14}\n  }\n  path.push(fromVertex); // {15}\n  let s = path.pop(); // {16}\n  while (!path.isEmpty()) {\n    // {17}\n    s += ' - ' + path.pop(); // {18}\n  }\n  console.log(s); // {19}\n}\n// A - B\n// A - C\n// A - D\n// A - B - E\n// A - B - F\n// A - C - G\n// A - D - H\n// A - B - E - I\n```\n\n_深入学习最短路径算法_\nDijkstra 算法解决了单源最短路径问题。\nBellman-Ford 算法解决了边权值为负的单源最短路径问题。\nA\\*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。\nFloyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题\n\n**深度优先搜索**\n深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点\n![graph-8](graph-8.png)\n\n深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。\n_步骤_\n(1) 标注 v 为被发现的（灰色）；\n(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；\n(3) 标注 v 为已被探索的（黑色）。\n\n深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）\n\n```javascript\nconst depthFirstSearch = (graph, callback) => {\n  // {1}\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    if (color[vertices[i]] === Colors.WHITE) {\n      // {3}\n      depthFirstSearchVisit(vertices[i], color, adjList, callback); // {4}\n    }\n  }\n};\nconst depthFirstSearchVisit = (u, color, adjList, callback) => {\n  color[u] = Colors.GREY; // {5}\n  if (callback) {\n    // {6}\n    callback(u);\n  }\n  const neighbors = adjList.get(u); // {7}\n  for (let i = 0; i < neighbors.length; i++) {\n    // {8}\n    const w = neighbors[i]; // {9}\n    if (color[w] === Colors.WHITE) {\n      // {10}\n      depthFirstSearchVisit(w, color, adjList, callback); // {11}\n    }\n  }\n  color[u] = Colors.BLACK; // {12}\n};\n\ndepthFirstSearch(graph, printVertex);\n// Visited vertex: A\n// Visited vertex: B\n// Visited vertex: E\n// Visited vertex: I\n// Visited vertex: F\n// Visited vertex: C\n// Visited vertex: D\n// Visited vertex: G\n// Visited vertex: H\n```\n\n![graph-9](graph-9.png)\n\n_Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。_\n\n_探索深度优先算法_\n对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。\n\n```javascript\nexport const DFS = (graph) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  const d = {};\n  const f = {};\n  const p = {};\n  const time = { count: 0 }; // {1}\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    f[vertices[i]] = 0;\n    d[vertices[i]] = 0;\n    p[vertices[i]] = null;\n  }\n  for (let i = 0; i < vertices.length; i++) {\n    if (color[vertices[i]] === Colors.WHITE) {\n      DFSVisit(vertices[i], color, d, f, p, time, adjList);\n    }\n  }\n  return {\n    // {3}\n    discovery: d, // 顶点 u 的发现时间 d[u]；\n    finished: f, // 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；\n    predecessors: p, // 顶点 u 的前溯点 p[u]\n  };\n};\nconst DFSVisit = (u, color, d, f, p, time, adjList) => {\n  color[u] = Colors.GREY;\n  d[u] = ++time.count; // {4}\n  const neighbors = adjList.get(u);\n  for (let i = 0; i < neighbors.length; i++) {\n    const w = neighbors[i];\n    if (color[w] === Colors.WHITE) {\n      p[w] = u; // {5}\n      DFSVisit(w, color, d, f, p, time, adjList);\n    }\n  }\n  color[u] = Colors.BLACK;\n  f[u] = ++time.count; // {6}\n};\n```\n\n(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；\n(2)对于所有的顶点 u，d[u] < f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。\n在这两个假设下，我们有如下的规则。\n_1 <= d [u] < f [u] <= 2|V|_\n如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间\n![graph-10](graph-10.png)\n\n**拓扑排序——使用深度优先搜索**\n![graph-11](graph-11.png)\n有向无环图（DAG）\n\n需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）\n\n_拓扑排序只能应用于 DAG_\n\n```javascript\ngraph = new Graph(true); // 有向图\nmyVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\nfor (i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('B', 'D');\ngraph.addEdge('B', 'E');\ngraph.addEdge('C', 'F');\ngraph.addEdge('F', 'E');\nconst result = DFS(graph);\n```\n\n![graph-12](graph-12.png)\n\n```javascript\nconst fTimes = result.finished;\ns = '';\nfor (let count = 0; count < myVertices.length; count++) {\n  let max = 0;\n  let maxName = null;\n  for (i = 0; i < myVertices.length; i++) {\n    if (fTimes[myVertices[i]] > max) {\n      max = fTimes[myVertices[i]];\n      maxName = myVertices[i];\n    }\n  }\n  s += ' - ' + maxName;\n  delete fTimes[maxName];\n}\nconsole.log(s);\n// B - A - D - C - F - E\n```\n\n###### 最短路径算法\n\n_Dijkstra 算法_\nDijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。\n\n![graph-13](graph-13.png)\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [0, 0, 1, 4, 2, 0],\n  [0, 0, 0, 0, 3, 0],\n  [0, 0, 0, 0, 0, 2],\n  [0, 0, 0, 3, 0, 2],\n  [0, 0, 0, 0, 0, 0],\n];\n// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER\nconst INF = Number.MAX_SAFE_INTEGER;\nconst dijkstra = (graph, src) => {\n  const dist = [];\n  const visited = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = INF; // 把所有的距离（dist）初始化为无限大\n    visited[i] = false;\n  }\n  dist[src] = 0; // {2} 把源顶点到自己的距离设为 0\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    const u = minDistance(dist, visited); // {4} 从尚未处理的顶点中选出距离最近的顶点\n    visited[u] = true; // {5} 把选出的顶点标为 visited，以免重复计算\n    for (let v = 0; v < length; v++) {\n      if (\n        !visited[v] &&\n        graph[u][v] !== 0 &&\n        dist[u] !== INF &&\n        dist[u] + graph[u][v] < dist[v]\n      ) {\n        // 如果找到更短的路径，则更新最短路径的值\n        // {6}\n        dist[v] = dist[u] + graph[u][v]; // {7}\n      }\n    }\n  }\n  return dist; // {8}\n};\n\nconst minDistance = (dist, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist.length; v++) {\n    if (visited[v] === false && dist[v] <= min) {\n      min = dist[v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// 0 0\n// 1 2\n// 2 4\n// 3 6\n// 4 4\n// 5 6\n```\n\n**Floyd-Warshall 算法**\nFloyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。\n\n```javascript\nconst floydWarshall = (graph) => {\n  const dist = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = [];\n    for (let j = 0; j < length; j++) {\n      if (i === j) {\n        dist[i][j] = 0; // {2}\n      } else if (!isFinite(graph[i][j])) {\n        // 如果两个顶点之间没有边，就将其表示为 Infinity\n        dist[i][j] = Infinity; // {3}\n      } else {\n        // 为 i 到 j 可能的最短距离就是这些顶点间的权值\n        dist[i][j] = graph[i][j]; // {4}\n      }\n    }\n  }\n  // 将顶点 0 到 k 作为中间点（行{5}），从 i 到 j 的最短路径经过 k。\n  for (let k = 0; k < length; k++) {\n    // {5}\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length; j++) {\n        // 计算通过顶点 k 的 i 和 j 之间的最短路径\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          // {6}\n          dist[i][j] = dist[i][k] + dist[k][j]; // {7}\n        }\n      }\n    }\n  }\n  return dist;\n};\n// 0 2 4 6 4 6\n// INF 0 2 4 2 4\n// INF INF 0 6 3 5\n// INF INF INF 0 INF 2\n// INF INF INF 3 0 2\n// INF INF INF INF INF 0\n```\n\n###### 最小生成树(MST)\n\n**Prim 算法**\nPrim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [2, 0, 2, 4, 2, 0],\n  [4, 2, 0, 0, 3, 0],\n  [0, 4, 0, 0, 3, 2],\n  [0, 2, 3, 3, 0, 2],\n  [0, 0, 0, 2, 2, 0],\n];\n\nconst INF = Number.MAX_SAFE_INTEGER;\nconst prim = (graph) => {\n  const parent = [];\n  const key = [];\n  const visited = [];\n  const { length } = graph;\n  // 把所有顶点（key）初始化为无限大\n  for (let i = 0; i < length; i++) {\n    // {1}\n    key[i] = INF;\n    visited[i] = false;\n  }\n  // 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1\n  key[0] = 0; // {2}\n  parent[0] = -1;\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    // 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）\n    const u = minKey(graph, key, visited); // {4}\n    visited[u] = true; // {5}\n    for (let v = 0; v < length; v++) {\n      // 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值\n      if (graph[u][v] && !visited[v] && graph[u][v] < key[v]) {\n        // {6}\n        parent[v] = u; // {7}\n        key[v] = graph[u][v]; // {8}\n      }\n    }\n  }\n  return parent; // {9}\n};\n\nconst minDistance = (dist, key, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist[key].length; v++) {\n    if (visited[v] === false && dist[key][v] <= min) {\n      min = dist[key][v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// Edge Weight\n// 0 - 1 2\n// 1 - 2 2\n// 5 - 3 2\n// 1 - 4 2\n// 4 - 5 2\n```\n\n**Kruskal 算法**\n是一种求加权无向连通图的 MST 的贪心算法\n\n```javascript\nconst kruskal = (graph) => {\n  const { length } = graph;\n  const parent = [];\n  let ne = 0;\n  let a;\n  let b;\n  let u;\n  let v;\n  // 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值\n  const cost = initializeCost(graph); // {1}\n  // 当 MST 的边数小于顶点总数减 1 时\n  while (ne < length - 1) {\n    // 找出权值最小的边\n    for (let i = 0, min = INF; i < length; i++) {\n      // {3}\n      for (let j = 0; j < length; j++) {\n        if (cost[i][j] < min) {\n          min = cost[i][j];\n          a = u = i;\n          b = v = j;\n        }\n      }\n    }\n    // 检查 MST 中是否已存在这条边，以避免环路\n    u = find(u, parent); // {4}\n    v = find(v, parent); // {5}\n    // 如果 u 和 v 是不同的边，则将其加入 MST\n    if (union(u, v, parent)) {\n      // {6}\n      ne++;\n    }\n    // ：从列表中移除这些边，以免重复计算\n    cost[a][b] = cost[b][a] = INF; // {7}\n  }\n  return parent;\n};\n\nconst find = (i, parent) => {\n  while (parent[i]) {\n    i = parent[i];\n  }\n  return i;\n};\nconst union = (i, j, parent) => {\n  if (i !== j) {\n    parent[j] = i;\n    return true;\n  }\n  return false;\n};\n```\n","source":"_posts/37-data-structure5.md","raw":"---\ntitle: 数据结构与算法阅读笔记(5)\ndate: 2022-10-08 16:33:37\ntags:\n---\n\n#### 二叉堆和堆排序\n\n###### 二叉堆数据结构\n\n(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。\n(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性\n![heat](heat.png)\n\n二叉树有两种表示方式\n第一种是使用一个动态的表示方式，也就是指针（用节点表示）\n第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。\n![min-heat](min-heat.png)\n\n访问使用普通数组的二叉树节点:\n它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；\n它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；\n它的父节点位置是 index / 2（如果位置可用）\n\n```javascript\nimport { defaultCompare } from '../util';\n\nexport class MinHeap {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // {1}\n    this.heap = []; // {2}\n  }\n  getLeftIndex(index) {\n    return 2 * index + 1;\n  }\n  getRightIndex(index) {\n    return 2 * index + 2;\n  }\n  getParentIndex(index) {\n    if (index === 0) {\n      return undefined;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n  insert(value) {\n    if (value != null) {\n      this.heap.push(value); // {1}\n      this.siftUp(this.heap.length - 1); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 上移操作\n  siftUp(index) {\n    let parent = this.getParentIndex(index); // {1}\n    while (\n      index > 0 &&\n      this.compareFn(this.heap[parent], this.heap[index]) > Compare.BIGGER_THAN\n    ) {\n      // {2}\n      swap(this.heap, parent, index); // {3}\n      index = parent;\n      parent = this.getParentIndex(index); // {4}\n    }\n    function swap(array, a, b) {\n      const temp = array[a]; // {5}\n      array[a] = array[b]; // {6}\n      array[b] = temp; // {7}\n    }\n  }\n  size() {\n    return this.heap.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  findMinimum() {\n    return this.isEmpty() ? undefined : this.heap[0]; // {1}\n  }\n  extract() {\n    if (this.isEmpty()) {\n      return undefined; // {1}\n    }\n    if (this.size() === 1) {\n      return this.heap.shift(); // {2}\n    }\n    const removedValue = this.heap.shift(); // {3}\n    this.siftDown(0); // {4}\n    return removedValue; // {5}\n  }\n  siftDown(index) {\n    let element = index;\n    const left = this.getLeftIndex(index); // {1}\n    const right = this.getRightIndex(index); // {2}\n    const size = this.size();\n    if (\n      left < size &&\n      this.compareFn(this.heap[element], this.heap[left]) > Compare.BIGGER_THAN\n    ) {\n      // {3}\n      element = left; // {4}\n    }\n    if (\n      right < size &&\n      this.compareFn(this.heap[element], this.heap[right]) > Compare.BIGGER_THAN\n    ) {\n      // {5}\n      element = right; // {6}\n    }\n    if (index !== element) {\n      // {7}\n      swap(this.heap, index, element); // {8}\n      this.siftDown(element); // {9}\n    }\n  }\n}\n```\n\n![min-heat-pic](min-heat-pic.png)\n\n**创建最大堆类**\nMaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有>（大于）的比较换成<（小于）的比较。\n\n```javascript\nfunction reverseCompare(compareFn) {\n  return (a, b) => compareFn(b, a);\n}\n\nexport class MaxHeap extends MinHeap {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = reverseCompare(compareFn); // {1}\n  }\n}\n```\n\n**堆排序算法**\n(1) 用数组创建一个最大堆用作源数据。\n(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。\n(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1\n\n```javascript\nfunction heapSort(array, compareFn = defaultCompare) {\n  let heapSize = array.length;\n  buildMaxHeap(array, compareFn); // 步骤 1\n  while (heapSize > 1) {\n    swap(array, 0, --heapSize); // 步骤 2\n    heapify(array, 0, heapSize, compareFn); // 步骤 3\n  }\n  return array;\n}\nfunction buildMaxHeap(array, compareFn) {\n  for (let i = Math.floor(array.length / 2); i >= 0; i -= 1) {\n    heapify(array, i, array.length, compareFn);\n  }\n  return array;\n}\n```\n\nheapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法\n![heap-sort](heap-sort.png)\n\n**堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。**\n\n#### 图\n\n###### 图的相关术语\n\n图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）\nG = (V, E)\nV: 一组顶点\nE: 一组边，连接 V 中的顶点\n![graph-1](graph-1.png)\n\n由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。\n一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。\n路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。\n简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。\n如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。\n\n**有向图和无向图**\n图可以是无向的（边没有方向）或是有向的（有向图）。\n如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。\n![graph-2](graph-2.png)\n图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。\n![graph-3](graph-3.png)\n\n###### 图的表示\n\n**邻接矩阵**\n每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0\n![graph-4](graph-4.png)\n_缺点：_\n(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。\n(2)顶点的数量可能会改变，而二维数组不太灵活\n\n**邻接表**\n邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。\n可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表\n![graph-5](graph-5.png)\n\n**关联矩阵**\n在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0\n![graph-6](graph-6.png)\n_关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存_\n\n###### 创建 Graph 类\n\n```javascript\nclass Graph {\n  constructor(isDirected = false) {\n    // 表示图是否有向\n    this.isDirected = isDirected; // {1}\n    //  所有顶点的名字\n    this.vertices = []; // {2}\n    //  字典将会使用顶点的名字作为键，邻接顶点列表作为值\n    this.adjList = new Dictionary(); // {3}\n  }\n  //  一个用来向图中添加一个新的顶点\n  addVertex(v) {\n    if (!this.vertices.includes(v)) {\n      // {5}\n      this.vertices.push(v); // {6}\n      this.adjList.set(v, []); // {7}\n    }\n  }\n  // 来添加顶点之间的边\n  addEdge(v, w) {\n    if (!this.adjList.get(v)) {\n      this.addVertex(v); // {8}\n    }\n    if (!this.adjList.get(w)) {\n      this.addVertex(w); // {9}\n    }\n    this.adjList.get(v).push(w); // {10}\n    if (!this.isDirected) {\n      this.adjList.get(w).push(v); // {11}\n    }\n  }\n  // 获取顶点列表\n  getVertices() {\n    return this.vertices;\n  }\n  // 获取邻接表\n  getAdjList() {\n    return this.adjList;\n  }\n  toString() {\n    let s = '';\n    for (let i = 0; i < this.vertices.length; i++) {\n      // {15}\n      s += `${this.vertices[i]} -> `;\n      const neighbors = this.adjList.get(this.vertices[i]); // {16}\n      for (let j = 0; j < neighbors.length; j++) {\n        // {17}\n        s += `${neighbors[j]} `;\n      }\n      s += '\\n'; // {18}\n    }\n    return s;\n  }\n}\n```\n\n###### 图的遍历\n\n*作用：*图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等\n图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。\n完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。\n为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。\n\n**广度优先搜索（breadth-first search，BFS）**\n**深度优先搜索（depth-first search，DFS）**\n*不同点：*待访问顶点列表的数据结构\n| 算 法        | 数据结构 | 描 述                                                          |\n| ------------ | -------- | -------------------------------------------------------------- |\n| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |\n| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |\n\n```javascript\n// 白色：表示该顶点还没有被访问。\n// 灰色：表示该顶点被访问过，但并未被探索过。\n// 黑色：表示该顶点被访问过且被完全探索过\nconst Colors = {\n  WHITE: 0,\n  GREY: 1,\n  BLACK: 2,\n};\n// 初始化每个顶点的颜色\nconst initializeColor = (vertices) => {\n  const color = {};\n  for (let i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = Colors.WHITE;\n  }\n  return color;\n};\n```\n\n**广度优先搜索**\n从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点\n![graph-7](graph-7.png)\n_步骤_\n(1) 创建一个队列 Q。\n(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。\n(3) 如果 Q 非空，则运行以下步骤：\n\n- (a) 将 u 从 Q 中出队列；\n- (b) 标注 u 为被发现的（灰色）；\n- (c) 将 u 所有未被访问过的邻点（白色）入队列；\n- (d) 标注 u 为已被探索的（黑色）\n\n```javascript\nexport const breadthFirstSearch = (graph, startVertex, callback) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices); // {1}\n  const queue = new Queue(); // {2}\n  queue.enqueue(startVertex); // {3}\n  while (!queue.isEmpty()) {\n    // {4}\n    const u = queue.dequeue(); // {5}\n    const neighbors = adjList.get(u); // {6}\n    // 发现了节点，但尚未完成探索\n    color[u] = Colors.GREY; // {7}\n    for (let i = 0; i < neighbors.length; i++) {\n      // {8}\n      const w = neighbors[i]; // {9}\n      if (color[w] === Colors.WHITE) {\n        // {10}\n        color[w] = Colors.GREY; // {11}\n        queue.enqueue(w); // {12}\n      }\n    }\n    color[u] = Colors.BLACK; // {13}\n    // 可选回调函数\n    if (callback) {\n      // {14}\n      callback(u);\n    }\n  }\n};\n\nconst printVertex = (value) => console.log('Visited vertex: ' + value); // {15}\nbreadthFirstSearch(graph, myVertices[0], printVertex);\n```\n\n_使用 BFS 寻找最短路径_\n给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）\n\n```javascript\nconst BFS = (graph, startVertex) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  // 创建一个队列\n  const queue = new Queue();\n  const distances = {}; // {1}\n  const predecessors = {}; // {2}\n  queue.enqueue(startVertex);\n  for (let i = 0; i < vertices.length; i++) {\n    // {3}\n    distances[vertices[i]] = 0; // {4}\n    predecessors[vertices[i]] = null; // {5}\n  }\n  while (!queue.isEmpty()) {\n    const u = queue.dequeue();\n    const neighbors = adjList.get(u);\n    color[u] = Colors.GREY;\n    for (let i = 0; i < neighbors.length; i++) {\n      const w = neighbors[i];\n      if (color[w] === Colors.WHITE) {\n        color[w] = Colors.GREY;\n        distances[w] = distances[u] + 1; // {6}\n        predecessors[w] = u; // {7}\n        queue.enqueue(w);\n      }\n    }\n    color[u] = Colors.BLACK;\n  }\n  return {\n    // {8}\n    distances, // 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]\n    predecessors, // 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径\n  };\n};\n\nconst shortestPathA = BFS(graph, myVertices[0]);\nconsole.log(shortestPathA);\n// distances: {A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3},\n// predecessors: {A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"}\n\nconst fromVertex = myVertices[0]; // {9}\n\nfor (i = 1; i < myVertices.length; i++) {\n  // {10}\n  const toVertex = myVertices[i]; // {11}\n  // 创建一个栈\n  const path = new Stack(); // {12}\n  // 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点\n  for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) {\n    // {13}\n    path.push(v); // {14}\n  }\n  path.push(fromVertex); // {15}\n  let s = path.pop(); // {16}\n  while (!path.isEmpty()) {\n    // {17}\n    s += ' - ' + path.pop(); // {18}\n  }\n  console.log(s); // {19}\n}\n// A - B\n// A - C\n// A - D\n// A - B - E\n// A - B - F\n// A - C - G\n// A - D - H\n// A - B - E - I\n```\n\n_深入学习最短路径算法_\nDijkstra 算法解决了单源最短路径问题。\nBellman-Ford 算法解决了边权值为负的单源最短路径问题。\nA\\*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。\nFloyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题\n\n**深度优先搜索**\n深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点\n![graph-8](graph-8.png)\n\n深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。\n_步骤_\n(1) 标注 v 为被发现的（灰色）；\n(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；\n(3) 标注 v 为已被探索的（黑色）。\n\n深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）\n\n```javascript\nconst depthFirstSearch = (graph, callback) => {\n  // {1}\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    if (color[vertices[i]] === Colors.WHITE) {\n      // {3}\n      depthFirstSearchVisit(vertices[i], color, adjList, callback); // {4}\n    }\n  }\n};\nconst depthFirstSearchVisit = (u, color, adjList, callback) => {\n  color[u] = Colors.GREY; // {5}\n  if (callback) {\n    // {6}\n    callback(u);\n  }\n  const neighbors = adjList.get(u); // {7}\n  for (let i = 0; i < neighbors.length; i++) {\n    // {8}\n    const w = neighbors[i]; // {9}\n    if (color[w] === Colors.WHITE) {\n      // {10}\n      depthFirstSearchVisit(w, color, adjList, callback); // {11}\n    }\n  }\n  color[u] = Colors.BLACK; // {12}\n};\n\ndepthFirstSearch(graph, printVertex);\n// Visited vertex: A\n// Visited vertex: B\n// Visited vertex: E\n// Visited vertex: I\n// Visited vertex: F\n// Visited vertex: C\n// Visited vertex: D\n// Visited vertex: G\n// Visited vertex: H\n```\n\n![graph-9](graph-9.png)\n\n_Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。_\n\n_探索深度优先算法_\n对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。\n\n```javascript\nexport const DFS = (graph) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  const d = {};\n  const f = {};\n  const p = {};\n  const time = { count: 0 }; // {1}\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    f[vertices[i]] = 0;\n    d[vertices[i]] = 0;\n    p[vertices[i]] = null;\n  }\n  for (let i = 0; i < vertices.length; i++) {\n    if (color[vertices[i]] === Colors.WHITE) {\n      DFSVisit(vertices[i], color, d, f, p, time, adjList);\n    }\n  }\n  return {\n    // {3}\n    discovery: d, // 顶点 u 的发现时间 d[u]；\n    finished: f, // 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；\n    predecessors: p, // 顶点 u 的前溯点 p[u]\n  };\n};\nconst DFSVisit = (u, color, d, f, p, time, adjList) => {\n  color[u] = Colors.GREY;\n  d[u] = ++time.count; // {4}\n  const neighbors = adjList.get(u);\n  for (let i = 0; i < neighbors.length; i++) {\n    const w = neighbors[i];\n    if (color[w] === Colors.WHITE) {\n      p[w] = u; // {5}\n      DFSVisit(w, color, d, f, p, time, adjList);\n    }\n  }\n  color[u] = Colors.BLACK;\n  f[u] = ++time.count; // {6}\n};\n```\n\n(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；\n(2)对于所有的顶点 u，d[u] < f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。\n在这两个假设下，我们有如下的规则。\n_1 <= d [u] < f [u] <= 2|V|_\n如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间\n![graph-10](graph-10.png)\n\n**拓扑排序——使用深度优先搜索**\n![graph-11](graph-11.png)\n有向无环图（DAG）\n\n需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）\n\n_拓扑排序只能应用于 DAG_\n\n```javascript\ngraph = new Graph(true); // 有向图\nmyVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\nfor (i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('B', 'D');\ngraph.addEdge('B', 'E');\ngraph.addEdge('C', 'F');\ngraph.addEdge('F', 'E');\nconst result = DFS(graph);\n```\n\n![graph-12](graph-12.png)\n\n```javascript\nconst fTimes = result.finished;\ns = '';\nfor (let count = 0; count < myVertices.length; count++) {\n  let max = 0;\n  let maxName = null;\n  for (i = 0; i < myVertices.length; i++) {\n    if (fTimes[myVertices[i]] > max) {\n      max = fTimes[myVertices[i]];\n      maxName = myVertices[i];\n    }\n  }\n  s += ' - ' + maxName;\n  delete fTimes[maxName];\n}\nconsole.log(s);\n// B - A - D - C - F - E\n```\n\n###### 最短路径算法\n\n_Dijkstra 算法_\nDijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。\n\n![graph-13](graph-13.png)\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [0, 0, 1, 4, 2, 0],\n  [0, 0, 0, 0, 3, 0],\n  [0, 0, 0, 0, 0, 2],\n  [0, 0, 0, 3, 0, 2],\n  [0, 0, 0, 0, 0, 0],\n];\n// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER\nconst INF = Number.MAX_SAFE_INTEGER;\nconst dijkstra = (graph, src) => {\n  const dist = [];\n  const visited = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = INF; // 把所有的距离（dist）初始化为无限大\n    visited[i] = false;\n  }\n  dist[src] = 0; // {2} 把源顶点到自己的距离设为 0\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    const u = minDistance(dist, visited); // {4} 从尚未处理的顶点中选出距离最近的顶点\n    visited[u] = true; // {5} 把选出的顶点标为 visited，以免重复计算\n    for (let v = 0; v < length; v++) {\n      if (\n        !visited[v] &&\n        graph[u][v] !== 0 &&\n        dist[u] !== INF &&\n        dist[u] + graph[u][v] < dist[v]\n      ) {\n        // 如果找到更短的路径，则更新最短路径的值\n        // {6}\n        dist[v] = dist[u] + graph[u][v]; // {7}\n      }\n    }\n  }\n  return dist; // {8}\n};\n\nconst minDistance = (dist, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist.length; v++) {\n    if (visited[v] === false && dist[v] <= min) {\n      min = dist[v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// 0 0\n// 1 2\n// 2 4\n// 3 6\n// 4 4\n// 5 6\n```\n\n**Floyd-Warshall 算法**\nFloyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。\n\n```javascript\nconst floydWarshall = (graph) => {\n  const dist = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = [];\n    for (let j = 0; j < length; j++) {\n      if (i === j) {\n        dist[i][j] = 0; // {2}\n      } else if (!isFinite(graph[i][j])) {\n        // 如果两个顶点之间没有边，就将其表示为 Infinity\n        dist[i][j] = Infinity; // {3}\n      } else {\n        // 为 i 到 j 可能的最短距离就是这些顶点间的权值\n        dist[i][j] = graph[i][j]; // {4}\n      }\n    }\n  }\n  // 将顶点 0 到 k 作为中间点（行{5}），从 i 到 j 的最短路径经过 k。\n  for (let k = 0; k < length; k++) {\n    // {5}\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length; j++) {\n        // 计算通过顶点 k 的 i 和 j 之间的最短路径\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          // {6}\n          dist[i][j] = dist[i][k] + dist[k][j]; // {7}\n        }\n      }\n    }\n  }\n  return dist;\n};\n// 0 2 4 6 4 6\n// INF 0 2 4 2 4\n// INF INF 0 6 3 5\n// INF INF INF 0 INF 2\n// INF INF INF 3 0 2\n// INF INF INF INF INF 0\n```\n\n###### 最小生成树(MST)\n\n**Prim 算法**\nPrim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [2, 0, 2, 4, 2, 0],\n  [4, 2, 0, 0, 3, 0],\n  [0, 4, 0, 0, 3, 2],\n  [0, 2, 3, 3, 0, 2],\n  [0, 0, 0, 2, 2, 0],\n];\n\nconst INF = Number.MAX_SAFE_INTEGER;\nconst prim = (graph) => {\n  const parent = [];\n  const key = [];\n  const visited = [];\n  const { length } = graph;\n  // 把所有顶点（key）初始化为无限大\n  for (let i = 0; i < length; i++) {\n    // {1}\n    key[i] = INF;\n    visited[i] = false;\n  }\n  // 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1\n  key[0] = 0; // {2}\n  parent[0] = -1;\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    // 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）\n    const u = minKey(graph, key, visited); // {4}\n    visited[u] = true; // {5}\n    for (let v = 0; v < length; v++) {\n      // 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值\n      if (graph[u][v] && !visited[v] && graph[u][v] < key[v]) {\n        // {6}\n        parent[v] = u; // {7}\n        key[v] = graph[u][v]; // {8}\n      }\n    }\n  }\n  return parent; // {9}\n};\n\nconst minDistance = (dist, key, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist[key].length; v++) {\n    if (visited[v] === false && dist[key][v] <= min) {\n      min = dist[key][v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// Edge Weight\n// 0 - 1 2\n// 1 - 2 2\n// 5 - 3 2\n// 1 - 4 2\n// 4 - 5 2\n```\n\n**Kruskal 算法**\n是一种求加权无向连通图的 MST 的贪心算法\n\n```javascript\nconst kruskal = (graph) => {\n  const { length } = graph;\n  const parent = [];\n  let ne = 0;\n  let a;\n  let b;\n  let u;\n  let v;\n  // 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值\n  const cost = initializeCost(graph); // {1}\n  // 当 MST 的边数小于顶点总数减 1 时\n  while (ne < length - 1) {\n    // 找出权值最小的边\n    for (let i = 0, min = INF; i < length; i++) {\n      // {3}\n      for (let j = 0; j < length; j++) {\n        if (cost[i][j] < min) {\n          min = cost[i][j];\n          a = u = i;\n          b = v = j;\n        }\n      }\n    }\n    // 检查 MST 中是否已存在这条边，以避免环路\n    u = find(u, parent); // {4}\n    v = find(v, parent); // {5}\n    // 如果 u 和 v 是不同的边，则将其加入 MST\n    if (union(u, v, parent)) {\n      // {6}\n      ne++;\n    }\n    // ：从列表中移除这些边，以免重复计算\n    cost[a][b] = cost[b][a] = INF; // {7}\n  }\n  return parent;\n};\n\nconst find = (i, parent) => {\n  while (parent[i]) {\n    i = parent[i];\n  }\n  return i;\n};\nconst union = (i, j, parent) => {\n  if (i !== j) {\n    parent[j] = i;\n    return true;\n  }\n  return false;\n};\n```\n","slug":"37-data-structure5","published":1,"updated":"2022-10-13T06:14:03.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q20010k4ttg0q1ct2o","content":"<h4 id=\"二叉堆和堆排序\"><a href=\"#二叉堆和堆排序\" class=\"headerlink\" title=\"二叉堆和堆排序\"></a>二叉堆和堆排序</h4><h6 id=\"二叉堆数据结构\"><a href=\"#二叉堆数据结构\" class=\"headerlink\" title=\"二叉堆数据结构\"></a>二叉堆数据结构</h6><p>(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。<br>(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性<br><img src=\"/2022/10/08/37-data-structure5/heat.png\" alt=\"heat\"></p>\n<p>二叉树有两种表示方式<br>第一种是使用一个动态的表示方式，也就是指针（用节点表示）<br>第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。<br><img src=\"/2022/10/08/37-data-structure5/min-heat.png\" alt=\"min-heat\"></p>\n<p>访问使用普通数组的二叉树节点:<br>它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；<br>它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；<br>它的父节点位置是 index / 2（如果位置可用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.heap = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getLeftIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getRightIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getParentIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor((index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.heap.push(value); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftUp(<span class=\"built_in\">this</span>.heap.length - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 上移操作</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftUp</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      index &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[parent], <span class=\"built_in\">this</span>.heap[index]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, parent, index); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      index = parent;</span><br><span class=\"line\">      parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> temp = array[a]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[a] = array[b]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[b] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">findMinimum</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.isEmpty() ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">this</span>.heap[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">extract</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> removedValue = <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.siftDown(<span class=\"number\">0</span>); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> removedValue; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftDown</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = index;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = <span class=\"built_in\">this</span>.getLeftIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = <span class=\"built_in\">this</span>.getRightIndex(index); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> size = <span class=\"built_in\">this</span>.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      left &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[left]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      element = left; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      right &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[right]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      element = right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== element) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, index, element); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftDown(element); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/min-heat-pic.png\" alt=\"min-heat-pic\"></p>\n<p><strong>创建最大堆类</strong><br>MaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有&gt;（大于）的比较换成&lt;（小于）的比较。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverseCompare</span>(<span class=\"params\">compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> compareFn(b, a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxHeap</span> <span class=\"keyword\">extends</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = reverseCompare(compareFn); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆排序算法</strong><br>(1) 用数组创建一个最大堆用作源数据。<br>(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。<br>(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> heapSize = array.length;</span><br><span class=\"line\">  buildMaxHeap(array, compareFn); <span class=\"comment\">// 步骤 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (heapSize &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    swap(array, <span class=\"number\">0</span>, --heapSize); <span class=\"comment\">// 步骤 2</span></span><br><span class=\"line\">    heapify(array, <span class=\"number\">0</span>, heapSize, compareFn); <span class=\"comment\">// 步骤 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildMaxHeap</span>(<span class=\"params\">array, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(array.length / <span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i -= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    heapify(array, i, array.length, compareFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>heapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法<br><img src=\"/2022/10/08/37-data-structure5/heap-sort.png\" alt=\"heap-sort\"></p>\n<p><strong>堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。</strong></p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><h6 id=\"图的相关术语\"><a href=\"#图的相关术语\" class=\"headerlink\" title=\"图的相关术语\"></a>图的相关术语</h6><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）<br>G = (V, E)<br>V: 一组顶点<br>E: 一组边，连接 V 中的顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-1.png\" alt=\"graph-1\"></p>\n<p>由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。<br>一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。<br>路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。<br>简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。<br>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p>\n<p><strong>有向图和无向图</strong><br>图可以是无向的（边没有方向）或是有向的（有向图）。<br>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。<br><img src=\"/2022/10/08/37-data-structure5/graph-2.png\" alt=\"graph-2\"><br>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。<br><img src=\"/2022/10/08/37-data-structure5/graph-3.png\" alt=\"graph-3\"></p>\n<h6 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h6><p><strong>邻接矩阵</strong><br>每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-4.png\" alt=\"graph-4\"><br><em>缺点：</em><br>(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。<br>(2)顶点的数量可能会改变，而二维数组不太灵活</p>\n<p><strong>邻接表</strong><br>邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。<br>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表<br><img src=\"/2022/10/08/37-data-structure5/graph-5.png\" alt=\"graph-5\"></p>\n<p><strong>关联矩阵</strong><br>在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-6.png\" alt=\"graph-6\"><br><em>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存</em></p>\n<h6 id=\"创建-Graph-类\"><a href=\"#创建-Graph-类\" class=\"headerlink\" title=\"创建 Graph 类\"></a>创建 Graph 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">isDirected = <span class=\"literal\">false</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示图是否有向</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDirected = isDirected; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  所有顶点的名字</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.vertices = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  字典将会使用顶点的名字作为键，邻接顶点列表作为值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  一个用来向图中添加一个新的顶点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addVertex</span>(<span class=\"params\">v</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.vertices.includes(v)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.vertices.push(v); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.set(v, []); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 来添加顶点之间的边</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addEdge</span>(<span class=\"params\">v, w</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(v)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(v); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(w)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(w); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList.get(v).push(w); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isDirected) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.get(w).push(v); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取顶点列表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getVertices</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.vertices;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取邻接表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getAdjList</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.adjList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.vertices.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      s += <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.vertices[i]&#125;</span> -&gt; `</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> neighbors = <span class=\"built_in\">this</span>.adjList.get(<span class=\"built_in\">this</span>.vertices[i]); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">        s += <span class=\"string\">`<span class=\"subst\">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      s += <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h6><p><em>作用：</em>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。<br>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>\n<p><strong>广度优先搜索（breadth-first search，BFS）</strong><br><strong>深度优先搜索（depth-first search，DFS）</strong><br><em>不同点：</em>待访问顶点列表的数据结构<br>| 算 法        | 数据结构 | 描 述                                                          |<br>| ———— | ——– | ————————————————————– |<br>| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |<br>| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 白色：表示该顶点还没有被访问。</span></span><br><span class=\"line\"><span class=\"comment\">// 灰色：表示该顶点被访问过，但并未被探索过。</span></span><br><span class=\"line\"><span class=\"comment\">// 黑色：表示该顶点被访问过且被完全探索过</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Colors = &#123;</span><br><span class=\"line\">  <span class=\"attr\">WHITE</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">GREY</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">BLACK</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化每个顶点的颜色</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initializeColor = <span class=\"function\">(<span class=\"params\">vertices</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    color[vertices[i]] = Colors.WHITE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>广度优先搜索</strong><br>从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-7.png\" alt=\"graph-7\"><br><em>步骤</em><br>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：</p>\n<ul>\n<li>(a) 将 u 从 Q 中出队列；</li>\n<li>(b) 标注 u 为被发现的（灰色）；</li>\n<li>(c) 将 u 所有未被访问过的邻点（白色）入队列；</li>\n<li>(d) 标注 u 为已被探索的（黑色）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> breadthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue(); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 发现了节点，但尚未完成探索</span></span><br><span class=\"line\">    color[u] = Colors.GREY; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        color[w] = Colors.GREY; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        queue.enqueue(w); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 可选回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      callback(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> printVertex = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Visited vertex: &#x27;</span> + value); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">breadthFirstSearch(graph, myVertices[<span class=\"number\">0</span>], printVertex);</span><br></pre></td></tr></table></figure>\n\n<p><em>使用 BFS 寻找最短路径</em><br>给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BFS = <span class=\"function\">(<span class=\"params\">graph, startVertex</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> distances = &#123;&#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> predecessors = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    distances[vertices[i]] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    predecessors[vertices[i]] = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">    color[u] = Colors.GREY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        color[w] = Colors.GREY;</span><br><span class=\"line\">        distances[w] = distances[u] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        predecessors[w] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        queue.enqueue(w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    distances, <span class=\"comment\">// 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]</span></span><br><span class=\"line\">    predecessors, <span class=\"comment\">// 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shortestPathA = BFS(graph, myVertices[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shortestPathA);</span><br><span class=\"line\"><span class=\"comment\">// distances: &#123;A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// predecessors: &#123;A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G: &quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fromVertex = myVertices[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> toVertex = myVertices[i]; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 创建一个栈</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"keyword\">new</span> Stack(); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    path.push(v); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  path.push(fromVertex); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> s = path.pop(); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!path.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">    s += <span class=\"string\">&#x27; - &#x27;</span> + path.pop(); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// A - B</span></span><br><span class=\"line\"><span class=\"comment\">// A - C</span></span><br><span class=\"line\"><span class=\"comment\">// A - D</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - F</span></span><br><span class=\"line\"><span class=\"comment\">// A - C - G</span></span><br><span class=\"line\"><span class=\"comment\">// A - D - H</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E - I</span></span><br></pre></td></tr></table></figure>\n\n<p><em>深入学习最短路径算法</em><br>Dijkstra 算法解决了单源最短路径问题。<br>Bellman-Ford 算法解决了边权值为负的单源最短路径问题。<br>A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。<br>Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题</p>\n<p><strong>深度优先搜索</strong><br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-8.png\" alt=\"graph-8\"></p>\n<p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。<br><em>步骤</em><br>(1) 标注 v 为被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）。</p>\n<p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(vertices[i], color, adjList, callback); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearchVisit = <span class=\"function\">(<span class=\"params\">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    callback(u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(w, color, adjList, callback); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">depthFirstSearch(graph, printVertex);</span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: A</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: B</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: E</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: I</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: F</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: C</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: D</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: G</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: H</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-9.png\" alt=\"graph-9\"></p>\n<p><em>Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。</em></p>\n<p><em>探索深度优先算法</em><br>对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DFS = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> d = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    f[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    d[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    p[vertices[i]] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      DFSVisit(vertices[i], color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">discovery</span>: d, <span class=\"comment\">// 顶点 u 的发现时间 d[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">finished</span>: f, <span class=\"comment\">// 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">predecessors</span>: p, <span class=\"comment\">// 顶点 u 的前溯点 p[u]</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DFSVisit = <span class=\"function\">(<span class=\"params\">u, color, d, f, p, time, adjList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY;</span><br><span class=\"line\">  d[u] = ++time.count; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      p[w] = u; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      DFSVisit(w, color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK;</span><br><span class=\"line\">  f[u] = ++time.count; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；<br>(2)对于所有的顶点 u，d[u] &lt; f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。<br>在这两个假设下，我们有如下的规则。<br><em>1 &lt;= d [u] &lt; f [u] &lt;= 2|V|</em><br>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间<br><img src=\"/2022/10/08/37-data-structure5/graph-10.png\" alt=\"graph-10\"></p>\n<p><strong>拓扑排序——使用深度优先搜索</strong><br><img src=\"/2022/10/08/37-data-structure5/graph-11.png\" alt=\"graph-11\"><br>有向无环图（DAG）</p>\n<p>需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）</p>\n<p><em>拓扑排序只能应用于 DAG</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = <span class=\"keyword\">new</span> Graph(<span class=\"literal\">true</span>); <span class=\"comment\">// 有向图</span></span><br><span class=\"line\">myVertices = [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  graph.addVertex(myVertices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = DFS(graph);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-12.png\" alt=\"graph-12\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fTimes = result.finished;</span><br><span class=\"line\">s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> count = <span class=\"number\">0</span>; count &lt; myVertices.length; count++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxName = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fTimes[myVertices[i]] &gt; max) &#123;</span><br><span class=\"line\">      max = fTimes[myVertices[i]];</span><br><span class=\"line\">      maxName = myVertices[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s += <span class=\"string\">&#x27; - &#x27;</span> + maxName;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> fTimes[maxName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\"><span class=\"comment\">// B - A - D - C - F - E</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h6><p><em>Dijkstra 算法</em><br>Dijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p>\n<p><img src=\"/2022/10/08/37-data-structure5/graph-13.png\" alt=\"graph-13\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dijkstra = <span class=\"function\">(<span class=\"params\">graph, src</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = INF; <span class=\"comment\">// 把所有的距离（dist）初始化为无限大</span></span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dist[src] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; 把源顶点到自己的距离设为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minDistance(dist, visited); <span class=\"comment\">// &#123;4&#125; 从尚未处理的顶点中选出距离最近的顶点</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125; 把选出的顶点标为 visited，以免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !visited[v] &amp;&amp;</span><br><span class=\"line\">        graph[u][v] !== <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        dist[u] !== INF &amp;&amp;</span><br><span class=\"line\">        dist[u] + graph[u][v] &lt; dist[v]</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到更短的路径，则更新最短路径的值</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        dist[v] = dist[u] + graph[u][v]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// 3 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4 4</span></span><br><span class=\"line\"><span class=\"comment\">// 5 6</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Floyd-Warshall 算法</strong><br>Floyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floydWarshall = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">        dist[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">isFinite</span>(graph[i][j])) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果两个顶点之间没有边，就将其表示为 Infinity</span></span><br><span class=\"line\">        dist[i][j] = <span class=\"literal\">Infinity</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为 i 到 j 可能的最短距离就是这些顶点间的权值</span></span><br><span class=\"line\">        dist[i][j] = graph[i][j]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将顶点 0 到 k 作为中间点（行&#123;5&#125;），从 i 到 j 的最短路径经过 k。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; length; k++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算通过顶点 k 的 i 和 j 之间的最短路径</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">          dist[i][j] = dist[i][k] + dist[k][j]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 0 2 4 6 4 6</span></span><br><span class=\"line\"><span class=\"comment\">// INF 0 2 4 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF 0 6 3 5</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 0 INF 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 3 0 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树(MST)\"></a>最小生成树(MST)</h6><p><strong>Prim 算法</strong><br>Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> prim = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> key = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"comment\">// 把所有顶点（key）初始化为无限大</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    key[i] = INF;</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1</span></span><br><span class=\"line\">  key[<span class=\"number\">0</span>] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  parent[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minKey(graph, key, visited); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        parent[v] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        key[v] = graph[u][v]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, key, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist[key].length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[key][v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[key][v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Edge Weight</span></span><br><span class=\"line\"><span class=\"comment\">// 0 - 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 2 2</span></span><br><span class=\"line\"><span class=\"comment\">// 5 - 3 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 4 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4 - 5 2</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Kruskal 算法</strong><br>是一种求加权无向连通图的 MST 的贪心算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> kruskal = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> u;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> v;</span><br><span class=\"line\">  <span class=\"comment\">// 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> cost = initializeCost(graph); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 当 MST 的边数小于顶点总数减 1 时</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ne &lt; length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出权值最小的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class=\"line\">          min = cost[i][j];</span><br><span class=\"line\">          a = u = i;</span><br><span class=\"line\">          b = v = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查 MST 中是否已存在这条边，以避免环路</span></span><br><span class=\"line\">    u = find(u, parent); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    v = find(v, parent); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 u 和 v 是不同的边，则将其加入 MST</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (union(u, v, parent)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      ne++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ：从列表中移除这些边，以免重复计算</span></span><br><span class=\"line\">    cost[a][b] = cost[b][a] = INF; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> find = <span class=\"function\">(<span class=\"params\">i, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (parent[i]) &#123;</span><br><span class=\"line\">    i = parent[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> union = <span class=\"function\">(<span class=\"params\">i, j, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i !== j) &#123;</span><br><span class=\"line\">    parent[j] = i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"二叉堆和堆排序\"><a href=\"#二叉堆和堆排序\" class=\"headerlink\" title=\"二叉堆和堆排序\"></a>二叉堆和堆排序</h4><h6 id=\"二叉堆数据结构\"><a href=\"#二叉堆数据结构\" class=\"headerlink\" title=\"二叉堆数据结构\"></a>二叉堆数据结构</h6><p>(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。<br>(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性<br><img src=\"/2022/10/08/37-data-structure5/heat.png\" alt=\"heat\"></p>\n<p>二叉树有两种表示方式<br>第一种是使用一个动态的表示方式，也就是指针（用节点表示）<br>第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。<br><img src=\"/2022/10/08/37-data-structure5/min-heat.png\" alt=\"min-heat\"></p>\n<p>访问使用普通数组的二叉树节点:<br>它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；<br>它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；<br>它的父节点位置是 index / 2（如果位置可用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.heap = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getLeftIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getRightIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getParentIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor((index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.heap.push(value); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftUp(<span class=\"built_in\">this</span>.heap.length - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 上移操作</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftUp</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      index &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[parent], <span class=\"built_in\">this</span>.heap[index]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, parent, index); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      index = parent;</span><br><span class=\"line\">      parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> temp = array[a]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[a] = array[b]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[b] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">findMinimum</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.isEmpty() ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">this</span>.heap[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">extract</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> removedValue = <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.siftDown(<span class=\"number\">0</span>); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> removedValue; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftDown</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = index;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = <span class=\"built_in\">this</span>.getLeftIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = <span class=\"built_in\">this</span>.getRightIndex(index); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> size = <span class=\"built_in\">this</span>.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      left &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[left]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      element = left; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      right &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[right]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      element = right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== element) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, index, element); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftDown(element); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/min-heat-pic.png\" alt=\"min-heat-pic\"></p>\n<p><strong>创建最大堆类</strong><br>MaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有&gt;（大于）的比较换成&lt;（小于）的比较。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverseCompare</span>(<span class=\"params\">compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> compareFn(b, a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxHeap</span> <span class=\"keyword\">extends</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = reverseCompare(compareFn); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆排序算法</strong><br>(1) 用数组创建一个最大堆用作源数据。<br>(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。<br>(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> heapSize = array.length;</span><br><span class=\"line\">  buildMaxHeap(array, compareFn); <span class=\"comment\">// 步骤 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (heapSize &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    swap(array, <span class=\"number\">0</span>, --heapSize); <span class=\"comment\">// 步骤 2</span></span><br><span class=\"line\">    heapify(array, <span class=\"number\">0</span>, heapSize, compareFn); <span class=\"comment\">// 步骤 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildMaxHeap</span>(<span class=\"params\">array, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(array.length / <span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i -= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    heapify(array, i, array.length, compareFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>heapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法<br><img src=\"/2022/10/08/37-data-structure5/heap-sort.png\" alt=\"heap-sort\"></p>\n<p><strong>堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。</strong></p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><h6 id=\"图的相关术语\"><a href=\"#图的相关术语\" class=\"headerlink\" title=\"图的相关术语\"></a>图的相关术语</h6><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）<br>G = (V, E)<br>V: 一组顶点<br>E: 一组边，连接 V 中的顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-1.png\" alt=\"graph-1\"></p>\n<p>由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。<br>一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。<br>路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。<br>简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。<br>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p>\n<p><strong>有向图和无向图</strong><br>图可以是无向的（边没有方向）或是有向的（有向图）。<br>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。<br><img src=\"/2022/10/08/37-data-structure5/graph-2.png\" alt=\"graph-2\"><br>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。<br><img src=\"/2022/10/08/37-data-structure5/graph-3.png\" alt=\"graph-3\"></p>\n<h6 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h6><p><strong>邻接矩阵</strong><br>每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-4.png\" alt=\"graph-4\"><br><em>缺点：</em><br>(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。<br>(2)顶点的数量可能会改变，而二维数组不太灵活</p>\n<p><strong>邻接表</strong><br>邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。<br>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表<br><img src=\"/2022/10/08/37-data-structure5/graph-5.png\" alt=\"graph-5\"></p>\n<p><strong>关联矩阵</strong><br>在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-6.png\" alt=\"graph-6\"><br><em>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存</em></p>\n<h6 id=\"创建-Graph-类\"><a href=\"#创建-Graph-类\" class=\"headerlink\" title=\"创建 Graph 类\"></a>创建 Graph 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">isDirected = <span class=\"literal\">false</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示图是否有向</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDirected = isDirected; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  所有顶点的名字</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.vertices = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  字典将会使用顶点的名字作为键，邻接顶点列表作为值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  一个用来向图中添加一个新的顶点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addVertex</span>(<span class=\"params\">v</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.vertices.includes(v)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.vertices.push(v); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.set(v, []); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 来添加顶点之间的边</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addEdge</span>(<span class=\"params\">v, w</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(v)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(v); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(w)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(w); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList.get(v).push(w); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isDirected) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.get(w).push(v); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取顶点列表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getVertices</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.vertices;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取邻接表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getAdjList</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.adjList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.vertices.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      s += <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.vertices[i]&#125;</span> -&gt; `</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> neighbors = <span class=\"built_in\">this</span>.adjList.get(<span class=\"built_in\">this</span>.vertices[i]); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">        s += <span class=\"string\">`<span class=\"subst\">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      s += <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h6><p><em>作用：</em>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。<br>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>\n<p><strong>广度优先搜索（breadth-first search，BFS）</strong><br><strong>深度优先搜索（depth-first search，DFS）</strong><br><em>不同点：</em>待访问顶点列表的数据结构<br>| 算 法        | 数据结构 | 描 述                                                          |<br>| ———— | ——– | ————————————————————– |<br>| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |<br>| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 白色：表示该顶点还没有被访问。</span></span><br><span class=\"line\"><span class=\"comment\">// 灰色：表示该顶点被访问过，但并未被探索过。</span></span><br><span class=\"line\"><span class=\"comment\">// 黑色：表示该顶点被访问过且被完全探索过</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Colors = &#123;</span><br><span class=\"line\">  <span class=\"attr\">WHITE</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">GREY</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">BLACK</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化每个顶点的颜色</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initializeColor = <span class=\"function\">(<span class=\"params\">vertices</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    color[vertices[i]] = Colors.WHITE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>广度优先搜索</strong><br>从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-7.png\" alt=\"graph-7\"><br><em>步骤</em><br>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：</p>\n<ul>\n<li>(a) 将 u 从 Q 中出队列；</li>\n<li>(b) 标注 u 为被发现的（灰色）；</li>\n<li>(c) 将 u 所有未被访问过的邻点（白色）入队列；</li>\n<li>(d) 标注 u 为已被探索的（黑色）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> breadthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue(); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 发现了节点，但尚未完成探索</span></span><br><span class=\"line\">    color[u] = Colors.GREY; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        color[w] = Colors.GREY; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        queue.enqueue(w); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 可选回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      callback(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> printVertex = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Visited vertex: &#x27;</span> + value); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">breadthFirstSearch(graph, myVertices[<span class=\"number\">0</span>], printVertex);</span><br></pre></td></tr></table></figure>\n\n<p><em>使用 BFS 寻找最短路径</em><br>给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BFS = <span class=\"function\">(<span class=\"params\">graph, startVertex</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> distances = &#123;&#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> predecessors = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    distances[vertices[i]] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    predecessors[vertices[i]] = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">    color[u] = Colors.GREY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        color[w] = Colors.GREY;</span><br><span class=\"line\">        distances[w] = distances[u] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        predecessors[w] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        queue.enqueue(w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    distances, <span class=\"comment\">// 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]</span></span><br><span class=\"line\">    predecessors, <span class=\"comment\">// 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shortestPathA = BFS(graph, myVertices[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shortestPathA);</span><br><span class=\"line\"><span class=\"comment\">// distances: &#123;A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// predecessors: &#123;A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G: &quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fromVertex = myVertices[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> toVertex = myVertices[i]; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 创建一个栈</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"keyword\">new</span> Stack(); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    path.push(v); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  path.push(fromVertex); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> s = path.pop(); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!path.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">    s += <span class=\"string\">&#x27; - &#x27;</span> + path.pop(); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// A - B</span></span><br><span class=\"line\"><span class=\"comment\">// A - C</span></span><br><span class=\"line\"><span class=\"comment\">// A - D</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - F</span></span><br><span class=\"line\"><span class=\"comment\">// A - C - G</span></span><br><span class=\"line\"><span class=\"comment\">// A - D - H</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E - I</span></span><br></pre></td></tr></table></figure>\n\n<p><em>深入学习最短路径算法</em><br>Dijkstra 算法解决了单源最短路径问题。<br>Bellman-Ford 算法解决了边权值为负的单源最短路径问题。<br>A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。<br>Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题</p>\n<p><strong>深度优先搜索</strong><br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-8.png\" alt=\"graph-8\"></p>\n<p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。<br><em>步骤</em><br>(1) 标注 v 为被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）。</p>\n<p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(vertices[i], color, adjList, callback); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearchVisit = <span class=\"function\">(<span class=\"params\">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    callback(u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(w, color, adjList, callback); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">depthFirstSearch(graph, printVertex);</span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: A</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: B</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: E</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: I</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: F</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: C</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: D</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: G</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: H</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-9.png\" alt=\"graph-9\"></p>\n<p><em>Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。</em></p>\n<p><em>探索深度优先算法</em><br>对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DFS = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> d = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    f[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    d[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    p[vertices[i]] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      DFSVisit(vertices[i], color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">discovery</span>: d, <span class=\"comment\">// 顶点 u 的发现时间 d[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">finished</span>: f, <span class=\"comment\">// 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">predecessors</span>: p, <span class=\"comment\">// 顶点 u 的前溯点 p[u]</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DFSVisit = <span class=\"function\">(<span class=\"params\">u, color, d, f, p, time, adjList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY;</span><br><span class=\"line\">  d[u] = ++time.count; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      p[w] = u; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      DFSVisit(w, color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK;</span><br><span class=\"line\">  f[u] = ++time.count; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；<br>(2)对于所有的顶点 u，d[u] &lt; f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。<br>在这两个假设下，我们有如下的规则。<br><em>1 &lt;= d [u] &lt; f [u] &lt;= 2|V|</em><br>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间<br><img src=\"/2022/10/08/37-data-structure5/graph-10.png\" alt=\"graph-10\"></p>\n<p><strong>拓扑排序——使用深度优先搜索</strong><br><img src=\"/2022/10/08/37-data-structure5/graph-11.png\" alt=\"graph-11\"><br>有向无环图（DAG）</p>\n<p>需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）</p>\n<p><em>拓扑排序只能应用于 DAG</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = <span class=\"keyword\">new</span> Graph(<span class=\"literal\">true</span>); <span class=\"comment\">// 有向图</span></span><br><span class=\"line\">myVertices = [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  graph.addVertex(myVertices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = DFS(graph);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-12.png\" alt=\"graph-12\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fTimes = result.finished;</span><br><span class=\"line\">s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> count = <span class=\"number\">0</span>; count &lt; myVertices.length; count++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxName = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fTimes[myVertices[i]] &gt; max) &#123;</span><br><span class=\"line\">      max = fTimes[myVertices[i]];</span><br><span class=\"line\">      maxName = myVertices[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s += <span class=\"string\">&#x27; - &#x27;</span> + maxName;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> fTimes[maxName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\"><span class=\"comment\">// B - A - D - C - F - E</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h6><p><em>Dijkstra 算法</em><br>Dijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p>\n<p><img src=\"/2022/10/08/37-data-structure5/graph-13.png\" alt=\"graph-13\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dijkstra = <span class=\"function\">(<span class=\"params\">graph, src</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = INF; <span class=\"comment\">// 把所有的距离（dist）初始化为无限大</span></span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dist[src] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; 把源顶点到自己的距离设为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minDistance(dist, visited); <span class=\"comment\">// &#123;4&#125; 从尚未处理的顶点中选出距离最近的顶点</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125; 把选出的顶点标为 visited，以免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !visited[v] &amp;&amp;</span><br><span class=\"line\">        graph[u][v] !== <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        dist[u] !== INF &amp;&amp;</span><br><span class=\"line\">        dist[u] + graph[u][v] &lt; dist[v]</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到更短的路径，则更新最短路径的值</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        dist[v] = dist[u] + graph[u][v]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// 3 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4 4</span></span><br><span class=\"line\"><span class=\"comment\">// 5 6</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Floyd-Warshall 算法</strong><br>Floyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floydWarshall = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">        dist[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">isFinite</span>(graph[i][j])) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果两个顶点之间没有边，就将其表示为 Infinity</span></span><br><span class=\"line\">        dist[i][j] = <span class=\"literal\">Infinity</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为 i 到 j 可能的最短距离就是这些顶点间的权值</span></span><br><span class=\"line\">        dist[i][j] = graph[i][j]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将顶点 0 到 k 作为中间点（行&#123;5&#125;），从 i 到 j 的最短路径经过 k。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; length; k++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算通过顶点 k 的 i 和 j 之间的最短路径</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">          dist[i][j] = dist[i][k] + dist[k][j]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 0 2 4 6 4 6</span></span><br><span class=\"line\"><span class=\"comment\">// INF 0 2 4 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF 0 6 3 5</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 0 INF 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 3 0 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树(MST)\"></a>最小生成树(MST)</h6><p><strong>Prim 算法</strong><br>Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> prim = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> key = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"comment\">// 把所有顶点（key）初始化为无限大</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    key[i] = INF;</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1</span></span><br><span class=\"line\">  key[<span class=\"number\">0</span>] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  parent[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minKey(graph, key, visited); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        parent[v] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        key[v] = graph[u][v]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, key, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist[key].length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[key][v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[key][v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Edge Weight</span></span><br><span class=\"line\"><span class=\"comment\">// 0 - 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 2 2</span></span><br><span class=\"line\"><span class=\"comment\">// 5 - 3 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 4 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4 - 5 2</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Kruskal 算法</strong><br>是一种求加权无向连通图的 MST 的贪心算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> kruskal = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> u;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> v;</span><br><span class=\"line\">  <span class=\"comment\">// 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> cost = initializeCost(graph); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 当 MST 的边数小于顶点总数减 1 时</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ne &lt; length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出权值最小的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class=\"line\">          min = cost[i][j];</span><br><span class=\"line\">          a = u = i;</span><br><span class=\"line\">          b = v = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查 MST 中是否已存在这条边，以避免环路</span></span><br><span class=\"line\">    u = find(u, parent); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    v = find(v, parent); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 u 和 v 是不同的边，则将其加入 MST</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (union(u, v, parent)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      ne++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ：从列表中移除这些边，以免重复计算</span></span><br><span class=\"line\">    cost[a][b] = cost[b][a] = INF; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> find = <span class=\"function\">(<span class=\"params\">i, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (parent[i]) &#123;</span><br><span class=\"line\">    i = parent[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> union = <span class=\"function\">(<span class=\"params\">i, j, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i !== j) &#123;</span><br><span class=\"line\">    parent[j] = i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"浏览器渲染","date":"2022-05-23T06:13:56.000Z","_content":"\n## 渲染流程\n(1)深度遍历解析HTML建立DOM树\n(2)解析CSS建立CSSOM树\n(3)依据DOM树和CSSOM树构造Render树\n(4)计算各元素尺寸、位置\n(5)绘制页面像素信息\n(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上\n(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)\n## GUI渲染线程\n(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等\n(2)重排/重绘\n--1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。\n--2、任何页面布局和几何属性的改变都会触发重排，比如：\n页面渲染初始化；(无法避免)\n添加或删除可见的DOM元素；\n元素位置的改变；\n改变元素尺寸（宽、高、内外边距、边框等）；\n浏览器窗口尺寸的变化（resize事件发生时）；\n填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；\n读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)\n--3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。\n--4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。\n## JS引擎线程\n(1)解析Javascript脚本，单线程执行\n(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞\n## 事件触发线程\n(1)归属于浏览器而不是JS引擎，用来控制事件循环\n(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理\n## 定时触发器线程\n(1)setInterval与setTimeout所在线程\n(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确\n(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行\n## 异步http请求线程\n(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n## 实现hover等鼠标操作\n![hover](hover.png)\n\n## 使用performance分析页面性能\n![performance](performance.png)\n\n## 使用network调试\n![network](network.png)\n- preserve log 保留之前的请求\n","source":"_posts/4-browser-render.md","raw":"---\ntitle: 浏览器渲染\ndate: 2022-05-23 14:13:56\ntags:\n---\n\n## 渲染流程\n(1)深度遍历解析HTML建立DOM树\n(2)解析CSS建立CSSOM树\n(3)依据DOM树和CSSOM树构造Render树\n(4)计算各元素尺寸、位置\n(5)绘制页面像素信息\n(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上\n(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)\n## GUI渲染线程\n(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等\n(2)重排/重绘\n--1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。\n--2、任何页面布局和几何属性的改变都会触发重排，比如：\n页面渲染初始化；(无法避免)\n添加或删除可见的DOM元素；\n元素位置的改变；\n改变元素尺寸（宽、高、内外边距、边框等）；\n浏览器窗口尺寸的变化（resize事件发生时）；\n填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；\n读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)\n--3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。\n--4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。\n## JS引擎线程\n(1)解析Javascript脚本，单线程执行\n(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞\n## 事件触发线程\n(1)归属于浏览器而不是JS引擎，用来控制事件循环\n(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理\n## 定时触发器线程\n(1)setInterval与setTimeout所在线程\n(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确\n(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行\n## 异步http请求线程\n(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n## 实现hover等鼠标操作\n![hover](hover.png)\n\n## 使用performance分析页面性能\n![performance](performance.png)\n\n## 使用network调试\n![network](network.png)\n- preserve log 保留之前的请求\n","slug":"4-browser-render","published":1,"updated":"2022-10-25T03:20:16.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q30011k4tt8q2ygjkr","content":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p>(1)深度遍历解析HTML建立DOM树<br>(2)解析CSS建立CSSOM树<br>(3)依据DOM树和CSSOM树构造Render树<br>(4)计算各元素尺寸、位置<br>(5)绘制页面像素信息<br>(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)</p>\n<h2 id=\"GUI渲染线程\"><a href=\"#GUI渲染线程\" class=\"headerlink\" title=\"GUI渲染线程\"></a>GUI渲染线程</h2><p>(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等<br>(2)重排/重绘<br>–1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。<br>–2、任何页面布局和几何属性的改变都会触发重排，比如：<br>页面渲染初始化；(无法避免)<br>添加或删除可见的DOM元素；<br>元素位置的改变；<br>改变元素尺寸（宽、高、内外边距、边框等）；<br>浏览器窗口尺寸的变化（resize事件发生时）；<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)<br>–3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。<br>–4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。</p>\n<h2 id=\"JS引擎线程\"><a href=\"#JS引擎线程\" class=\"headerlink\" title=\"JS引擎线程\"></a>JS引擎线程</h2><p>(1)解析Javascript脚本，单线程执行<br>(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞</p>\n<h2 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h2><p>(1)归属于浏览器而不是JS引擎，用来控制事件循环<br>(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理</p>\n<h2 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h2><p>(1)setInterval与setTimeout所在线程<br>(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确<br>(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行</p>\n<h2 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步http请求线程</h2><p>(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n<h2 id=\"实现hover等鼠标操作\"><a href=\"#实现hover等鼠标操作\" class=\"headerlink\" title=\"实现hover等鼠标操作\"></a>实现hover等鼠标操作</h2><p><img src=\"/2022/05/23/4-browser-render/hover.png\" alt=\"hover\"></p>\n<h2 id=\"使用performance分析页面性能\"><a href=\"#使用performance分析页面性能\" class=\"headerlink\" title=\"使用performance分析页面性能\"></a>使用performance分析页面性能</h2><p><img src=\"/2022/05/23/4-browser-render/performance.png\" alt=\"performance\"></p>\n<h2 id=\"使用network调试\"><a href=\"#使用network调试\" class=\"headerlink\" title=\"使用network调试\"></a>使用network调试</h2><p><img src=\"/2022/05/23/4-browser-render/network.png\" alt=\"network\"></p>\n<ul>\n<li>preserve log 保留之前的请求</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p>(1)深度遍历解析HTML建立DOM树<br>(2)解析CSS建立CSSOM树<br>(3)依据DOM树和CSSOM树构造Render树<br>(4)计算各元素尺寸、位置<br>(5)绘制页面像素信息<br>(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)</p>\n<h2 id=\"GUI渲染线程\"><a href=\"#GUI渲染线程\" class=\"headerlink\" title=\"GUI渲染线程\"></a>GUI渲染线程</h2><p>(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等<br>(2)重排/重绘<br>–1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。<br>–2、任何页面布局和几何属性的改变都会触发重排，比如：<br>页面渲染初始化；(无法避免)<br>添加或删除可见的DOM元素；<br>元素位置的改变；<br>改变元素尺寸（宽、高、内外边距、边框等）；<br>浏览器窗口尺寸的变化（resize事件发生时）；<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)<br>–3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。<br>–4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。</p>\n<h2 id=\"JS引擎线程\"><a href=\"#JS引擎线程\" class=\"headerlink\" title=\"JS引擎线程\"></a>JS引擎线程</h2><p>(1)解析Javascript脚本，单线程执行<br>(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞</p>\n<h2 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h2><p>(1)归属于浏览器而不是JS引擎，用来控制事件循环<br>(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理</p>\n<h2 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h2><p>(1)setInterval与setTimeout所在线程<br>(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确<br>(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行</p>\n<h2 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步http请求线程</h2><p>(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n<h2 id=\"实现hover等鼠标操作\"><a href=\"#实现hover等鼠标操作\" class=\"headerlink\" title=\"实现hover等鼠标操作\"></a>实现hover等鼠标操作</h2><p><img src=\"/2022/05/23/4-browser-render/hover.png\" alt=\"hover\"></p>\n<h2 id=\"使用performance分析页面性能\"><a href=\"#使用performance分析页面性能\" class=\"headerlink\" title=\"使用performance分析页面性能\"></a>使用performance分析页面性能</h2><p><img src=\"/2022/05/23/4-browser-render/performance.png\" alt=\"performance\"></p>\n<h2 id=\"使用network调试\"><a href=\"#使用network调试\" class=\"headerlink\" title=\"使用network调试\"></a>使用network调试</h2><p><img src=\"/2022/05/23/4-browser-render/network.png\" alt=\"network\"></p>\n<ul>\n<li>preserve log 保留之前的请求</li>\n</ul>\n"},{"title":"数据结构与算法阅读笔记(7)","date":"2022-10-13T08:13:40.000Z","_content":"\n#### 算法设计与技巧\n\n###### 分而治之\n\n将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题\n\n分而治之算法可以分成三个部分。\n(1) 分解原问题为多个子问题（原问题的多个小实例）。\n(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。\n(3) 组合这些子问题的解决方式，得到原问题的解。\n\n**二分搜索**\n分解：计算 mid 并搜索数组较小或较大的一半。\n解决：在较小或较大的一半中搜索值。\n合并：这步不需要，因为我们直接返回了索引值。\n\n```javascript\nfunction binarySearchRecursive(\n  array,\n  value,\n  low,\n  high,\n  compareFn = defaultCompare\n) {\n  if (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const element = array[mid];\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {1}\n      return binarySearchRecursive(array, value, mid + 1, high, compareFn);\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {2}\n      return binarySearchRecursive(array, value, low, mid - 1, compareFn);\n    } else {\n      return mid; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\nexport function binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array);\n  const low = 0;\n  const high = sortedArray.length - 1;\n  return binarySearchRecursive(array, value, low, high, compareFn);\n}\n```\n\n![technology-1](technology-1.png)\n\n**动态规划**\n动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。\n\n_注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。_\n\n步骤：\n(1) 定义子问题；\n(2) 实现要反复执行来解决子问题的部分；\n(3) 识别并求解出基线条件。\n\n_能用动态规划解决的一些著名问题如下。_\n(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。\n(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。\n(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。\n(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。\n(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)\n\n_最少硬币找零问题_\n最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。\n\n```javascript\n// coins 硬币面额的数组\nfunction minCoinChange(coins, amount) {\n  const cache = []; // {1}\n  const makeChange = (value) => {\n    // {2}\n    if (!value) {\n      // {3}\n      return [];\n    }\n    if (cache[value]) {\n      // {4}\n      return cache[value];\n    }\n    let min = [];\n    let newMin;\n    let newAmount;\n    for (let i = 0; i < coins.length; i++) {\n      // {5}\n      const coin = coins[i];\n      newAmount = value - coin; // {6}\n      if (newAmount >= 0) {\n        newMin = makeChange(newAmount); // {7}\n      }\n      if (\n        newAmount >= 0 && // {8}\n        (newMin.length < min.length - 1 || !min.length) && // {9}\n        (newMin.length || !newAmount) // {10}\n      ) {\n        min = [coin].concat(newMin); // {11}\n        console.log('new Min ' + min + ' for ' + amount);\n      }\n    }\n    return (cache[value] = min); // {12}\n  };\n  return makeChange(amount); // {13}\n}\n```\n\n_背包问题_\n背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。\n\n```javascript\nfunction knapSack(capacity, weights, values, n) {\n  const kS = [];\n  // 初始化将用于寻找解决方案的矩阵\n  for (let i = 0; i <= n; i++) {\n    kS[i] = [];\n  }\n  for (let i = 0; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (i === 0 || w === 0) {\n        // {2}\n        kS[i][w] = 0;\n      } else if (weights[i - 1] <= w) {\n        // 。物品 i 的重量必须小于约束\n        const a = values[i - 1] + kS[i - 1][w - weights[i - 1]];\n        const b = kS[i - 1][w];\n        // 当找到可以构成解决方案的物品时，选择价值最大的那个\n        kS[i][w] = a > b ? a : b; // {4} max(a,b)\n      } else {\n        kS[i][w] = kS[i - 1][w]; // {5}\n      }\n    }\n  }\n  findValues(n, capacity, kS, weights, values); // {6} 增加的代码\n  return kS[n][capacity]; // {7}\n}\n\nfunction findValues(n, capacity, kS, weights, values) {\n  let i = n;\n  let k = capacity;\n  console.log('构成解的物品：');\n  while (i > 0 && k > 0) {\n    if (kS[i][k] !== kS[i - 1][k]) {\n      console.log(\n        `物品 ${i} 可以是解的一部分 w,v: ${weights[i - 1]}, ${values[i - 1]}`\n      );\n      i--;\n      k -= kS[i][k];\n    } else {\n      i--;\n    }\n  }\n}\n```\n\n![technology-2](technology-2.png)\n\n_最长公共子序列(LCS)_\n找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。\n![technology-3](technology-3.png)\n\n```javascript\nfunction lcs(wordX, wordY) {\n  const m = wordX.length;\n  const n = wordY.length;\n  const l = [];\n  for (let i = 0; i <= m; i++) {\n    l[i] = []; // {1}\n    // solution[i] = [];\n    for (let j = 0; j <= n; j++) {\n      l[i][j] = 0; // {2}\n      // solution[i][j] = '0';\n    }\n  }\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      if (i === 0 || j === 0) {\n        l[i][j] = 0;\n      } else if (wordX[i - 1] === wordY[j - 1]) {\n        l[i][j] = l[i - 1][j - 1] + 1; // {3}\n        // solution[i][j] = 'diagonal';\n      } else {\n        const a = l[i - 1][j];\n        const b = l[i][j - 1];\n        l[i][j] = a > b ? a : b; // {4} max(a,b)\n        // solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';\n      }\n    }\n  }\n  return l[m][n]; // {5}\n  // printSolution(solution, wordX, m, n);\n}\n\nfunction printSolution(solution, wordX, m, n) {\n  let a = m;\n  let b = n;\n  let x = solution[a][b];\n  let answer = '';\n  while (x !== '0') {\n    if (solution[a][b] === 'diagonal') {\n      answer = wordX[a - 1] + answer;\n      a--;\n      b--;\n    } else if (solution[a][b] === 'left') {\n      b--;\n    } else if (solution[a][b] === 'top') {\n      a--;\n    }\n    x = solution[a][b];\n  }\n  console.log('lcs: ' + answer);\n}\n```\n\n![technology-4](technology-4.png)\n\n_矩阵链相乘_\n要找出一组矩阵相乘的最佳方式（顺序）\n\nA*B*C\\*D 的乘法\n\nA 是一个 10 行 100 列的矩阵；\nB 是一个 100 行 5 列的矩阵；\nC 是一个 5 行 50 列的矩阵；\nD 是一个 50 行 1 列的矩阵；\nA*B*C\\*D 的结果是一个 10 行 1 列的矩阵\n\n(1) (A(B(CD)))：乘法运算的次数是 1750 次。\n(2) ((AB)(CD))：乘法运算的次数是 5300 次。\n(3) (((AB)C)D)：乘法运算的次数是 8000 次。\n(4) ((A(BC))D)：乘法运算的次数是 75 500 次。\n(5) (A((BC)D))：乘法运算的次数是 31 000 次。\n\n```javascript\nfunction matrixChainOrder(p) {\n  const n = p.length;\n  const m = [];\n  const s = [];\n  for (let i = 1; i <= n; i++) {\n    m[i] = [];\n    m[i][i] = 0;\n  }\n\n  //   const s = [];\n  // for (let i = 0; i <= n; i++){\n  //  s[i] = [];\n  //  for (let j=0; j <= n; j++){\n  //  s[i][j] = 0;\n  //  }\n  // }\n\n  for (let l = 2; l < n; l++) {\n    for (let i = 1; i <= n - l + 1; i++) {\n      const j = i + l - 1;\n      m[i][j] = Number.MAX_SAFE_INTEGER;\n      for (let k = i; k <= j - 1; k++) {\n        const q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // {1}\n        if (q < m[i][j]) {\n          m[i][j] = q; // {2}\n          // s[i][j] = k;\n        }\n      }\n    }\n  }\n  return m[1][n - 1]; // {3}\n  // printOptimalParenthesis(s, 1, n-1);\n}\n\nfunction printOptimalParenthesis(s, i, j) {\n  if (i === j) {\n    console.log('A[' + i + ']');\n  } else {\n    console.log('(');\n    printOptimalParenthesis(s, i, s[i][j]);\n    printOptimalParenthesis(s, s[i][j] + 1, j);\n    console.log(')');\n  }\n}\n// (A[1](A[2](A[3]A[4]))) => (A(B(CD)))\n```\n\n###### 贪心算法\n\n贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。\n\n**最少硬币找零问题**\n\n```javascript\nfunction minCoinChange(coins, amount) {\n  const change = [];\n  let total = 0;\n  for (let i = coins.length; i >= 0; i--) {\n    // {1}\n    const coin = coins[i];\n    while (total + coin <= amount) {\n      // {2}\n      change.push(coin); // {3}\n      total += coin; // {4}\n    }\n  }\n  return change;\n}\n```\n\n![technology-5](technology-5.png)\n\n_比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。_\n\n**分数背包问题**\n\n```javascript\nfunction knapSack(capacity, weights, values) {\n  const n = values.length;\n  let load = 0;\n  let val = 0;\n  for (let i = 0; i < n && load < capacity; i++) {\n    // {1}\n    if (weights[i] <= capacity - load) {\n      // {2}\n      val += values[i];\n      load += weights[i];\n    } else {\n      const r = (capacity - load) / weights[i]; // {3}\n      val += r * values[i];\n      load += weights[i];\n    }\n  }\n  return val;\n}\n```\n\n###### 回溯算法\n\n回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。\n\n**迷宫老鼠问题**\n\n```javascript\nexport function ratInAMaze(maze) {\n  const solution = [];\n  // 每个位置初始化为零\n  for (let i = 0; i < maze.length; i++) {\n    // {1}\n    solution[i] = [];\n    for (let j = 0; j < maze[i].length; j++) {\n      solution[i][j] = 0;\n    }\n  }\n  if (findPath(maze, 0, 0, solution) === true) {\n    // {2}\n    return solution;\n  }\n  return 'NO PATH FOUND'; // {3}\n}\n\nfunction findPath(maze, x, y, solution) {\n  const n = maze.length;\n  if (x === n - 1 && y === n - 1) {\n    // {4}\n    solution[x][y] = 1;\n    return true;\n  }\n  if (isSafe(maze, x, y) === true) {\n    // {5}\n    solution[x][y] = 1; // {6}\n    if (findPath(maze, x + 1, y, solution)) {\n      // {7}\n      return true;\n    }\n    if (findPath(maze, x, y + 1, solution)) {\n      // {8}\n      return true;\n    }\n    solution[x][y] = 0; // {9}\n    return false;\n  }\n  return false; // {10}\n}\n\nfunction isSafe(maze, x, y) {\n  const n = maze.length;\n  if (x >= 0 && y >= 0 && x < n && y < n && maze[x][y] !== 0) {\n    return true; // {11}\n  }\n  return false;\n}\n\nconst maze = [\n  [1, 0, 0, 0],\n  [1, 1, 1, 1],\n  [0, 0, 1, 0],\n  [0, 1, 1, 1],\n];\nconsole.log(ratInAMaze(maze));\n[\n  [1, 0, 0, 0],\n  [1, 1, 1, 0],\n  [0, 0, 1, 0],\n  [0, 0, 1, 1],\n];\n```\n\n**数独解题器**\n\n```javascript\nfunction sudokuSolver(matrix) {\n  if (solveSudoku(matrix) === true) {\n    return matrix;\n  }\n  return '问题无解！';\n}\n\nconst UNASSIGNED = 0;\nfunction solveSudoku(matrix) {\n  let row = 0;\n  let col = 0;\n  let checkBlankSpaces = false;\n  for (row = 0; row < matrix.length; row++) {\n    // {1}\n    for (col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] === UNASSIGNED) {\n        checkBlankSpaces = true; // {2}\n        break;\n      }\n    }\n    if (checkBlankSpaces === true) {\n      // {3}\n      break;\n    }\n  }\n  if (checkBlankSpaces === false) {\n    return true; // {4}\n  }\n  for (let num = 1; num <= 9; num++) {\n    // {5}\n    if (isSafe(matrix, row, col, num)) {\n      // {6}\n      matrix[row][col] = num; // {7}\n      if (solveSudoku(matrix)) {\n        // {8}\n        return true;\n      }\n      matrix[row][col] = UNASSIGNED; // {9}\n    }\n  }\n  return false; // {10}\n}\nfunction isSafe(matrix, row, col, num) {\n  return (\n    !usedInRow(matrix, row, num) &&\n    !usedInCol(matrix, col, num) &&\n    !usedInBox(matrix, row - (row % 3), col - (col % 3), num)\n  );\n}\n\nfunction usedInRow(matrix, row, num) {\n  for (let col = 0; col < matrix.length; col++) {\n    // {11}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInCol(matrix, col, num) {\n  for (let row = 0; row < matrix.length; row++) {\n    // {12}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInBox(matrix, boxStartRow, boxStartCol, num) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (matrix[row + boxStartRow][col + boxStartCol] === num) {\n        // {13}\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst sudokuGrid = [\n  [5, 3, 0, 0, 7, 0, 0, 0, 0],\n  [6, 0, 0, 1, 9, 5, 0, 0, 0],\n  [0, 9, 8, 0, 0, 0, 0, 6, 0],\n  [8, 0, 0, 0, 6, 0, 0, 0, 3],\n  [4, 0, 0, 8, 0, 3, 0, 0, 1],\n  [7, 0, 0, 0, 2, 0, 0, 0, 6],\n  [0, 6, 0, 0, 0, 0, 2, 8, 0],\n  [0, 0, 0, 4, 1, 9, 0, 0, 5],\n  [0, 0, 0, 0, 8, 0, 0, 7, 9],\n];\nconsole.log(sudokuSolver(sudokuGrid));\n[\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9],\n];\n```\n\n###### 函数式编程(FP)简介\n\n**函数式编程与命令式编程**\n\n```javascript\n// 命令式编程\nconst printArray = function (array) {\n  for (var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n  }\n};\nprintArray([1, 2, 3, 4, 5]);\n\n// 函数式编程\nconst forEach = function (array, action) {\n  for (var i = 0; i < array.length; i++) {\n    action(array[i]);\n  }\n};\nconst logItem = function (item) {\n  console.log(item);\n};\nforEach([1, 2, 3, 4, 5], logItem);\n```\n\n_注意：_\n(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。\n(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。\n(3)函数和数据集合是函数式编程的核心。\n(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。\n(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。\n\n**JavaScript 函数式类库和数据结构**\nUnderscode.js：http://underscorejs.org/\nBilby.js：http://bilby.brianmckenna.org/\nLazy.js：http://danieltao.com/lazy.js/\nBacon.js：https://baconjs.github.io/\nFn.js：http://eliperelman.com/fn.js/\nFunctional.js：http://functionaljs.com/\nRamda.js：http://ramdajs.com/0.20.1/index.html\nMori：http://swannodette.github.io/mori/\n\nJavaScript 函数式编程：https://www.packtpub.com/web-development/functional-programming-javascript\n\n#### 算法复杂度\n\n###### 大 O 表示法\n\n用于描述算法的性能和复杂程度。\n大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。\n\n| 符 号        | 名 称        |\n| ------------ | ------------ |\n| O(1)         | 常数的       |\n| O(log(n))    | 对数的       |\n| O((log(n))c) | 对数多项式的 |\n| O(n)         | 线性的       |\n| O(n^2)       | 二次的       |\n| O(n^c)       | 多项式的     |\n| O(c^n)       | 指数的       |\n\n**理解大 O 表示法**\n\n衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。\n\n1. O(1)\n\n```javascript\nfunction increment(num) {\n  return ++num;\n}\n```\n\n假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）\n\n2. O(n)\n\n函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。\n\n以顺序搜索算法为例\n\n```javascript\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    if (equalsFn(value, array[i])) {\n      // {1}\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  let cost = 0;\n  for (let i = 0; i < array.length; i++) {\n    cost++;\n    if (equalsFn(value, array[i])) {\n      return i;\n    }\n  }\n  console.log(\n    `cost for sequentialSearch with input size ${array.length} is ${cost}`\n  );\n  return -1;\n}\n```\n\n3. O(n^2)\n\n以冒泡排序为例\n\n```javascript\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n\n// 假设行{1}和行{2}的开销分别是 1。修改算法的实现使之计算开销。\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  let cost = 0;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    cost++;\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      cost++;\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  console.log(`cost for bubbleSort with input size ${length} is ${cost}`);\n  return array;\n}\n```\n\n如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久\n\n*时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)*\n\n**时间复杂度比较**\n\n| 输入大小（n） | O(1) | O(log(n)) | O(n)   | O(nlog(n)) | O(n^2)      | O(2^n)    |\n| ------------- | ---- | --------- | ------ | ---------- | ----------- | --------- |\n| 10            | 1    | 1         | 10     | 10         | 100         | 1024      |\n| 20            | 1    | 1.30      | 20     | 26.02      | 400         | 1 048 576 |\n| 50            | 1    | 1.69      | 50     | 84.94      | 2500        | 非常大    |\n| 100           | 1    | 2         | 100    | 200        | 10 000      | 非常大    |\n| 500           | 1    | 2.69      | 500    | 1349.48    | 250 000     | 非常大    |\n| 1000          | 1    | 3         | 1000   | 3000       | 1 000 000   | 非常大    |\n| 10 000        | 1    | 4         | 10 000 | 40 000     | 100 000 000 | 非常大    |\n\n不同的大 O 表示法的消耗\n\n![big-o-1](big-o-1.png)\n\n*常用数据结构的时间复杂度*\n![big-o-2](big-o-2.png)\n\n*图的时间复杂度*\n![big-o-3](big-o-3.png)\n\n*排序算法的时间复杂度*\n![big-o-4](big-o-4.png)\n\n*搜索算法的时间复杂度*\n![big-o-5](big-o-5.png)\n\n**NP 完全理论概述**\n一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.\n\n对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）\n\nNP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP\n\n如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。\n\nNP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：\n(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；\n(2) 所有的 NP 问题都能在多项式时间内归约为 L。\n\n为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。\n\n还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。\n\n下面是满足 P<>NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。\n![big-o-6](big-o-6.png)\n\n非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。\n\nNP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。\n\n以上问题，具体可查看：https://en.wikipedia.org/wiki/NP-completeness\n\n*不可解问题与启发式算法*\n有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。\n启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。\n启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。\n详情请查阅 https://en.wikipedia.org/wiki/Heuristic_(computer_science)\n\nUVa Online Judge（http://uva.onlinejudge.org/）\nSphere Online Judge（http://www.spoj.com/）\nCoderbyte（http://coderbyte.com/）\nProject Euler（https://projecteuler.net/）\nHackerRank（https://www.hackerrank.com）\nCodeChef（http://www.codechef.com/）\nTop Coder（http://www.topcoder.com/）\n\n\n#### 疑问点\n尾调用优化\n- 调用栈长\n- 使用后性能有较大的提升\nFloyd-Warshall 算法\nKruskal 算法\n背包问题\n最长公共子序列\n矩阵链相乘\nNP 完全理论\n- 多项式时间\n\n算法的使用，什么情况下用合适？需要将数据转换处理\n合适\n\n自己写的算法怎么验证正确性？\nLeetCode或其他刷题网站\n\nantd升级后的visible修改任务\n评估修改时间\ntesting-library/react测试react组件的库，安装了却没用？\numc-ui的项目框架使用的是别的项目的，原来就有，没删","source":"_posts/39-data-structure7.md","raw":"---\ntitle: 数据结构与算法阅读笔记(7)\ndate: 2022-10-13 16:13:40\ntags:\n---\n\n#### 算法设计与技巧\n\n###### 分而治之\n\n将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题\n\n分而治之算法可以分成三个部分。\n(1) 分解原问题为多个子问题（原问题的多个小实例）。\n(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。\n(3) 组合这些子问题的解决方式，得到原问题的解。\n\n**二分搜索**\n分解：计算 mid 并搜索数组较小或较大的一半。\n解决：在较小或较大的一半中搜索值。\n合并：这步不需要，因为我们直接返回了索引值。\n\n```javascript\nfunction binarySearchRecursive(\n  array,\n  value,\n  low,\n  high,\n  compareFn = defaultCompare\n) {\n  if (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const element = array[mid];\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {1}\n      return binarySearchRecursive(array, value, mid + 1, high, compareFn);\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {2}\n      return binarySearchRecursive(array, value, low, mid - 1, compareFn);\n    } else {\n      return mid; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\nexport function binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array);\n  const low = 0;\n  const high = sortedArray.length - 1;\n  return binarySearchRecursive(array, value, low, high, compareFn);\n}\n```\n\n![technology-1](technology-1.png)\n\n**动态规划**\n动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。\n\n_注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。_\n\n步骤：\n(1) 定义子问题；\n(2) 实现要反复执行来解决子问题的部分；\n(3) 识别并求解出基线条件。\n\n_能用动态规划解决的一些著名问题如下。_\n(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。\n(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。\n(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。\n(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。\n(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)\n\n_最少硬币找零问题_\n最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。\n\n```javascript\n// coins 硬币面额的数组\nfunction minCoinChange(coins, amount) {\n  const cache = []; // {1}\n  const makeChange = (value) => {\n    // {2}\n    if (!value) {\n      // {3}\n      return [];\n    }\n    if (cache[value]) {\n      // {4}\n      return cache[value];\n    }\n    let min = [];\n    let newMin;\n    let newAmount;\n    for (let i = 0; i < coins.length; i++) {\n      // {5}\n      const coin = coins[i];\n      newAmount = value - coin; // {6}\n      if (newAmount >= 0) {\n        newMin = makeChange(newAmount); // {7}\n      }\n      if (\n        newAmount >= 0 && // {8}\n        (newMin.length < min.length - 1 || !min.length) && // {9}\n        (newMin.length || !newAmount) // {10}\n      ) {\n        min = [coin].concat(newMin); // {11}\n        console.log('new Min ' + min + ' for ' + amount);\n      }\n    }\n    return (cache[value] = min); // {12}\n  };\n  return makeChange(amount); // {13}\n}\n```\n\n_背包问题_\n背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。\n\n```javascript\nfunction knapSack(capacity, weights, values, n) {\n  const kS = [];\n  // 初始化将用于寻找解决方案的矩阵\n  for (let i = 0; i <= n; i++) {\n    kS[i] = [];\n  }\n  for (let i = 0; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (i === 0 || w === 0) {\n        // {2}\n        kS[i][w] = 0;\n      } else if (weights[i - 1] <= w) {\n        // 。物品 i 的重量必须小于约束\n        const a = values[i - 1] + kS[i - 1][w - weights[i - 1]];\n        const b = kS[i - 1][w];\n        // 当找到可以构成解决方案的物品时，选择价值最大的那个\n        kS[i][w] = a > b ? a : b; // {4} max(a,b)\n      } else {\n        kS[i][w] = kS[i - 1][w]; // {5}\n      }\n    }\n  }\n  findValues(n, capacity, kS, weights, values); // {6} 增加的代码\n  return kS[n][capacity]; // {7}\n}\n\nfunction findValues(n, capacity, kS, weights, values) {\n  let i = n;\n  let k = capacity;\n  console.log('构成解的物品：');\n  while (i > 0 && k > 0) {\n    if (kS[i][k] !== kS[i - 1][k]) {\n      console.log(\n        `物品 ${i} 可以是解的一部分 w,v: ${weights[i - 1]}, ${values[i - 1]}`\n      );\n      i--;\n      k -= kS[i][k];\n    } else {\n      i--;\n    }\n  }\n}\n```\n\n![technology-2](technology-2.png)\n\n_最长公共子序列(LCS)_\n找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。\n![technology-3](technology-3.png)\n\n```javascript\nfunction lcs(wordX, wordY) {\n  const m = wordX.length;\n  const n = wordY.length;\n  const l = [];\n  for (let i = 0; i <= m; i++) {\n    l[i] = []; // {1}\n    // solution[i] = [];\n    for (let j = 0; j <= n; j++) {\n      l[i][j] = 0; // {2}\n      // solution[i][j] = '0';\n    }\n  }\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      if (i === 0 || j === 0) {\n        l[i][j] = 0;\n      } else if (wordX[i - 1] === wordY[j - 1]) {\n        l[i][j] = l[i - 1][j - 1] + 1; // {3}\n        // solution[i][j] = 'diagonal';\n      } else {\n        const a = l[i - 1][j];\n        const b = l[i][j - 1];\n        l[i][j] = a > b ? a : b; // {4} max(a,b)\n        // solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';\n      }\n    }\n  }\n  return l[m][n]; // {5}\n  // printSolution(solution, wordX, m, n);\n}\n\nfunction printSolution(solution, wordX, m, n) {\n  let a = m;\n  let b = n;\n  let x = solution[a][b];\n  let answer = '';\n  while (x !== '0') {\n    if (solution[a][b] === 'diagonal') {\n      answer = wordX[a - 1] + answer;\n      a--;\n      b--;\n    } else if (solution[a][b] === 'left') {\n      b--;\n    } else if (solution[a][b] === 'top') {\n      a--;\n    }\n    x = solution[a][b];\n  }\n  console.log('lcs: ' + answer);\n}\n```\n\n![technology-4](technology-4.png)\n\n_矩阵链相乘_\n要找出一组矩阵相乘的最佳方式（顺序）\n\nA*B*C\\*D 的乘法\n\nA 是一个 10 行 100 列的矩阵；\nB 是一个 100 行 5 列的矩阵；\nC 是一个 5 行 50 列的矩阵；\nD 是一个 50 行 1 列的矩阵；\nA*B*C\\*D 的结果是一个 10 行 1 列的矩阵\n\n(1) (A(B(CD)))：乘法运算的次数是 1750 次。\n(2) ((AB)(CD))：乘法运算的次数是 5300 次。\n(3) (((AB)C)D)：乘法运算的次数是 8000 次。\n(4) ((A(BC))D)：乘法运算的次数是 75 500 次。\n(5) (A((BC)D))：乘法运算的次数是 31 000 次。\n\n```javascript\nfunction matrixChainOrder(p) {\n  const n = p.length;\n  const m = [];\n  const s = [];\n  for (let i = 1; i <= n; i++) {\n    m[i] = [];\n    m[i][i] = 0;\n  }\n\n  //   const s = [];\n  // for (let i = 0; i <= n; i++){\n  //  s[i] = [];\n  //  for (let j=0; j <= n; j++){\n  //  s[i][j] = 0;\n  //  }\n  // }\n\n  for (let l = 2; l < n; l++) {\n    for (let i = 1; i <= n - l + 1; i++) {\n      const j = i + l - 1;\n      m[i][j] = Number.MAX_SAFE_INTEGER;\n      for (let k = i; k <= j - 1; k++) {\n        const q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // {1}\n        if (q < m[i][j]) {\n          m[i][j] = q; // {2}\n          // s[i][j] = k;\n        }\n      }\n    }\n  }\n  return m[1][n - 1]; // {3}\n  // printOptimalParenthesis(s, 1, n-1);\n}\n\nfunction printOptimalParenthesis(s, i, j) {\n  if (i === j) {\n    console.log('A[' + i + ']');\n  } else {\n    console.log('(');\n    printOptimalParenthesis(s, i, s[i][j]);\n    printOptimalParenthesis(s, s[i][j] + 1, j);\n    console.log(')');\n  }\n}\n// (A[1](A[2](A[3]A[4]))) => (A(B(CD)))\n```\n\n###### 贪心算法\n\n贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。\n\n**最少硬币找零问题**\n\n```javascript\nfunction minCoinChange(coins, amount) {\n  const change = [];\n  let total = 0;\n  for (let i = coins.length; i >= 0; i--) {\n    // {1}\n    const coin = coins[i];\n    while (total + coin <= amount) {\n      // {2}\n      change.push(coin); // {3}\n      total += coin; // {4}\n    }\n  }\n  return change;\n}\n```\n\n![technology-5](technology-5.png)\n\n_比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。_\n\n**分数背包问题**\n\n```javascript\nfunction knapSack(capacity, weights, values) {\n  const n = values.length;\n  let load = 0;\n  let val = 0;\n  for (let i = 0; i < n && load < capacity; i++) {\n    // {1}\n    if (weights[i] <= capacity - load) {\n      // {2}\n      val += values[i];\n      load += weights[i];\n    } else {\n      const r = (capacity - load) / weights[i]; // {3}\n      val += r * values[i];\n      load += weights[i];\n    }\n  }\n  return val;\n}\n```\n\n###### 回溯算法\n\n回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。\n\n**迷宫老鼠问题**\n\n```javascript\nexport function ratInAMaze(maze) {\n  const solution = [];\n  // 每个位置初始化为零\n  for (let i = 0; i < maze.length; i++) {\n    // {1}\n    solution[i] = [];\n    for (let j = 0; j < maze[i].length; j++) {\n      solution[i][j] = 0;\n    }\n  }\n  if (findPath(maze, 0, 0, solution) === true) {\n    // {2}\n    return solution;\n  }\n  return 'NO PATH FOUND'; // {3}\n}\n\nfunction findPath(maze, x, y, solution) {\n  const n = maze.length;\n  if (x === n - 1 && y === n - 1) {\n    // {4}\n    solution[x][y] = 1;\n    return true;\n  }\n  if (isSafe(maze, x, y) === true) {\n    // {5}\n    solution[x][y] = 1; // {6}\n    if (findPath(maze, x + 1, y, solution)) {\n      // {7}\n      return true;\n    }\n    if (findPath(maze, x, y + 1, solution)) {\n      // {8}\n      return true;\n    }\n    solution[x][y] = 0; // {9}\n    return false;\n  }\n  return false; // {10}\n}\n\nfunction isSafe(maze, x, y) {\n  const n = maze.length;\n  if (x >= 0 && y >= 0 && x < n && y < n && maze[x][y] !== 0) {\n    return true; // {11}\n  }\n  return false;\n}\n\nconst maze = [\n  [1, 0, 0, 0],\n  [1, 1, 1, 1],\n  [0, 0, 1, 0],\n  [0, 1, 1, 1],\n];\nconsole.log(ratInAMaze(maze));\n[\n  [1, 0, 0, 0],\n  [1, 1, 1, 0],\n  [0, 0, 1, 0],\n  [0, 0, 1, 1],\n];\n```\n\n**数独解题器**\n\n```javascript\nfunction sudokuSolver(matrix) {\n  if (solveSudoku(matrix) === true) {\n    return matrix;\n  }\n  return '问题无解！';\n}\n\nconst UNASSIGNED = 0;\nfunction solveSudoku(matrix) {\n  let row = 0;\n  let col = 0;\n  let checkBlankSpaces = false;\n  for (row = 0; row < matrix.length; row++) {\n    // {1}\n    for (col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] === UNASSIGNED) {\n        checkBlankSpaces = true; // {2}\n        break;\n      }\n    }\n    if (checkBlankSpaces === true) {\n      // {3}\n      break;\n    }\n  }\n  if (checkBlankSpaces === false) {\n    return true; // {4}\n  }\n  for (let num = 1; num <= 9; num++) {\n    // {5}\n    if (isSafe(matrix, row, col, num)) {\n      // {6}\n      matrix[row][col] = num; // {7}\n      if (solveSudoku(matrix)) {\n        // {8}\n        return true;\n      }\n      matrix[row][col] = UNASSIGNED; // {9}\n    }\n  }\n  return false; // {10}\n}\nfunction isSafe(matrix, row, col, num) {\n  return (\n    !usedInRow(matrix, row, num) &&\n    !usedInCol(matrix, col, num) &&\n    !usedInBox(matrix, row - (row % 3), col - (col % 3), num)\n  );\n}\n\nfunction usedInRow(matrix, row, num) {\n  for (let col = 0; col < matrix.length; col++) {\n    // {11}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInCol(matrix, col, num) {\n  for (let row = 0; row < matrix.length; row++) {\n    // {12}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInBox(matrix, boxStartRow, boxStartCol, num) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (matrix[row + boxStartRow][col + boxStartCol] === num) {\n        // {13}\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst sudokuGrid = [\n  [5, 3, 0, 0, 7, 0, 0, 0, 0],\n  [6, 0, 0, 1, 9, 5, 0, 0, 0],\n  [0, 9, 8, 0, 0, 0, 0, 6, 0],\n  [8, 0, 0, 0, 6, 0, 0, 0, 3],\n  [4, 0, 0, 8, 0, 3, 0, 0, 1],\n  [7, 0, 0, 0, 2, 0, 0, 0, 6],\n  [0, 6, 0, 0, 0, 0, 2, 8, 0],\n  [0, 0, 0, 4, 1, 9, 0, 0, 5],\n  [0, 0, 0, 0, 8, 0, 0, 7, 9],\n];\nconsole.log(sudokuSolver(sudokuGrid));\n[\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9],\n];\n```\n\n###### 函数式编程(FP)简介\n\n**函数式编程与命令式编程**\n\n```javascript\n// 命令式编程\nconst printArray = function (array) {\n  for (var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n  }\n};\nprintArray([1, 2, 3, 4, 5]);\n\n// 函数式编程\nconst forEach = function (array, action) {\n  for (var i = 0; i < array.length; i++) {\n    action(array[i]);\n  }\n};\nconst logItem = function (item) {\n  console.log(item);\n};\nforEach([1, 2, 3, 4, 5], logItem);\n```\n\n_注意：_\n(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。\n(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。\n(3)函数和数据集合是函数式编程的核心。\n(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。\n(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。\n\n**JavaScript 函数式类库和数据结构**\nUnderscode.js：http://underscorejs.org/\nBilby.js：http://bilby.brianmckenna.org/\nLazy.js：http://danieltao.com/lazy.js/\nBacon.js：https://baconjs.github.io/\nFn.js：http://eliperelman.com/fn.js/\nFunctional.js：http://functionaljs.com/\nRamda.js：http://ramdajs.com/0.20.1/index.html\nMori：http://swannodette.github.io/mori/\n\nJavaScript 函数式编程：https://www.packtpub.com/web-development/functional-programming-javascript\n\n#### 算法复杂度\n\n###### 大 O 表示法\n\n用于描述算法的性能和复杂程度。\n大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。\n\n| 符 号        | 名 称        |\n| ------------ | ------------ |\n| O(1)         | 常数的       |\n| O(log(n))    | 对数的       |\n| O((log(n))c) | 对数多项式的 |\n| O(n)         | 线性的       |\n| O(n^2)       | 二次的       |\n| O(n^c)       | 多项式的     |\n| O(c^n)       | 指数的       |\n\n**理解大 O 表示法**\n\n衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。\n\n1. O(1)\n\n```javascript\nfunction increment(num) {\n  return ++num;\n}\n```\n\n假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）\n\n2. O(n)\n\n函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。\n\n以顺序搜索算法为例\n\n```javascript\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    if (equalsFn(value, array[i])) {\n      // {1}\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  let cost = 0;\n  for (let i = 0; i < array.length; i++) {\n    cost++;\n    if (equalsFn(value, array[i])) {\n      return i;\n    }\n  }\n  console.log(\n    `cost for sequentialSearch with input size ${array.length} is ${cost}`\n  );\n  return -1;\n}\n```\n\n3. O(n^2)\n\n以冒泡排序为例\n\n```javascript\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n\n// 假设行{1}和行{2}的开销分别是 1。修改算法的实现使之计算开销。\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  let cost = 0;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    cost++;\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      cost++;\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  console.log(`cost for bubbleSort with input size ${length} is ${cost}`);\n  return array;\n}\n```\n\n如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久\n\n*时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)*\n\n**时间复杂度比较**\n\n| 输入大小（n） | O(1) | O(log(n)) | O(n)   | O(nlog(n)) | O(n^2)      | O(2^n)    |\n| ------------- | ---- | --------- | ------ | ---------- | ----------- | --------- |\n| 10            | 1    | 1         | 10     | 10         | 100         | 1024      |\n| 20            | 1    | 1.30      | 20     | 26.02      | 400         | 1 048 576 |\n| 50            | 1    | 1.69      | 50     | 84.94      | 2500        | 非常大    |\n| 100           | 1    | 2         | 100    | 200        | 10 000      | 非常大    |\n| 500           | 1    | 2.69      | 500    | 1349.48    | 250 000     | 非常大    |\n| 1000          | 1    | 3         | 1000   | 3000       | 1 000 000   | 非常大    |\n| 10 000        | 1    | 4         | 10 000 | 40 000     | 100 000 000 | 非常大    |\n\n不同的大 O 表示法的消耗\n\n![big-o-1](big-o-1.png)\n\n*常用数据结构的时间复杂度*\n![big-o-2](big-o-2.png)\n\n*图的时间复杂度*\n![big-o-3](big-o-3.png)\n\n*排序算法的时间复杂度*\n![big-o-4](big-o-4.png)\n\n*搜索算法的时间复杂度*\n![big-o-5](big-o-5.png)\n\n**NP 完全理论概述**\n一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.\n\n对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）\n\nNP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP\n\n如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。\n\nNP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：\n(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；\n(2) 所有的 NP 问题都能在多项式时间内归约为 L。\n\n为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。\n\n还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。\n\n下面是满足 P<>NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。\n![big-o-6](big-o-6.png)\n\n非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。\n\nNP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。\n\n以上问题，具体可查看：https://en.wikipedia.org/wiki/NP-completeness\n\n*不可解问题与启发式算法*\n有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。\n启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。\n启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。\n详情请查阅 https://en.wikipedia.org/wiki/Heuristic_(computer_science)\n\nUVa Online Judge（http://uva.onlinejudge.org/）\nSphere Online Judge（http://www.spoj.com/）\nCoderbyte（http://coderbyte.com/）\nProject Euler（https://projecteuler.net/）\nHackerRank（https://www.hackerrank.com）\nCodeChef（http://www.codechef.com/）\nTop Coder（http://www.topcoder.com/）\n\n\n#### 疑问点\n尾调用优化\n- 调用栈长\n- 使用后性能有较大的提升\nFloyd-Warshall 算法\nKruskal 算法\n背包问题\n最长公共子序列\n矩阵链相乘\nNP 完全理论\n- 多项式时间\n\n算法的使用，什么情况下用合适？需要将数据转换处理\n合适\n\n自己写的算法怎么验证正确性？\nLeetCode或其他刷题网站\n\nantd升级后的visible修改任务\n评估修改时间\ntesting-library/react测试react组件的库，安装了却没用？\numc-ui的项目框架使用的是别的项目的，原来就有，没删","slug":"39-data-structure7","published":1,"updated":"2022-10-25T02:34:13.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q30012k4tt3ya42jfn","content":"<h4 id=\"算法设计与技巧\"><a href=\"#算法设计与技巧\" class=\"headerlink\" title=\"算法设计与技巧\"></a>算法设计与技巧</h4><h6 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h6><p>将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p>\n<p>分而治之算法可以分成三个部分。<br>(1) 分解原问题为多个子问题（原问题的多个小实例）。<br>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。<br>(3) 组合这些子问题的解决方式，得到原问题的解。</p>\n<p><strong>二分搜索</strong><br>分解：计算 mid 并搜索数组较小或较大的一半。<br>解决：在较小或较大的一半中搜索值。<br>合并：这步不需要，因为我们直接返回了索引值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearchRecursive</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  low,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  high,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (low &lt;= high) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = array[mid];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, mid + <span class=\"number\">1</span>, high, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, mid - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> high = sortedArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, high, compareFn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-1.png\" alt=\"technology-1\"></p>\n<p><strong>动态规划</strong><br>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>\n<p><em>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</em></p>\n<p>步骤：<br>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分；<br>(3) 识别并求解出基线条件。</p>\n<p><em>能用动态规划解决的一些著名问题如下。</em><br>(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)</p>\n<p><em>最少硬币找零问题</em><br>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// coins 硬币面额的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> makeChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache[value]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache[value];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> min = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newMin;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newAmount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">      newAmount = value - coin; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newAmount &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        newMin = makeChange(newAmount); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        newAmount &gt;= <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        (newMin.length &lt; min.length - <span class=\"number\">1</span> || !min.length) &amp;&amp; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        (newMin.length || !newAmount) <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        min = [coin].concat(newMin); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;new Min &#x27;</span> + min + <span class=\"string\">&#x27; for &#x27;</span> + amount);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cache[value] = min); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> makeChange(amount); <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>背包问题</em><br>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> kS = [];</span><br><span class=\"line\">  <span class=\"comment\">// 初始化将用于寻找解决方案的矩阵</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    kS[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> w = <span class=\"number\">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || w === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        kS[i][w] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (weights[i - <span class=\"number\">1</span>] &lt;= w) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 。物品 i 的重量必须小于约束</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = values[i - <span class=\"number\">1</span>] + kS[i - <span class=\"number\">1</span>][w - weights[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = kS[i - <span class=\"number\">1</span>][w];</span><br><span class=\"line\">        <span class=\"comment\">// 当找到可以构成解决方案的物品时，选择价值最大的那个</span></span><br><span class=\"line\">        kS[i][w] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        kS[i][w] = kS[i - <span class=\"number\">1</span>][w]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  findValues(n, capacity, kS, weights, values); <span class=\"comment\">// &#123;6&#125; 增加的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> kS[n][capacity]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findValues</span>(<span class=\"params\">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> k = capacity;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;构成解的物品：&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kS[i][k] !== kS[i - <span class=\"number\">1</span>][k]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">        <span class=\"string\">`物品 <span class=\"subst\">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class=\"subst\">$&#123;weights[i - <span class=\"number\">1</span>]&#125;</span>, <span class=\"subst\">$&#123;values[i - <span class=\"number\">1</span>]&#125;</span>`</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">      k -= kS[i][k];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-2.png\" alt=\"technology-2\"></p>\n<p><em>最长公共子序列(LCS)</em><br>找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。<br><img src=\"/2022/10/13/39-data-structure7/technology-3.png\" alt=\"technology-3\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">wordX, wordY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = wordX.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = wordY.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    l[i] = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// solution[i] = [];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      l[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// solution[i][j] = &#x27;0&#x27;;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        l[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wordX[i - <span class=\"number\">1</span>] === wordY[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        l[i][j] = l[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j] = &#x27;diagonal&#x27;;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = l[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = l[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        l[i][j] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j]=(l[i][j] == l[i-1][j]) ? &#x27;top&#x27; : &#x27;left&#x27;;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l[m][n]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printSolution(solution, wordX, m, n);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printSolution</span>(<span class=\"params\">solution, wordX, m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = m;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = solution[a][b];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> answer = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (x !== <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;diagonal&#x27;</span>) &#123;</span><br><span class=\"line\">      answer = wordX[a - <span class=\"number\">1</span>] + answer;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;left&#x27;</span>) &#123;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;top&#x27;</span>) &#123;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x = solution[a][b];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;lcs: &#x27;</span> + answer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-4.png\" alt=\"technology-4\"></p>\n<p><em>矩阵链相乘</em><br>要找出一组矩阵相乘的最佳方式（顺序）</p>\n<p>A<em>B</em>C*D 的乘法</p>\n<p>A 是一个 10 行 100 列的矩阵；<br>B 是一个 100 行 5 列的矩阵；<br>C 是一个 5 行 50 列的矩阵；<br>D 是一个 50 行 1 列的矩阵；<br>A<em>B</em>C*D 的结果是一个 10 行 1 列的矩阵</p>\n<p>(1) (A(B(CD)))：乘法运算的次数是 1750 次。<br>(2) ((AB)(CD))：乘法运算的次数是 5300 次。<br>(3) (((AB)C)D)：乘法运算的次数是 8000 次。<br>(4) ((A(BC))D)：乘法运算的次数是 75 500 次。<br>(5) (A((BC)D))：乘法运算的次数是 31 000 次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matrixChainOrder</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = p.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> s = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    m[i] = [];</span><br><span class=\"line\">    m[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//   const s = [];</span></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 0; i &lt;= n; i++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i] = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for (let j=0; j &lt;= n; j++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i][j] = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">2</span>; l &lt; n; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n - l + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> j = i + l - <span class=\"number\">1</span>;</span><br><span class=\"line\">      m[i][j] = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = i; k &lt;= j - <span class=\"number\">1</span>; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> q = m[i][k] + m[k + <span class=\"number\">1</span>][j] + p[i - <span class=\"number\">1</span>] * p[k] * p[j]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &lt; m[i][j]) &#123;</span><br><span class=\"line\">          m[i][j] = q; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"comment\">// s[i][j] = k;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m[<span class=\"number\">1</span>][n - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printOptimalParenthesis(s, 1, n-1);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printOptimalParenthesis</span>(<span class=\"params\">s, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;A[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;(&#x27;</span>);</span><br><span class=\"line\">    printOptimalParenthesis(s, i, s[i][j]);</span><br><span class=\"line\">    printOptimalParenthesis(s, s[i][j] + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// (A[1](A[2](A[3]A[4]))) =&gt; (A(B(CD)))</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h6><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p>\n<p><strong>最少硬币找零问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> change = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = coins.length; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (total + coin &lt;= amount) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      change.push(coin); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      total += coin; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> change;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-5.png\" alt=\"technology-5\"></p>\n<p><em>比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</em></p>\n<p><strong>分数背包问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = values.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> load = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weights[i] &lt;= capacity - load) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      val += values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> r = (capacity - load) / weights[i]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      val += r * values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h6><p>回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。</p>\n<p><strong>迷宫老鼠问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ratInAMaze</span>(<span class=\"params\">maze</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> solution = [];</span><br><span class=\"line\">  <span class=\"comment\">// 每个位置初始化为零</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; maze.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    solution[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; maze[i].length; j++) &#123;</span><br><span class=\"line\">      solution[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (findPath(maze, <span class=\"number\">0</span>, <span class=\"number\">0</span>, solution) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> solution;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NO PATH FOUND&#x27;</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findPath</span>(<span class=\"params\">maze, x, y, solution</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === n - <span class=\"number\">1</span> &amp;&amp; y === n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSafe(maze, x, y) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x + <span class=\"number\">1</span>, y, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x, y + <span class=\"number\">1</span>, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">maze, x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> maze = [</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ratInAMaze(maze));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><strong>数独解题器</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sudokuSolver</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (solveSudoku(matrix) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;问题无解！&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UNASSIGNED = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">solveSudoku</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> col = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> checkBlankSpaces = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (col = <span class=\"number\">0</span>; col &lt; matrix[row].length; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row][col] === UNASSIGNED) &#123;</span><br><span class=\"line\">        checkBlankSpaces = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num = <span class=\"number\">1</span>; num &lt;= <span class=\"number\">9</span>; num++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSafe(matrix, row, col, num)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      matrix[row][col] = num; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (solveSudoku(matrix)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      matrix[row][col] = UNASSIGNED; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">matrix, row, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !usedInRow(matrix, row, num) &amp;&amp;</span><br><span class=\"line\">    !usedInCol(matrix, col, num) &amp;&amp;</span><br><span class=\"line\">    !usedInBox(matrix, row - (row % <span class=\"number\">3</span>), col - (col % <span class=\"number\">3</span>), num)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInRow</span>(<span class=\"params\">matrix, row, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; matrix.length; col++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInCol</span>(<span class=\"params\">matrix, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInBox</span>(<span class=\"params\">matrix, boxStartRow, boxStartCol, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; <span class=\"number\">3</span>; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; <span class=\"number\">3</span>; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row + boxStartRow][col + boxStartCol] === num) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sudokuGrid = [</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sudokuSolver(sudokuGrid));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"函数式编程-FP-简介\"><a href=\"#函数式编程-FP-简介\" class=\"headerlink\" title=\"函数式编程(FP)简介\"></a>函数式编程(FP)简介</h6><p><strong>函数式编程与命令式编程</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> printArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printArray([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    action(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> logItem = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">forEach([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], logItem);</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：</em><br>(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。<br>(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。<br>(3)函数和数据集合是函数式编程的核心。<br>(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。<br>(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。</p>\n<p><strong>JavaScript 函数式类库和数据结构</strong><br>Underscode.js：<a href=\"http://underscorejs.org/\">http://underscorejs.org/</a><br>Bilby.js：<a href=\"http://bilby.brianmckenna.org/\">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a href=\"http://danieltao.com/lazy.js/\">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a href=\"https://baconjs.github.io/\">https://baconjs.github.io/</a><br>Fn.js：<a href=\"http://eliperelman.com/fn.js/\">http://eliperelman.com/fn.js/</a><br>Functional.js：<a href=\"http://functionaljs.com/\">http://functionaljs.com/</a><br>Ramda.js：<a href=\"http://ramdajs.com/0.20.1/index.html\">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a href=\"http://swannodette.github.io/mori/\">http://swannodette.github.io/mori/</a></p>\n<p>JavaScript 函数式编程：<a href=\"https://www.packtpub.com/web-development/functional-programming-javascript\">https://www.packtpub.com/web-development/functional-programming-javascript</a></p>\n<h4 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h4><h6 id=\"大-O-表示法\"><a href=\"#大-O-表示法\" class=\"headerlink\" title=\"大 O 表示法\"></a>大 O 表示法</h6><p>用于描述算法的性能和复杂程度。<br>大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。</p>\n<table>\n<thead>\n<tr>\n<th>符 号</th>\n<th>名 称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td>常数的</td>\n</tr>\n<tr>\n<td>O(log(n))</td>\n<td>对数的</td>\n</tr>\n<tr>\n<td>O((log(n))c)</td>\n<td>对数多项式的</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>线性的</td>\n</tr>\n<tr>\n<td>O(n^2)</td>\n<td>二次的</td>\n</tr>\n<tr>\n<td>O(n^c)</td>\n<td>多项式的</td>\n</tr>\n<tr>\n<td>O(c^n)</td>\n<td>指数的</td>\n</tr>\n</tbody></table>\n<p><strong>理解大 O 表示法</strong></p>\n<p>衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。</p>\n<ol>\n<li>O(1)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ++num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）</p>\n<ol start=\"2\">\n<li>O(n)</li>\n</ol>\n<p>函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。</p>\n<p>以顺序搜索算法为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">    <span class=\"string\">`cost for sequentialSearch with input size <span class=\"subst\">$&#123;array.length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>O(n^2)</li>\n</ol>\n<p>以冒泡排序为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设行&#123;1&#125;和行&#123;2&#125;的开销分别是 1。修改算法的实现使之计算开销。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      cost++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`cost for bubbleSort with input size <span class=\"subst\">$&#123;length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久</p>\n<p><em>时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)</em></p>\n<p><strong>时间复杂度比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>输入大小（n）</th>\n<th>O(1)</th>\n<th>O(log(n))</th>\n<th>O(n)</th>\n<th>O(nlog(n))</th>\n<th>O(n^2)</th>\n<th>O(2^n)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>10</td>\n<td>10</td>\n<td>100</td>\n<td>1024</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1</td>\n<td>1.30</td>\n<td>20</td>\n<td>26.02</td>\n<td>400</td>\n<td>1 048 576</td>\n</tr>\n<tr>\n<td>50</td>\n<td>1</td>\n<td>1.69</td>\n<td>50</td>\n<td>84.94</td>\n<td>2500</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1</td>\n<td>2</td>\n<td>100</td>\n<td>200</td>\n<td>10 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>500</td>\n<td>1</td>\n<td>2.69</td>\n<td>500</td>\n<td>1349.48</td>\n<td>250 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>1</td>\n<td>3</td>\n<td>1000</td>\n<td>3000</td>\n<td>1 000 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>10 000</td>\n<td>1</td>\n<td>4</td>\n<td>10 000</td>\n<td>40 000</td>\n<td>100 000 000</td>\n<td>非常大</td>\n</tr>\n</tbody></table>\n<p>不同的大 O 表示法的消耗</p>\n<p><img src=\"/2022/10/13/39-data-structure7/big-o-1.png\" alt=\"big-o-1\"></p>\n<p><em>常用数据结构的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-2.png\" alt=\"big-o-2\"></p>\n<p><em>图的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-3.png\" alt=\"big-o-3\"></p>\n<p><em>排序算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-4.png\" alt=\"big-o-4\"></p>\n<p><em>搜索算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-5.png\" alt=\"big-o-5\"></p>\n<p><strong>NP 完全理论概述</strong><br>一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.</p>\n<p>对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）</p>\n<p>NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP</p>\n<p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。</p>\n<p>NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：<br>(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；<br>(2) 所有的 NP 问题都能在多项式时间内归约为 L。</p>\n<p>为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。</p>\n<p>还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。</p>\n<p>下面是满足 P&lt;&gt;NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。<br><img src=\"/2022/10/13/39-data-structure7/big-o-6.png\" alt=\"big-o-6\"></p>\n<p>非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。</p>\n<p>NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p>\n<p>以上问题，具体可查看：<a href=\"https://en.wikipedia.org/wiki/NP-completeness\">https://en.wikipedia.org/wiki/NP-completeness</a></p>\n<p><em>不可解问题与启发式算法</em><br>有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。<br>启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。<br>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。<br>详情请查阅 <a href=\"https://en.wikipedia.org/wiki/Heuristic_(computer_science)\">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a></p>\n<p>UVa Online Judge（<a href=\"http://uva.onlinejudge.org/%EF%BC%89\">http://uva.onlinejudge.org/）</a><br>Sphere Online Judge（<a href=\"http://www.spoj.com/%EF%BC%89\">http://www.spoj.com/）</a><br>Coderbyte（<a href=\"http://coderbyte.com/%EF%BC%89\">http://coderbyte.com/）</a><br>Project Euler（<a href=\"https://projecteuler.net/%EF%BC%89\">https://projecteuler.net/）</a><br>HackerRank（<a href=\"https://www.hackerrank.com)/\">https://www.hackerrank.com）</a><br>CodeChef（<a href=\"http://www.codechef.com/%EF%BC%89\">http://www.codechef.com/）</a><br>Top Coder（<a href=\"http://www.topcoder.com/%EF%BC%89\">http://www.topcoder.com/）</a></p>\n<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>尾调用优化</p>\n<ul>\n<li>调用栈长</li>\n<li>使用后性能有较大的提升<br>Floyd-Warshall 算法<br>Kruskal 算法<br>背包问题<br>最长公共子序列<br>矩阵链相乘<br>NP 完全理论</li>\n<li>多项式时间</li>\n</ul>\n<p>算法的使用，什么情况下用合适？需要将数据转换处理<br>合适</p>\n<p>自己写的算法怎么验证正确性？<br>LeetCode或其他刷题网站</p>\n<p>antd升级后的visible修改任务<br>评估修改时间<br>testing-library/react测试react组件的库，安装了却没用？<br>umc-ui的项目框架使用的是别的项目的，原来就有，没删</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"算法设计与技巧\"><a href=\"#算法设计与技巧\" class=\"headerlink\" title=\"算法设计与技巧\"></a>算法设计与技巧</h4><h6 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h6><p>将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p>\n<p>分而治之算法可以分成三个部分。<br>(1) 分解原问题为多个子问题（原问题的多个小实例）。<br>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。<br>(3) 组合这些子问题的解决方式，得到原问题的解。</p>\n<p><strong>二分搜索</strong><br>分解：计算 mid 并搜索数组较小或较大的一半。<br>解决：在较小或较大的一半中搜索值。<br>合并：这步不需要，因为我们直接返回了索引值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearchRecursive</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  low,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  high,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (low &lt;= high) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = array[mid];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, mid + <span class=\"number\">1</span>, high, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, mid - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> high = sortedArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, high, compareFn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-1.png\" alt=\"technology-1\"></p>\n<p><strong>动态规划</strong><br>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>\n<p><em>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</em></p>\n<p>步骤：<br>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分；<br>(3) 识别并求解出基线条件。</p>\n<p><em>能用动态规划解决的一些著名问题如下。</em><br>(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)</p>\n<p><em>最少硬币找零问题</em><br>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// coins 硬币面额的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> makeChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache[value]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache[value];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> min = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newMin;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newAmount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">      newAmount = value - coin; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newAmount &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        newMin = makeChange(newAmount); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        newAmount &gt;= <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        (newMin.length &lt; min.length - <span class=\"number\">1</span> || !min.length) &amp;&amp; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        (newMin.length || !newAmount) <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        min = [coin].concat(newMin); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;new Min &#x27;</span> + min + <span class=\"string\">&#x27; for &#x27;</span> + amount);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cache[value] = min); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> makeChange(amount); <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>背包问题</em><br>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> kS = [];</span><br><span class=\"line\">  <span class=\"comment\">// 初始化将用于寻找解决方案的矩阵</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    kS[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> w = <span class=\"number\">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || w === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        kS[i][w] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (weights[i - <span class=\"number\">1</span>] &lt;= w) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 。物品 i 的重量必须小于约束</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = values[i - <span class=\"number\">1</span>] + kS[i - <span class=\"number\">1</span>][w - weights[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = kS[i - <span class=\"number\">1</span>][w];</span><br><span class=\"line\">        <span class=\"comment\">// 当找到可以构成解决方案的物品时，选择价值最大的那个</span></span><br><span class=\"line\">        kS[i][w] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        kS[i][w] = kS[i - <span class=\"number\">1</span>][w]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  findValues(n, capacity, kS, weights, values); <span class=\"comment\">// &#123;6&#125; 增加的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> kS[n][capacity]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findValues</span>(<span class=\"params\">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> k = capacity;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;构成解的物品：&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kS[i][k] !== kS[i - <span class=\"number\">1</span>][k]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">        <span class=\"string\">`物品 <span class=\"subst\">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class=\"subst\">$&#123;weights[i - <span class=\"number\">1</span>]&#125;</span>, <span class=\"subst\">$&#123;values[i - <span class=\"number\">1</span>]&#125;</span>`</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">      k -= kS[i][k];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-2.png\" alt=\"technology-2\"></p>\n<p><em>最长公共子序列(LCS)</em><br>找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。<br><img src=\"/2022/10/13/39-data-structure7/technology-3.png\" alt=\"technology-3\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">wordX, wordY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = wordX.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = wordY.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    l[i] = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// solution[i] = [];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      l[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// solution[i][j] = &#x27;0&#x27;;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        l[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wordX[i - <span class=\"number\">1</span>] === wordY[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        l[i][j] = l[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j] = &#x27;diagonal&#x27;;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = l[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = l[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        l[i][j] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j]=(l[i][j] == l[i-1][j]) ? &#x27;top&#x27; : &#x27;left&#x27;;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l[m][n]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printSolution(solution, wordX, m, n);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printSolution</span>(<span class=\"params\">solution, wordX, m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = m;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = solution[a][b];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> answer = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (x !== <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;diagonal&#x27;</span>) &#123;</span><br><span class=\"line\">      answer = wordX[a - <span class=\"number\">1</span>] + answer;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;left&#x27;</span>) &#123;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;top&#x27;</span>) &#123;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x = solution[a][b];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;lcs: &#x27;</span> + answer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-4.png\" alt=\"technology-4\"></p>\n<p><em>矩阵链相乘</em><br>要找出一组矩阵相乘的最佳方式（顺序）</p>\n<p>A<em>B</em>C*D 的乘法</p>\n<p>A 是一个 10 行 100 列的矩阵；<br>B 是一个 100 行 5 列的矩阵；<br>C 是一个 5 行 50 列的矩阵；<br>D 是一个 50 行 1 列的矩阵；<br>A<em>B</em>C*D 的结果是一个 10 行 1 列的矩阵</p>\n<p>(1) (A(B(CD)))：乘法运算的次数是 1750 次。<br>(2) ((AB)(CD))：乘法运算的次数是 5300 次。<br>(3) (((AB)C)D)：乘法运算的次数是 8000 次。<br>(4) ((A(BC))D)：乘法运算的次数是 75 500 次。<br>(5) (A((BC)D))：乘法运算的次数是 31 000 次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matrixChainOrder</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = p.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> s = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    m[i] = [];</span><br><span class=\"line\">    m[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//   const s = [];</span></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 0; i &lt;= n; i++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i] = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for (let j=0; j &lt;= n; j++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i][j] = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">2</span>; l &lt; n; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n - l + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> j = i + l - <span class=\"number\">1</span>;</span><br><span class=\"line\">      m[i][j] = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = i; k &lt;= j - <span class=\"number\">1</span>; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> q = m[i][k] + m[k + <span class=\"number\">1</span>][j] + p[i - <span class=\"number\">1</span>] * p[k] * p[j]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &lt; m[i][j]) &#123;</span><br><span class=\"line\">          m[i][j] = q; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"comment\">// s[i][j] = k;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m[<span class=\"number\">1</span>][n - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printOptimalParenthesis(s, 1, n-1);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printOptimalParenthesis</span>(<span class=\"params\">s, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;A[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;(&#x27;</span>);</span><br><span class=\"line\">    printOptimalParenthesis(s, i, s[i][j]);</span><br><span class=\"line\">    printOptimalParenthesis(s, s[i][j] + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// (A[1](A[2](A[3]A[4]))) =&gt; (A(B(CD)))</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h6><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p>\n<p><strong>最少硬币找零问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> change = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = coins.length; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (total + coin &lt;= amount) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      change.push(coin); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      total += coin; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> change;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-5.png\" alt=\"technology-5\"></p>\n<p><em>比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</em></p>\n<p><strong>分数背包问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = values.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> load = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weights[i] &lt;= capacity - load) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      val += values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> r = (capacity - load) / weights[i]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      val += r * values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h6><p>回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。</p>\n<p><strong>迷宫老鼠问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ratInAMaze</span>(<span class=\"params\">maze</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> solution = [];</span><br><span class=\"line\">  <span class=\"comment\">// 每个位置初始化为零</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; maze.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    solution[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; maze[i].length; j++) &#123;</span><br><span class=\"line\">      solution[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (findPath(maze, <span class=\"number\">0</span>, <span class=\"number\">0</span>, solution) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> solution;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NO PATH FOUND&#x27;</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findPath</span>(<span class=\"params\">maze, x, y, solution</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === n - <span class=\"number\">1</span> &amp;&amp; y === n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSafe(maze, x, y) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x + <span class=\"number\">1</span>, y, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x, y + <span class=\"number\">1</span>, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">maze, x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> maze = [</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ratInAMaze(maze));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><strong>数独解题器</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sudokuSolver</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (solveSudoku(matrix) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;问题无解！&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UNASSIGNED = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">solveSudoku</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> col = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> checkBlankSpaces = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (col = <span class=\"number\">0</span>; col &lt; matrix[row].length; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row][col] === UNASSIGNED) &#123;</span><br><span class=\"line\">        checkBlankSpaces = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num = <span class=\"number\">1</span>; num &lt;= <span class=\"number\">9</span>; num++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSafe(matrix, row, col, num)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      matrix[row][col] = num; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (solveSudoku(matrix)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      matrix[row][col] = UNASSIGNED; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">matrix, row, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !usedInRow(matrix, row, num) &amp;&amp;</span><br><span class=\"line\">    !usedInCol(matrix, col, num) &amp;&amp;</span><br><span class=\"line\">    !usedInBox(matrix, row - (row % <span class=\"number\">3</span>), col - (col % <span class=\"number\">3</span>), num)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInRow</span>(<span class=\"params\">matrix, row, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; matrix.length; col++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInCol</span>(<span class=\"params\">matrix, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInBox</span>(<span class=\"params\">matrix, boxStartRow, boxStartCol, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; <span class=\"number\">3</span>; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; <span class=\"number\">3</span>; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row + boxStartRow][col + boxStartCol] === num) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sudokuGrid = [</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sudokuSolver(sudokuGrid));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"函数式编程-FP-简介\"><a href=\"#函数式编程-FP-简介\" class=\"headerlink\" title=\"函数式编程(FP)简介\"></a>函数式编程(FP)简介</h6><p><strong>函数式编程与命令式编程</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> printArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printArray([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    action(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> logItem = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">forEach([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], logItem);</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：</em><br>(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。<br>(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。<br>(3)函数和数据集合是函数式编程的核心。<br>(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。<br>(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。</p>\n<p><strong>JavaScript 函数式类库和数据结构</strong><br>Underscode.js：<a href=\"http://underscorejs.org/\">http://underscorejs.org/</a><br>Bilby.js：<a href=\"http://bilby.brianmckenna.org/\">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a href=\"http://danieltao.com/lazy.js/\">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a href=\"https://baconjs.github.io/\">https://baconjs.github.io/</a><br>Fn.js：<a href=\"http://eliperelman.com/fn.js/\">http://eliperelman.com/fn.js/</a><br>Functional.js：<a href=\"http://functionaljs.com/\">http://functionaljs.com/</a><br>Ramda.js：<a href=\"http://ramdajs.com/0.20.1/index.html\">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a href=\"http://swannodette.github.io/mori/\">http://swannodette.github.io/mori/</a></p>\n<p>JavaScript 函数式编程：<a href=\"https://www.packtpub.com/web-development/functional-programming-javascript\">https://www.packtpub.com/web-development/functional-programming-javascript</a></p>\n<h4 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h4><h6 id=\"大-O-表示法\"><a href=\"#大-O-表示法\" class=\"headerlink\" title=\"大 O 表示法\"></a>大 O 表示法</h6><p>用于描述算法的性能和复杂程度。<br>大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。</p>\n<table>\n<thead>\n<tr>\n<th>符 号</th>\n<th>名 称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td>常数的</td>\n</tr>\n<tr>\n<td>O(log(n))</td>\n<td>对数的</td>\n</tr>\n<tr>\n<td>O((log(n))c)</td>\n<td>对数多项式的</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>线性的</td>\n</tr>\n<tr>\n<td>O(n^2)</td>\n<td>二次的</td>\n</tr>\n<tr>\n<td>O(n^c)</td>\n<td>多项式的</td>\n</tr>\n<tr>\n<td>O(c^n)</td>\n<td>指数的</td>\n</tr>\n</tbody></table>\n<p><strong>理解大 O 表示法</strong></p>\n<p>衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。</p>\n<ol>\n<li>O(1)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ++num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）</p>\n<ol start=\"2\">\n<li>O(n)</li>\n</ol>\n<p>函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。</p>\n<p>以顺序搜索算法为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">    <span class=\"string\">`cost for sequentialSearch with input size <span class=\"subst\">$&#123;array.length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>O(n^2)</li>\n</ol>\n<p>以冒泡排序为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设行&#123;1&#125;和行&#123;2&#125;的开销分别是 1。修改算法的实现使之计算开销。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      cost++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`cost for bubbleSort with input size <span class=\"subst\">$&#123;length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久</p>\n<p><em>时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)</em></p>\n<p><strong>时间复杂度比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>输入大小（n）</th>\n<th>O(1)</th>\n<th>O(log(n))</th>\n<th>O(n)</th>\n<th>O(nlog(n))</th>\n<th>O(n^2)</th>\n<th>O(2^n)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>10</td>\n<td>10</td>\n<td>100</td>\n<td>1024</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1</td>\n<td>1.30</td>\n<td>20</td>\n<td>26.02</td>\n<td>400</td>\n<td>1 048 576</td>\n</tr>\n<tr>\n<td>50</td>\n<td>1</td>\n<td>1.69</td>\n<td>50</td>\n<td>84.94</td>\n<td>2500</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1</td>\n<td>2</td>\n<td>100</td>\n<td>200</td>\n<td>10 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>500</td>\n<td>1</td>\n<td>2.69</td>\n<td>500</td>\n<td>1349.48</td>\n<td>250 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>1</td>\n<td>3</td>\n<td>1000</td>\n<td>3000</td>\n<td>1 000 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>10 000</td>\n<td>1</td>\n<td>4</td>\n<td>10 000</td>\n<td>40 000</td>\n<td>100 000 000</td>\n<td>非常大</td>\n</tr>\n</tbody></table>\n<p>不同的大 O 表示法的消耗</p>\n<p><img src=\"/2022/10/13/39-data-structure7/big-o-1.png\" alt=\"big-o-1\"></p>\n<p><em>常用数据结构的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-2.png\" alt=\"big-o-2\"></p>\n<p><em>图的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-3.png\" alt=\"big-o-3\"></p>\n<p><em>排序算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-4.png\" alt=\"big-o-4\"></p>\n<p><em>搜索算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-5.png\" alt=\"big-o-5\"></p>\n<p><strong>NP 完全理论概述</strong><br>一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.</p>\n<p>对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）</p>\n<p>NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP</p>\n<p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。</p>\n<p>NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：<br>(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；<br>(2) 所有的 NP 问题都能在多项式时间内归约为 L。</p>\n<p>为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。</p>\n<p>还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。</p>\n<p>下面是满足 P&lt;&gt;NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。<br><img src=\"/2022/10/13/39-data-structure7/big-o-6.png\" alt=\"big-o-6\"></p>\n<p>非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。</p>\n<p>NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p>\n<p>以上问题，具体可查看：<a href=\"https://en.wikipedia.org/wiki/NP-completeness\">https://en.wikipedia.org/wiki/NP-completeness</a></p>\n<p><em>不可解问题与启发式算法</em><br>有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。<br>启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。<br>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。<br>详情请查阅 <a href=\"https://en.wikipedia.org/wiki/Heuristic_(computer_science)\">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a></p>\n<p>UVa Online Judge（<a href=\"http://uva.onlinejudge.org/%EF%BC%89\">http://uva.onlinejudge.org/）</a><br>Sphere Online Judge（<a href=\"http://www.spoj.com/%EF%BC%89\">http://www.spoj.com/）</a><br>Coderbyte（<a href=\"http://coderbyte.com/%EF%BC%89\">http://coderbyte.com/）</a><br>Project Euler（<a href=\"https://projecteuler.net/%EF%BC%89\">https://projecteuler.net/）</a><br>HackerRank（<a href=\"https://www.hackerrank.com)/\">https://www.hackerrank.com）</a><br>CodeChef（<a href=\"http://www.codechef.com/%EF%BC%89\">http://www.codechef.com/）</a><br>Top Coder（<a href=\"http://www.topcoder.com/%EF%BC%89\">http://www.topcoder.com/）</a></p>\n<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>尾调用优化</p>\n<ul>\n<li>调用栈长</li>\n<li>使用后性能有较大的提升<br>Floyd-Warshall 算法<br>Kruskal 算法<br>背包问题<br>最长公共子序列<br>矩阵链相乘<br>NP 完全理论</li>\n<li>多项式时间</li>\n</ul>\n<p>算法的使用，什么情况下用合适？需要将数据转换处理<br>合适</p>\n<p>自己写的算法怎么验证正确性？<br>LeetCode或其他刷题网站</p>\n<p>antd升级后的visible修改任务<br>评估修改时间<br>testing-library/react测试react组件的库，安装了却没用？<br>umc-ui的项目框架使用的是别的项目的，原来就有，没删</p>\n"},{"title":"尾调用与尾递归","date":"2022-10-17T02:26:13.000Z","_content":"\n###### 什么是尾调用？\n**某个函数的最后一步调用另一个函数**\n\n```javascript\nfunction call1(a) {\n return call2(a);\n}\n\n// 以下三种情况不属于尾调用！！！\n// 函数调用后还有其他操作\nfunction call1(a) {\n const x = call2(a);\n return x;\n}\n\nfunction call1(a) {\n return call2(a) + 1;\n}\n\nfunction call1(a) {\n call2(a);\n}\n\n// 以下属于尾调用\nfunction call1(a) {\n if (!!a) {\n  return call2(a);\n }\n return call3(a);\n}\n```\n\n###### 尾调用优化\n\n*注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度*\n\n函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。\n\n![call-stack](call-stack.png)\n\n但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。\n\n*注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’*\n\n###### 尾递归\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。\n\n```javascript\n// 阶乘计算\n// 复杂度 O(n)\nfunction factorial(n) {\n if (n === 1) return 1;\n return n * factorial(n - 1);\n}\n\n// 复杂度O(1)\nfunction factorial(n, total) {\n if (n === 1) return total;\n return factorial(n -1, n* total);\n}\nfactorial(5, 1);\n\n// factorial(5, 1);\n// factorial(4, 5);\n// factorial(3, 20);\n// factorial(2, 60);\n// factorial(1, 120);\n// 120\n```\n\n###### 递归函数的改写优化\n尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：\n\n(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数\n\n```javascript\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nfunction call(n) {\n return tailCall(n, 1);\n}\n\ncall(5);\n```\n\n(2) 使用柯理化，将多参数的函数转化为单参数形式\n\n```javascript\nfunction currying(fn, n) {\n return function (m) {\n  return fn.call(this, m, n);\n }\n}\n\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nconst factorial = currying(tailCall, 1);\nfactorial(5);\n\n// 或者使用ES6函数默认值\nfunction factorial(n, total = 1) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\nfactorial(5);\n```\n\n*ES6的尾调用优化只在严格模式下开启，正常模式无效*\n正常模式下，函数内部有两个变量，可以跟踪函数的调用栈\n- arguments 返回调用时函数的参数\n- func.caller 返回调用当前函数的那个函数\n尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。\n\n[尾调用-维基百科](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)","source":"_posts/40-tail-call.md","raw":"---\ntitle: 尾调用与尾递归\ndate: 2022-10-17 10:26:13\ntags:\n---\n\n###### 什么是尾调用？\n**某个函数的最后一步调用另一个函数**\n\n```javascript\nfunction call1(a) {\n return call2(a);\n}\n\n// 以下三种情况不属于尾调用！！！\n// 函数调用后还有其他操作\nfunction call1(a) {\n const x = call2(a);\n return x;\n}\n\nfunction call1(a) {\n return call2(a) + 1;\n}\n\nfunction call1(a) {\n call2(a);\n}\n\n// 以下属于尾调用\nfunction call1(a) {\n if (!!a) {\n  return call2(a);\n }\n return call3(a);\n}\n```\n\n###### 尾调用优化\n\n*注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度*\n\n函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。\n\n![call-stack](call-stack.png)\n\n但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。\n\n*注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’*\n\n###### 尾递归\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。\n\n```javascript\n// 阶乘计算\n// 复杂度 O(n)\nfunction factorial(n) {\n if (n === 1) return 1;\n return n * factorial(n - 1);\n}\n\n// 复杂度O(1)\nfunction factorial(n, total) {\n if (n === 1) return total;\n return factorial(n -1, n* total);\n}\nfactorial(5, 1);\n\n// factorial(5, 1);\n// factorial(4, 5);\n// factorial(3, 20);\n// factorial(2, 60);\n// factorial(1, 120);\n// 120\n```\n\n###### 递归函数的改写优化\n尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：\n\n(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数\n\n```javascript\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nfunction call(n) {\n return tailCall(n, 1);\n}\n\ncall(5);\n```\n\n(2) 使用柯理化，将多参数的函数转化为单参数形式\n\n```javascript\nfunction currying(fn, n) {\n return function (m) {\n  return fn.call(this, m, n);\n }\n}\n\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nconst factorial = currying(tailCall, 1);\nfactorial(5);\n\n// 或者使用ES6函数默认值\nfunction factorial(n, total = 1) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\nfactorial(5);\n```\n\n*ES6的尾调用优化只在严格模式下开启，正常模式无效*\n正常模式下，函数内部有两个变量，可以跟踪函数的调用栈\n- arguments 返回调用时函数的参数\n- func.caller 返回调用当前函数的那个函数\n尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。\n\n[尾调用-维基百科](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)","slug":"40-tail-call","published":1,"updated":"2022-10-17T06:06:31.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q40013k4tt6x7j6wkd","content":"<h6 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h6><p><strong>某个函数的最后一步调用另一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下三种情况不属于尾调用！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 函数调用后还有其他操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> x = call2(a);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下属于尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!!a) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call3(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h6><p><em>注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度</em></p>\n<p>函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。</p>\n<p><img src=\"/2022/10/17/40-tail-call/call-stack.png\" alt=\"call-stack\"></p>\n<p>但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。</p>\n<p><em>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’</em></p>\n<h6 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h6><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阶乘计算</span></span><br><span class=\"line\"><span class=\"comment\">// 复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复杂度O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> factorial(n -<span class=\"number\">1</span>, n* total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// factorial(5, 1);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(4, 5);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(3, 20);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(2, 60);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(1, 120);</span></span><br><span class=\"line\"><span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"递归函数的改写优化\"><a href=\"#递归函数的改写优化\" class=\"headerlink\" title=\"递归函数的改写优化\"></a>递归函数的改写优化</h6><p>尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：</p>\n<p>(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>(2) 使用柯理化，将多参数的函数转化为单参数形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.call(<span class=\"built_in\">this</span>, m, n);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> factorial = currying(tailCall, <span class=\"number\">1</span>);</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用ES6函数默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6的尾调用优化只在严格模式下开启，正常模式无效</em><br>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈</p>\n<ul>\n<li>arguments 返回调用时函数的参数</li>\n<li>func.caller 返回调用当前函数的那个函数<br>尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。</li>\n</ul>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\">尾调用-维基百科</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h6><p><strong>某个函数的最后一步调用另一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下三种情况不属于尾调用！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 函数调用后还有其他操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> x = call2(a);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下属于尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!!a) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call3(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h6><p><em>注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度</em></p>\n<p>函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。</p>\n<p><img src=\"/2022/10/17/40-tail-call/call-stack.png\" alt=\"call-stack\"></p>\n<p>但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。</p>\n<p><em>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’</em></p>\n<h6 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h6><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阶乘计算</span></span><br><span class=\"line\"><span class=\"comment\">// 复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复杂度O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> factorial(n -<span class=\"number\">1</span>, n* total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// factorial(5, 1);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(4, 5);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(3, 20);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(2, 60);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(1, 120);</span></span><br><span class=\"line\"><span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"递归函数的改写优化\"><a href=\"#递归函数的改写优化\" class=\"headerlink\" title=\"递归函数的改写优化\"></a>递归函数的改写优化</h6><p>尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：</p>\n<p>(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>(2) 使用柯理化，将多参数的函数转化为单参数形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.call(<span class=\"built_in\">this</span>, m, n);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> factorial = currying(tailCall, <span class=\"number\">1</span>);</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用ES6函数默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6的尾调用优化只在严格模式下开启，正常模式无效</em><br>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈</p>\n<ul>\n<li>arguments 返回调用时函数的参数</li>\n<li>func.caller 返回调用当前函数的那个函数<br>尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。</li>\n</ul>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\">尾调用-维基百科</a></p>\n"},{"title":"nodejs基础知识(1)","date":"2022-10-19T11:12:12.000Z","_content":"\n###### nodejs是什么\n脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。\n\n每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。\n\n###### nodejs的安装\n官网地址：https://nodejs.org/en/\n\n直接从官网下载nodejs安装包，使用默认安装即可\n安装完成后打开dos，输入 *node -v*，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下\n\n**注意**\n1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）\n2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置\n3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 *npm -v*，查看npm版本\n\n根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发\n\n**nodejs官网地址：https://nodejs.org/zh-cn/docs/**\n**nodejs中文文档地址：https://www.nodeapp.cn/documentation.html**\n\n#### nodejs文档知识点\n\n###### assert-断言\n*作用：*用于测试不变式\n\n*assert.deepEqual(a, b[, message])*\n只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等\n注意：子对象中可枚举的属性也会被测试\n\n*assert.deepStrictEqual(a, b[, message])*\n与assert.deepEqual作用类似，使用全等 === 进行比较\n\n*assert.doesNotThrow(block[, error][, message])*\n调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误\n\n*assert.equal(actual, expected[, message])*\n使用相等运算符 == 测试actual与expected是否相等\n\n*assert.fail(message)*\n*assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])*\n抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 '!='。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除\n\n*assert.ifError(value)*\n如果value为真，则抛出value，即value为错误信息\n\n*assert.notDeepEqual(actual, expected[, message])*\n测试不深度相等","source":"_posts/41-nodejs-base.md","raw":"---\ntitle: nodejs基础知识(1)\ndate: 2022-10-19 19:12:12\ntags:\n---\n\n###### nodejs是什么\n脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。\n\n每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。\n\n###### nodejs的安装\n官网地址：https://nodejs.org/en/\n\n直接从官网下载nodejs安装包，使用默认安装即可\n安装完成后打开dos，输入 *node -v*，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下\n\n**注意**\n1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）\n2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置\n3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 *npm -v*，查看npm版本\n\n根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发\n\n**nodejs官网地址：https://nodejs.org/zh-cn/docs/**\n**nodejs中文文档地址：https://www.nodeapp.cn/documentation.html**\n\n#### nodejs文档知识点\n\n###### assert-断言\n*作用：*用于测试不变式\n\n*assert.deepEqual(a, b[, message])*\n只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等\n注意：子对象中可枚举的属性也会被测试\n\n*assert.deepStrictEqual(a, b[, message])*\n与assert.deepEqual作用类似，使用全等 === 进行比较\n\n*assert.doesNotThrow(block[, error][, message])*\n调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误\n\n*assert.equal(actual, expected[, message])*\n使用相等运算符 == 测试actual与expected是否相等\n\n*assert.fail(message)*\n*assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])*\n抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 '!='。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除\n\n*assert.ifError(value)*\n如果value为真，则抛出value，即value为错误信息\n\n*assert.notDeepEqual(actual, expected[, message])*\n测试不深度相等","slug":"41-nodejs-base","published":1,"updated":"2022-10-24T07:04:13.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q40014k4tteui3eion","content":"<h6 id=\"nodejs是什么\"><a href=\"#nodejs是什么\" class=\"headerlink\" title=\"nodejs是什么\"></a>nodejs是什么</h6><p>脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。</p>\n<p>每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。</p>\n<h6 id=\"nodejs的安装\"><a href=\"#nodejs的安装\" class=\"headerlink\" title=\"nodejs的安装\"></a>nodejs的安装</h6><p>官网地址：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n<p>直接从官网下载nodejs安装包，使用默认安装即可<br>安装完成后打开dos，输入 <em>node -v</em>，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下</p>\n<p><strong>注意</strong><br>1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）<br>2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置<br>3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 <em>npm -v</em>，查看npm版本</p>\n<p>根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发</p>\n<p><strong>nodejs官网地址：<a href=\"https://nodejs.org/zh-cn/docs/\">https://nodejs.org/zh-cn/docs/</a></strong><br><strong>nodejs中文文档地址：<a href=\"https://www.nodeapp.cn/documentation.html\">https://www.nodeapp.cn/documentation.html</a></strong></p>\n<h4 id=\"nodejs文档知识点\"><a href=\"#nodejs文档知识点\" class=\"headerlink\" title=\"nodejs文档知识点\"></a>nodejs文档知识点</h4><h6 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert-断言\"></a>assert-断言</h6><p><em>作用：</em>用于测试不变式</p>\n<p><em>assert.deepEqual(a, b[, message])</em><br>只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等<br>注意：子对象中可枚举的属性也会被测试</p>\n<p><em>assert.deepStrictEqual(a, b[, message])</em><br>与assert.deepEqual作用类似，使用全等 === 进行比较</p>\n<p><em>assert.doesNotThrow(block[, error][, message])</em><br>调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误</p>\n<p><em>assert.equal(actual, expected[, message])</em><br>使用相等运算符 == 测试actual与expected是否相等</p>\n<p><em>assert.fail(message)</em><br><em>assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])</em><br>抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 ‘!=’。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除</p>\n<p><em>assert.ifError(value)</em><br>如果value为真，则抛出value，即value为错误信息</p>\n<p><em>assert.notDeepEqual(actual, expected[, message])</em><br>测试不深度相等</p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"nodejs是什么\"><a href=\"#nodejs是什么\" class=\"headerlink\" title=\"nodejs是什么\"></a>nodejs是什么</h6><p>脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。</p>\n<p>每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。</p>\n<h6 id=\"nodejs的安装\"><a href=\"#nodejs的安装\" class=\"headerlink\" title=\"nodejs的安装\"></a>nodejs的安装</h6><p>官网地址：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n<p>直接从官网下载nodejs安装包，使用默认安装即可<br>安装完成后打开dos，输入 <em>node -v</em>，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下</p>\n<p><strong>注意</strong><br>1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）<br>2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置<br>3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 <em>npm -v</em>，查看npm版本</p>\n<p>根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发</p>\n<p><strong>nodejs官网地址：<a href=\"https://nodejs.org/zh-cn/docs/\">https://nodejs.org/zh-cn/docs/</a></strong><br><strong>nodejs中文文档地址：<a href=\"https://www.nodeapp.cn/documentation.html\">https://www.nodeapp.cn/documentation.html</a></strong></p>\n<h4 id=\"nodejs文档知识点\"><a href=\"#nodejs文档知识点\" class=\"headerlink\" title=\"nodejs文档知识点\"></a>nodejs文档知识点</h4><h6 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert-断言\"></a>assert-断言</h6><p><em>作用：</em>用于测试不变式</p>\n<p><em>assert.deepEqual(a, b[, message])</em><br>只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等<br>注意：子对象中可枚举的属性也会被测试</p>\n<p><em>assert.deepStrictEqual(a, b[, message])</em><br>与assert.deepEqual作用类似，使用全等 === 进行比较</p>\n<p><em>assert.doesNotThrow(block[, error][, message])</em><br>调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误</p>\n<p><em>assert.equal(actual, expected[, message])</em><br>使用相等运算符 == 测试actual与expected是否相等</p>\n<p><em>assert.fail(message)</em><br><em>assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])</em><br>抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 ‘!=’。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除</p>\n<p><em>assert.ifError(value)</em><br>如果value为真，则抛出value，即value为错误信息</p>\n<p><em>assert.notDeepEqual(actual, expected[, message])</em><br>测试不深度相等</p>\n"},{"title":"react渲染","date":"2022-06-22T14:12:37.000Z","_content":"\n## 主要步骤\n#### React.createElement语法糖\n(1)React.createElement(type, [props], [...children]);\n(2)type：元素类型\n(3)props：属性值\n(4)children：子元素\n#### 虚拟DOM\n(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系\n(2)$$typeof：标识符，使用Symbol数据结构确保唯一性\n\n#### 协调算法\n#### filter图示\n![filter_tree](fiber_tree.png)\n\n## Element转化为Dom\n(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化\n(2)ReactDOM.render(element, container[, callback])\n(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function\n\n## 源码相关\n1、setState触发更新、父组件重新渲染时触发更新\n![update_class](update_class.png)\n(1)static getDerivedStateFromProps()\n(2)shouldComponentUpdate(nextProps,nextState)\n(3)render()\n(4)getSnapshotBeforeUpdate(prevProps,prevState)\n(5)componentDidUpdate(prevProps,prevState,snapshot)\n其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参\n2、forceUpdate触发更新\n![force_update](force_update.png)\n(1)static getDerivedStateFromProps()\n(2)render()\n(3)getSnapshotBeforeUpdate()\n(4)componentDidUpdate()","source":"_posts/5-react-render.md","raw":"---\ntitle: react渲染\ndate: 2022-06-22 22:12:37\ntags:\n---\n\n## 主要步骤\n#### React.createElement语法糖\n(1)React.createElement(type, [props], [...children]);\n(2)type：元素类型\n(3)props：属性值\n(4)children：子元素\n#### 虚拟DOM\n(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系\n(2)$$typeof：标识符，使用Symbol数据结构确保唯一性\n\n#### 协调算法\n#### filter图示\n![filter_tree](fiber_tree.png)\n\n## Element转化为Dom\n(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化\n(2)ReactDOM.render(element, container[, callback])\n(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function\n\n## 源码相关\n1、setState触发更新、父组件重新渲染时触发更新\n![update_class](update_class.png)\n(1)static getDerivedStateFromProps()\n(2)shouldComponentUpdate(nextProps,nextState)\n(3)render()\n(4)getSnapshotBeforeUpdate(prevProps,prevState)\n(5)componentDidUpdate(prevProps,prevState,snapshot)\n其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参\n2、forceUpdate触发更新\n![force_update](force_update.png)\n(1)static getDerivedStateFromProps()\n(2)render()\n(3)getSnapshotBeforeUpdate()\n(4)componentDidUpdate()","slug":"5-react-render","published":1,"updated":"2022-08-10T03:15:06.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q50015k4tt1px4akzs","content":"<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><h4 id=\"React-createElement语法糖\"><a href=\"#React-createElement语法糖\" class=\"headerlink\" title=\"React.createElement语法糖\"></a>React.createElement语法糖</h4><p>(1)React.createElement(type, [props], […children]);<br>(2)type：元素类型<br>(3)props：属性值<br>(4)children：子元素</p>\n<h4 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h4><p>(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系<br>(2)$$typeof：标识符，使用Symbol数据结构确保唯一性</p>\n<h4 id=\"协调算法\"><a href=\"#协调算法\" class=\"headerlink\" title=\"协调算法\"></a>协调算法</h4><h4 id=\"filter图示\"><a href=\"#filter图示\" class=\"headerlink\" title=\"filter图示\"></a>filter图示</h4><p><img src=\"/2022/06/22/5-react-render/fiber_tree.png\" alt=\"filter_tree\"></p>\n<h2 id=\"Element转化为Dom\"><a href=\"#Element转化为Dom\" class=\"headerlink\" title=\"Element转化为Dom\"></a>Element转化为Dom</h2><p>(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化<br>(2)ReactDOM.render(element, container[, callback])<br>(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function</p>\n<h2 id=\"源码相关\"><a href=\"#源码相关\" class=\"headerlink\" title=\"源码相关\"></a>源码相关</h2><p>1、setState触发更新、父组件重新渲染时触发更新<br><img src=\"/2022/06/22/5-react-render/update_class.png\" alt=\"update_class\"><br>(1)static getDerivedStateFromProps()<br>(2)shouldComponentUpdate(nextProps,nextState)<br>(3)render()<br>(4)getSnapshotBeforeUpdate(prevProps,prevState)<br>(5)componentDidUpdate(prevProps,prevState,snapshot)<br>其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参<br>2、forceUpdate触发更新<br><img src=\"/2022/06/22/5-react-render/force_update.png\" alt=\"force_update\"><br>(1)static getDerivedStateFromProps()<br>(2)render()<br>(3)getSnapshotBeforeUpdate()<br>(4)componentDidUpdate()</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><h4 id=\"React-createElement语法糖\"><a href=\"#React-createElement语法糖\" class=\"headerlink\" title=\"React.createElement语法糖\"></a>React.createElement语法糖</h4><p>(1)React.createElement(type, [props], […children]);<br>(2)type：元素类型<br>(3)props：属性值<br>(4)children：子元素</p>\n<h4 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h4><p>(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系<br>(2)$$typeof：标识符，使用Symbol数据结构确保唯一性</p>\n<h4 id=\"协调算法\"><a href=\"#协调算法\" class=\"headerlink\" title=\"协调算法\"></a>协调算法</h4><h4 id=\"filter图示\"><a href=\"#filter图示\" class=\"headerlink\" title=\"filter图示\"></a>filter图示</h4><p><img src=\"/2022/06/22/5-react-render/fiber_tree.png\" alt=\"filter_tree\"></p>\n<h2 id=\"Element转化为Dom\"><a href=\"#Element转化为Dom\" class=\"headerlink\" title=\"Element转化为Dom\"></a>Element转化为Dom</h2><p>(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化<br>(2)ReactDOM.render(element, container[, callback])<br>(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function</p>\n<h2 id=\"源码相关\"><a href=\"#源码相关\" class=\"headerlink\" title=\"源码相关\"></a>源码相关</h2><p>1、setState触发更新、父组件重新渲染时触发更新<br><img src=\"/2022/06/22/5-react-render/update_class.png\" alt=\"update_class\"><br>(1)static getDerivedStateFromProps()<br>(2)shouldComponentUpdate(nextProps,nextState)<br>(3)render()<br>(4)getSnapshotBeforeUpdate(prevProps,prevState)<br>(5)componentDidUpdate(prevProps,prevState,snapshot)<br>其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参<br>2、forceUpdate触发更新<br><img src=\"/2022/06/22/5-react-render/force_update.png\" alt=\"force_update\"><br>(1)static getDerivedStateFromProps()<br>(2)render()<br>(3)getSnapshotBeforeUpdate()<br>(4)componentDidUpdate()</p>\n"},{"title":"js-新建固定长度数据","date":"2022-06-27T02:20:46.000Z","_content":"\n#### 新建固定长度数组\n\n###### 使用primitives填充数组\n```javascript\nconst newArray = Array(3).fill(3);\nconsole.log(newArray);  // [3, 3, 3]\n```\nArray(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法\n\n###### 使用对象填充数组\n(1)使用Array().fill()创建数组\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\nArray(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。\n这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 2}, {value: 2}, {value: 2}]\n```\n(2)使用Array.from()创建数组\nArray.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n(3)使用Array.map()结合Array.fill()创建数组\n注意：不要直接使用map新建数组，**array.map()跳过 empty 元素**\n```javascript\nconst newArray = Array(3).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [empty x 3]\n```\n解决方法很简单，将 empty 数组 fill null 即可：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n注意：使用这种方法创建的数组，修改某一项时不影响其他项：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n","source":"_posts/8-create-fixed-length-array.md","raw":"---\ntitle: js-新建固定长度数据\ndate: 2022-06-27 10:20:46\ntags:\n---\n\n#### 新建固定长度数组\n\n###### 使用primitives填充数组\n```javascript\nconst newArray = Array(3).fill(3);\nconsole.log(newArray);  // [3, 3, 3]\n```\nArray(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法\n\n###### 使用对象填充数组\n(1)使用Array().fill()创建数组\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\nArray(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。\n这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 2}, {value: 2}, {value: 2}]\n```\n(2)使用Array.from()创建数组\nArray.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n(3)使用Array.map()结合Array.fill()创建数组\n注意：不要直接使用map新建数组，**array.map()跳过 empty 元素**\n```javascript\nconst newArray = Array(3).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [empty x 3]\n```\n解决方法很简单，将 empty 数组 fill null 即可：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n注意：使用这种方法创建的数组，修改某一项时不影响其他项：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n","slug":"8-create-fixed-length-array","published":1,"updated":"2022-08-10T03:12:26.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q50016k4tt9w0le81s","content":"<h4 id=\"新建固定长度数组\"><a href=\"#新建固定长度数组\" class=\"headerlink\" title=\"新建固定长度数组\"></a>新建固定长度数组</h4><h6 id=\"使用primitives填充数组\"><a href=\"#使用primitives填充数组\" class=\"headerlink\" title=\"使用primitives填充数组\"></a>使用primitives填充数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [3, 3, 3]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法</p>\n<h6 id=\"使用对象填充数组\"><a href=\"#使用对象填充数组\" class=\"headerlink\" title=\"使用对象填充数组\"></a>使用对象填充数组</h6><p>(1)使用Array().fill()创建数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。<br>这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 2&#125;, &#123;value: 2&#125;, &#123;value: 2&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(2)使用Array.from()创建数组<br>Array.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。<br>因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(3)使用Array.map()结合Array.fill()创建数组<br>注意：不要直接使用map新建数组，<strong>array.map()跳过 empty 元素</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [empty x 3]</span></span><br></pre></td></tr></table></figure>\n<p>解决方法很简单，将 empty 数组 fill null 即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>注意：使用这种方法创建的数组，修改某一项时不影响其他项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"新建固定长度数组\"><a href=\"#新建固定长度数组\" class=\"headerlink\" title=\"新建固定长度数组\"></a>新建固定长度数组</h4><h6 id=\"使用primitives填充数组\"><a href=\"#使用primitives填充数组\" class=\"headerlink\" title=\"使用primitives填充数组\"></a>使用primitives填充数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [3, 3, 3]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法</p>\n<h6 id=\"使用对象填充数组\"><a href=\"#使用对象填充数组\" class=\"headerlink\" title=\"使用对象填充数组\"></a>使用对象填充数组</h6><p>(1)使用Array().fill()创建数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。<br>这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 2&#125;, &#123;value: 2&#125;, &#123;value: 2&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(2)使用Array.from()创建数组<br>Array.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。<br>因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(3)使用Array.map()结合Array.fill()创建数组<br>注意：不要直接使用map新建数组，<strong>array.map()跳过 empty 元素</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [empty x 3]</span></span><br></pre></td></tr></table></figure>\n<p>解决方法很简单，将 empty 数组 fill null 即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>注意：使用这种方法创建的数组，修改某一项时不影响其他项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"MarkDown语法及示例","date":"2022-06-27T02:43:07.000Z","_content":"\n#### MarkDown语法及示例\n\n###### 代码块\n\\```javascript\nconst name = 'eric';\n....\n\\``` \n###### 加粗字体\n\\*\\*文字\\*\\*\n\\_\\_文字\\_\\_\n\n###### 倾斜字体\n\\*文字\\*\n\\_文字\\_\n\n###### 斜体加粗\n\\*\\*\\*文字\\*\\*\\*\n\\_\\_\\_文字\\_\\_\\_\n\n###### 删除线\n\\~\\~文字\\~\\~\n\n###### 表格\n| 表头1 | 表头2 |\n| ----- | ----- |\n| 文字1 | 文字2 |\n\n###### 文字颜色\n<font color=\"red\">文字</font>\n```javascript\n<font color=\"red\">文字</font>\n<font color=\"blue\">文字</font>\n```\n\n###### 文字大小\n<font size=\"10\">文字</font>\n```javascript\n<font size=\"10\">文字</font>\n<font size=\"14\">文字</font>\n```\n\n###### 文字字体\n<font face=\"黑体\">文字</font>\n```javascript\n<font face=\"黑体\">文字</font>\n<font face=\"微软雅黑\">文字</font>\n```\n\n###### 背景色\n<mark style=\"bgcolor:red\">文字</mark>\n```javascript\n<mark style=\"bgcolor:red\">文字</mark>\n```\n\n###### 无序列表\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```javascript\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```\n\n###### 有序列表\n1. 第一行\n2. 第二行\n3. 第三行\n\n```javascript\n1. 第一行\n2. 第二行\n3. 第三行\n```\n\n###### 嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n\n```javascript\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n```\n\n###### 区块：区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号\n\\> 区块\n> 区块1\n> 区块2\n\n区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推\n> 1\n> > 2\n> > > 3\n\n###### 链接\n\\[链接名称\\]\\(链接地址\\) 或 <链接地址>\n```\n[百度](www.baidu.com)\n<www.baidu.com>\n```\n\n###### 图片\n!\\[alt 属性文本\\]\\(图片地址\\)\n\n\n###### 插入公式\n$ 数学公式 $​​​​​​​\n$$ 数学公式 $$​\n\n###### 指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\na^1\na_1\n$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$\n\n\n","source":"_posts/9-text-type-about-markdown.md","raw":"---\ntitle: MarkDown语法及示例\ndate: 2022-06-27 10:43:07\ntags:\n---\n\n#### MarkDown语法及示例\n\n###### 代码块\n\\```javascript\nconst name = 'eric';\n....\n\\``` \n###### 加粗字体\n\\*\\*文字\\*\\*\n\\_\\_文字\\_\\_\n\n###### 倾斜字体\n\\*文字\\*\n\\_文字\\_\n\n###### 斜体加粗\n\\*\\*\\*文字\\*\\*\\*\n\\_\\_\\_文字\\_\\_\\_\n\n###### 删除线\n\\~\\~文字\\~\\~\n\n###### 表格\n| 表头1 | 表头2 |\n| ----- | ----- |\n| 文字1 | 文字2 |\n\n###### 文字颜色\n<font color=\"red\">文字</font>\n```javascript\n<font color=\"red\">文字</font>\n<font color=\"blue\">文字</font>\n```\n\n###### 文字大小\n<font size=\"10\">文字</font>\n```javascript\n<font size=\"10\">文字</font>\n<font size=\"14\">文字</font>\n```\n\n###### 文字字体\n<font face=\"黑体\">文字</font>\n```javascript\n<font face=\"黑体\">文字</font>\n<font face=\"微软雅黑\">文字</font>\n```\n\n###### 背景色\n<mark style=\"bgcolor:red\">文字</mark>\n```javascript\n<mark style=\"bgcolor:red\">文字</mark>\n```\n\n###### 无序列表\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```javascript\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```\n\n###### 有序列表\n1. 第一行\n2. 第二行\n3. 第三行\n\n```javascript\n1. 第一行\n2. 第二行\n3. 第三行\n```\n\n###### 嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n\n```javascript\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n```\n\n###### 区块：区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号\n\\> 区块\n> 区块1\n> 区块2\n\n区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推\n> 1\n> > 2\n> > > 3\n\n###### 链接\n\\[链接名称\\]\\(链接地址\\) 或 <链接地址>\n```\n[百度](www.baidu.com)\n<www.baidu.com>\n```\n\n###### 图片\n!\\[alt 属性文本\\]\\(图片地址\\)\n\n\n###### 插入公式\n$ 数学公式 $​​​​​​​\n$$ 数学公式 $$​\n\n###### 指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\na^1\na_1\n$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$\n\n\n","slug":"9-text-type-about-markdown","published":1,"updated":"2022-10-14T03:01:44.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q60017k4ttc5dtbxlg","content":"<h4 id=\"MarkDown语法及示例\"><a href=\"#MarkDown语法及示例\" class=\"headerlink\" title=\"MarkDown语法及示例\"></a>MarkDown语法及示例</h4><h6 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h6><p>```javascript<br>const name = ‘eric’;<br>….<br>``` </p>\n<h6 id=\"加粗字体\"><a href=\"#加粗字体\" class=\"headerlink\" title=\"加粗字体\"></a>加粗字体</h6><p>**文字**<br>__文字__</p>\n<h6 id=\"倾斜字体\"><a href=\"#倾斜字体\" class=\"headerlink\" title=\"倾斜字体\"></a>倾斜字体</h6><p>*文字*<br>_文字_</p>\n<h6 id=\"斜体加粗\"><a href=\"#斜体加粗\" class=\"headerlink\" title=\"斜体加粗\"></a>斜体加粗</h6><p>***文字***<br>___文字___</p>\n<h6 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h6><p>~~文字~~</p>\n<h6 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h6><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文字1</td>\n<td>文字2</td>\n</tr>\n</tbody></table>\n<h6 id=\"文字颜色\"><a href=\"#文字颜色\" class=\"headerlink\" title=\"文字颜色\"></a>文字颜色</h6><p><font color=\"red\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font color=<span class=\"string\">&quot;red&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;blue&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字大小\"><a href=\"#文字大小\" class=\"headerlink\" title=\"文字大小\"></a>文字大小</h6><p><font size=\"10\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font size=<span class=\"string\">&quot;10&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;14&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字字体\"><a href=\"#文字字体\" class=\"headerlink\" title=\"文字字体\"></a>文字字体</h6><p><font face=\"黑体\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font face=<span class=\"string\">&quot;黑体&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">face</span>=<span class=\"string\">&quot;微软雅黑&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"背景色\"><a href=\"#背景色\" class=\"headerlink\" title=\"背景色\"></a>背景色</h6><p><mark style=\"bgcolor:red\">文字</mark></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mark style=<span class=\"string\">&quot;bgcolor:red&quot;</span>&gt;文字&lt;/mark&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h6><ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">* 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一行</span><br><span class=\"line\">+ 第二行</span><br><span class=\"line\">+ 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一行</span><br><span class=\"line\">- 第二行</span><br><span class=\"line\">- 第三行</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h6><ol>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 第一行</span><br><span class=\"line\"><span class=\"number\">2.</span> 第二行</span><br><span class=\"line\"><span class=\"number\">3.</span> 第三行</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"><a href=\"#嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\" class=\"headerlink\" title=\"嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"></a>嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</h6><ul>\n<li>第一行<ul>\n<li>1-1</li>\n</ul>\n</li>\n<li>第二行<ul>\n<li>2-1</li>\n</ul>\n</li>\n<li>第三行<ul>\n<li>3-1</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>第一行<ol>\n<li>1-1</li>\n</ol>\n</li>\n<li>第二行<ol>\n<li>2-1</li>\n</ol>\n</li>\n<li>第三行<ol>\n<li>3-1</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">  - <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  - <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  - <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">* 第一行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\"><a href=\"#区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\" class=\"headerlink\" title=\"区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号\"></a>区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</h6><p>&gt; 区块</p>\n<blockquote>\n<p>区块1<br>区块2</p>\n</blockquote>\n<p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p>\n<blockquote>\n<p>1</p>\n<blockquote>\n<p>2</p>\n<blockquote>\n<p>3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>[链接名称](链接地址) 或 &lt;链接地址&gt;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[百度](www.baidu.com)</span><br><span class=\"line\">&lt;www.baidu.com&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>![alt 属性文本](图片地址)</p>\n<h6 id=\"插入公式\"><a href=\"#插入公式\" class=\"headerlink\" title=\"插入公式\"></a>插入公式</h6><p>$ 数学公式 $​​​​​​​<br>$$ 数学公式 $$​</p>\n<h6 id=\"指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"><a href=\"#指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\" class=\"headerlink\" title=\"指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"></a>指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</h6><p>a^1<br>a_1<br>$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"MarkDown语法及示例\"><a href=\"#MarkDown语法及示例\" class=\"headerlink\" title=\"MarkDown语法及示例\"></a>MarkDown语法及示例</h4><h6 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h6><p>```javascript<br>const name = ‘eric’;<br>….<br>``` </p>\n<h6 id=\"加粗字体\"><a href=\"#加粗字体\" class=\"headerlink\" title=\"加粗字体\"></a>加粗字体</h6><p>**文字**<br>__文字__</p>\n<h6 id=\"倾斜字体\"><a href=\"#倾斜字体\" class=\"headerlink\" title=\"倾斜字体\"></a>倾斜字体</h6><p>*文字*<br>_文字_</p>\n<h6 id=\"斜体加粗\"><a href=\"#斜体加粗\" class=\"headerlink\" title=\"斜体加粗\"></a>斜体加粗</h6><p>***文字***<br>___文字___</p>\n<h6 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h6><p>~~文字~~</p>\n<h6 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h6><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文字1</td>\n<td>文字2</td>\n</tr>\n</tbody></table>\n<h6 id=\"文字颜色\"><a href=\"#文字颜色\" class=\"headerlink\" title=\"文字颜色\"></a>文字颜色</h6><p><font color=\"red\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font color=<span class=\"string\">&quot;red&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;blue&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字大小\"><a href=\"#文字大小\" class=\"headerlink\" title=\"文字大小\"></a>文字大小</h6><p><font size=\"10\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font size=<span class=\"string\">&quot;10&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;14&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字字体\"><a href=\"#文字字体\" class=\"headerlink\" title=\"文字字体\"></a>文字字体</h6><p><font face=\"黑体\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font face=<span class=\"string\">&quot;黑体&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">face</span>=<span class=\"string\">&quot;微软雅黑&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"背景色\"><a href=\"#背景色\" class=\"headerlink\" title=\"背景色\"></a>背景色</h6><p><mark style=\"bgcolor:red\">文字</mark></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mark style=<span class=\"string\">&quot;bgcolor:red&quot;</span>&gt;文字&lt;/mark&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h6><ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">* 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一行</span><br><span class=\"line\">+ 第二行</span><br><span class=\"line\">+ 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一行</span><br><span class=\"line\">- 第二行</span><br><span class=\"line\">- 第三行</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h6><ol>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 第一行</span><br><span class=\"line\"><span class=\"number\">2.</span> 第二行</span><br><span class=\"line\"><span class=\"number\">3.</span> 第三行</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"><a href=\"#嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\" class=\"headerlink\" title=\"嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"></a>嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</h6><ul>\n<li>第一行<ul>\n<li>1-1</li>\n</ul>\n</li>\n<li>第二行<ul>\n<li>2-1</li>\n</ul>\n</li>\n<li>第三行<ul>\n<li>3-1</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>第一行<ol>\n<li>1-1</li>\n</ol>\n</li>\n<li>第二行<ol>\n<li>2-1</li>\n</ol>\n</li>\n<li>第三行<ol>\n<li>3-1</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">  - <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  - <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  - <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">* 第一行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\"><a href=\"#区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\" class=\"headerlink\" title=\"区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号\"></a>区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</h6><p>&gt; 区块</p>\n<blockquote>\n<p>区块1<br>区块2</p>\n</blockquote>\n<p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p>\n<blockquote>\n<p>1</p>\n<blockquote>\n<p>2</p>\n<blockquote>\n<p>3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>[链接名称](链接地址) 或 &lt;链接地址&gt;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[百度](www.baidu.com)</span><br><span class=\"line\">&lt;www.baidu.com&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>![alt 属性文本](图片地址)</p>\n<h6 id=\"插入公式\"><a href=\"#插入公式\" class=\"headerlink\" title=\"插入公式\"></a>插入公式</h6><p>$ 数学公式 $​​​​​​​<br>$$ 数学公式 $$​</p>\n<h6 id=\"指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"><a href=\"#指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\" class=\"headerlink\" title=\"指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"></a>指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</h6><p>a^1<br>a_1<br>$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$</p>\n"},{"title":"vue3渲染","date":"2022-06-22T14:12:51.000Z","_content":"\n## 渲染流程\n![vue3_render](vue3_render.png)\n(1)创建一个vue实例 -> 初始化实例（包括需要相关事件与生命周期函数等）\n(2)调用beforeCreate\n(3)初始化注入，包括data、method等添加到实例对象\n(4)实例创建完成，调用created\n(5)有el挂载，使用template替换；无挂载，使用mount自动挂载\n(6)有template，进行编译，使其成为render函数\n(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板\n(8)调用beforeMount（vue实例挂载在虚拟DOM上）\n(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）\n(10)调用mounted\n-- （1）数据变更，即将重新渲染\n-- （2）调用beforeUpdate\n-- （3）进行虚拟DOM和真实DOM对比，进行patch\n-- （4）渲染完成，调用updated\n(11)实例销毁之前调用beforeUnmount\n(12)实例销毁，vm.$destroy\n(13)销毁后调用unmounted\n\n## render函数\n![render](render.png)\n(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载\n(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）\n(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池\n(4)最后更新容器上的Vnode\n注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）\n\n## patch函数\n![render_node1](render_node1.png)\n![render_node2](render_node2.png)\n![render_function](render_function.png)\n注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等\n(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点\n(2)container 是新节点的容器\n(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物\n(4)optimized 参数是是否开启优化模式的标识\n\n## 卸载组件\n如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：\n(1)如果存在ref，会首先重置ref\n(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载\n(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载\n","source":"_posts/6-vue3-render.md","raw":"---\ntitle: vue3渲染\ndate: 2022-06-22 22:12:51\ntags:\n---\n\n## 渲染流程\n![vue3_render](vue3_render.png)\n(1)创建一个vue实例 -> 初始化实例（包括需要相关事件与生命周期函数等）\n(2)调用beforeCreate\n(3)初始化注入，包括data、method等添加到实例对象\n(4)实例创建完成，调用created\n(5)有el挂载，使用template替换；无挂载，使用mount自动挂载\n(6)有template，进行编译，使其成为render函数\n(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板\n(8)调用beforeMount（vue实例挂载在虚拟DOM上）\n(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）\n(10)调用mounted\n-- （1）数据变更，即将重新渲染\n-- （2）调用beforeUpdate\n-- （3）进行虚拟DOM和真实DOM对比，进行patch\n-- （4）渲染完成，调用updated\n(11)实例销毁之前调用beforeUnmount\n(12)实例销毁，vm.$destroy\n(13)销毁后调用unmounted\n\n## render函数\n![render](render.png)\n(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载\n(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）\n(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池\n(4)最后更新容器上的Vnode\n注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）\n\n## patch函数\n![render_node1](render_node1.png)\n![render_node2](render_node2.png)\n![render_function](render_function.png)\n注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等\n(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点\n(2)container 是新节点的容器\n(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物\n(4)optimized 参数是是否开启优化模式的标识\n\n## 卸载组件\n如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：\n(1)如果存在ref，会首先重置ref\n(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载\n(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载\n","slug":"6-vue3-render","published":1,"updated":"2022-08-10T03:16:20.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q70018k4tt4jqgem20","content":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p><img src=\"/2022/06/22/6-vue3-render/vue3_render.png\" alt=\"vue3_render\"><br>(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）<br>(2)调用beforeCreate<br>(3)初始化注入，包括data、method等添加到实例对象<br>(4)实例创建完成，调用created<br>(5)有el挂载，使用template替换；无挂载，使用mount自动挂载<br>(6)有template，进行编译，使其成为render函数<br>(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板<br>(8)调用beforeMount（vue实例挂载在虚拟DOM上）<br>(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）<br>(10)调用mounted<br>– （1）数据变更，即将重新渲染<br>– （2）调用beforeUpdate<br>– （3）进行虚拟DOM和真实DOM对比，进行patch<br>– （4）渲染完成，调用updated<br>(11)实例销毁之前调用beforeUnmount<br>(12)实例销毁，vm.$destroy<br>(13)销毁后调用unmounted</p>\n<h2 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render.png\" alt=\"render\"><br>(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载<br>(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）<br>(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池<br>(4)最后更新容器上的Vnode<br>注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）</p>\n<h2 id=\"patch函数\"><a href=\"#patch函数\" class=\"headerlink\" title=\"patch函数\"></a>patch函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render_node1.png\" alt=\"render_node1\"><br><img src=\"/2022/06/22/6-vue3-render/render_node2.png\" alt=\"render_node2\"><br><img src=\"/2022/06/22/6-vue3-render/render_function.png\" alt=\"render_function\"><br>注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等<br>(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点<br>(2)container 是新节点的容器<br>(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物<br>(4)optimized 参数是是否开启优化模式的标识</p>\n<h2 id=\"卸载组件\"><a href=\"#卸载组件\" class=\"headerlink\" title=\"卸载组件\"></a>卸载组件</h2><p>如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：<br>(1)如果存在ref，会首先重置ref<br>(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载<br>(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p><img src=\"/2022/06/22/6-vue3-render/vue3_render.png\" alt=\"vue3_render\"><br>(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）<br>(2)调用beforeCreate<br>(3)初始化注入，包括data、method等添加到实例对象<br>(4)实例创建完成，调用created<br>(5)有el挂载，使用template替换；无挂载，使用mount自动挂载<br>(6)有template，进行编译，使其成为render函数<br>(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板<br>(8)调用beforeMount（vue实例挂载在虚拟DOM上）<br>(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）<br>(10)调用mounted<br>– （1）数据变更，即将重新渲染<br>– （2）调用beforeUpdate<br>– （3）进行虚拟DOM和真实DOM对比，进行patch<br>– （4）渲染完成，调用updated<br>(11)实例销毁之前调用beforeUnmount<br>(12)实例销毁，vm.$destroy<br>(13)销毁后调用unmounted</p>\n<h2 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render.png\" alt=\"render\"><br>(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载<br>(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）<br>(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池<br>(4)最后更新容器上的Vnode<br>注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）</p>\n<h2 id=\"patch函数\"><a href=\"#patch函数\" class=\"headerlink\" title=\"patch函数\"></a>patch函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render_node1.png\" alt=\"render_node1\"><br><img src=\"/2022/06/22/6-vue3-render/render_node2.png\" alt=\"render_node2\"><br><img src=\"/2022/06/22/6-vue3-render/render_function.png\" alt=\"render_function\"><br>注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等<br>(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点<br>(2)container 是新节点的容器<br>(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物<br>(4)optimized 参数是是否开启优化模式的标识</p>\n<h2 id=\"卸载组件\"><a href=\"#卸载组件\" class=\"headerlink\" title=\"卸载组件\"></a>卸载组件</h2><p>如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：<br>(1)如果存在ref，会首先重置ref<br>(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载<br>(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载</p>\n"},{"title":"react & vue渲染问题","date":"2022-06-23T05:21:12.000Z","_content":"\n#### 疑问点\n(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？\n类似渲染的子节点？？？\n(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？\n没什么特别意义，团队规范规定\n(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？\n性能、更新\n(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js\nreact-dom =》 渲染浏览器\nvue可以搭配react-dom\n(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？\n可以，使用createElement\n(6)hooks和函数的区别是什么？没区别\n(7)vue3中element-plus组件函数的类型从哪里获取？\n(8)如何将看到的东西和实际应用联系起来？\n(9)怎么抓住重点？\n","source":"_posts/7-question-about-render.md","raw":"---\ntitle: react & vue渲染问题\ndate: 2022-06-23 13:21:12\ntags:\n---\n\n#### 疑问点\n(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？\n类似渲染的子节点？？？\n(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？\n没什么特别意义，团队规范规定\n(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？\n性能、更新\n(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js\nreact-dom =》 渲染浏览器\nvue可以搭配react-dom\n(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？\n可以，使用createElement\n(6)hooks和函数的区别是什么？没区别\n(7)vue3中element-plus组件函数的类型从哪里获取？\n(8)如何将看到的东西和实际应用联系起来？\n(9)怎么抓住重点？\n","slug":"7-question-about-render","published":1,"updated":"2022-08-10T03:14:53.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q80019k4ttb9st64vm","content":"<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？<br>类似渲染的子节点？？？<br>(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？<br>没什么特别意义，团队规范规定<br>(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？<br>性能、更新<br>(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js<br>react-dom =》 渲染浏览器<br>vue可以搭配react-dom<br>(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？<br>可以，使用createElement<br>(6)hooks和函数的区别是什么？没区别<br>(7)vue3中element-plus组件函数的类型从哪里获取？<br>(8)如何将看到的东西和实际应用联系起来？<br>(9)怎么抓住重点？</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？<br>类似渲染的子节点？？？<br>(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？<br>没什么特别意义，团队规范规定<br>(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？<br>性能、更新<br>(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js<br>react-dom =》 渲染浏览器<br>vue可以搭配react-dom<br>(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？<br>可以，使用createElement<br>(6)hooks和函数的区别是什么？没区别<br>(7)vue3中element-plus组件函数的类型从哪里获取？<br>(8)如何将看到的东西和实际应用联系起来？<br>(9)怎么抓住重点？</p>\n"},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n","source":"_posts/15-js-transform/js-transform.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n","slug":"15-js-transform/js-transform","published":1,"date":"2022-08-11T05:19:34.637Z","updated":"2022-08-11T09:29:33.722Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9nrr8q8001ak4tt5ftc3a35","content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n"}],"PostAsset":[{"_id":"source/_posts/15-js-transform/convert-table.png","slug":"convert-table.png","post":"cl9nrr8po000bk4ttftbz2nyu","modified":0,"renderable":0},{"_id":"source/_posts/15-js-transform/js-transform.html","post":"cl9nrr8po000bk4ttftbz2nyu","slug":"js-transform.html","modified":1,"renderable":1},{"_id":"source/_posts/18-fake-array/array_from.png","slug":"array_from.png","post":"cl9nrr8pq000ek4tt962wb6sv","modified":0,"renderable":0},{"_id":"source/_posts/18-fake-array/document.png","slug":"document.png","post":"cl9nrr8pq000ek4tt962wb6sv","modified":0,"renderable":0},{"_id":"source/_posts/18-fake-array/prototype_call.png","slug":"prototype_call.png","post":"cl9nrr8pq000ek4tt962wb6sv","modified":0,"renderable":0},{"_id":"source/_posts/18-fake-array/slice_call.png","slug":"slice_call.png","post":"cl9nrr8pq000ek4tt962wb6sv","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/class-inherit.png","slug":"class-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/combination-inherit.png","slug":"combination-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/constructor-inherit.png","slug":"constructor-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/create-pop.png","slug":"create-pop.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/how-to-inherit.png","slug":"how-to-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/multiple-inherit.png","slug":"multiple-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/multiple-status.png","slug":"multiple-status.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/parasitic-combination-inherit.png","slug":"parasitic-combination-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/parasitic-inherit-change.png","slug":"parasitic-inherit-change.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/parasitic-inherit.png","slug":"parasitic-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/prototype-inherit.png","slug":"prototype-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/prototype.png","slug":"prototype.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/public-and-private.png","slug":"public-and-private.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/safe-model.png","slug":"safe-model.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/simple-factory1.png","slug":"simple-factory1.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/simple-factory2.png","slug":"simple-factory2.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/static-and-public.png","slug":"static-and-public.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/23-about-design-model/test-prototype-inherit.png","slug":"test-prototype-inherit.png","post":"cl9nrr8pt000kk4tth8kd5gio","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/abstract-car.png","slug":"abstract-car.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/abstract-factory1.png","slug":"abstract-factory1.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/abstract-factory2.png","slug":"abstract-factory2.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/abstract-factory3.png","slug":"abstract-factory3.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/human.png","slug":"human.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/lazy-single-instance.png","slug":"lazy-single-instance.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/name.png","slug":"name.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/person.png","slug":"person.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/prototype-inherit1.png","slug":"prototype-inherit1.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/prototype-inherit2.png","slug":"prototype-inherit2.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/prototype-model.png","slug":"prototype-model.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/safe-factory-model.png","slug":"safe-factory-model.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/safe-model-class.png","slug":"safe-model-class.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/static-param.png","slug":"static-param.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/24-about-design-model1/work.png","slug":"work.png","post":"cl9nrr8pu000lk4ttai5p9t2y","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/add-message.png","slug":"add-message.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/basic-model.png","slug":"basic-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/cache-model.png","slug":"cache-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/command-model-1.png","slug":"command-model-1.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/command-model-2.png","slug":"command-model-2.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/command-model-3.png","slug":"command-model-3.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/create-component.png","slug":"create-component.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/deal-data.png","slug":"deal-data.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/explain-model-1.png","slug":"explain-model-1.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/explain-model-2.png","slug":"explain-model-2.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/explain-model-3.png","slug":"explain-model-3.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/inherit-as-basic-model.png","slug":"inherit-as-basic-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/inherit-model.png","slug":"inherit-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/iterator-model.png","slug":"iterator-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/marry-state.png","slug":"marry-state.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/marry-state1.png","slug":"marry-state1.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/mediator-model.png","slug":"mediator-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/observer-fire.png","slug":"observer-fire.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/observer-regist.png","slug":"observer-regist.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/observer-remove.png","slug":"observer-remove.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/observer.png","slug":"observer.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/price-strategy.png","slug":"price-strategy.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/regist-change-num.png","slug":"regist-change-num.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/regist-message.png","slug":"regist-message.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/send-data.png","slug":"send-data.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/visitor-model.png","slug":"visitor-model.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/26-about-design-model3/vote-status.png","slug":"vote-status.png","post":"cl9nrr8pv000nk4tt0fqs7x6a","modified":0,"renderable":0},{"_id":"source/_posts/25-about-design-model2/bridge1.png","slug":"bridge1.png","post":"cl9nrr8pu000mk4tt42nha5ly","modified":0,"renderable":0},{"_id":"source/_posts/25-about-design-model2/bridge2.png","slug":"bridge2.png","post":"cl9nrr8pu000mk4tt42nha5ly","modified":0,"renderable":0},{"_id":"source/_posts/25-about-design-model2/bridge3.png","slug":"bridge3.png","post":"cl9nrr8pu000mk4tt42nha5ly","modified":0,"renderable":0},{"_id":"source/_posts/25-about-design-model2/decorator.png","slug":"decorator.png","post":"cl9nrr8pu000mk4tt42nha5ly","modified":0,"renderable":0},{"_id":"source/_posts/25-about-design-model2/out-look.png","slug":"out-look.png","post":"cl9nrr8pu000mk4tt42nha5ly","modified":0,"renderable":0},{"_id":"source/_posts/25-about-design-model2/station-culculate.png","slug":"station-culculate.png","post":"cl9nrr8pu000mk4tt42nha5ly","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/chain-model-1.png","slug":"chain-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/chain-model-2.png","slug":"chain-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/chain-model-3.png","slug":"chain-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/chain-model-4.png","slug":"chain-model-4.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/chain-model-5.png","slug":"chain-model-5.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/chain-model-6.png","slug":"chain-model-6.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/entrust-model-1.png","slug":"entrust-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/entrust-model-2.png","slug":"entrust-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/lazy-model-1.png","slug":"lazy-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/lazy-model-2.png","slug":"lazy-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/lazy-model-3.png","slug":"lazy-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/lazy-model-4.png","slug":"lazy-model-4.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/lazy-model-5.png","slug":"lazy-model-5.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/lazy-model-6.png","slug":"lazy-model-6.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/localstorage-model-1.png","slug":"localstorage-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/localstorage-model-2.png","slug":"localstorage-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/localstorage-model-3.png","slug":"localstorage-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/localstorage-model-4.png","slug":"localstorage-model-4.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/localstorage-model-5.png","slug":"localstorage-model-5.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/localstorage-model-6.png","slug":"localstorage-model-6.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/participate-model-1.png","slug":"participate-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/participate-model-2.png","slug":"participate-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/participate-model-3.png","slug":"participate-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/participate-model-4.png","slug":"participate-model-4.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/participate-model-5.png","slug":"participate-model-5.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/participate-model-6.png","slug":"participate-model-6.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/template-model-1.png","slug":"template-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/template-model-2.png","slug":"template-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/template-model-3.png","slug":"template-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/template-model-4.png","slug":"template-model-4.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/template-model-5.png","slug":"template-model-5.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/template-model-6.png","slug":"template-model-6.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/throttle-model-1.png","slug":"throttle-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/throttle-model-2.png","slug":"throttle-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/throttle-model-3.png","slug":"throttle-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-1.png","slug":"waiter-model-1.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-2.png","slug":"waiter-model-2.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-3.png","slug":"waiter-model-3.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-4.png","slug":"waiter-model-4.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-5.png","slug":"waiter-model-5.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-6.png","slug":"waiter-model-6.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-7.png","slug":"waiter-model-7.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/27-about-design-model4/waiter-model-8.png","slug":"waiter-model-8.png","post":"cl9nrr8pv000ok4ttc0g75m9t","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-1.png","slug":"appendix-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-10.png","slug":"appendix-10.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-2.png","slug":"appendix-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-3.png","slug":"appendix-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-4.png","slug":"appendix-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-5.png","slug":"appendix-5.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-6.png","slug":"appendix-6.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-7.png","slug":"appendix-7.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-8.png","slug":"appendix-8.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/appendix-9.png","slug":"appendix-9.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-1.png","slug":"async-module-model-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-2.png","slug":"async-module-model-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-3.png","slug":"async-module-model-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-4.png","slug":"async-module-model-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-5.png","slug":"async-module-model-5.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-6.png","slug":"async-module-model-6.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-7.png","slug":"async-module-model-7.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-8.png","slug":"async-module-model-8.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/async-module-model-9.png","slug":"async-module-model-9.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/module-model-1.png","slug":"module-model-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/module-model-2.png","slug":"module-model-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/module-model-3.png","slug":"module-model-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/module-model-4.png","slug":"module-model-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/module-model-5.png","slug":"module-model-5.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvc-model-1.png","slug":"mvc-model-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvc-model-2.png","slug":"mvc-model-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvc-model-3.png","slug":"mvc-model-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvc-model-4.png","slug":"mvc-model-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-1.png","slug":"mvp-model-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-2.png","slug":"mvp-model-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-3.png","slug":"mvp-model-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-4.png","slug":"mvp-model-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-5.png","slug":"mvp-model-5.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-6.png","slug":"mvp-model-6.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvp-model-7.png","slug":"mvp-model-7.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-1.png","slug":"mvvm-model-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-2.png","slug":"mvvm-model-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-3.png","slug":"mvvm-model-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-4.png","slug":"mvvm-model-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-5.png","slug":"mvvm-model-5.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-6.png","slug":"mvvm-model-6.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-7.png","slug":"mvvm-model-7.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/mvvm-model-8.png","slug":"mvvm-model-8.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/widget-model-1.png","slug":"widget-model-1.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/widget-model-2.png","slug":"widget-model-2.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/widget-model-3.png","slug":"widget-model-3.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/widget-model-4.png","slug":"widget-model-4.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/widget-model-5.png","slug":"widget-model-5.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/28-about-design-model5/widget-model-6.png","slug":"widget-model-6.png","post":"cl9nrr8pw000pk4tt93xj8sk3","modified":0,"renderable":0},{"_id":"source/_posts/34-data-structure2/chain-table-1.png","slug":"chain-table-1.png","post":"cl9nrr8q0000wk4ttbiee43b5","modified":0,"renderable":0},{"_id":"source/_posts/34-data-structure2/chain-table-2.png","slug":"chain-table-2.png","post":"cl9nrr8q0000wk4ttbiee43b5","modified":0,"renderable":0},{"_id":"source/_posts/34-data-structure2/chain-table-3.png","slug":"chain-table-3.png","post":"cl9nrr8q0000wk4ttbiee43b5","modified":0,"renderable":0},{"_id":"source/_posts/34-data-structure2/chain-table-4.png","slug":"chain-table-4.png","post":"cl9nrr8q0000wk4ttbiee43b5","modified":0,"renderable":0},{"_id":"source/_posts/35-data-structure3/linear-probing.png","slug":"linear-probing.png","post":"cl9nrr8q1000xk4tt2l1c228i","modified":0,"renderable":0},{"_id":"source/_posts/35-data-structure3/lose-lose.png","slug":"lose-lose.png","post":"cl9nrr8q1000xk4tt2l1c228i","modified":0,"renderable":0},{"_id":"source/_posts/35-data-structure3/move-key.png","slug":"move-key.png","post":"cl9nrr8q1000xk4tt2l1c228i","modified":0,"renderable":0},{"_id":"source/_posts/35-data-structure3/soft-delete.png","slug":"soft-delete.png","post":"cl9nrr8q1000xk4tt2l1c228i","modified":0,"renderable":0},{"_id":"source/_posts/35-data-structure3/sperate-chain.png","slug":"sperate-chain.png","post":"cl9nrr8q1000xk4tt2l1c228i","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/search-1.png","slug":"search-1.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/search-2.png","slug":"search-2.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/search-3.png","slug":"search-3.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/search-4.png","slug":"search-4.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-1.png","slug":"sort-1.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-10.png","slug":"sort-10.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-11.png","slug":"sort-11.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-12.png","slug":"sort-12.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-2.png","slug":"sort-2.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-3.png","slug":"sort-3.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-4.png","slug":"sort-4.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-5.png","slug":"sort-5.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-6.png","slug":"sort-6.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-7.png","slug":"sort-7.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-8.png","slug":"sort-8.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/38-data-structure6/sort-9.png","slug":"sort-9.png","post":"cl9nrr8q2000zk4tt41ox8w40","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/binary-search-tree.png","slug":"binary-search-tree.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/factorial.png","slug":"factorial.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/in-order-traverse.png","slug":"in-order-traverse.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/left-left-1.png","slug":"left-left-1.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/left-left-2.png","slug":"left-left-2.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/left-right-1.png","slug":"left-right-1.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/left-right-2.png","slug":"left-right-2.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/post-order-traverse.png","slug":"post-order-traverse.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/pre-order-traverse.png","slug":"pre-order-traverse.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/red-black-2a.png","slug":"red-black-2a.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/red-black-2b.png","slug":"red-black-2b.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/red-black-3a.png","slug":"red-black-3a.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/red-black-3b.png","slug":"red-black-3b.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/remove-left-right.png","slug":"remove-left-right.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/right-left-1.png","slug":"right-left-1.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/right-left-2.png","slug":"right-left-2.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/right-right-1.png","slug":"right-right-1.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/right-right-2.png","slug":"right-right-2.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/36-data-structure4/tree.png","slug":"tree.png","post":"cl9nrr8q1000yk4tt8bav964a","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-1.png","slug":"graph-1.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-10.png","slug":"graph-10.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-11.png","slug":"graph-11.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-12.png","slug":"graph-12.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-13.png","slug":"graph-13.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-2.png","slug":"graph-2.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-3.png","slug":"graph-3.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-4.png","slug":"graph-4.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-5.png","slug":"graph-5.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-6.png","slug":"graph-6.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-7.png","slug":"graph-7.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-8.png","slug":"graph-8.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/graph-9.png","slug":"graph-9.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/heap-sort.png","slug":"heap-sort.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/heat.png","slug":"heat.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/min-heat-pic.png","slug":"min-heat-pic.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/37-data-structure5/min-heat.png","slug":"min-heat.png","post":"cl9nrr8q20010k4ttg0q1ct2o","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/big-o-1.png","slug":"big-o-1.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/big-o-2.png","slug":"big-o-2.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/big-o-3.png","slug":"big-o-3.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/big-o-4.png","slug":"big-o-4.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/big-o-5.png","slug":"big-o-5.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/big-o-6.png","slug":"big-o-6.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/technology-1.png","slug":"technology-1.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/technology-2.png","slug":"technology-2.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/technology-3.png","slug":"technology-3.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/technology-4.png","slug":"technology-4.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/39-data-structure7/technology-5.png","slug":"technology-5.png","post":"cl9nrr8q30012k4tt3ya42jfn","modified":0,"renderable":0},{"_id":"source/_posts/40-tail-call/call-stack.png","slug":"call-stack.png","post":"cl9nrr8q40013k4tt6x7j6wkd","modified":0,"renderable":0},{"_id":"source/_posts/5-react-render/fiber_tree.png","slug":"fiber_tree.png","post":"cl9nrr8q50015k4tt1px4akzs","modified":0,"renderable":0},{"_id":"source/_posts/5-react-render/force_update.png","slug":"force_update.png","post":"cl9nrr8q50015k4tt1px4akzs","modified":0,"renderable":0},{"_id":"source/_posts/5-react-render/update_class.png","slug":"update_class.png","post":"cl9nrr8q50015k4tt1px4akzs","modified":0,"renderable":0},{"_id":"source/_posts/6-vue3-render/render.png","slug":"render.png","post":"cl9nrr8q70018k4tt4jqgem20","modified":0,"renderable":0},{"_id":"source/_posts/6-vue3-render/render_function.png","slug":"render_function.png","post":"cl9nrr8q70018k4tt4jqgem20","modified":0,"renderable":0},{"_id":"source/_posts/6-vue3-render/render_node1.png","slug":"render_node1.png","post":"cl9nrr8q70018k4tt4jqgem20","modified":0,"renderable":0},{"_id":"source/_posts/6-vue3-render/render_node2.png","slug":"render_node2.png","post":"cl9nrr8q70018k4tt4jqgem20","modified":0,"renderable":0},{"_id":"source/_posts/6-vue3-render/vue3_render.png","slug":"vue3_render.png","post":"cl9nrr8q70018k4tt4jqgem20","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}