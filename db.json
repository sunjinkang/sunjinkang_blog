{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/nodejs/file/stderr.log","path":"nodejs/file/stderr.log","modified":1,"renderable":0},{"_id":"source/nodejs/file/test.enc","path":"nodejs/file/test.enc","modified":1,"renderable":0},{"_id":"source/nodejs/file/stdout.log","path":"nodejs/file/stdout.log","modified":1,"renderable":0},{"_id":"source/nodejs/images/async-experience.png","path":"nodejs/images/async-experience.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/async-progress.png","path":"nodejs/images/async-progress.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/async-call.png","path":"nodejs/images/async-call.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/bigpipe.png","path":"nodejs/images/bigpipe.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/buffer-3.png","path":"nodejs/images/buffer-3.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/buffer.png","path":"nodejs/images/buffer.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/buffer-2.png","path":"nodejs/images/buffer-2.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/buffer-1.png","path":"nodejs/images/buffer-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/ca-1.png","path":"nodejs/images/ca-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/ca.png","path":"nodejs/images/ca.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/cache.png","path":"nodejs/images/cache.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/collect-diff.png","path":"nodejs/images/collect-diff.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/cross-platform.png","path":"nodejs/images/cross-platform.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/commonjs-node-relation.png","path":"nodejs/images/commonjs-node-relation.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/epoll-loop.png","path":"nodejs/images/epoll-loop.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/how-to-call-async.png","path":"nodejs/images/how-to-call-async.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/fork.png","path":"nodejs/images/fork.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/defer-promise.png","path":"nodejs/images/defer-promise.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/http.png","path":"nodejs/images/http.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/increase-target.png","path":"nodejs/images/increase-target.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/jam.png","path":"nodejs/images/jam.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/loop-1.png","path":"nodejs/images/loop-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/loop.png","path":"nodejs/images/loop.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/master-slave.png","path":"nodejs/images/master-slave.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/mvc.png","path":"nodejs/images/mvc.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/middle.png","path":"nodejs/images/middle.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/net-1.png","path":"nodejs/images/net-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/net-3.png","path":"nodejs/images/net-3.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/net-2.png","path":"nodejs/images/net-2.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/net-4.png","path":"nodejs/images/net-4.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/node-modules.png","path":"nodejs/images/node-modules.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/no-jam.png","path":"nodejs/images/no-jam.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/nvm-setting-content.png","path":"nodejs/images/nvm-setting-content.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/node-require.png","path":"nodejs/images/node-require.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/nvm-install.png","path":"nodejs/images/nvm-install.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/nvm-download.png","path":"nodejs/images/nvm-download.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/nvm-setting.png","path":"nodejs/images/nvm-setting.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/package.png","path":"nodejs/images/package.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/pipe-2.png","path":"nodejs/images/pipe-2.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/pipe-1.png","path":"nodejs/images/pipe-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/pipe-3.png","path":"nodejs/images/pipe-3.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/product-1.png","path":"nodejs/images/product-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/pipe-4.png","path":"nodejs/images/pipe-4.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/poll-loop.png","path":"nodejs/images/poll-loop.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/pipe.png","path":"nodejs/images/pipe.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/settimeout.png","path":"nodejs/images/settimeout.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/read-loop.png","path":"nodejs/images/read-loop.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/product.png","path":"nodejs/images/product.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/sweep-compact.png","path":"nodejs/images/sweep-compact.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/select-loop.png","path":"nodejs/images/select-loop.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/test-2.png","path":"nodejs/images/test-2.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/test.png","path":"nodejs/images/test.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/symlinks.png","path":"nodejs/images/symlinks.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/tail-trigger.png","path":"nodejs/images/tail-trigger.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/test-1.png","path":"nodejs/images/test-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/v8-promot2.png","path":"nodejs/images/v8-promot2.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/v8-promot.png","path":"nodejs/images/v8-promot.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/tls-ssl.png","path":"nodejs/images/tls-ssl.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/websocket-1.png","path":"nodejs/images/websocket-1.png","modified":1,"renderable":0},{"_id":"source/nodejs/images/websocket.png","path":"nodejs/images/websocket.png","modified":1,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.jpeg","path":"images/logo.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/nodejs/nodejs-note-14.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1672819655798},{"_id":"source/nodejs/nodejs-note-15.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1672819667764},{"_id":"source/nodejs/file/stdout.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1672814667830},{"_id":"source/index.md","hash":"b55e6f2c2b127640284ae1c862095d2e57cd2d03","modified":1667272331961},{"_id":"source/commonweal/index.md","hash":"ad7fb815e56ba127e811a3567a619a7ab7edf654","modified":1660024567905},{"_id":"source/vue/index.md","hash":"a57df7e0596d7db725d855a700185c74dcfed5c4","modified":1643106514167},{"_id":"source/_posts/12-create-github-tokens.md","hash":"36bc1839b5bbc1938ce1e8b84ada86cb81b5683b","modified":1656566299719},{"_id":"source/vue/change.md","hash":"0657a56e1da4d07caae9b44aae3d845ade2e7325","modified":1643105454040},{"_id":"source/vue/dependency.md","hash":"b96d71c3fd9006df71d6a7e7a25602472b1caa0d","modified":1643105980849},{"_id":"source/_posts/1-hello-world.md","hash":"270b836ccfe6be2557efe7cff4f7508dcbe21bba","modified":1655949513679},{"_id":"source/_posts/11-github-push-insert-password.md","hash":"4b012a4cc4f906f27b1073639d349af384637565","modified":1656566532389},{"_id":"source/_posts/10-about-meta.md","hash":"bb4ea509d4e70d028ab897066775a3c5daa92e4c","modified":1658389708630},{"_id":"source/_posts/13-document-location.md","hash":"658fe2b78f7a73ab1f289730905cd9c1e813e07c","modified":1666681454558},{"_id":"source/_posts/14-about-fe-theory.md","hash":"5a090673e16c377c4d2d578998cb29d6fb88aa5a","modified":1658123245279},{"_id":"source/_posts/16-origin-type-and-reference-type.md","hash":"10b010393111f0a8cf7c4644b8acd4bfc87cf2ef","modified":1660101267201},{"_id":"source/_posts/18-fake-array.md","hash":"1c2ab5ff218428b5e1de4a589f681afd808e21ec","modified":1659597456091},{"_id":"source/_posts/15-js-transform.md","hash":"e696a1a70a8634cac69b43cd2892f45e82838a37","modified":1660101077050},{"_id":"source/_posts/19-about-map.md","hash":"f39821c6d8c12680cecf25f6abddd8430f3ed0eb","modified":1659598283549},{"_id":"source/_posts/17-about-dom.md","hash":"8b9d82b293d05a8607338ba7805995668a2a75bc","modified":1661856873610},{"_id":"source/_posts/2-var-const-let.md","hash":"41e5f191349193383557269ea8ec33cf0d9ce21c","modified":1660101369107},{"_id":"source/_posts/20-create-vscode-plugin.md","hash":"653b6b918bb11faa8cc85909e37b971d5d07bf0e","modified":1659679736829},{"_id":"source/_posts/22-about-symbol.md","hash":"99d71ea1b58e50276b11a2debd131027221678e0","modified":1660887762437},{"_id":"source/_posts/24-about-design-model1.md","hash":"8f76ec64f22977e4d5a6486f4e4090779a91f5c5","modified":1663838190022},{"_id":"source/_posts/21-devan-operation.md","hash":"6bbc2c6364decd9a99cb4f72c1626a757fa4a871","modified":1660807793069},{"_id":"source/_posts/25-about-design-model2.md","hash":"6adc57fe87e1a23af4cb2ccf359caaa5e9d52a23","modified":1663838204404},{"_id":"source/_posts/23-about-design-model.md","hash":"9eb2c5bd6124d1a582158156ccc553a079934b46","modified":1663838158613},{"_id":"source/_posts/27-about-design-model4.md","hash":"8b9f3064b26ee72f6a4d886726923dab412a6043","modified":1663915885454},{"_id":"source/_posts/30-some-convenient-code.md","hash":"77144e1fdf0f043b670668068dfce18ff5c73b18","modified":1662356523830},{"_id":"source/_posts/28-about-design-model5.md","hash":"8fb3151d527abdb7b72d37b7072df8e9cf9e90a0","modified":1663916378606},{"_id":"source/_posts/3-about-use-hexo.md","hash":"dfe2e57286b86d882621511540b190d20445efea","modified":1671176642565},{"_id":"source/_posts/26-about-design-model3.md","hash":"5f3244ba3d46a81d344ad7a0436b1ed877ed6121","modified":1663838226427},{"_id":"source/_posts/32-apply-array-to-params.md","hash":"52d35507e347e52b26921224d017b6d2a82edc58","modified":1666680400737},{"_id":"source/_posts/31-get-and-set-prototypeof.md","hash":"035d9fccc65f0c58943ade176ca7d6ec49026c7f","modified":1662360142960},{"_id":"source/_posts/34-data-structure2.md","hash":"4e0f33961038eb3349bcb221f53886a7b8732882","modified":1664270489523},{"_id":"source/_posts/29-es6-object-strong.md","hash":"6ae821db818da9d8730d16f9569103b5e560f350","modified":1662097772109},{"_id":"source/_posts/36-data-structure4.md","hash":"7951edc4e2ffb8d2e63b958726c452062cd91c06","modified":1665217503909},{"_id":"source/_posts/33-data-structure1.md","hash":"e6524756037ae38015b2ada98ef9e8c3783b0090","modified":1663919512037},{"_id":"source/_posts/35-data-structure3.md","hash":"c92d6cb215fc4f8386a98274573e19ca678ff032","modified":1665206691061},{"_id":"source/_posts/38-data-structure6.md","hash":"d912b4354998b96e9dfab0b0781172ece08451de","modified":1665648774939},{"_id":"source/_posts/41-js-equal-type.md","hash":"44974b3f8b3f563ebc9844fca893418189c8f12e","modified":1666776409205},{"_id":"source/_posts/4-browser-render.md","hash":"748dabbf3eaa00f47492d9d5909abaebbb4ae79e","modified":1666668016618},{"_id":"source/_posts/40-tail-call.md","hash":"2a0fdab19e2e7590782f190297152c8da77a57c7","modified":1671173782607},{"_id":"source/_posts/37-data-structure5.md","hash":"ffc693174996ef51966af77150292509158b426b","modified":1665641643893},{"_id":"source/_posts/39-data-structure7.md","hash":"8a45476dfce18636b702ba2e62b184cb5d27feae","modified":1666665253998},{"_id":"source/_posts/5-react-render.md","hash":"3d1ecf1f8ba758118a9958874f508559db7f5a93","modified":1660101306301},{"_id":"source/_posts/42-scrollInToView-params.md","hash":"9c66eec9bf7671c178b696b05b1349bc5c3914b6","modified":1668049745623},{"_id":"source/_posts/44-about-grid.md","hash":"c549a3880d0e996c797dea258ce229d8388bf39a","modified":1672733878368},{"_id":"source/_posts/7-question-about-render.md","hash":"362aefe2d4a9469e1320feb49412433993979820","modified":1660101293040},{"_id":"source/_posts/6-vue3-render.md","hash":"0e7f667b40d879002559a3e6be9ea488e11a467b","modified":1660101380555},{"_id":"source/_posts/43-compress-picture.md","hash":"be187f049a28b605f9dc7b150de11e49d2c4e63c","modified":1670550219494},{"_id":"source/_posts/9-text-type-about-markdown.md","hash":"0d57e2234ae893536c0e0a54f958129b02e46ed7","modified":1665716504781},{"_id":"source/_posts/8-create-fixed-length-array.md","hash":"bb6b775930a2282b80b9b78f0239c17461fec807","modified":1660101146408},{"_id":"source/nodejs/nodejs-note-13.md","hash":"e0d7e52fc03232a40447c60e10e469ca1507c1e7","modified":1672825060464},{"_id":"source/nodejs/nodejs-note-1.md","hash":"1c43517aefbf32e5d016226ab544cd607ccb19fa","modified":1671528431300},{"_id":"source/nodejs/nodejs-note-10.md","hash":"d1c249a8797304dfbfcdb119d51e445bf895aa9a","modified":1672388818409},{"_id":"source/nodejs/index.md","hash":"bbbcb26a2cec461888979c6c74d39df63bd6ed05","modified":1672819968576},{"_id":"source/nodejs/install-diff-version-node-by-nvm.md","hash":"3f5a735e29bb261fe649cb965538c77c19ccc19e","modified":1671173826867},{"_id":"source/nodejs/nodejs-note-5.md","hash":"f329a87ea5bacff1c0675a6df18eaef74d3063a2","modified":1672819772366},{"_id":"source/nodejs/nodejs-note-11.md","hash":"42f868eab0fab129daa570a71fac3ba8bbb8fe1d","modified":1672393876757},{"_id":"source/nodejs/nodejs-note-12.md","hash":"3e37245c9952654618f6d6434f7ce45185b5de41","modified":1672817676290},{"_id":"source/nodejs/nodejs-note-2.md","hash":"2251399aaebac272c59f1efa8b10a4fe02832f3b","modified":1672192016920},{"_id":"source/nodejs/nodejs-note-4.md","hash":"6641ebc712ce1bac59f69824752303112554eccb","modified":1672192016926},{"_id":"source/nodejs/nodejs-note-9.md","hash":"b2cec2d93742c647aaf4355b0b669a25e2039222","modified":1672283208248},{"_id":"source/nodejs/nodejs-note-8.md","hash":"1bf326db297f141a9ad5b1670432b6ef16c79ce2","modified":1672218701079},{"_id":"source/nodejs/nodejs-note-3.md","hash":"ecf0a16f86dfb92a8051b8a12de336700a7cc54a","modified":1672192016923},{"_id":"source/nodejs/nodejs-note-7.md","hash":"84c4002f7bc3a7e281e712e5841890f30c192df8","modified":1672218643846},{"_id":"source/nodejs/nodejs-note-6.md","hash":"edad9e6637dd7713f25da3a3a9ce50d1e83c158a","modified":1667273295463},{"_id":"source/_posts/15-js-transform/js-transform.html","hash":"f4f8d85e5386d9b251c24aea038d4c57c88ede50","modified":1660210173722},{"_id":"source/_posts/18-fake-array/prototype_call.png","hash":"166ae1ed6f21a1c4ee961508d06adae89f22c6d6","modified":1659583249658},{"_id":"source/_posts/18-fake-array/document.png","hash":"c0e73c5d922eaf7f899856685f5fbd8245517fe8","modified":1659583001215},{"_id":"source/_posts/18-fake-array/array_from.png","hash":"50733fd866277f6aa27e12e432f2511fa886855f","modified":1659583606408},{"_id":"source/_posts/18-fake-array/slice_call.png","hash":"a97bd9fef96df18bbe6097521df710bd9615090a","modified":1659583430484},{"_id":"source/_posts/24-about-design-model1/abstract-car.png","hash":"63b2384c0b130f2d40907996aeb528d2131ab01f","modified":1662443039673},{"_id":"source/_posts/24-about-design-model1/static-param.png","hash":"ec22668e0901214c3d2efadcdae0ae34f801c2ac","modified":1662448007534},{"_id":"source/_posts/24-about-design-model1/safe-model-class.png","hash":"90a874baec5df9156cf7b65d7c7754d28c82337e","modified":1662442491219},{"_id":"source/_posts/25-about-design-model2/bridge1.png","hash":"70973d153e1e628ebf1152bce98b1a68b7530784","modified":1662458463138},{"_id":"source/_posts/25-about-design-model2/bridge3.png","hash":"8358d5a031c07b8a0dbe61df13f0642bf03b7c5d","modified":1662458499287},{"_id":"source/_posts/25-about-design-model2/bridge2.png","hash":"0d4e3980c0c177ef97e690e69919f954f2292ddb","modified":1662458485135},{"_id":"source/_posts/26-about-design-model3/command-model-3.png","hash":"f8973520dfc9d241d4e418d016dbde7cf647482f","modified":1663577292848},{"_id":"source/_posts/26-about-design-model3/explain-model-2.png","hash":"13dd495c6f42e9820c60034d2e87bc917486129e","modified":1663580905852},{"_id":"source/_posts/26-about-design-model3/observer-regist.png","hash":"160d15173ed43415298e65c9b3d9a63159aacb91","modified":1662604465638},{"_id":"source/_posts/28-about-design-model5/async-module-model-7.png","hash":"8473d1889cf3ba7e45e0b71a8dd861cc233f05c2","modified":1663661966862},{"_id":"source/_posts/28-about-design-model5/async-module-model-2.png","hash":"8898b83e3301783ee9bfb43b2488f4171e86a2bc","modified":1663661641923},{"_id":"source/_posts/28-about-design-model5/async-module-model-8.png","hash":"3a03fb902c96d787e256412ebc5a604a26aabd93","modified":1663662004136},{"_id":"source/_posts/28-about-design-model5/async-module-model-9.png","hash":"3959c02225b63e07adce93a968ed0bb0e2e6c365","modified":1663662019419},{"_id":"source/_posts/28-about-design-model5/module-model-5.png","hash":"c866de378508cfdbfd9307dd72b719577d2a3cff","modified":1663659938940},{"_id":"source/_posts/28-about-design-model5/mvc-model-4.png","hash":"03b64f2faf10dbcc8c3a32fb96b29e0b135f2f49","modified":1663663969725},{"_id":"source/_posts/28-about-design-model5/mvc-model-1.png","hash":"9fe4ed86ba3315ba722de0660cc6ec5770666487","modified":1663663438592},{"_id":"source/_posts/28-about-design-model5/mvp-model-1.png","hash":"ff42b48b0eb5f6ac14adc79c348d093c14f164de","modified":1663664391940},{"_id":"source/_posts/28-about-design-model5/mvvm-model-2.png","hash":"3cb6051a5054c50231162690a8494170b90397f4","modified":1663665412492},{"_id":"source/_posts/28-about-design-model5/widget-model-1.png","hash":"4f89287a4f8aa1122864cbc4c77f89d592a68c45","modified":1663662384573},{"_id":"source/_posts/27-about-design-model4/entrust-model-2.png","hash":"71764eebae7d27ba83deff08b4d925307914e3d0","modified":1663651049352},{"_id":"source/_posts/27-about-design-model4/lazy-model-1.png","hash":"5237b5b92b4b542f593af63d48afb088237eb2ed","modified":1663654190148},{"_id":"source/_posts/27-about-design-model4/localstorage-model-1.png","hash":"d78dd470675aa3f2a42ad1ce9617ef7d89e2168a","modified":1663651957734},{"_id":"source/_posts/27-about-design-model4/participate-model-1.png","hash":"44ef46104d7428d99d7b80b7ca8e2f9059d02340","modified":1663655013113},{"_id":"source/_posts/27-about-design-model4/participate-model-2.png","hash":"04cb3a2efcc6a9a9b3cc52a11c14b75ebfa332d6","modified":1663655036348},{"_id":"source/_posts/27-about-design-model4/template-model-6.png","hash":"f34ff79b1d619c45ccb21c2158a4680a6617942f","modified":1663653640090},{"_id":"source/_posts/27-about-design-model4/waiter-model-3.png","hash":"b59dca3e470f10063815167bca6227f8341dbc8e","modified":1663657400528},{"_id":"source/_posts/27-about-design-model4/waiter-model-8.png","hash":"9be78a26ae2db46d9ec8d4bb36902be64991e2f9","modified":1663658341497},{"_id":"source/_posts/35-data-structure3/lose-lose.png","hash":"55e49878d996f933010c1ac93b306b407a74019a","modified":1665196106863},{"_id":"source/_posts/35-data-structure3/linear-probing.png","hash":"0a020e8afc93027a2f5d6873414f7afbfa4b6f83","modified":1665198665394},{"_id":"source/_posts/35-data-structure3/move-key.png","hash":"ebb4944fee6e7aa9426ad27101ccaaca152e2fa2","modified":1665199125857},{"_id":"source/_posts/34-data-structure2/chain-table-1.png","hash":"b4a240e43972349b743117265ca1897051389bed","modified":1664174288096},{"_id":"source/_posts/35-data-structure3/sperate-chain.png","hash":"1c7b05c0f24bd68757a3497182c41da36cf91bbc","modified":1665197999026},{"_id":"source/_posts/35-data-structure3/soft-delete.png","hash":"f8fc5195e6b92a91af6b1a283be51fea18d95ccb","modified":1665198884241},{"_id":"source/_posts/34-data-structure2/chain-table-2.png","hash":"ea63e231035c3929b320bb52dc63c363a1b1ff39","modified":1664263190912},{"_id":"source/_posts/34-data-structure2/chain-table-4.png","hash":"04054fdc4cbdfb48b13bde3769b7ccb590e6bff9","modified":1664264606764},{"_id":"source/_posts/34-data-structure2/chain-table-3.png","hash":"6db25c5f058ceecae16751cea75e2a13e62a6b3d","modified":1664264590232},{"_id":"source/_posts/38-data-structure6/search-1.png","hash":"a844a9c7aabbe1a2fc3c7151e88a35f494e9d09b","modified":1665647613587},{"_id":"source/_posts/38-data-structure6/sort-1.png","hash":"97f90c860ce1d2669135aa5a7a474aeb7a799ad6","modified":1665642448596},{"_id":"source/_posts/38-data-structure6/search-2.png","hash":"3626ed24aaf5d1563eb1daa3a4f8d5136150bb83","modified":1665648010123},{"_id":"source/_posts/38-data-structure6/search-4.png","hash":"ecf4e1f8dd0fdf38b91d89de529f09da6eb88dd8","modified":1665648752017},{"_id":"source/_posts/38-data-structure6/search-3.png","hash":"719072030a73de7c3054974d55b626d221894218","modified":1665648563915},{"_id":"source/_posts/38-data-structure6/sort-3.png","hash":"913bb3906ff437f6dfe6a773b852918b7a49ae0d","modified":1665642939385},{"_id":"source/_posts/38-data-structure6/sort-10.png","hash":"cbb2fbde7d06aae552356dd7e4c65274d322f0fe","modified":1665645027520},{"_id":"source/_posts/38-data-structure6/sort-11.png","hash":"067113a10d14e5524fe4e7972c61d1b077811134","modified":1665646466063},{"_id":"source/_posts/38-data-structure6/sort-12.png","hash":"a8fdcaca8fd646997a58eca48c76809cb25c7571","modified":1665647384547},{"_id":"source/_posts/38-data-structure6/sort-2.png","hash":"a63daadd4590ed6b4ad7519bd1a14ae4be364a64","modified":1665642647310},{"_id":"source/_posts/38-data-structure6/sort-4.png","hash":"273c67388337e6e5eeb6c6e3486e5047d8d02321","modified":1665643284083},{"_id":"source/_posts/38-data-structure6/sort-8.png","hash":"f62f618f88c3715fa98532f136e36afea5153b3b","modified":1665644910757},{"_id":"source/_posts/38-data-structure6/sort-5.png","hash":"05867cc82ce12a1a2b6c92d0d37e2155df04d0a5","modified":1665643898545},{"_id":"source/_posts/38-data-structure6/sort-6.png","hash":"c4802ae6c84bee330fec94ddd888543a590ec692","modified":1665644667547},{"_id":"source/_posts/37-data-structure5/graph-10.png","hash":"be4ed69d06ae7dcea2b875b3b0ce92922a7fd0b2","modified":1665638234796},{"_id":"source/_posts/38-data-structure6/sort-7.png","hash":"681be89ab6425489c526125d890ae38ef8ee1435","modified":1665644820524},{"_id":"source/_posts/37-data-structure5/graph-1.png","hash":"a1b2db6ab3de04b1adf413855eaa4220c96ae523","modified":1665297136845},{"_id":"source/_posts/38-data-structure6/sort-9.png","hash":"b1a616076a59411ae21537a155e8f12e198c78b0","modified":1665645011262},{"_id":"source/_posts/37-data-structure5/graph-13.png","hash":"0ef979dea025ae063ccc8477915e14c2bada6f77","modified":1665639214755},{"_id":"source/_posts/37-data-structure5/graph-2.png","hash":"f56455b618e7b41e84fba80e91ade7ed29df91ca","modified":1665297469781},{"_id":"source/_posts/37-data-structure5/graph-3.png","hash":"4bca0b6ea37be10e8ab4b015ab1879bc9c95f98b","modified":1665297485922},{"_id":"source/_posts/37-data-structure5/graph-11.png","hash":"070f67f44e46097fb8750af9a315c9bca7fc6c0f","modified":1665638354099},{"_id":"source/_posts/37-data-structure5/graph-12.png","hash":"b557ac7c33f3672b559a4a1eacf84aba2fcff1cf","modified":1665638654654},{"_id":"source/_posts/37-data-structure5/graph-5.png","hash":"a85fa2dffae020f8d02eebce15b1592e9b222a5e","modified":1665544487331},{"_id":"source/_posts/37-data-structure5/graph-4.png","hash":"47bcd4a1de612d5af3bd3301602b4b6bc07b4c6a","modified":1665543988878},{"_id":"source/_posts/37-data-structure5/graph-6.png","hash":"3781b637547025de758bec7262c50fe45bb57774","modified":1665544659172},{"_id":"source/_posts/28-about-design-model5/mvp-model-7.png","hash":"85c76e7e1a84df4345885b58a4495b8472da6c7c","modified":1663664792064},{"_id":"source/_posts/37-data-structure5/graph-7.png","hash":"dbd8e52679bcbf321c3a8d17006729c4af0c87ad","modified":1665627475943},{"_id":"source/_posts/37-data-structure5/heat.png","hash":"a37ac1abfbbf1bd9742deec30a783d0f90e49657","modified":1665220131039},{"_id":"source/_posts/37-data-structure5/graph-8.png","hash":"93de61e5c29df7b193e41f2595521446bc81226d","modified":1665630724506},{"_id":"source/_posts/37-data-structure5/min-heat.png","hash":"c2c5f8cc68ba6cf3d89bebb94c0a7a7d22c1e5a0","modified":1665220362202},{"_id":"source/_posts/36-data-structure4/factorial.png","hash":"ddfb0d84eab3db09c51a4b87376c023e35c597be","modified":1665207523429},{"_id":"source/_posts/36-data-structure4/left-left-1.png","hash":"655a6a8118dd11fffc1c0bf38c1a06fd9d861fb7","modified":1665215196749},{"_id":"source/_posts/36-data-structure4/binary-search-tree.png","hash":"ad74f8c6b96f77ca95d6b9b48cf87fda5efcfdbc","modified":1665211252907},{"_id":"source/_posts/36-data-structure4/in-order-traverse.png","hash":"db6c59fc444e910a9921f50bc9e8e66964ef2849","modified":1665212570747},{"_id":"source/_posts/36-data-structure4/left-right-1.png","hash":"b0d03e54c49df4be3cdc60f9436e4ecb40a3c6b6","modified":1665216006922},{"_id":"source/_posts/36-data-structure4/left-left-2.png","hash":"31829f0a81c4d517a768b0d824702e96ed38af94","modified":1665215213180},{"_id":"source/_posts/36-data-structure4/left-right-2.png","hash":"dde339c5a7c4a70be0a832190a2678237f10331d","modified":1665216028366},{"_id":"source/_posts/36-data-structure4/post-order-traverse.png","hash":"aee9c88702a4fa397c4146e997f7ba3504b19a3e","modified":1665212712548},{"_id":"source/_posts/36-data-structure4/pre-order-traverse.png","hash":"d93c415f7de4fd6c9d5bf3dfc7fdaf4484d6173c","modified":1665212594930},{"_id":"source/_posts/36-data-structure4/red-black-2a.png","hash":"618993219918c6d178ac4f468129647d0c0d6f72","modified":1665217313231},{"_id":"source/_posts/36-data-structure4/red-black-3a.png","hash":"6db63a5d31e7477b9d3a7ce036c9607db9262fb8","modified":1665217328381},{"_id":"source/_posts/36-data-structure4/red-black-2b.png","hash":"88a4290e21e993ca3a39a86a83283bc607f24b9c","modified":1665217348189},{"_id":"source/_posts/36-data-structure4/red-black-3b.png","hash":"e4f8a20d976abc667a94482eeeeaa0f5281c410e","modified":1665217363966},{"_id":"source/_posts/36-data-structure4/right-left-2.png","hash":"9fd153762d1b34409ac583c8dd871153f0ce5fc1","modified":1665216334102},{"_id":"source/_posts/36-data-structure4/remove-left-right.png","hash":"4141ff9827c5c74323d60196c96038c898c07cf6","modified":1665214241529},{"_id":"source/_posts/36-data-structure4/right-right-2.png","hash":"b6a6f5a17aa73fc8daf16313e0204a05314c3c16","modified":1665215704532},{"_id":"source/_posts/39-data-structure7/big-o-3.png","hash":"b7140be66eb3272f0dd9c183b48cfb8555cb4511","modified":1665725727100},{"_id":"source/_posts/36-data-structure4/right-left-1.png","hash":"3d1ec645ec1def7aeb460386d421b9dc3cc684e0","modified":1665216318337},{"_id":"source/_posts/36-data-structure4/tree.png","hash":"c1a3dff14361fa7bfc3f73bf7391d46c57044737","modified":1665210436072},{"_id":"source/_posts/36-data-structure4/right-right-1.png","hash":"5d6258c158f22e8582f538f06c89dc86bbedfba7","modified":1665215690448},{"_id":"source/_posts/39-data-structure7/big-o-1.png","hash":"bfc4e8cd9822858a4f5afd7ea21ac69ae391248f","modified":1665725447129},{"_id":"source/_posts/39-data-structure7/big-o-4.png","hash":"75fd12b92a8ef511524bb5306c73fb63346d586d","modified":1665725788955},{"_id":"source/_posts/39-data-structure7/big-o-6.png","hash":"443cef5a2ff290edd7a7b9f9c3e4580e9d8375b3","modified":1665726382980},{"_id":"source/_posts/39-data-structure7/big-o-2.png","hash":"5abf1a71a4b31ade53b60d5d6edf850266d502e2","modified":1665725587116},{"_id":"source/_posts/39-data-structure7/technology-2.png","hash":"00436e4649e1f7cdeecb39e78e1cece84a8c0591","modified":1665650645629},{"_id":"source/_posts/39-data-structure7/big-o-5.png","hash":"0e81454c15a22289ae8fd29e9ba356f9058ca226","modified":1665725847508},{"_id":"source/_posts/39-data-structure7/technology-1.png","hash":"25d324e43b4ae5d4921a2fa9bf40479a54ba55d2","modified":1665649253588},{"_id":"source/_posts/39-data-structure7/technology-4.png","hash":"956d458c4792a6a56ad0f9292f3e7773bafca1d1","modified":1665651529899},{"_id":"source/_posts/39-data-structure7/technology-5.png","hash":"61dc4bb992375a4f2d5c5b5afdb594877f58510a","modified":1665652235775},{"_id":"source/_posts/39-data-structure7/technology-3.png","hash":"fe308b75c03e0efc9bc24154073ae4a31c1fc73f","modified":1665650992570},{"_id":"source/nodejs/file/stderr.log","hash":"c8598eb267a5b8880fb5e4a09c3e432baa246662","modified":1672814667831},{"_id":"source/_posts/40-tail-call/call-stack.png","hash":"9ceba234d31d636baca2b4f2af1384b6b25d4a4a","modified":1665977002591},{"_id":"source/nodejs/file/test.enc","hash":"aa3e64643dde19f29c413cfae1160dd980ac3ad3","modified":1672823414698},{"_id":"source/nodejs/file/test.js","hash":"6b6f9b68f4f7d8f1ac490f905677d2b21a0a59f6","modified":1672823829617},{"_id":"source/_posts/6-vue3-render/render.png","hash":"0b20ebf2700ccd675e40f6330e07dce8341807a0","modified":1658223255522},{"_id":"source/nodejs/images/async-experience.png","hash":"c7c903136156205117f819ae03a5ce81204c23b9","modified":1671528846950},{"_id":"source/nodejs/images/async-progress.png","hash":"5e6ef5a50ac929df8694a62ec96202048c4bb18b","modified":1671530008459},{"_id":"source/nodejs/images/async-call.png","hash":"cf73b4e1fa6ef2c5eb1d6813c73ed2abe6bb5989","modified":1668393615739},{"_id":"source/nodejs/images/buffer-3.png","hash":"586ecdade8a0bd9f926e4a9e4c8f9b328517719d","modified":1672192016797},{"_id":"source/nodejs/images/buffer.png","hash":"0c585b0181968674a65b89c42f8c31421af99dc6","modified":1672192016800},{"_id":"source/nodejs/images/bigpipe.png","hash":"dc9b44b4ed5e79203f2690bd2e87ee7aefac6b23","modified":1672192016787},{"_id":"source/nodejs/images/buffer-2.png","hash":"3fc41fcc7896fe6af165cbdb5f4048770c915b9e","modified":1672192016795},{"_id":"source/nodejs/images/buffer-1.png","hash":"2ddb6050f0ebac6bb733b8d50f9abdb71bb21563","modified":1672192016793},{"_id":"source/nodejs/images/ca-1.png","hash":"89317164d8d399085df7d23a37d737c26a2c5a30","modified":1672192016803},{"_id":"source/nodejs/images/ca.png","hash":"81f692dee7584b2c9d6e7ad0360b4461953c40d9","modified":1672192016805},{"_id":"source/nodejs/images/collect-diff.png","hash":"d69687d4300e224c23ef3169a9c6e4f3db396fc3","modified":1672192016809},{"_id":"source/nodejs/images/cross-platform.png","hash":"2c1a28975ade0c9f106e3716dcaf24c877e0773d","modified":1668394708045},{"_id":"source/nodejs/images/cache.png","hash":"1ac69103427a3c1a8b0022af1620a927362c3385","modified":1672192016807},{"_id":"source/nodejs/images/commonjs-node-relation.png","hash":"5cc6679d9fe66c78a61dbacd4e94f3f11fd848d2","modified":1668403442143},{"_id":"source/nodejs/images/fork.png","hash":"d3796212324ee8f24e8405d54ec6ad8e57b49bf8","modified":1672192016814},{"_id":"source/nodejs/images/epoll-loop.png","hash":"bc7af5054040babc3f1af3b688d8764760f7bfb3","modified":1671529534645},{"_id":"source/nodejs/images/how-to-call-async.png","hash":"39ac29400db5abed7d02b2b3e3397cc761006271","modified":1671528909417},{"_id":"source/nodejs/images/defer-promise.png","hash":"6b8484c9a5882e75524b0944be43b010c22e1d5c","modified":1672192016812},{"_id":"source/nodejs/images/jam.png","hash":"638a73d978e27ade2b7e8e0ac66d340caa63453d","modified":1671529015582},{"_id":"source/nodejs/images/http.png","hash":"335a31f82a46e1bf32a09cdd9f51a17aaf827a14","modified":1672192016816},{"_id":"source/nodejs/images/increase-target.png","hash":"55ed1f32bfd6360265eb8b16ce0f0ed2c21c514c","modified":1672192016818},{"_id":"source/nodejs/images/loop.png","hash":"a1b9e75136f79dcccdafc48d6f30606b8664a9f4","modified":1672192016823},{"_id":"source/nodejs/images/loop-1.png","hash":"7dd0d30cf11ca3d1851d68d9c04b186d0b97aa23","modified":1672192016820},{"_id":"source/nodejs/images/master-slave.png","hash":"4f45a0cadfd5ab7633103418fcf49bcc018da4d2","modified":1672192016825},{"_id":"source/nodejs/images/mvc.png","hash":"f86ed56705edc5f57ab24298801afe09cd4badc6","modified":1672192016854},{"_id":"source/nodejs/images/middle.png","hash":"e68b0513b166f049e4f0d72b91e1d5c2c8338747","modified":1672192016845},{"_id":"source/nodejs/images/net-3.png","hash":"8af8561052ec1608a0773304cf04af4234557052","modified":1672192016861},{"_id":"source/nodejs/images/net-2.png","hash":"1b28b0d5d2ac3d95c136285f9be2d83ba2ba7bdb","modified":1672192016858},{"_id":"source/nodejs/images/net-1.png","hash":"4f9169ff8774a785573375b0eae0bf611d918376","modified":1672192016856},{"_id":"source/nodejs/images/net-4.png","hash":"81f06ad4be9d956662e629238db1590287228ce7","modified":1672192016863},{"_id":"source/nodejs/images/no-jam.png","hash":"5d4728cbaa1c2f7e680f6f3a12202ec94347211c","modified":1671529121288},{"_id":"source/nodejs/images/nvm-setting-content.png","hash":"8d0ebc40648adcebe40cc663caab2cee4b8f6436","modified":1671169620381},{"_id":"source/nodejs/images/node-require.png","hash":"9e2fd7eee0b6bdf918b4fb34544beb7424702ab8","modified":1671506376382},{"_id":"source/nodejs/images/node-modules.png","hash":"e5835f2da7cca29d0eb1676c7b081c7122a52528","modified":1671506697202},{"_id":"source/nodejs/images/package.png","hash":"dccf0cad2808e81718b9efe11c884aa24fe6b73d","modified":1671506820867},{"_id":"source/nodejs/images/pipe-2.png","hash":"7bda2919687448a1c427e768f6474271782ef1fa","modified":1672192016867},{"_id":"source/nodejs/images/nvm-setting.png","hash":"742427d031db38180aebc79883d7fe7f2b5082dd","modified":1671169466385},{"_id":"source/nodejs/images/pipe-1.png","hash":"7385963b2e8c0359641f3f3ccf316dbcb60b32f8","modified":1672192016865},{"_id":"source/nodejs/images/pipe-3.png","hash":"38b94af4d0d88bef05b17d1233bf2e3b3623b25e","modified":1672192016869},{"_id":"source/nodejs/images/product-1.png","hash":"a127d5caca21588163ce2a98490b4f677aeb78c6","modified":1672192016876},{"_id":"source/nodejs/images/pipe-4.png","hash":"ce3c89fb6762678626193ff9fc6aaa9227de6660","modified":1672192016872},{"_id":"source/nodejs/images/poll-loop.png","hash":"8d0bfc2b615eb460d6ab8be0837e523af238c8f0","modified":1671529448910},{"_id":"source/nodejs/images/pipe.png","hash":"e92d4834ee1fc339f8d36a745950a10d7633955a","modified":1672192016874},{"_id":"source/nodejs/images/read-loop.png","hash":"8656ba0172108ecb0a251139cbe0a8df61873b40","modified":1671529287934},{"_id":"source/nodejs/images/settimeout.png","hash":"55f051726fe3210ac5ad039ce469da805b5c45de","modified":1672192016880},{"_id":"source/nodejs/images/sweep-compact.png","hash":"5af9bde21db63d1483a807be5b0f6cde77ef5cda","modified":1672192016888},{"_id":"source/nodejs/images/test-2.png","hash":"e613d096c62a0d27f72b8b50224e5b5fafafc3e9","modified":1672192016902},{"_id":"source/nodejs/images/product.png","hash":"47cef8cf353b57b3a18c013ea8b6bed0a8e617cf","modified":1672192016878},{"_id":"source/nodejs/images/select-loop.png","hash":"bba3437eb7794c0fe3abb77fb37ac8897bf19bb5","modified":1671529365037},{"_id":"source/nodejs/images/test.png","hash":"840cda90b44467e3648decdf62f1d146f1261538","modified":1672192016905},{"_id":"source/nodejs/images/tail-trigger.png","hash":"052e9473880c882918ae9b763b9fa6f808bccdf1","modified":1672192016895},{"_id":"source/nodejs/images/symlinks.png","hash":"48dd00ba4c43783739716fdc0b0790b0e3187893","modified":1672798793053},{"_id":"source/nodejs/images/v8-promot2.png","hash":"4fe47a4a361987c7928001641f8b092af4f5764a","modified":1672192016912},{"_id":"source/nodejs/images/test-1.png","hash":"0bac06c06b58a4a61acd1a6c17971046d56c1d82","modified":1672192016900},{"_id":"source/nodejs/images/websocket-1.png","hash":"a6e3598d6c9cdef36c1930c9e7535c3a76b1dcc9","modified":1672192016914},{"_id":"source/nodejs/images/websocket.png","hash":"907dcc1e99f2e6d20f1133508ff3b84e1985e065","modified":1672192016917},{"_id":"source/nodejs/images/tls-ssl.png","hash":"e7011243d619ef7b1f2489146744a741d80e027d","modified":1672192016907},{"_id":"source/nodejs/images/v8-promot.png","hash":"28d3849e4e768a3ae7954bae653b55ce6e9a7bb5","modified":1672192016910},{"_id":"source/_posts/23-about-design-model/how-to-inherit.png","hash":"2610b10429de1454b684733ede30778da89da750","modified":1661856873590},{"_id":"source/_posts/23-about-design-model/prototype.png","hash":"fe3518ce58c5945b8f5db473d69be75f67a98b0a","modified":1661490846012},{"_id":"source/_posts/23-about-design-model/parasitic-inherit.png","hash":"dcde79d7db360d5f56bf441be778908d3056f693","modified":1661856873597},{"_id":"source/_posts/23-about-design-model/public-and-private.png","hash":"275fce752eaeadf6eee22e10bf14451ed9eb675c","modified":1661490846014},{"_id":"source/_posts/23-about-design-model/prototype-inherit.png","hash":"a5f0085a3caf9e0519fe3cb26129dd144cfc7594","modified":1661856873599},{"_id":"source/_posts/23-about-design-model/simple-factory2.png","hash":"e8d75951fa119c24b2c188eb639f16a32bf70928","modified":1662355408197},{"_id":"source/_posts/23-about-design-model/static-and-public.png","hash":"aef2330dce27ebc420b7654abdf1859266ec48a4","modified":1661856873605},{"_id":"source/_posts/24-about-design-model1/lazy-single-instance.png","hash":"4bbd91090a4364cc48ec5cf388ae29f1f3626b8a","modified":1662448167315},{"_id":"source/_posts/24-about-design-model1/human.png","hash":"f78b9964ce7223cc99122c99667673d9242df348","modified":1662444891472},{"_id":"source/_posts/24-about-design-model1/name.png","hash":"d46e84150e7fdea9eb17d8ad0624e7eb79654ace","modified":1662444908093},{"_id":"source/_posts/24-about-design-model1/abstract-factory2.png","hash":"a1a8a6b4b0c2aa47bbc543add6b6a675670b41ce","modified":1662443556932},{"_id":"source/_posts/24-about-design-model1/prototype-inherit2.png","hash":"cd61b59785ea6144fabce855bd363ff7906468a9","modified":1662446461834},{"_id":"source/_posts/24-about-design-model1/person.png","hash":"12e19fccdb8ee0dea2ec9e55c4f55125a536b76e","modified":1662444952362},{"_id":"source/_posts/25-about-design-model2/decorator.png","hash":"a0fdfe4dc2b74b52a33fd13ed7e1b3c1fba8480e","modified":1662457093764},{"_id":"source/_posts/25-about-design-model2/out-look.png","hash":"d9f11180b44ccded8da8ecba5593bdd6ebd58eb4","modified":1662450856453},{"_id":"source/_posts/25-about-design-model2/station-culculate.png","hash":"26cda447bac04b0260f0ec11ca1dcb836f93855a","modified":1662454433567},{"_id":"source/_posts/26-about-design-model3/add-message.png","hash":"03712141c27e51d24f4361c6c48a609b366f5692","modified":1662605334378},{"_id":"source/_posts/26-about-design-model3/marry-state1.png","hash":"2f5c004568231ff2a14ab499c91aabd48c302f28","modified":1662606880721},{"_id":"source/_posts/26-about-design-model3/observer-fire.png","hash":"0204e744bdcb2480cae91e03d4e79c26913cf85a","modified":1662604570583},{"_id":"source/_posts/26-about-design-model3/observer.png","hash":"05738a02cd73736025351c0e9e3fc0d0de27158f","modified":1662604356379},{"_id":"source/_posts/26-about-design-model3/observer-remove.png","hash":"e0e97122604f5eaa716042ffd19d7e6fc4d9535f","modified":1662604648684},{"_id":"source/_posts/26-about-design-model3/regist-change-num.png","hash":"3aa9791db11e1985c21e29959201f022a0f98a88","modified":1662605277899},{"_id":"source/_posts/28-about-design-model5/async-module-model-4.png","hash":"731b4ee9c777c9d9bd6664bf674e1abf1f48af65","modified":1663661830015},{"_id":"source/_posts/28-about-design-model5/async-module-model-5.png","hash":"436f66ba99f8bd7400ad91b3d857d255f6f3034c","modified":1663661873825},{"_id":"source/_posts/28-about-design-model5/module-model-2.png","hash":"a22fb6b41b50875766d5382664361095fca59051","modified":1663659739443},{"_id":"source/_posts/28-about-design-model5/module-model-3.png","hash":"aa42c569b2a73fae726d6518fda8a48a325c5a3f","modified":1663659772912},{"_id":"source/_posts/28-about-design-model5/mvc-model-3.png","hash":"28fd4de773e1352941b4b0773858520ec4e21039","modified":1663663871483},{"_id":"source/_posts/28-about-design-model5/mvp-model-4.png","hash":"59ab08a2d276eb142c4789000d2c484aaaeb4890","modified":1663664644640},{"_id":"source/_posts/28-about-design-model5/mvvm-model-3.png","hash":"b4f73f397dcb296b03350b04390a8f2cdc0906d4","modified":1663665441365},{"_id":"source/_posts/28-about-design-model5/mvvm-model-7.png","hash":"4d8187320d10b1bb36a49169575baf54fe7e7a71","modified":1663665616436},{"_id":"source/_posts/28-about-design-model5/widget-model-4.png","hash":"7c2ca9c608b6829fa768590455a8785c9ff13781","modified":1663662590740},{"_id":"source/_posts/28-about-design-model5/widget-model-5.png","hash":"5ff7151981d6c83fa8a45556de7e17f4e527c093","modified":1663662677871},{"_id":"source/_posts/27-about-design-model4/chain-model-2.png","hash":"8a59f234053c9a85a94f74273fafed9051ec578d","modified":1663643706105},{"_id":"source/_posts/27-about-design-model4/chain-model-1.png","hash":"ac13400dfce89f26fe4bcadca5c2a1f4994083ca","modified":1663643204079},{"_id":"source/_posts/27-about-design-model4/chain-model-4.png","hash":"33fa9dc7cb773d0e519dcb4a4a5869aa78234950","modified":1663644189761},{"_id":"source/_posts/27-about-design-model4/lazy-model-3.png","hash":"7cf3eba1156eb71177fee16c281edfd2f7d3d0e0","modified":1663654271863},{"_id":"source/_posts/27-about-design-model4/lazy-model-2.png","hash":"29a6f621b06f9283d3caff7d3c63f7c711095978","modified":1663654206105},{"_id":"source/_posts/27-about-design-model4/lazy-model-6.png","hash":"bb1487d2e1e38d3c2ea4cb6dcc310f0025664444","modified":1663654392861},{"_id":"source/_posts/27-about-design-model4/lazy-model-5.png","hash":"ce1428d6b73612a3290d3cbd0efa607829fdb233","modified":1663654372118},{"_id":"source/_posts/27-about-design-model4/participate-model-3.png","hash":"257320d7e940dcef49305ea8d1642621bfbf3ff1","modified":1663655711666},{"_id":"source/_posts/27-about-design-model4/participate-model-4.png","hash":"5f13e728cfa8cf2eabd3925f1a0798bc905d267b","modified":1663655973145},{"_id":"source/_posts/27-about-design-model4/template-model-1.png","hash":"41e2537938230a77a4072987778016031fe92291","modified":1663653270177},{"_id":"source/_posts/27-about-design-model4/participate-model-5.png","hash":"9694840f32c90094e37228de41fc2cfdf4f66388","modified":1663656014526},{"_id":"source/_posts/27-about-design-model4/template-model-3.png","hash":"3a24763c6d9e280dd6c26d966da99ceb0d658ec5","modified":1663653576402},{"_id":"source/_posts/27-about-design-model4/template-model-4.png","hash":"b301423b25f6447a52369e96a6f0d1c3b93da6c5","modified":1663653602447},{"_id":"source/_posts/27-about-design-model4/entrust-model-1.png","hash":"900a7cc246a17adae923b5e0b87d5b8b8d255674","modified":1663650878995},{"_id":"source/_posts/27-about-design-model4/waiter-model-4.png","hash":"ad67d02d972353793d59f1ca5f1191fb9a220e52","modified":1663658084841},{"_id":"source/_posts/27-about-design-model4/waiter-model-6.png","hash":"007198e00695be520e246815152687e250bf4941","modified":1663658288382},{"_id":"source/_posts/27-about-design-model4/waiter-model-5.png","hash":"30412937d3a27e5d8bf1db0d87fce38a8d59839e","modified":1663658170337},{"_id":"source/_posts/27-about-design-model4/waiter-model-7.png","hash":"0eefaa7468c3726aecd02980b1c10574a1d06c40","modified":1663658323937},{"_id":"source/_posts/37-data-structure5/min-heat-pic.png","hash":"6d8794be490f9dd7f0664813070eea6169c49181","modified":1665221648680},{"_id":"source/_posts/37-data-structure5/heap-sort.png","hash":"a344a2264bed09372c160b691a6e0a581bea3bd6","modified":1665222218747},{"_id":"source/_posts/5-react-render/update_class.png","hash":"5854028928496a0b6c4ad02452cd07c12650f8e8","modified":1658223255534},{"_id":"source/_posts/5-react-render/force_update.png","hash":"f0333239066cd2e4a8cdf12bff8fcdfcc01a7616","modified":1658223255498},{"_id":"source/_posts/6-vue3-render/render_node2.png","hash":"bd8cbab05ce653b80a1cc89e609b7ae9c309b7fe","modified":1658223255530},{"_id":"source/_posts/6-vue3-render/render_node1.png","hash":"4a4266c87a315afeb55de174b11784431f3c40b9","modified":1658223255527},{"_id":"source/nodejs/images/nvm-install.png","hash":"347c3fe9e8ac21a112d1eba02b594b5f5b2af672","modified":1671169201268},{"_id":"source/nodejs/images/nvm-download.png","hash":"1fddd6469f02c83d3c54603c3f43a72224565a29","modified":1671168901622},{"_id":"source/_posts/15-js-transform/convert-table.png","hash":"fdffd1b86ddacb402a9a3a423cffd91fcc229fce","modified":1658223643116},{"_id":"source/_posts/23-about-design-model/create-pop.png","hash":"43feb1eed0b060643140cfa80c073e12729b47af","modified":1662355408187},{"_id":"source/_posts/23-about-design-model/class-inherit.png","hash":"7316cf53af5ae3d11eb708f911ddc2b9fbf35027","modified":1661856873580},{"_id":"source/_posts/23-about-design-model/multiple-inherit.png","hash":"3370f1d5c3f1c73449ddc04e438559b4a0925ad0","modified":1662355408189},{"_id":"source/_posts/23-about-design-model/parasitic-combination-inherit.png","hash":"5b7c9be2d070fe04cd77d8923eaa4e1585ad9e02","modified":1661856873592},{"_id":"source/_posts/23-about-design-model/parasitic-inherit-change.png","hash":"0b683e58266a2816c17a932a910be6ce1bdbbf1e","modified":1661856873595},{"_id":"source/_posts/24-about-design-model1/abstract-factory1.png","hash":"27096d5d5c2a949d2b5a0b8b4483cd0955007a30","modified":1662443533233},{"_id":"source/_posts/24-about-design-model1/abstract-factory3.png","hash":"565cc1a91ec9f7f4113759d8ee84d9e7e5765dec","modified":1662443974163},{"_id":"source/_posts/24-about-design-model1/prototype-inherit1.png","hash":"3d8d602b70b2a85f84ccb77667bfdf58688ef1e6","modified":1662446439629},{"_id":"source/_posts/24-about-design-model1/safe-factory-model.png","hash":"1d4838406d573590c135cb651e98e970dd03d761","modified":1662442704945},{"_id":"source/_posts/26-about-design-model3/command-model-2.png","hash":"394963fe76e75b6ff152d0bc64eb440812f181e4","modified":1663577276883},{"_id":"source/_posts/26-about-design-model3/create-component.png","hash":"313f9c4b04afdb3c0bbb24d02394ff7ed7f7afa9","modified":1662616644243},{"_id":"source/_posts/26-about-design-model3/deal-data.png","hash":"229c21fa8cd0891d9cf137520e2756088d805b32","modified":1662616593064},{"_id":"source/_posts/26-about-design-model3/marry-state.png","hash":"9d3b9fd7f74062d32194ddee1084db94ab8f2f5e","modified":1662606865403},{"_id":"source/_posts/26-about-design-model3/send-data.png","hash":"f2dd937ad9d5dbd6373c78b766b0ca7d18689bb8","modified":1662616481110},{"_id":"source/_posts/28-about-design-model5/appendix-10.png","hash":"47f4c469384a2ae6ee68920c9c9d056323bc6964","modified":1663666108395},{"_id":"source/_posts/28-about-design-model5/appendix-1.png","hash":"63d1fb2d7060dc8e20879b271cfc0fae5ba53ce5","modified":1663665944379},{"_id":"source/_posts/26-about-design-model3/vote-status.png","hash":"ce2f7e1b2250efafac59e7e0a6c69a8f2f57e1fb","modified":1662606197496},{"_id":"source/_posts/28-about-design-model5/async-module-model-6.png","hash":"c0234e34b71f60317c8532f9b4332297ddbfc3b2","modified":1663661929958},{"_id":"source/_posts/28-about-design-model5/async-module-model-3.png","hash":"955761aa1d41f38f58070239091ec7ef56eab433","modified":1663661813279},{"_id":"source/_posts/28-about-design-model5/mvp-model-2.png","hash":"a05c2d67784dc8a0c9dadb55ff4cb313ff0a4581","modified":1663664414889},{"_id":"source/_posts/28-about-design-model5/mvp-model-5.png","hash":"b38b48df97224ac10c391b5231c27b5ff9439d15","modified":1663664712013},{"_id":"source/_posts/28-about-design-model5/mvp-model-6.png","hash":"b678a14aa7203ed211d9b03cc517629296d39ccb","modified":1663664732256},{"_id":"source/_posts/28-about-design-model5/mvvm-model-5.png","hash":"f5b38278a65c50724df598782714d46b16198ddb","modified":1663665520771},{"_id":"source/_posts/28-about-design-model5/mvvm-model-8.png","hash":"ae0f8837c7bf0b7cebcf1b643602ef1b7c91d9b0","modified":1663665710456},{"_id":"source/_posts/28-about-design-model5/mvvm-model-1.png","hash":"dec3d9b3d1b759d8ab97b596942a57870ea5e899","modified":1663665306275},{"_id":"source/_posts/28-about-design-model5/widget-model-3.png","hash":"8caaa1350394bb4924a26779474bd8ffdedfd1a3","modified":1663662560598},{"_id":"source/_posts/28-about-design-model5/widget-model-6.png","hash":"17625b96826cacb789210181082942b9d92c9685","modified":1663662713550},{"_id":"source/_posts/27-about-design-model4/chain-model-5.png","hash":"6c1d9aaa8a2f5c8a33e827428f33df74156af591","modified":1663644269641},{"_id":"source/_posts/27-about-design-model4/chain-model-6.png","hash":"0a2af8c6826567da8695e8010d13bf7101a75d0a","modified":1663644305196},{"_id":"source/_posts/28-about-design-model5/widget-model-2.png","hash":"d5b2a749b270b467d4e5ca0442f079ad0d68c0ad","modified":1663662526925},{"_id":"source/_posts/27-about-design-model4/lazy-model-4.png","hash":"d2cec3917cabaf4da67a6ac877730c32d27d6b82","modified":1663654340065},{"_id":"source/_posts/27-about-design-model4/localstorage-model-2.png","hash":"b130a85fa7ca8cc738c636091e35ce86095e4da4","modified":1663651981780},{"_id":"source/_posts/27-about-design-model4/localstorage-model-4.png","hash":"c7d8b6cd9bc0093ceaaa9a731d6b721dabf0c2e2","modified":1663652031905},{"_id":"source/_posts/27-about-design-model4/template-model-2.png","hash":"f0f1cf1e6328ed7dd2da13e3ef19f0ba3090d50b","modified":1663653559773},{"_id":"source/_posts/27-about-design-model4/template-model-5.png","hash":"a615f27465cba32bd7ef16f4aa2d229123c6cd04","modified":1663653621150},{"_id":"source/_posts/27-about-design-model4/waiter-model-1.png","hash":"4ecd76529d5af3bab1200944f956550c438d7e4c","modified":1663657090941},{"_id":"source/_posts/27-about-design-model4/throttle-model-2.png","hash":"4d06f2204e6a312ad534b08e4aa3a0cc199b0fe4","modified":1663652874513},{"_id":"source/_posts/27-about-design-model4/throttle-model-3.png","hash":"9ba30093c88bda5cdf0b74397078c98615ab14e8","modified":1663652906337},{"_id":"source/_posts/27-about-design-model4/waiter-model-2.png","hash":"115d73933b2c9e3b333f0173a9c67b40b82b360e","modified":1663657379627},{"_id":"source/_posts/4-brower-render/hover.png","hash":"310534f76efad7820e4f9527f39b9232feb717da","modified":1666667873150},{"_id":"source/_posts/5-react-render/fiber_tree.png","hash":"947d11b845e1abb74cbb2d4e135767a377692041","modified":1658223255494},{"_id":"source/_posts/4-brower-render/performance.png","hash":"c54be1dc0abe417046e5abd2a9ac3bbfc89bb98e","modified":1666667920282},{"_id":"source/_posts/37-data-structure5/graph-9.png","hash":"3e0a9c9a2cb3f8145448b3dab7b9066c53f468d2","modified":1665631403989},{"_id":"source/_posts/4-brower-render/network.png","hash":"bb36a90979d2b630aa4c09b7187c9e4ca300f3d4","modified":1666667960216},{"_id":"source/_posts/6-vue3-render/render_function.png","hash":"ab09e61382c872069a70212525d4333d6ba8cd19","modified":1658223255525},{"_id":"source/_posts/23-about-design-model/multiple-status.png","hash":"99f1acc2445ec0c692d48660ddbd71b510f1284b","modified":1662355408192},{"_id":"source/_posts/23-about-design-model/simple-factory1.png","hash":"7a9ab5660cbd92e1e0f851985402404fb0f49814","modified":1662355408196},{"_id":"source/_posts/23-about-design-model/test-prototype-inherit.png","hash":"ffe8e406495b76ed7e8fa5fa95247335f0842bd8","modified":1661856873608},{"_id":"source/_posts/23-about-design-model/safe-model.png","hash":"8ddf098b287fc1582ef3c57f6641b8cdfe529ee0","modified":1661856873602},{"_id":"source/_posts/26-about-design-model3/basic-model.png","hash":"d11299e00239d8eee68fa84742cf934d7b2b7455","modified":1662544252055},{"_id":"source/_posts/24-about-design-model1/work.png","hash":"85878cbf259712eba4a4d960bef9fc8f72361f7d","modified":1662444928587},{"_id":"source/_posts/26-about-design-model3/command-model-1.png","hash":"e8f27f13a8b8964e1f98cf90c9d11336745ce4cd","modified":1663577254334},{"_id":"source/_posts/26-about-design-model3/cache-model.png","hash":"849dac393027d49c7932b80aeacdeb6dc665ad8d","modified":1663579414660},{"_id":"source/_posts/26-about-design-model3/explain-model-1.png","hash":"b41f3ee9472b65e45fd3699586fe343b90801e1c","modified":1663580887647},{"_id":"source/_posts/26-about-design-model3/explain-model-3.png","hash":"7090631280b778e1a081cf14ee1aef4eaddf2724","modified":1663580922971},{"_id":"source/_posts/26-about-design-model3/inherit-as-basic-model.png","hash":"04bcb6c49805f61c210a276673688925342a97a2","modified":1662544568359},{"_id":"source/_posts/26-about-design-model3/inherit-model.png","hash":"c458570cfbf5cb544f160dbf7f5ea2688eb54cfe","modified":1662544386649},{"_id":"source/_posts/26-about-design-model3/mediator-model.png","hash":"037a378a4fd6a9b68621c714239390a175768283","modified":1663578864540},{"_id":"source/_posts/26-about-design-model3/visitor-model.png","hash":"b47054fdf9198975a39ebfc6b4ea46cb988dc080","modified":1663578342393},{"_id":"source/_posts/26-about-design-model3/regist-message.png","hash":"94993ad78c5391eb4cc60f851d1bf5de794d680a","modified":1662605173515},{"_id":"source/_posts/26-about-design-model3/price-strategy.png","hash":"8c9b4bc9e46d85dbd5ff1db682f35d7727ac2d24","modified":1662615179307},{"_id":"source/_posts/28-about-design-model5/appendix-3.png","hash":"972a431f1b9f113e9c28acd09c21965abf3ae776","modified":1663665981472},{"_id":"source/_posts/28-about-design-model5/appendix-2.png","hash":"c793bb154006138580dfe636e8e96f48af31c136","modified":1663665961797},{"_id":"source/_posts/28-about-design-model5/appendix-4.png","hash":"0caa8c2b2efef085bf73708c696b163b27cf4acd","modified":1663666001722},{"_id":"source/_posts/28-about-design-model5/appendix-6.png","hash":"ebaf47a4d6e618ed357e3ef105bf1a78aac86dcd","modified":1663666041654},{"_id":"source/_posts/28-about-design-model5/appendix-5.png","hash":"7d00695f69933f1493a5b215459372aa8922aa90","modified":1663666020584},{"_id":"source/_posts/28-about-design-model5/appendix-9.png","hash":"5128c7e89b6784e2e75e7f74154a3a2a36859a4a","modified":1663666091964},{"_id":"source/_posts/28-about-design-model5/appendix-8.png","hash":"acc5e67aafb4ec4d3a10ca9507832f965d05bb86","modified":1663666074927},{"_id":"source/_posts/28-about-design-model5/appendix-7.png","hash":"c12235fa4218a1f12d5f04de3c292d9d8a1cc606","modified":1663666058765},{"_id":"source/_posts/28-about-design-model5/module-model-4.png","hash":"0591ff679bd8b40d96b399c2df5db22e5d6857f1","modified":1663659920967},{"_id":"source/_posts/28-about-design-model5/mvc-model-2.png","hash":"2ad2eeb884aac27d63ceb815d119f4bdab3b28bf","modified":1663663790767},{"_id":"source/_posts/28-about-design-model5/mvvm-model-6.png","hash":"7d62d18ec951b6be1b53157c9380618cb8f65cc2","modified":1663665578927},{"_id":"source/_posts/28-about-design-model5/mvvm-model-4.png","hash":"362b306d44bd195ca4adee181dabcbbb524da1ac","modified":1663665502377},{"_id":"source/_posts/27-about-design-model4/chain-model-3.png","hash":"de232baf72880e1c2bfca1e52ca3dece90b30922","modified":1663643787303},{"_id":"source/_posts/27-about-design-model4/localstorage-model-3.png","hash":"0dd09a8620412a0a10e0749a2eae5b990e14131f","modified":1663652010756},{"_id":"source/_posts/27-about-design-model4/localstorage-model-6.png","hash":"af1bc9d6bd7aa6c6582b3b498aaace38b3beb7d0","modified":1663652073728},{"_id":"source/_posts/27-about-design-model4/localstorage-model-5.png","hash":"f60b1b8098b39c8d16bef6ce21e93f80eed6a06d","modified":1663652051324},{"_id":"source/_posts/27-about-design-model4/participate-model-6.png","hash":"a27676bb25d07081323b4801ff167a2f9c830583","modified":1663656339712},{"_id":"source/_posts/27-about-design-model4/throttle-model-1.png","hash":"efe9c32037c01c30eef7c906b1477675a4b22296","modified":1663652476137},{"_id":"source/_posts/23-about-design-model/combination-inherit.png","hash":"51a2c5f4775a37e5f2a21ab257749912178476c3","modified":1661856873584},{"_id":"source/_posts/24-about-design-model1/prototype-model.png","hash":"7e1b5e0841203ae571b20c1c21fc40fb6589f946","modified":1662445978153},{"_id":"source/_posts/26-about-design-model3/iterator-model.png","hash":"b372e782497790afdac5ef90a53eb4ecd88bc18f","modified":1663580424387},{"_id":"source/_posts/28-about-design-model5/async-module-model-1.png","hash":"f465cd97d9c16ecea67b0d0f8ee7d3bb6ebb545c","modified":1663661413721},{"_id":"source/_posts/28-about-design-model5/module-model-1.png","hash":"940ec1732a0d822780c486ccb9ffc6cc29119a6f","modified":1663659235916},{"_id":"source/_posts/28-about-design-model5/mvp-model-3.png","hash":"f3ebcf32efc3e9b536605c9df96654c81cfc9b82","modified":1663664626784},{"_id":"source/_posts/23-about-design-model/constructor-inherit.png","hash":"e1eb49fe9cd4796f60678113b6f865f2e1576464","modified":1661856873588},{"_id":"source/_posts/6-vue3-render/vue3_render.png","hash":"c27773553432184cba670aac70e69865c21a4727","modified":1658223255541},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1654110695000},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1654110695000},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1654110695000},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1654110695000},{"_id":"themes/next/_vendors.yml","hash":"8c2886a6af624f04fc6a376daf48c0698ea71bf7","modified":1654110695000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1654110695000},{"_id":"themes/next/package.json","hash":"b32be32269dd2e241790a766a60357bfe13f2d45","modified":1654110695000},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1654110695000},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1654110695000},{"_id":"themes/next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":1654110695000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1654110695000},{"_id":"themes/next/_config.yml","hash":"fb825f15b5651df878aa77fb3637ee2eeff68900","modified":1671171081165},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1654110695000},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1654110695000},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1654110695000},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1654110695000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1654110695000},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1654110695000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1654110695000},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1654110695000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1654110695000},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1654110695000},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1654110695000},{"_id":"themes/next/.github/release-drafter.yml","hash":"423275ec021104b263cd88776936a8c8d6872b66","modified":1654110695000},{"_id":"themes/next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":1654110695000},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1654110695000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1654110695000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1654110695000},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1654110695000},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1654110695000},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1654110695000},{"_id":"themes/next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1654110695000},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1654110695000},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1654110695000},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1654110695000},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1654110695000},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1654110695000},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1654110695000},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1654110695000},{"_id":"themes/next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1654110695000},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1654110695000},{"_id":"themes/next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1654110695000},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1654110695000},{"_id":"themes/next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1654110695000},{"_id":"themes/next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1654110695000},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1654110695000},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1654110695000},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1654110695000},{"_id":"themes/next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1654110695000},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1654110695000},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1654110695000},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1654110695000},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1654110695000},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1654110695000},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1654110695000},{"_id":"themes/next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1654110695000},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1654110695000},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1654110695000},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1654110695000},{"_id":"themes/next/.github/workflows/linter.yml","hash":"b6c111344bc0f3500ca69d7590791ff85ef1090d","modified":1654110695000},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1654110695000},{"_id":"themes/next/.github/workflows/lock.yml","hash":"e48d1ced9a673d3f0911a700d3e68c0f4ca79263","modified":1654110695000},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1654110695000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1654110695000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1654110695000},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1654110695000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1654110695000},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1654110695000},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1654110695000},{"_id":"themes/next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":1654110695000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":1654110695000},{"_id":"themes/next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1654110695000},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1654110695000},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1654110695000},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1654110695000},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1654110695000},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1654110695000},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1654110695000},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1654110695000},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1654110695000},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1654110695000},{"_id":"themes/next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1654110695000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1654110695000},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1654110695000},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1654110695000},{"_id":"themes/next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":1654110695000},{"_id":"themes/next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1654110695000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1654110695000},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1654110695000},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1654110695000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1654110695000},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1654110695000},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1654110695000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1654110695000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1654110695000},{"_id":"themes/next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1654110695000},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1654110695000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1654110695000},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1654110695000},{"_id":"themes/next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1654110695000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1654110695000},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1654110695000},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1654110695000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1654110695000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1654110695000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1654110695000},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1654110695000},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1654110695000},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1654110695000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1654110695000},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1654110695000},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1654110695000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1654110695000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1654110695000},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1654110695000},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1654110695000},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1654110695000},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1654110695000},{"_id":"themes/next/source/images/logo.jpeg","hash":"cf0f17140f5d4eefe4607db39c354c73eb9b6500","modified":1660025565133},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1654110695000},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1654110695000},{"_id":"themes/next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1654110695000},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1654110695000},{"_id":"themes/next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1654110695000},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1654110695000},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1654110695000},{"_id":"themes/next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1654110695000},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1654110695000},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1654110695000},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1654110695000},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1654110695000},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1654110695000},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1654110695000},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1654110695000},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1654110695000},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1654110695000},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1654110695000},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1654110695000},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1654110695000},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1654110695000},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1654110695000},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1654110695000},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1654110695000},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1654110695000},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1654110695000},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1654110695000},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1654110695000},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1654110695000},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1654110695000},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1654110695000},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1654110695000},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1654110695000},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1654110695000},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"45477a04cf2b3c077061c8c3ada216c1ae288e0e","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1654110695000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1654110695000},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1654110695000},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1654110695000},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1654110695000},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1654110695000},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1654110695000},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1654110695000},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1654110695000},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1654110695000},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1654110695000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1654110695000},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1654110695000},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1654110695000},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1654110695000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1654110695000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":1654110695000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1654110695000},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1654110695000},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1654110695000},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1654110695000},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1654110695000},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1654110695000},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1654110695000},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1654110695000},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1654110695000},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1654110695000},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1654110695000},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1654110695000},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1654110695000},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1654110695000},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1654110695000},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1654110695000},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1654110695000},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1654110695000},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1654110695000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1654110695000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1654110695000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1654110695000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1654110695000},{"_id":"themes/next/source/images/avatar.jpg","hash":"6c8990146a8952732d3fa65f7933f4644c62f475","modified":1660025159934},{"_id":"public/nodejs/file/test.js","hash":"1d1283c896591c6c91699e4c7325cb2226074321","modified":1672825520261},{"_id":"public/atom.xml","hash":"77764e55152b60567d56c9c694614df9cebd9549","modified":1672825520261},{"_id":"public/index.html","hash":"b26b91f3cc1d9eefd574d40cb76909f503e697eb","modified":1672825520261},{"_id":"public/vue/dependency.html","hash":"4af3fe48c69e1012a1c8165a2750c9430d564f14","modified":1672825520261},{"_id":"public/commonweal/index.html","hash":"c58d1c7c7bf65223419b0e79bb5562763be59144","modified":1672825520261},{"_id":"public/vue/index.html","hash":"ea038a0781a04bb5894a8a7d5da2909100e37984","modified":1672825520261},{"_id":"public/nodejs/index.html","hash":"cc6ec3d85b3fb21177cce545d82c511b8eda5b28","modified":1672825520261},{"_id":"public/nodejs/install-diff-version-node-by-nvm.html","hash":"1970c72b1555d40f24740360beaa5374880c97b5","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-14.html","hash":"1b67d2566daf8afe8687b07ac9a83c297c77c354","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-15.html","hash":"99657548d6f5f3f5a0473c2895f6bc0c4ac6663d","modified":1672825520261},{"_id":"public/2022/11/10/42-scrollInToView-params/index.html","hash":"1bbecb03573482441a32a8f11b5d017ab009f0a5","modified":1672825520261},{"_id":"public/2022/10/26/41-js-equal-type/index.html","hash":"d7e26ea5b190c6aa138f8f0dabd0ade08d638e08","modified":1672825520261},{"_id":"public/2022/08/19/22-about-symbol/index.html","hash":"28681fe9f40b4263546212dfb214218a50edd5e5","modified":1672825520261},{"_id":"public/2022/08/11/15-js-transform/js-transform/index.html","hash":"febc7d2dead98a99117d450a6cb32490c5bf007b","modified":1672825520261},{"_id":"public/2022/08/05/20-create-vscode-plugin/index.html","hash":"d8a6051c4da8fccf736a708d8991d804fb32f5a1","modified":1672825520261},{"_id":"public/2022/08/04/18-fake-array/index.html","hash":"bd78d20580571a345972f1a683ca2411cb16fe7b","modified":1672825520261},{"_id":"public/2022/07/19/16-origin-type-and-reference-type/index.html","hash":"b1b654f93050c0ff3849e87725268be39fb5c9ac","modified":1672825520261},{"_id":"public/2022/06/30/12-create-github-tokens/index.html","hash":"ce02f988551e11a1cac59f839b383de55f4da93f","modified":1672825520261},{"_id":"public/2022/06/23/7-question-about-render/index.html","hash":"e292f6f0f074627dd4f5541035d810fd83295e82","modified":1672825520261},{"_id":"public/2022/06/22/6-vue3-render/index.html","hash":"7c52880d5ace893192e77c5fed93372b38308551","modified":1672825520261},{"_id":"public/2022/06/22/5-react-render/index.html","hash":"41c91b0197de40b90965930d7a71b0471ff0ad86","modified":1672825520261},{"_id":"public/2022/03/26/2-var-const-let/index.html","hash":"7f01e6e862ff70e1f255dd2c44fdfb742ff4b160","modified":1672825520261},{"_id":"public/2022/01/05/1-hello-world/index.html","hash":"d3824b397ab68acf0f444a9b9367692ab9a2ff8a","modified":1672825520261},{"_id":"public/archives/page/3/index.html","hash":"57b7fe8027d803d93376345a3b3dc534cd909a43","modified":1672825520261},{"_id":"public/archives/2022/page/3/index.html","hash":"4d7138b22e42771c5997b488b0e0037fad1e702a","modified":1672825520261},{"_id":"public/archives/2022/01/index.html","hash":"f575a71d49fa4d4d30120af927be9e15af698dbd","modified":1672825520261},{"_id":"public/archives/2022/03/index.html","hash":"23e7965f4476216240c08f4defc850491e5dc48b","modified":1672825520261},{"_id":"public/archives/2022/05/index.html","hash":"7f29e76bec37c633a50ec24b46f954b0fd745903","modified":1672825520261},{"_id":"public/archives/2022/06/index.html","hash":"d49405ba001c4218d079dc94580db183ab2f39d9","modified":1672825520261},{"_id":"public/archives/2022/07/index.html","hash":"383236786f17b957720d82bbcf01b82a2dee17f8","modified":1672825520261},{"_id":"public/archives/2022/08/index.html","hash":"3fd3289212cf263c618f9012dfe192ca9408db20","modified":1672825520261},{"_id":"public/archives/2022/09/index.html","hash":"79a42954671544a88b3a00fafbe7ef841d6a5270","modified":1672825520261},{"_id":"public/archives/2022/10/index.html","hash":"561f1c0db9b44fcfe846b94b4228e0a68d5c7947","modified":1672825520261},{"_id":"public/archives/2022/11/index.html","hash":"67cbebd16d4d4f8c7dbf512c313e7a4e6ec0dec9","modified":1672825520261},{"_id":"public/archives/2022/12/index.html","hash":"1b0d55d299df94c2b4c97f84d1ff6a1feac78fb0","modified":1672825520261},{"_id":"public/archives/2023/index.html","hash":"ebdb5b996a2e591e8d1181cd2bb06122aef22218","modified":1672825520261},{"_id":"public/archives/2023/01/index.html","hash":"b8bea867a05dcadbc6a2843ed86784f8e265338d","modified":1672825520261},{"_id":"public/vue/change.html","hash":"d958c0d8c8acd5779adc4e9a8654e52eb3dcb5f6","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-1.html","hash":"29c9ca2f64dafca63e1c3bbe7b330bda2d91a432","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-10.html","hash":"8529e56fe2e78ebcfcad72c18830266e411f7cbd","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-13.html","hash":"d9b2532de88cef7c8fa61836d601592f882ad0e8","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-11.html","hash":"f861a95784d57d6708fb426dfab60b895e5dd8ad","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-12.html","hash":"fcb5e6783493290e24dbba78f95f721cfdc2b2b4","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-2.html","hash":"11f393da37577988f79ab3461daa1374647f43d2","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-5.html","hash":"b8151ad630b8a8e4dd5679e8925a94b553120970","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-4.html","hash":"6f045d599650673017911449584027a9538b899e","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-6.html","hash":"7ec92208ebe2ea1374683791519264f90b90a457","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-3.html","hash":"09e08529aea3955ac1a31a29d28151dfc5067e9b","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-8.html","hash":"4f4a7bfbc59cc427b9beba3146b829cad7d1f057","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-9.html","hash":"82a28b8f7e4097d9444938aceb5b09e5a618d1a8","modified":1672825520261},{"_id":"public/nodejs/nodejs-note-7.html","hash":"0c135d2fdc111e463a3ad4a11c7a28d437b0bbd3","modified":1672825520261},{"_id":"public/2023/01/03/44-about-grid/index.html","hash":"6512d29118e678989ab79d287b0aaa9442655a01","modified":1672825520261},{"_id":"public/2022/12/08/43-compress-picture/index.html","hash":"c85d472abf0fcbca0d23794fd7ad89a01c2aebb3","modified":1672825520261},{"_id":"public/2022/10/17/40-tail-call/index.html","hash":"0f76f303842feb1c6a6abd54db44e32ea6779628","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/index.html","hash":"f9c6b6b5fdec564d0b3e7e42b385dd8abb92fd6d","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/index.html","hash":"527cd3b48fbb6ec731838b55b3e8ab2201bb014d","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/index.html","hash":"ca010eb5f97703e2f06d3920a1a2dd54387202b2","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/index.html","hash":"2b202e82d35fb4aab2da9290f50657deb4dddad9","modified":1672825520261},{"_id":"public/2022/09/29/35-data-structure3/index.html","hash":"4bbe8c50221f9fd3b8794cf97e8ac8f93a2be266","modified":1672825520261},{"_id":"public/2022/09/23/34-data-structure2/index.html","hash":"da3d4152e1b6386fe26d0b39196dfd2430cc4e58","modified":1672825520261},{"_id":"public/2022/09/21/32-apply-array-to-params/index.html","hash":"cf1f00d1470baa4fcd9f65e74e2921ed0c33b19f","modified":1672825520261},{"_id":"public/2022/09/20/33-data-structure1/index.html","hash":"6c38e3ebfdf237e8d7d0a4057fe4d22d556e5b04","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/index.html","hash":"cb9b53bfcc08097c33d2a03a7c812f6eea511269","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/index.html","hash":"975365d1a43ce37ac02b82337988cadd617b198d","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/index.html","hash":"d67455e71293b8f93a53a71ff8cef2c07a59dd99","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/index.html","hash":"c6ae58adc77fce9a68f37314ae1f49de7b259067","modified":1672825520261},{"_id":"public/2022/09/05/31-get-and-set-prototypeof/index.html","hash":"202e94cc827ac0f18b17ccca827baf9392518130","modified":1672825520261},{"_id":"public/2022/09/05/30-some-convenient-code/index.html","hash":"ebd831555760380c88e51a0cdc3bf0a928e366ca","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/index.html","hash":"1c6a5cd6519cff0bdd42332a904b62cdcc2eca92","modified":1672825520261},{"_id":"public/2022/09/02/29-es6-object-strong/index.html","hash":"12a3ac7648710fc67a1d60c080b8ddb0ca736548","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/index.html","hash":"83744b205f9b47806102f0b893d339b0207aa6df","modified":1672825520261},{"_id":"public/2022/08/09/21-devan-operation/index.html","hash":"b8766591250c6786559c4e0ce6685358f64355ee","modified":1672825520261},{"_id":"public/2022/08/04/19-about-map/index.html","hash":"a526ca8e757584eb834355a5ccf995078fdc3c19","modified":1672825520261},{"_id":"public/2022/07/31/17-about-dom/index.html","hash":"fe57137d10e24525702371db8a077369791ac916","modified":1672825520261},{"_id":"public/2022/07/19/15-js-transform/index.html","hash":"e887e09d67b6c2a7eed00c6004d3f9a93f0e5d10","modified":1672825520261},{"_id":"public/2022/07/12/14-about-fe-theory/index.html","hash":"6c71d1da70ae246dda3d20263a358b89ebd9cc2d","modified":1672825520261},{"_id":"public/2022/07/05/13-document-location/index.html","hash":"37f32ab02ca479199918769bf61ecaa1553ea65a","modified":1672825520261},{"_id":"public/2022/06/30/11-github-push-insert-password/index.html","hash":"e13a71c05857140b0d683525724742cdcc6b2716","modified":1672825520261},{"_id":"public/2022/06/28/10-about-meta/index.html","hash":"10a5b43bc8f6017c52934d7e18b9fcbfe54eeadc","modified":1672825520261},{"_id":"public/2022/06/27/9-text-type-about-markdown/index.html","hash":"6fb8f226574e5d917214edca57dbeeb84954d7eb","modified":1672825520261},{"_id":"public/2022/06/27/8-create-fixed-length-array/index.html","hash":"be9558c32be65fb2bb5f03e9d50ef788196e2a2f","modified":1672825520261},{"_id":"public/2022/05/23/4-browser-render/index.html","hash":"af2fce533e30098fa4d5d53cd676f9db7bfcce31","modified":1672825520261},{"_id":"public/2022/03/26/3-about-use-hexo/index.html","hash":"c4dc97b593bb32e2f1292f073cdcde95ab35a21d","modified":1672825520261},{"_id":"public/archives/index.html","hash":"74cf6aba174b71409d42189587b1d7b911830a4d","modified":1672825520261},{"_id":"public/archives/page/2/index.html","hash":"fd9b1f9290e5f1e2844fc885df1ee83d2ee71aef","modified":1672825520261},{"_id":"public/archives/2022/index.html","hash":"bea890ecb8809957b1683554517170642bc385e6","modified":1672825520261},{"_id":"public/archives/2022/page/2/index.html","hash":"b93b4d8f90faf2e516f4c671db8a42fa5e1ded64","modified":1672825520261},{"_id":"public/default-index/index.html","hash":"bb67442777d7dd404092e189c07a0e1fd53fe698","modified":1672825520261},{"_id":"public/default-index/page/2/index.html","hash":"b5b9614552d5b027e8a5ce0eea434d814abd2f4b","modified":1672825520261},{"_id":"public/default-index/page/3/index.html","hash":"7a5fcb9427fa1100a28bdb11868e84a92382bc0e","modified":1672825520261},{"_id":"public/default-index/page/4/index.html","hash":"befbe25ad435a8c7170572caaeee9c83348e075a","modified":1672825520261},{"_id":"public/default-index/page/5/index.html","hash":"59fc88654d893ea07829a2e8ffa51b54cfc9abfe","modified":1672825520261},{"_id":"public/nodejs/file/stdout.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1672825520261},{"_id":"public/nodejs/file/test.enc","hash":"aa3e64643dde19f29c413cfae1160dd980ac3ad3","modified":1672825520261},{"_id":"public/nodejs/images/async-experience.png","hash":"c7c903136156205117f819ae03a5ce81204c23b9","modified":1672825520261},{"_id":"public/nodejs/file/stderr.log","hash":"c8598eb267a5b8880fb5e4a09c3e432baa246662","modified":1672825520261},{"_id":"public/nodejs/images/async-progress.png","hash":"5e6ef5a50ac929df8694a62ec96202048c4bb18b","modified":1672825520261},{"_id":"public/nodejs/images/buffer-3.png","hash":"586ecdade8a0bd9f926e4a9e4c8f9b328517719d","modified":1672825520261},{"_id":"public/nodejs/images/bigpipe.png","hash":"dc9b44b4ed5e79203f2690bd2e87ee7aefac6b23","modified":1672825520261},{"_id":"public/nodejs/images/async-call.png","hash":"cf73b4e1fa6ef2c5eb1d6813c73ed2abe6bb5989","modified":1672825520261},{"_id":"public/nodejs/images/buffer-1.png","hash":"2ddb6050f0ebac6bb733b8d50f9abdb71bb21563","modified":1672825520261},{"_id":"public/nodejs/images/buffer.png","hash":"0c585b0181968674a65b89c42f8c31421af99dc6","modified":1672825520261},{"_id":"public/nodejs/images/buffer-2.png","hash":"3fc41fcc7896fe6af165cbdb5f4048770c915b9e","modified":1672825520261},{"_id":"public/nodejs/images/ca-1.png","hash":"89317164d8d399085df7d23a37d737c26a2c5a30","modified":1672825520261},{"_id":"public/nodejs/images/ca.png","hash":"81f692dee7584b2c9d6e7ad0360b4461953c40d9","modified":1672825520261},{"_id":"public/nodejs/images/cache.png","hash":"1ac69103427a3c1a8b0022af1620a927362c3385","modified":1672825520261},{"_id":"public/nodejs/images/collect-diff.png","hash":"d69687d4300e224c23ef3169a9c6e4f3db396fc3","modified":1672825520261},{"_id":"public/nodejs/images/cross-platform.png","hash":"2c1a28975ade0c9f106e3716dcaf24c877e0773d","modified":1672825520261},{"_id":"public/nodejs/images/commonjs-node-relation.png","hash":"5cc6679d9fe66c78a61dbacd4e94f3f11fd848d2","modified":1672825520261},{"_id":"public/nodejs/images/fork.png","hash":"d3796212324ee8f24e8405d54ec6ad8e57b49bf8","modified":1672825520261},{"_id":"public/nodejs/images/epoll-loop.png","hash":"bc7af5054040babc3f1af3b688d8764760f7bfb3","modified":1672825520261},{"_id":"public/nodejs/images/how-to-call-async.png","hash":"39ac29400db5abed7d02b2b3e3397cc761006271","modified":1672825520261},{"_id":"public/nodejs/images/http.png","hash":"335a31f82a46e1bf32a09cdd9f51a17aaf827a14","modified":1672825520261},{"_id":"public/nodejs/images/defer-promise.png","hash":"6b8484c9a5882e75524b0944be43b010c22e1d5c","modified":1672825520261},{"_id":"public/nodejs/images/jam.png","hash":"638a73d978e27ade2b7e8e0ac66d340caa63453d","modified":1672825520261},{"_id":"public/nodejs/images/increase-target.png","hash":"55ed1f32bfd6360265eb8b16ce0f0ed2c21c514c","modified":1672825520261},{"_id":"public/nodejs/images/loop-1.png","hash":"7dd0d30cf11ca3d1851d68d9c04b186d0b97aa23","modified":1672825520261},{"_id":"public/nodejs/images/loop.png","hash":"a1b9e75136f79dcccdafc48d6f30606b8664a9f4","modified":1672825520261},{"_id":"public/nodejs/images/net-1.png","hash":"4f9169ff8774a785573375b0eae0bf611d918376","modified":1672825520261},{"_id":"public/nodejs/images/master-slave.png","hash":"4f45a0cadfd5ab7633103418fcf49bcc018da4d2","modified":1672825520261},{"_id":"public/nodejs/images/mvc.png","hash":"f86ed56705edc5f57ab24298801afe09cd4badc6","modified":1672825520261},{"_id":"public/nodejs/images/net-3.png","hash":"8af8561052ec1608a0773304cf04af4234557052","modified":1672825520261},{"_id":"public/nodejs/images/middle.png","hash":"e68b0513b166f049e4f0d72b91e1d5c2c8338747","modified":1672825520261},{"_id":"public/nodejs/images/net-2.png","hash":"1b28b0d5d2ac3d95c136285f9be2d83ba2ba7bdb","modified":1672825520261},{"_id":"public/nodejs/images/net-4.png","hash":"81f06ad4be9d956662e629238db1590287228ce7","modified":1672825520261},{"_id":"public/nodejs/images/node-modules.png","hash":"e5835f2da7cca29d0eb1676c7b081c7122a52528","modified":1672825520261},{"_id":"public/nodejs/images/no-jam.png","hash":"5d4728cbaa1c2f7e680f6f3a12202ec94347211c","modified":1672825520261},{"_id":"public/nodejs/images/nvm-setting-content.png","hash":"8d0ebc40648adcebe40cc663caab2cee4b8f6436","modified":1672825520261},{"_id":"public/nodejs/images/node-require.png","hash":"9e2fd7eee0b6bdf918b4fb34544beb7424702ab8","modified":1672825520261},{"_id":"public/nodejs/images/nvm-setting.png","hash":"742427d031db38180aebc79883d7fe7f2b5082dd","modified":1672825520261},{"_id":"public/nodejs/images/package.png","hash":"dccf0cad2808e81718b9efe11c884aa24fe6b73d","modified":1672825520261},{"_id":"public/nodejs/images/pipe-2.png","hash":"7bda2919687448a1c427e768f6474271782ef1fa","modified":1672825520261},{"_id":"public/nodejs/images/pipe-1.png","hash":"7385963b2e8c0359641f3f3ccf316dbcb60b32f8","modified":1672825520261},{"_id":"public/nodejs/images/pipe-4.png","hash":"ce3c89fb6762678626193ff9fc6aaa9227de6660","modified":1672825520261},{"_id":"public/nodejs/images/product-1.png","hash":"a127d5caca21588163ce2a98490b4f677aeb78c6","modified":1672825520261},{"_id":"public/nodejs/images/poll-loop.png","hash":"8d0bfc2b615eb460d6ab8be0837e523af238c8f0","modified":1672825520261},{"_id":"public/nodejs/images/settimeout.png","hash":"55f051726fe3210ac5ad039ce469da805b5c45de","modified":1672825520261},{"_id":"public/nodejs/images/pipe-3.png","hash":"38b94af4d0d88bef05b17d1233bf2e3b3623b25e","modified":1672825520261},{"_id":"public/nodejs/images/read-loop.png","hash":"8656ba0172108ecb0a251139cbe0a8df61873b40","modified":1672825520261},{"_id":"public/nodejs/images/product.png","hash":"47cef8cf353b57b3a18c013ea8b6bed0a8e617cf","modified":1672825520261},{"_id":"public/nodejs/images/pipe.png","hash":"e92d4834ee1fc339f8d36a745950a10d7633955a","modified":1672825520261},{"_id":"public/nodejs/images/select-loop.png","hash":"bba3437eb7794c0fe3abb77fb37ac8897bf19bb5","modified":1672825520261},{"_id":"public/nodejs/images/sweep-compact.png","hash":"5af9bde21db63d1483a807be5b0f6cde77ef5cda","modified":1672825520261},{"_id":"public/nodejs/images/test-2.png","hash":"e613d096c62a0d27f72b8b50224e5b5fafafc3e9","modified":1672825520261},{"_id":"public/nodejs/images/symlinks.png","hash":"48dd00ba4c43783739716fdc0b0790b0e3187893","modified":1672825520261},{"_id":"public/nodejs/images/test.png","hash":"840cda90b44467e3648decdf62f1d146f1261538","modified":1672825520261},{"_id":"public/nodejs/images/test-1.png","hash":"0bac06c06b58a4a61acd1a6c17971046d56c1d82","modified":1672825520261},{"_id":"public/nodejs/images/tail-trigger.png","hash":"052e9473880c882918ae9b763b9fa6f808bccdf1","modified":1672825520261},{"_id":"public/nodejs/images/v8-promot2.png","hash":"4fe47a4a361987c7928001641f8b092af4f5764a","modified":1672825520261},{"_id":"public/nodejs/images/tls-ssl.png","hash":"e7011243d619ef7b1f2489146744a741d80e027d","modified":1672825520261},{"_id":"public/nodejs/images/v8-promot.png","hash":"28d3849e4e768a3ae7954bae653b55ce6e9a7bb5","modified":1672825520261},{"_id":"public/nodejs/images/websocket.png","hash":"907dcc1e99f2e6d20f1133508ff3b84e1985e065","modified":1672825520261},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1672825520261},{"_id":"public/nodejs/images/websocket-1.png","hash":"a6e3598d6c9cdef36c1930c9e7535c3a76b1dcc9","modified":1672825520261},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1672825520261},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1672825520261},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1672825520261},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1672825520261},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1672825520261},{"_id":"public/images/logo.jpeg","hash":"cf0f17140f5d4eefe4607db39c354c73eb9b6500","modified":1672825520261},{"_id":"public/2022/08/04/18-fake-array/document.png","hash":"c0e73c5d922eaf7f899856685f5fbd8245517fe8","modified":1672825520261},{"_id":"public/2022/08/04/18-fake-array/array_from.png","hash":"50733fd866277f6aa27e12e432f2511fa886855f","modified":1672825520261},{"_id":"public/2022/08/04/18-fake-array/prototype_call.png","hash":"166ae1ed6f21a1c4ee961508d06adae89f22c6d6","modified":1672825520261},{"_id":"public/2022/08/04/18-fake-array/slice_call.png","hash":"a97bd9fef96df18bbe6097521df710bd9615090a","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/abstract-car.png","hash":"63b2384c0b130f2d40907996aeb528d2131ab01f","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/safe-model-class.png","hash":"90a874baec5df9156cf7b65d7c7754d28c82337e","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/static-param.png","hash":"ec22668e0901214c3d2efadcdae0ae34f801c2ac","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/bridge2.png","hash":"0d4e3980c0c177ef97e690e69919f954f2292ddb","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/bridge1.png","hash":"70973d153e1e628ebf1152bce98b1a68b7530784","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/bridge3.png","hash":"8358d5a031c07b8a0dbe61df13f0642bf03b7c5d","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/command-model-3.png","hash":"f8973520dfc9d241d4e418d016dbde7cf647482f","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/explain-model-2.png","hash":"13dd495c6f42e9820c60034d2e87bc917486129e","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/observer-regist.png","hash":"160d15173ed43415298e65c9b3d9a63159aacb91","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/entrust-model-2.png","hash":"71764eebae7d27ba83deff08b4d925307914e3d0","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-1.png","hash":"5237b5b92b4b542f593af63d48afb088237eb2ed","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-1.png","hash":"d78dd470675aa3f2a42ad1ce9617ef7d89e2168a","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-2.png","hash":"04cb3a2efcc6a9a9b3cc52a11c14b75ebfa332d6","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-1.png","hash":"44ef46104d7428d99d7b80b7ca8e2f9059d02340","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/template-model-6.png","hash":"f34ff79b1d619c45ccb21c2158a4680a6617942f","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-3.png","hash":"b59dca3e470f10063815167bca6227f8341dbc8e","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-8.png","hash":"9be78a26ae2db46d9ec8d4bb36902be64991e2f9","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-2.png","hash":"8898b83e3301783ee9bfb43b2488f4171e86a2bc","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-7.png","hash":"8473d1889cf3ba7e45e0b71a8dd861cc233f05c2","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-9.png","hash":"3959c02225b63e07adce93a968ed0bb0e2e6c365","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-8.png","hash":"3a03fb902c96d787e256412ebc5a604a26aabd93","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/module-model-5.png","hash":"c866de378508cfdbfd9307dd72b719577d2a3cff","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-1.png","hash":"9fe4ed86ba3315ba722de0660cc6ec5770666487","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-1.png","hash":"ff42b48b0eb5f6ac14adc79c348d093c14f164de","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-4.png","hash":"03b64f2faf10dbcc8c3a32fb96b29e0b135f2f49","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-2.png","hash":"3cb6051a5054c50231162690a8494170b90397f4","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-7.png","hash":"85c76e7e1a84df4345885b58a4495b8472da6c7c","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-1.png","hash":"4f89287a4f8aa1122864cbc4c77f89d592a68c45","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/binary-search-tree.png","hash":"ad74f8c6b96f77ca95d6b9b48cf87fda5efcfdbc","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/factorial.png","hash":"ddfb0d84eab3db09c51a4b87376c023e35c597be","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/in-order-traverse.png","hash":"db6c59fc444e910a9921f50bc9e8e66964ef2849","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/left-left-1.png","hash":"655a6a8118dd11fffc1c0bf38c1a06fd9d861fb7","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/left-left-2.png","hash":"31829f0a81c4d517a768b0d824702e96ed38af94","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/left-right-1.png","hash":"b0d03e54c49df4be3cdc60f9436e4ecb40a3c6b6","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/left-right-2.png","hash":"dde339c5a7c4a70be0a832190a2678237f10331d","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/post-order-traverse.png","hash":"aee9c88702a4fa397c4146e997f7ba3504b19a3e","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/pre-order-traverse.png","hash":"d93c415f7de4fd6c9d5bf3dfc7fdaf4484d6173c","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/red-black-2a.png","hash":"618993219918c6d178ac4f468129647d0c0d6f72","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/red-black-2b.png","hash":"88a4290e21e993ca3a39a86a83283bc607f24b9c","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/red-black-3a.png","hash":"6db63a5d31e7477b9d3a7ce036c9607db9262fb8","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/remove-left-right.png","hash":"4141ff9827c5c74323d60196c96038c898c07cf6","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/right-left-1.png","hash":"3d1ec645ec1def7aeb460386d421b9dc3cc684e0","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/right-left-2.png","hash":"9fd153762d1b34409ac583c8dd871153f0ce5fc1","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/red-black-3b.png","hash":"e4f8a20d976abc667a94482eeeeaa0f5281c410e","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/right-right-1.png","hash":"5d6258c158f22e8582f538f06c89dc86bbedfba7","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/right-right-2.png","hash":"b6a6f5a17aa73fc8daf16313e0204a05314c3c16","modified":1672825520261},{"_id":"public/2022/10/08/36-data-structure4/tree.png","hash":"c1a3dff14361fa7bfc3f73bf7391d46c57044737","modified":1672825520261},{"_id":"public/2022/09/23/34-data-structure2/chain-table-1.png","hash":"b4a240e43972349b743117265ca1897051389bed","modified":1672825520261},{"_id":"public/2022/09/23/34-data-structure2/chain-table-2.png","hash":"ea63e231035c3929b320bb52dc63c363a1b1ff39","modified":1672825520261},{"_id":"public/2022/09/23/34-data-structure2/chain-table-3.png","hash":"6db25c5f058ceecae16751cea75e2a13e62a6b3d","modified":1672825520261},{"_id":"public/2022/09/23/34-data-structure2/chain-table-4.png","hash":"04054fdc4cbdfb48b13bde3769b7ccb590e6bff9","modified":1672825520261},{"_id":"public/2022/09/29/35-data-structure3/linear-probing.png","hash":"0a020e8afc93027a2f5d6873414f7afbfa4b6f83","modified":1672825520261},{"_id":"public/2022/09/29/35-data-structure3/lose-lose.png","hash":"55e49878d996f933010c1ac93b306b407a74019a","modified":1672825520261},{"_id":"public/2022/09/29/35-data-structure3/move-key.png","hash":"ebb4944fee6e7aa9426ad27101ccaaca152e2fa2","modified":1672825520261},{"_id":"public/2022/09/29/35-data-structure3/soft-delete.png","hash":"f8fc5195e6b92a91af6b1a283be51fea18d95ccb","modified":1672825520261},{"_id":"public/2022/09/29/35-data-structure3/sperate-chain.png","hash":"1c7b05c0f24bd68757a3497182c41da36cf91bbc","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/search-2.png","hash":"3626ed24aaf5d1563eb1daa3a4f8d5136150bb83","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/search-1.png","hash":"a844a9c7aabbe1a2fc3c7151e88a35f494e9d09b","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/search-4.png","hash":"ecf4e1f8dd0fdf38b91d89de529f09da6eb88dd8","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/search-3.png","hash":"719072030a73de7c3054974d55b626d221894218","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-1.png","hash":"97f90c860ce1d2669135aa5a7a474aeb7a799ad6","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-10.png","hash":"cbb2fbde7d06aae552356dd7e4c65274d322f0fe","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-11.png","hash":"067113a10d14e5524fe4e7972c61d1b077811134","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-4.png","hash":"273c67388337e6e5eeb6c6e3486e5047d8d02321","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-2.png","hash":"a63daadd4590ed6b4ad7519bd1a14ae4be364a64","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-3.png","hash":"913bb3906ff437f6dfe6a773b852918b7a49ae0d","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-12.png","hash":"a8fdcaca8fd646997a58eca48c76809cb25c7571","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-5.png","hash":"05867cc82ce12a1a2b6c92d0d37e2155df04d0a5","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-6.png","hash":"c4802ae6c84bee330fec94ddd888543a590ec692","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-7.png","hash":"681be89ab6425489c526125d890ae38ef8ee1435","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-8.png","hash":"f62f618f88c3715fa98532f136e36afea5153b3b","modified":1672825520261},{"_id":"public/2022/10/13/38-data-structure6/sort-9.png","hash":"b1a616076a59411ae21537a155e8f12e198c78b0","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-1.png","hash":"a1b2db6ab3de04b1adf413855eaa4220c96ae523","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-10.png","hash":"be4ed69d06ae7dcea2b875b3b0ce92922a7fd0b2","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-11.png","hash":"070f67f44e46097fb8750af9a315c9bca7fc6c0f","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-12.png","hash":"b557ac7c33f3672b559a4a1eacf84aba2fcff1cf","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-13.png","hash":"0ef979dea025ae063ccc8477915e14c2bada6f77","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-2.png","hash":"f56455b618e7b41e84fba80e91ade7ed29df91ca","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-3.png","hash":"4bca0b6ea37be10e8ab4b015ab1879bc9c95f98b","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-4.png","hash":"47bcd4a1de612d5af3bd3301602b4b6bc07b4c6a","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-5.png","hash":"a85fa2dffae020f8d02eebce15b1592e9b222a5e","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-6.png","hash":"3781b637547025de758bec7262c50fe45bb57774","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-7.png","hash":"dbd8e52679bcbf321c3a8d17006729c4af0c87ad","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-8.png","hash":"93de61e5c29df7b193e41f2595521446bc81226d","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/heat.png","hash":"a37ac1abfbbf1bd9742deec30a783d0f90e49657","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/min-heat.png","hash":"c2c5f8cc68ba6cf3d89bebb94c0a7a7d22c1e5a0","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/big-o-1.png","hash":"bfc4e8cd9822858a4f5afd7ea21ac69ae391248f","modified":1672825520261},{"_id":"public/2022/10/17/40-tail-call/call-stack.png","hash":"9ceba234d31d636baca2b4f2af1384b6b25d4a4a","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/big-o-2.png","hash":"5abf1a71a4b31ade53b60d5d6edf850266d502e2","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/big-o-3.png","hash":"b7140be66eb3272f0dd9c183b48cfb8555cb4511","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/big-o-4.png","hash":"75fd12b92a8ef511524bb5306c73fb63346d586d","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/big-o-5.png","hash":"0e81454c15a22289ae8fd29e9ba356f9058ca226","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/big-o-6.png","hash":"443cef5a2ff290edd7a7b9f9c3e4580e9d8375b3","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/technology-1.png","hash":"25d324e43b4ae5d4921a2fa9bf40479a54ba55d2","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/technology-2.png","hash":"00436e4649e1f7cdeecb39e78e1cece84a8c0591","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/technology-4.png","hash":"956d458c4792a6a56ad0f9292f3e7773bafca1d1","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/technology-3.png","hash":"fe308b75c03e0efc9bc24154073ae4a31c1fc73f","modified":1672825520261},{"_id":"public/2022/10/13/39-data-structure7/technology-5.png","hash":"61dc4bb992375a4f2d5c5b5afdb594877f58510a","modified":1672825520261},{"_id":"public/2022/06/22/6-vue3-render/render.png","hash":"0b20ebf2700ccd675e40f6330e07dce8341807a0","modified":1672825520261},{"_id":"public/nodejs/images/nvm-download.png","hash":"1fddd6469f02c83d3c54603c3f43a72224565a29","modified":1672825520261},{"_id":"public/nodejs/images/nvm-install.png","hash":"347c3fe9e8ac21a112d1eba02b594b5f5b2af672","modified":1672825520261},{"_id":"public/images/avatar.jpg","hash":"6c8990146a8952732d3fa65f7933f4644c62f475","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/abstract-factory2.png","hash":"a1a8a6b4b0c2aa47bbc543add6b6a675670b41ce","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/human.png","hash":"f78b9964ce7223cc99122c99667673d9242df348","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/name.png","hash":"d46e84150e7fdea9eb17d8ad0624e7eb79654ace","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/lazy-single-instance.png","hash":"4bbd91090a4364cc48ec5cf388ae29f1f3626b8a","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/person.png","hash":"12e19fccdb8ee0dea2ec9e55c4f55125a536b76e","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/prototype-inherit2.png","hash":"cd61b59785ea6144fabce855bd363ff7906468a9","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/decorator.png","hash":"a0fdfe4dc2b74b52a33fd13ed7e1b3c1fba8480e","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/out-look.png","hash":"d9f11180b44ccded8da8ecba5593bdd6ebd58eb4","modified":1672825520261},{"_id":"public/2022/09/06/25-about-design-model2/station-culculate.png","hash":"26cda447bac04b0260f0ec11ca1dcb836f93855a","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/how-to-inherit.png","hash":"2610b10429de1454b684733ede30778da89da750","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/prototype.png","hash":"fe3518ce58c5945b8f5db473d69be75f67a98b0a","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/prototype-inherit.png","hash":"a5f0085a3caf9e0519fe3cb26129dd144cfc7594","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/parasitic-inherit.png","hash":"dcde79d7db360d5f56bf441be778908d3056f693","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/public-and-private.png","hash":"275fce752eaeadf6eee22e10bf14451ed9eb675c","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/static-and-public.png","hash":"aef2330dce27ebc420b7654abdf1859266ec48a4","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/simple-factory2.png","hash":"e8d75951fa119c24b2c188eb639f16a32bf70928","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/add-message.png","hash":"03712141c27e51d24f4361c6c48a609b366f5692","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/observer-fire.png","hash":"0204e744bdcb2480cae91e03d4e79c26913cf85a","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/marry-state1.png","hash":"2f5c004568231ff2a14ab499c91aabd48c302f28","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/observer.png","hash":"05738a02cd73736025351c0e9e3fc0d0de27158f","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/regist-change-num.png","hash":"3aa9791db11e1985c21e29959201f022a0f98a88","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-2.png","hash":"8a59f234053c9a85a94f74273fafed9051ec578d","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-1.png","hash":"ac13400dfce89f26fe4bcadca5c2a1f4994083ca","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-4.png","hash":"33fa9dc7cb773d0e519dcb4a4a5869aa78234950","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/observer-remove.png","hash":"e0e97122604f5eaa716042ffd19d7e6fc4d9535f","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/entrust-model-1.png","hash":"900a7cc246a17adae923b5e0b87d5b8b8d255674","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-2.png","hash":"29a6f621b06f9283d3caff7d3c63f7c711095978","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-3.png","hash":"7cf3eba1156eb71177fee16c281edfd2f7d3d0e0","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-6.png","hash":"bb1487d2e1e38d3c2ea4cb6dcc310f0025664444","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-5.png","hash":"ce1428d6b73612a3290d3cbd0efa607829fdb233","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-3.png","hash":"257320d7e940dcef49305ea8d1642621bfbf3ff1","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-4.png","hash":"5f13e728cfa8cf2eabd3925f1a0798bc905d267b","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/template-model-1.png","hash":"41e2537938230a77a4072987778016031fe92291","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-5.png","hash":"9694840f32c90094e37228de41fc2cfdf4f66388","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/template-model-3.png","hash":"3a24763c6d9e280dd6c26d966da99ceb0d658ec5","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/template-model-4.png","hash":"b301423b25f6447a52369e96a6f0d1c3b93da6c5","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-4.png","hash":"ad67d02d972353793d59f1ca5f1191fb9a220e52","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-5.png","hash":"30412937d3a27e5d8bf1db0d87fce38a8d59839e","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-6.png","hash":"007198e00695be520e246815152687e250bf4941","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-7.png","hash":"0eefaa7468c3726aecd02980b1c10574a1d06c40","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-4.png","hash":"731b4ee9c777c9d9bd6664bf674e1abf1f48af65","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-5.png","hash":"436f66ba99f8bd7400ad91b3d857d255f6f3034c","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/module-model-3.png","hash":"aa42c569b2a73fae726d6518fda8a48a325c5a3f","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/module-model-2.png","hash":"a22fb6b41b50875766d5382664361095fca59051","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-3.png","hash":"28fd4de773e1352941b4b0773858520ec4e21039","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-4.png","hash":"59ab08a2d276eb142c4789000d2c484aaaeb4890","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-3.png","hash":"b4f73f397dcb296b03350b04390a8f2cdc0906d4","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-7.png","hash":"4d8187320d10b1bb36a49169575baf54fe7e7a71","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-4.png","hash":"7c2ca9c608b6829fa768590455a8785c9ff13781","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-5.png","hash":"5ff7151981d6c83fa8a45556de7e17f4e527c093","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/heap-sort.png","hash":"a344a2264bed09372c160b691a6e0a581bea3bd6","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/min-heat-pic.png","hash":"6d8794be490f9dd7f0664813070eea6169c49181","modified":1672825520261},{"_id":"public/2022/06/22/5-react-render/force_update.png","hash":"f0333239066cd2e4a8cdf12bff8fcdfcc01a7616","modified":1672825520261},{"_id":"public/2022/06/22/5-react-render/update_class.png","hash":"5854028928496a0b6c4ad02452cd07c12650f8e8","modified":1672825520261},{"_id":"public/2022/06/22/6-vue3-render/render_node1.png","hash":"4a4266c87a315afeb55de174b11784431f3c40b9","modified":1672825520261},{"_id":"public/2022/06/22/6-vue3-render/render_node2.png","hash":"bd8cbab05ce653b80a1cc89e609b7ae9c309b7fe","modified":1672825520261},{"_id":"public/css/noscript.css","hash":"ec89b3425fbce20863d554c6fd495ea29c3c303d","modified":1672825520261},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1672825520261},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1672825520261},{"_id":"public/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1672825520261},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1672825520261},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1672825520261},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1672825520261},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1672825520261},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1672825520261},{"_id":"public/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1672825520261},{"_id":"public/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1672825520261},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1672825520261},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1672825520261},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1672825520261},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1672825520261},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1672825520261},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1672825520261},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1672825520261},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1672825520261},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1672825520261},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1672825520261},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1672825520261},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1672825520261},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1672825520261},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1672825520261},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1672825520261},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1672825520261},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1672825520261},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1672825520261},{"_id":"public/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1672825520261},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1672825520261},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1672825520261},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1672825520261},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1672825520261},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1672825520261},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1672825520261},{"_id":"public/2022/07/19/15-js-transform/js-transform.html","hash":"18caf0ae505ad384d3fa4c402aaf049e263f6fc0","modified":1672825520261},{"_id":"public/css/main.css","hash":"b4ee45f983412d5fa84f99c4991fbc24d0bc8a7e","modified":1672825520261},{"_id":"public/2022/07/19/15-js-transform/convert-table.png","hash":"fdffd1b86ddacb402a9a3a423cffd91fcc229fce","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/abstract-factory3.png","hash":"565cc1a91ec9f7f4113759d8ee84d9e7e5765dec","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/abstract-factory1.png","hash":"27096d5d5c2a949d2b5a0b8b4483cd0955007a30","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/prototype-inherit1.png","hash":"3d8d602b70b2a85f84ccb77667bfdf58688ef1e6","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/safe-factory-model.png","hash":"1d4838406d573590c135cb651e98e970dd03d761","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/class-inherit.png","hash":"7316cf53af5ae3d11eb708f911ddc2b9fbf35027","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/create-pop.png","hash":"43feb1eed0b060643140cfa80c073e12729b47af","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/multiple-inherit.png","hash":"3370f1d5c3f1c73449ddc04e438559b4a0925ad0","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/parasitic-inherit-change.png","hash":"0b683e58266a2816c17a932a910be6ce1bdbbf1e","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/parasitic-combination-inherit.png","hash":"5b7c9be2d070fe04cd77d8923eaa4e1585ad9e02","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/command-model-2.png","hash":"394963fe76e75b6ff152d0bc64eb440812f181e4","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/create-component.png","hash":"313f9c4b04afdb3c0bbb24d02394ff7ed7f7afa9","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/deal-data.png","hash":"229c21fa8cd0891d9cf137520e2756088d805b32","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/marry-state.png","hash":"9d3b9fd7f74062d32194ddee1084db94ab8f2f5e","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/send-data.png","hash":"f2dd937ad9d5dbd6373c78b766b0ca7d18689bb8","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/vote-status.png","hash":"ce2f7e1b2250efafac59e7e0a6c69a8f2f57e1fb","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-5.png","hash":"6c1d9aaa8a2f5c8a33e827428f33df74156af591","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-6.png","hash":"0a2af8c6826567da8695e8010d13bf7101a75d0a","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/lazy-model-4.png","hash":"d2cec3917cabaf4da67a6ac877730c32d27d6b82","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-2.png","hash":"b130a85fa7ca8cc738c636091e35ce86095e4da4","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-4.png","hash":"c7d8b6cd9bc0093ceaaa9a731d6b721dabf0c2e2","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/template-model-5.png","hash":"a615f27465cba32bd7ef16f4aa2d229123c6cd04","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/template-model-2.png","hash":"f0f1cf1e6328ed7dd2da13e3ef19f0ba3090d50b","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/throttle-model-2.png","hash":"4d06f2204e6a312ad534b08e4aa3a0cc199b0fe4","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/throttle-model-3.png","hash":"9ba30093c88bda5cdf0b74397078c98615ab14e8","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-1.png","hash":"4ecd76529d5af3bab1200944f956550c438d7e4c","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/waiter-model-2.png","hash":"115d73933b2c9e3b333f0173a9c67b40b82b360e","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-1.png","hash":"63d1fb2d7060dc8e20879b271cfc0fae5ba53ce5","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-10.png","hash":"47f4c469384a2ae6ee68920c9c9d056323bc6964","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-3.png","hash":"955761aa1d41f38f58070239091ec7ef56eab433","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-6.png","hash":"c0234e34b71f60317c8532f9b4332297ddbfc3b2","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-2.png","hash":"a05c2d67784dc8a0c9dadb55ff4cb313ff0a4581","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-5.png","hash":"b38b48df97224ac10c391b5231c27b5ff9439d15","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-6.png","hash":"b678a14aa7203ed211d9b03cc517629296d39ccb","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-1.png","hash":"dec3d9b3d1b759d8ab97b596942a57870ea5e899","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-5.png","hash":"f5b38278a65c50724df598782714d46b16198ddb","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-8.png","hash":"ae0f8837c7bf0b7cebcf1b643602ef1b7c91d9b0","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-2.png","hash":"d5b2a749b270b467d4e5ca0442f079ad0d68c0ad","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-3.png","hash":"8caaa1350394bb4924a26779474bd8ffdedfd1a3","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/widget-model-6.png","hash":"17625b96826cacb789210181082942b9d92c9685","modified":1672825520261},{"_id":"public/2022/10/08/37-data-structure5/graph-9.png","hash":"3e0a9c9a2cb3f8145448b3dab7b9066c53f468d2","modified":1672825520261},{"_id":"public/2022/06/22/5-react-render/fiber_tree.png","hash":"947d11b845e1abb74cbb2d4e135767a377692041","modified":1672825520261},{"_id":"public/2022/06/22/6-vue3-render/render_function.png","hash":"ab09e61382c872069a70212525d4333d6ba8cd19","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/work.png","hash":"85878cbf259712eba4a4d960bef9fc8f72361f7d","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/multiple-status.png","hash":"99f1acc2445ec0c692d48660ddbd71b510f1284b","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/safe-model.png","hash":"8ddf098b287fc1582ef3c57f6641b8cdfe529ee0","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/simple-factory1.png","hash":"7a9ab5660cbd92e1e0f851985402404fb0f49814","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/test-prototype-inherit.png","hash":"ffe8e406495b76ed7e8fa5fa95247335f0842bd8","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/basic-model.png","hash":"d11299e00239d8eee68fa84742cf934d7b2b7455","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/cache-model.png","hash":"849dac393027d49c7932b80aeacdeb6dc665ad8d","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/command-model-1.png","hash":"e8f27f13a8b8964e1f98cf90c9d11336745ce4cd","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/explain-model-1.png","hash":"b41f3ee9472b65e45fd3699586fe343b90801e1c","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/explain-model-3.png","hash":"7090631280b778e1a081cf14ee1aef4eaddf2724","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/inherit-model.png","hash":"c458570cfbf5cb544f160dbf7f5ea2688eb54cfe","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/inherit-as-basic-model.png","hash":"04bcb6c49805f61c210a276673688925342a97a2","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/mediator-model.png","hash":"037a378a4fd6a9b68621c714239390a175768283","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/price-strategy.png","hash":"8c9b4bc9e46d85dbd5ff1db682f35d7727ac2d24","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/regist-message.png","hash":"94993ad78c5391eb4cc60f851d1bf5de794d680a","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/visitor-model.png","hash":"b47054fdf9198975a39ebfc6b4ea46cb988dc080","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/chain-model-3.png","hash":"de232baf72880e1c2bfca1e52ca3dece90b30922","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-3.png","hash":"0dd09a8620412a0a10e0749a2eae5b990e14131f","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-5.png","hash":"f60b1b8098b39c8d16bef6ce21e93f80eed6a06d","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/localstorage-model-6.png","hash":"af1bc9d6bd7aa6c6582b3b498aaace38b3beb7d0","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/participate-model-6.png","hash":"a27676bb25d07081323b4801ff167a2f9c830583","modified":1672825520261},{"_id":"public/2022/09/19/27-about-design-model4/throttle-model-1.png","hash":"efe9c32037c01c30eef7c906b1477675a4b22296","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-3.png","hash":"972a431f1b9f113e9c28acd09c21965abf3ae776","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-4.png","hash":"0caa8c2b2efef085bf73708c696b163b27cf4acd","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-5.png","hash":"7d00695f69933f1493a5b215459372aa8922aa90","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-2.png","hash":"c793bb154006138580dfe636e8e96f48af31c136","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-6.png","hash":"ebaf47a4d6e618ed357e3ef105bf1a78aac86dcd","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-7.png","hash":"c12235fa4218a1f12d5f04de3c292d9d8a1cc606","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-8.png","hash":"acc5e67aafb4ec4d3a10ca9507832f965d05bb86","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/appendix-9.png","hash":"5128c7e89b6784e2e75e7f74154a3a2a36859a4a","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/module-model-4.png","hash":"0591ff679bd8b40d96b399c2df5db22e5d6857f1","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvc-model-2.png","hash":"2ad2eeb884aac27d63ceb815d119f4bdab3b28bf","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-6.png","hash":"7d62d18ec951b6be1b53157c9380618cb8f65cc2","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvvm-model-4.png","hash":"362b306d44bd195ca4adee181dabcbbb524da1ac","modified":1672825520261},{"_id":"public/2022/09/04/24-about-design-model1/prototype-model.png","hash":"7e1b5e0841203ae571b20c1c21fc40fb6589f946","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/combination-inherit.png","hash":"51a2c5f4775a37e5f2a21ab257749912178476c3","modified":1672825520261},{"_id":"public/2022/09/07/26-about-design-model3/iterator-model.png","hash":"b372e782497790afdac5ef90a53eb4ecd88bc18f","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/async-module-model-1.png","hash":"f465cd97d9c16ecea67b0d0f8ee7d3bb6ebb545c","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/module-model-1.png","hash":"940ec1732a0d822780c486ccb9ffc6cc29119a6f","modified":1672825520261},{"_id":"public/2022/09/20/28-about-design-model5/mvp-model-3.png","hash":"f3ebcf32efc3e9b536605c9df96654c81cfc9b82","modified":1672825520261},{"_id":"public/2022/08/20/23-about-design-model/constructor-inherit.png","hash":"e1eb49fe9cd4796f60678113b6f865f2e1576464","modified":1672825520261},{"_id":"public/2022/06/22/6-vue3-render/vue3_render.png","hash":"c27773553432184cba670aac70e69865c21a4727","modified":1672825520261}],"Category":[],"Data":[],"Page":[{"_content":"#### This is Sun Jinkang＇s page.\n\n* [Post文章](/archives/)\n* [vue相关](/vue/)\n* [Nodejs相关](/nodejs/)\n\n\n[常用官网地址](/2022/07/05/13-document-location/)","source":"index.md","raw":"#### This is Sun Jinkang＇s page.\n\n* [Post文章](/archives/)\n* [vue相关](/vue/)\n* [Nodejs相关](/nodejs/)\n\n\n[常用官网地址](/2022/07/05/13-document-location/)","date":"2022-11-01T03:12:11.961Z","updated":"2022-11-01T03:12:11.961Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"clchh4gw80000ckttea1i5dsz","content":"<h4 id=\"This-is-Sun-Jinkang＇s-page\"><a href=\"#This-is-Sun-Jinkang＇s-page\" class=\"headerlink\" title=\"This is Sun Jinkang＇s page.\"></a>This is Sun Jinkang＇s page.</h4><ul>\n<li><a href=\"/archives/\">Post文章</a></li>\n<li><a href=\"/vue/\">vue相关</a></li>\n<li><a href=\"/nodejs/\">Nodejs相关</a></li>\n</ul>\n<p><a href=\"/2022/07/05/13-document-location/\">常用官网地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"This-is-Sun-Jinkang＇s-page\"><a href=\"#This-is-Sun-Jinkang＇s-page\" class=\"headerlink\" title=\"This is Sun Jinkang＇s page.\"></a>This is Sun Jinkang＇s page.</h4><ul>\n<li><a href=\"/archives/\">Post文章</a></li>\n<li><a href=\"/vue/\">vue相关</a></li>\n<li><a href=\"/nodejs/\">Nodejs相关</a></li>\n</ul>\n<p><a href=\"/2022/07/05/13-document-location/\">常用官网地址</a></p>\n"},{"title":"2.x迁移到3.x变更点","date":"2022-01-25T06:17:57.000Z","_content":"### 生命周期变更\n| 选项式 API | Hook inside setup |\n| :------: | :------: |\n| beforeCreate | Not needed* |\n| created | Not needed* |\n| beforeMount | onBeforeMount |\n| mounted | onMounted |\n| beforeUpdate | onBeforeUpdate |\n| updated | onUpdated |\n| beforeUnmount | onBeforeUnmount |\n| unmounted | onUnmounted |\n| errorCaptured | onErrorCaptured |\n| renderTracked | onRenderTracked |\n| renderTriggered | onRenderTriggered |\n| activated | onActivated |\n| deactivated | onDeactivated |\n\n### vue3允许组件有多个根节点\n\n### 移除过滤器\n过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器\n\n### template应用挂载变更\n在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。\n在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML\n\n### 过渡的 class 名更改\n过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from\n\n### <transition> 组件的相关 prop 名称变化\nleave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)\nenter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)\n\n### Transition Group 根元素\n<transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag='span' 即可\n\n### 移除v-on.native修饰符\nv-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。\n\n### v-if 与 v-for 的优先级变更\n| vue2 | vue3 |\n| :--- | :--- |\n| 在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用 | v-if 总是优先于 v-for 生效 |\n\n### v-bind 合并行为\n| vue2 | vue3 |\n| :--- | :--- |\n| 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后） | 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前） |\n\n### VNode 生命周期事件\n| vue2 | vue3 |\n| :--- | :--- |\n| 事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字 | 以 vnode- 前缀开头，事件也可用于 HTML 元素 |\n\n举例：vnode- 前缀：@vnode-updated=\"onUpdated\"；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=\"onUpdated\"；\n生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。\n\n[从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)](https://v3.cn.vuejs.org/guide/migration/introduction.html)\n","source":"vue/change.md","raw":"---\ntitle: 2.x迁移到3.x变更点\ndate: 2022-01-25 14:17:57\n---\n### 生命周期变更\n| 选项式 API | Hook inside setup |\n| :------: | :------: |\n| beforeCreate | Not needed* |\n| created | Not needed* |\n| beforeMount | onBeforeMount |\n| mounted | onMounted |\n| beforeUpdate | onBeforeUpdate |\n| updated | onUpdated |\n| beforeUnmount | onBeforeUnmount |\n| unmounted | onUnmounted |\n| errorCaptured | onErrorCaptured |\n| renderTracked | onRenderTracked |\n| renderTriggered | onRenderTriggered |\n| activated | onActivated |\n| deactivated | onDeactivated |\n\n### vue3允许组件有多个根节点\n\n### 移除过滤器\n过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器\n\n### template应用挂载变更\n在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。\n在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML\n\n### 过渡的 class 名更改\n过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from\n\n### <transition> 组件的相关 prop 名称变化\nleave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)\nenter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)\n\n### Transition Group 根元素\n<transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag='span' 即可\n\n### 移除v-on.native修饰符\nv-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。\n\n### v-if 与 v-for 的优先级变更\n| vue2 | vue3 |\n| :--- | :--- |\n| 在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用 | v-if 总是优先于 v-for 生效 |\n\n### v-bind 合并行为\n| vue2 | vue3 |\n| :--- | :--- |\n| 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后） | 如果一个元素同时定义了 v-bind=\"object\" 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前） |\n\n### VNode 生命周期事件\n| vue2 | vue3 |\n| :--- | :--- |\n| 事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字 | 以 vnode- 前缀开头，事件也可用于 HTML 元素 |\n\n举例：vnode- 前缀：@vnode-updated=\"onUpdated\"；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=\"onUpdated\"；\n生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。\n\n[从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)](https://v3.cn.vuejs.org/guide/migration/introduction.html)\n","updated":"2022-01-25T10:10:54.040Z","path":"vue/change.html","comments":1,"layout":"page","_id":"clchh4gwf0002cktt6iwgbif6","content":"<h3 id=\"生命周期变更\"><a href=\"#生命周期变更\" class=\"headerlink\" title=\"生命周期变更\"></a>生命周期变更</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选项式 API</th>\n<th align=\"center\">Hook inside setup</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">beforeCreate</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">created</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">beforeMount</td>\n<td align=\"center\">onBeforeMount</td>\n</tr>\n<tr>\n<td align=\"center\">mounted</td>\n<td align=\"center\">onMounted</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUpdate</td>\n<td align=\"center\">onBeforeUpdate</td>\n</tr>\n<tr>\n<td align=\"center\">updated</td>\n<td align=\"center\">onUpdated</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUnmount</td>\n<td align=\"center\">onBeforeUnmount</td>\n</tr>\n<tr>\n<td align=\"center\">unmounted</td>\n<td align=\"center\">onUnmounted</td>\n</tr>\n<tr>\n<td align=\"center\">errorCaptured</td>\n<td align=\"center\">onErrorCaptured</td>\n</tr>\n<tr>\n<td align=\"center\">renderTracked</td>\n<td align=\"center\">onRenderTracked</td>\n</tr>\n<tr>\n<td align=\"center\">renderTriggered</td>\n<td align=\"center\">onRenderTriggered</td>\n</tr>\n<tr>\n<td align=\"center\">activated</td>\n<td align=\"center\">onActivated</td>\n</tr>\n<tr>\n<td align=\"center\">deactivated</td>\n<td align=\"center\">onDeactivated</td>\n</tr>\n</tbody></table>\n<h3 id=\"vue3允许组件有多个根节点\"><a href=\"#vue3允许组件有多个根节点\" class=\"headerlink\" title=\"vue3允许组件有多个根节点\"></a>vue3允许组件有多个根节点</h3><h3 id=\"移除过滤器\"><a href=\"#移除过滤器\" class=\"headerlink\" title=\"移除过滤器\"></a>移除过滤器</h3><p>过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器</p>\n<h3 id=\"template应用挂载变更\"><a href=\"#template应用挂载变更\" class=\"headerlink\" title=\"template应用挂载变更\"></a>template应用挂载变更</h3><p>在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。<br>在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML</p>\n<h3 id=\"过渡的-class-名更改\"><a href=\"#过渡的-class-名更改\" class=\"headerlink\" title=\"过渡的 class 名更改\"></a>过渡的 class 名更改</h3><p>过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from</p>\n<h3 id=\"组件的相关-prop-名称变化\"><a href=\"#组件的相关-prop-名称变化\" class=\"headerlink\" title=\" 组件的相关 prop 名称变化\"></a><transition> 组件的相关 prop 名称变化</transition></h3><p>leave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)<br>enter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)</p>\n<h3 id=\"Transition-Group-根元素\"><a href=\"#Transition-Group-根元素\" class=\"headerlink\" title=\"Transition Group 根元素\"></a>Transition Group 根元素</h3><p><transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag=’span’ 即可</transition-group></p>\n<h3 id=\"移除v-on-native修饰符\"><a href=\"#移除v-on-native修饰符\" class=\"headerlink\" title=\"移除v-on.native修饰符\"></a>移除v-on.native修饰符</h3><p>v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。</p>\n<h3 id=\"v-if-与-v-for-的优先级变更\"><a href=\"#v-if-与-v-for-的优先级变更\" class=\"headerlink\" title=\"v-if 与 v-for 的优先级变更\"></a>v-if 与 v-for 的优先级变更</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用</td>\n<td align=\"left\">v-if 总是优先于 v-for 生效</td>\n</tr>\n</tbody></table>\n<h3 id=\"v-bind-合并行为\"><a href=\"#v-bind-合并行为\" class=\"headerlink\" title=\"v-bind 合并行为\"></a>v-bind 合并行为</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后）</td>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前）</td>\n</tr>\n</tbody></table>\n<h3 id=\"VNode-生命周期事件\"><a href=\"#VNode-生命周期事件\" class=\"headerlink\" title=\"VNode 生命周期事件\"></a>VNode 生命周期事件</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字</td>\n<td align=\"left\">以 vnode- 前缀开头，事件也可用于 HTML 元素</td>\n</tr>\n</tbody></table>\n<p>举例：vnode- 前缀：@vnode-updated=”onUpdated”；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=”onUpdated”；<br>生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。</p>\n<p><a href=\"https://v3.cn.vuejs.org/guide/migration/introduction.html\">从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"生命周期变更\"><a href=\"#生命周期变更\" class=\"headerlink\" title=\"生命周期变更\"></a>生命周期变更</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选项式 API</th>\n<th align=\"center\">Hook inside setup</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">beforeCreate</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">created</td>\n<td align=\"center\">Not needed*</td>\n</tr>\n<tr>\n<td align=\"center\">beforeMount</td>\n<td align=\"center\">onBeforeMount</td>\n</tr>\n<tr>\n<td align=\"center\">mounted</td>\n<td align=\"center\">onMounted</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUpdate</td>\n<td align=\"center\">onBeforeUpdate</td>\n</tr>\n<tr>\n<td align=\"center\">updated</td>\n<td align=\"center\">onUpdated</td>\n</tr>\n<tr>\n<td align=\"center\">beforeUnmount</td>\n<td align=\"center\">onBeforeUnmount</td>\n</tr>\n<tr>\n<td align=\"center\">unmounted</td>\n<td align=\"center\">onUnmounted</td>\n</tr>\n<tr>\n<td align=\"center\">errorCaptured</td>\n<td align=\"center\">onErrorCaptured</td>\n</tr>\n<tr>\n<td align=\"center\">renderTracked</td>\n<td align=\"center\">onRenderTracked</td>\n</tr>\n<tr>\n<td align=\"center\">renderTriggered</td>\n<td align=\"center\">onRenderTriggered</td>\n</tr>\n<tr>\n<td align=\"center\">activated</td>\n<td align=\"center\">onActivated</td>\n</tr>\n<tr>\n<td align=\"center\">deactivated</td>\n<td align=\"center\">onDeactivated</td>\n</tr>\n</tbody></table>\n<h3 id=\"vue3允许组件有多个根节点\"><a href=\"#vue3允许组件有多个根节点\" class=\"headerlink\" title=\"vue3允许组件有多个根节点\"></a>vue3允许组件有多个根节点</h3><h3 id=\"移除过滤器\"><a href=\"#移除过滤器\" class=\"headerlink\" title=\"移除过滤器\"></a>移除过滤器</h3><p>过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器</p>\n<h3 id=\"template应用挂载变更\"><a href=\"#template应用挂载变更\" class=\"headerlink\" title=\"template应用挂载变更\"></a>template应用挂载变更</h3><p>在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。<br>在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML</p>\n<h3 id=\"过渡的-class-名更改\"><a href=\"#过渡的-class-名更改\" class=\"headerlink\" title=\"过渡的 class 名更改\"></a>过渡的 class 名更改</h3><p>过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from</p>\n<h3 id=\"组件的相关-prop-名称变化\"><a href=\"#组件的相关-prop-名称变化\" class=\"headerlink\" title=\" 组件的相关 prop 名称变化\"></a><transition> 组件的相关 prop 名称变化</transition></h3><p>leave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)<br>enter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass)</p>\n<h3 id=\"Transition-Group-根元素\"><a href=\"#Transition-Group-根元素\" class=\"headerlink\" title=\"Transition Group 根元素\"></a>Transition Group 根元素</h3><p><transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag=’span’ 即可</transition-group></p>\n<h3 id=\"移除v-on-native修饰符\"><a href=\"#移除v-on-native修饰符\" class=\"headerlink\" title=\"移除v-on.native修饰符\"></a>移除v-on.native修饰符</h3><p>v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。</p>\n<h3 id=\"v-if-与-v-for-的优先级变更\"><a href=\"#v-if-与-v-for-的优先级变更\" class=\"headerlink\" title=\"v-if 与 v-for 的优先级变更\"></a>v-if 与 v-for 的优先级变更</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用</td>\n<td align=\"left\">v-if 总是优先于 v-for 生效</td>\n</tr>\n</tbody></table>\n<h3 id=\"v-bind-合并行为\"><a href=\"#v-bind-合并行为\" class=\"headerlink\" title=\"v-bind 合并行为\"></a>v-bind 合并行为</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后）</td>\n<td align=\"left\">如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前）</td>\n</tr>\n</tbody></table>\n<h3 id=\"VNode-生命周期事件\"><a href=\"#VNode-生命周期事件\" class=\"headerlink\" title=\"VNode 生命周期事件\"></a>VNode 生命周期事件</h3><table>\n<thead>\n<tr>\n<th align=\"left\">vue2</th>\n<th align=\"left\">vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字</td>\n<td align=\"left\">以 vnode- 前缀开头，事件也可用于 HTML 元素</td>\n</tr>\n</tbody></table>\n<p>举例：vnode- 前缀：@vnode-updated=”onUpdated”；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=”onUpdated”；<br>生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。</p>\n<p><a href=\"https://v3.cn.vuejs.org/guide/migration/introduction.html\">从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)</a></p>\n"},{"title":"3.x生态环境","date":"2022-01-25T09:02:52.000Z","_content":"#### [Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！](https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75)\n[基于 Vite 的极速构建工具链](https://vitejs.dev/)\n\n`<script setup>` 带来的开发体验更丝滑的组合式 API 语法\n\n[Volar 提供的单文件组件 TypeScript IDE 支持](https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar)\n\n[vue-tsc 提供的针对单文件组件的命令行类型检查和生成](https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc)\n\n[Pinia 提供的更简洁的状态管理](https://pinia.vuejs.org/) / [Vuex4](https://next.vuex.vuejs.org/)\n\n[新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板](https://devtools.vuejs.org/plugin/plugins-guide.html)\n\n[vuejs/core](https://github.com/vuejs/core)\n\n[Vue Router 4.0](https://next.router.vuejs.org/)\n[代码地址](https://github.com/vuejs/router)\n\n[vuejs/docs](https://github.com/vuejs/docs)\n\n[vuejs/test-utils](https://github.com/vuejs/test-utils)\n\n[vuejs/babel-plugin-jsx](https://github.com/vuejs/babel-plugin-jsx)\n\n[Element Plus(稳定版本预计于2022/02/07发布)](https://element-plus.gitee.io/zh-CN/)\n\n[Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)](https://next.antdv.com/)\n\n其他Vue UI框架：[Vuetify](https://vuetifyjs.com/zh-Hans/)、[Quasar](https://quasar.dev/)\n\n[全新的文档(目前只能预览)](https://staging.vuejs.org/)（[中文翻译中](https://staging-cn.vuejs.org/)）","source":"vue/dependency.md","raw":"---\ntitle: 3.x生态环境\ndate: 2022-01-25 17:02:52\n---\n#### [Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！](https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75)\n[基于 Vite 的极速构建工具链](https://vitejs.dev/)\n\n`<script setup>` 带来的开发体验更丝滑的组合式 API 语法\n\n[Volar 提供的单文件组件 TypeScript IDE 支持](https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar)\n\n[vue-tsc 提供的针对单文件组件的命令行类型检查和生成](https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc)\n\n[Pinia 提供的更简洁的状态管理](https://pinia.vuejs.org/) / [Vuex4](https://next.vuex.vuejs.org/)\n\n[新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板](https://devtools.vuejs.org/plugin/plugins-guide.html)\n\n[vuejs/core](https://github.com/vuejs/core)\n\n[Vue Router 4.0](https://next.router.vuejs.org/)\n[代码地址](https://github.com/vuejs/router)\n\n[vuejs/docs](https://github.com/vuejs/docs)\n\n[vuejs/test-utils](https://github.com/vuejs/test-utils)\n\n[vuejs/babel-plugin-jsx](https://github.com/vuejs/babel-plugin-jsx)\n\n[Element Plus(稳定版本预计于2022/02/07发布)](https://element-plus.gitee.io/zh-CN/)\n\n[Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)](https://next.antdv.com/)\n\n其他Vue UI框架：[Vuetify](https://vuetifyjs.com/zh-Hans/)、[Quasar](https://quasar.dev/)\n\n[全新的文档(目前只能预览)](https://staging.vuejs.org/)（[中文翻译中](https://staging-cn.vuejs.org/)）","updated":"2022-01-25T10:19:40.849Z","path":"vue/dependency.html","comments":1,"layout":"page","_id":"clchh4gwh0004ckttag3h6r9s","content":"<h4 id=\"Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\"><a href=\"#Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\" class=\"headerlink\" title=\"Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！\"></a><a href=\"https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75\">Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！</a></h4><p><a href=\"https://vitejs.dev/\">基于 Vite 的极速构建工具链</a></p>\n<p><code>&lt;script setup&gt;</code> 带来的开发体验更丝滑的组合式 API 语法</p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar\">Volar 提供的单文件组件 TypeScript IDE 支持</a></p>\n<p><a href=\"https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc\">vue-tsc 提供的针对单文件组件的命令行类型检查和生成</a></p>\n<p><a href=\"https://pinia.vuejs.org/\">Pinia 提供的更简洁的状态管理</a> / <a href=\"https://next.vuex.vuejs.org/\">Vuex4</a></p>\n<p><a href=\"https://devtools.vuejs.org/plugin/plugins-guide.html\">新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板</a></p>\n<p><a href=\"https://github.com/vuejs/core\">vuejs/core</a></p>\n<p><a href=\"https://next.router.vuejs.org/\">Vue Router 4.0</a><br><a href=\"https://github.com/vuejs/router\">代码地址</a></p>\n<p><a href=\"https://github.com/vuejs/docs\">vuejs/docs</a></p>\n<p><a href=\"https://github.com/vuejs/test-utils\">vuejs/test-utils</a></p>\n<p><a href=\"https://github.com/vuejs/babel-plugin-jsx\">vuejs/babel-plugin-jsx</a></p>\n<p><a href=\"https://element-plus.gitee.io/zh-CN/\">Element Plus(稳定版本预计于2022/02/07发布)</a></p>\n<p><a href=\"https://next.antdv.com/\">Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)</a></p>\n<p>其他Vue UI框架：<a href=\"https://vuetifyjs.com/zh-Hans/\">Vuetify</a>、<a href=\"https://quasar.dev/\">Quasar</a></p>\n<p><a href=\"https://staging.vuejs.org/\">全新的文档(目前只能预览)</a>（<a href=\"https://staging-cn.vuejs.org/\">中文翻译中</a>）</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\"><a href=\"#Vue-3-将在-2022-年-2-月-7-日成为新的默认版本！\" class=\"headerlink\" title=\"Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！\"></a><a href=\"https://gist.github.com/yyx990803/bf9a625eeff8b471bf0701afb8e3fe75\">Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！</a></h4><p><a href=\"https://vitejs.dev/\">基于 Vite 的极速构建工具链</a></p>\n<p><code>&lt;script setup&gt;</code> 带来的开发体验更丝滑的组合式 API 语法</p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=johnsoncodehk.volar\">Volar 提供的单文件组件 TypeScript IDE 支持</a></p>\n<p><a href=\"https://github.com/johnsoncodehk/volar/tree/master/packages/vue-tsc\">vue-tsc 提供的针对单文件组件的命令行类型检查和生成</a></p>\n<p><a href=\"https://pinia.vuejs.org/\">Pinia 提供的更简洁的状态管理</a> / <a href=\"https://next.vuex.vuejs.org/\">Vuex4</a></p>\n<p><a href=\"https://devtools.vuejs.org/plugin/plugins-guide.html\">新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板</a></p>\n<p><a href=\"https://github.com/vuejs/core\">vuejs/core</a></p>\n<p><a href=\"https://next.router.vuejs.org/\">Vue Router 4.0</a><br><a href=\"https://github.com/vuejs/router\">代码地址</a></p>\n<p><a href=\"https://github.com/vuejs/docs\">vuejs/docs</a></p>\n<p><a href=\"https://github.com/vuejs/test-utils\">vuejs/test-utils</a></p>\n<p><a href=\"https://github.com/vuejs/babel-plugin-jsx\">vuejs/babel-plugin-jsx</a></p>\n<p><a href=\"https://element-plus.gitee.io/zh-CN/\">Element Plus(稳定版本预计于2022/02/07发布)</a></p>\n<p><a href=\"https://next.antdv.com/\">Ant Design Vue(从v2开始支持vue3，v3目前为beta版本)</a></p>\n<p>其他Vue UI框架：<a href=\"https://vuetifyjs.com/zh-Hans/\">Vuetify</a>、<a href=\"https://quasar.dev/\">Quasar</a></p>\n<p><a href=\"https://staging.vuejs.org/\">全新的文档(目前只能预览)</a>（<a href=\"https://staging-cn.vuejs.org/\">中文翻译中</a>）</p>\n"},{"title":"commonweal","date":"2022-08-09T05:51:41.000Z","_content":"\n### 找不到对应页面，请确认是否存在页面！！！","source":"commonweal/index.md","raw":"---\ntitle: commonweal\ndate: 2022-08-09 13:51:41\n---\n\n### 找不到对应页面，请确认是否存在页面！！！","updated":"2022-08-09T05:56:07.905Z","path":"commonweal/index.html","comments":1,"layout":"page","_id":"clchh4gwj0006ckttddkicep1","content":"<h3 id=\"找不到对应页面，请确认是否存在页面！！！\"><a href=\"#找不到对应页面，请确认是否存在页面！！！\" class=\"headerlink\" title=\"找不到对应页面，请确认是否存在页面！！！\"></a>找不到对应页面，请确认是否存在页面！！！</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"找不到对应页面，请确认是否存在页面！！！\"><a href=\"#找不到对应页面，请确认是否存在页面！！！\" class=\"headerlink\" title=\"找不到对应页面，请确认是否存在页面！！！\"></a>找不到对应页面，请确认是否存在页面！！！</h3>"},{"title":"vue","date":"2022-01-07T09:11:56.000Z","_content":"## VUE 2\n\n### 本部分用于记录vue2相关的文章地址\n暂无\n\n## VUE 3\n\n### 本部分用于记录vue3相关的文章地址\n[2.x迁移到3.x变更点](/vue/change.html)\n[vue3.x生态环境](/vue/dependency.html)","source":"vue/index.md","raw":"---\ntitle: vue\ndate: 2022-01-07 17:11:56\n---\n## VUE 2\n\n### 本部分用于记录vue2相关的文章地址\n暂无\n\n## VUE 3\n\n### 本部分用于记录vue3相关的文章地址\n[2.x迁移到3.x变更点](/vue/change.html)\n[vue3.x生态环境](/vue/dependency.html)","updated":"2022-01-25T10:28:34.167Z","path":"vue/index.html","comments":1,"layout":"page","_id":"clchh4gwk0008cktt6e3l0vby","content":"<h2 id=\"VUE-2\"><a href=\"#VUE-2\" class=\"headerlink\" title=\"VUE 2\"></a>VUE 2</h2><h3 id=\"本部分用于记录vue2相关的文章地址\"><a href=\"#本部分用于记录vue2相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue2相关的文章地址\"></a>本部分用于记录vue2相关的文章地址</h3><p>暂无</p>\n<h2 id=\"VUE-3\"><a href=\"#VUE-3\" class=\"headerlink\" title=\"VUE 3\"></a>VUE 3</h2><h3 id=\"本部分用于记录vue3相关的文章地址\"><a href=\"#本部分用于记录vue3相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue3相关的文章地址\"></a>本部分用于记录vue3相关的文章地址</h3><p><a href=\"/vue/change.html\">2.x迁移到3.x变更点</a><br><a href=\"/vue/dependency.html\">vue3.x生态环境</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"VUE-2\"><a href=\"#VUE-2\" class=\"headerlink\" title=\"VUE 2\"></a>VUE 2</h2><h3 id=\"本部分用于记录vue2相关的文章地址\"><a href=\"#本部分用于记录vue2相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue2相关的文章地址\"></a>本部分用于记录vue2相关的文章地址</h3><p>暂无</p>\n<h2 id=\"VUE-3\"><a href=\"#VUE-3\" class=\"headerlink\" title=\"VUE 3\"></a>VUE 3</h2><h3 id=\"本部分用于记录vue3相关的文章地址\"><a href=\"#本部分用于记录vue3相关的文章地址\" class=\"headerlink\" title=\"本部分用于记录vue3相关的文章地址\"></a>本部分用于记录vue3相关的文章地址</h3><p><a href=\"/vue/change.html\">2.x迁移到3.x变更点</a><br><a href=\"/vue/dependency.html\">vue3.x生态环境</a></p>\n"},{"title":"nodejs基础知识 & 深入浅出nodejs阅读笔记(1)","date":"2022-10-19T11:12:12.000Z","tags":["node","docs"],"_content":"\n###### nodejs是什么\n脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。\n\n每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。\n\n###### nodejs的安装\n官网地址：https://nodejs.org/en/\n\n直接从官网下载nodejs安装包，使用默认安装即可\n安装完成后打开dos，输入 *node -v*，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下\n\n**注意**\n1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）\n2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置\n3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 *npm -v*，查看npm版本\n\n根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发\n\n**nodejs官网地址：https://nodejs.org/zh-cn/docs/**\n**nodejs中文文档地址：https://www.nodeapp.cn/documentation.html**\n\n###### node的特点\n(1)异步I/O\n![异步调用](./images/async-call.png)\n在Node中，绝大多数的操作都以异步的方式进行调用\n(2)事件与回调函数\n(3)单线程\n在Node中，JavaScript与其余线程是无法共享任何状态的。\n单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。\n*单线程弱点*\n- 无法利用多核CPU\n- 错误会引起整个应用退出，应用的健壮性值得考验\n- 大量计算占用CPU导致无法继续调用异步I/O\n\nnode使用子进程的方式解决以上问题\n(4)跨平台\nNode基于libuv实现跨平台\n![跨平台](./images/cross-platform.png)\n\n###### Node 的应用场景\n(1)I/O密集型\nNode面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。\nI/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。\n(2)是否不擅长CPU密集型业务\nnode优秀的运算能力主要来自V8的深度性能优化\n*CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。*\n\nnode充分利用CPU的方式：\n- Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。\n- 如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。\n(3)与遗留系统和平共处\n(4)分布式应用\n\n###### Node 的使用者\n- 前后端编程语言环境统一\n- Node带来的高性能I/O用于实时应用\n- 并行I/O使得使用者可以更高效地利用分布式环境\n- 并行I/O，有效利用稳定接口提升Web渲染能力\n- 云计算平台提供Node支持\n- 游戏开发领域\n- 工具类应用\n\n#### 模块机制\n\n###### CommonJS\nCommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。\n\n过去javascript缺陷：\n- 没有模块系统。\n- 标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。\n- 没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。\n- 缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。\n\n![commonjs与node、浏览器的生态系统](./images/commonjs-node-relation.png)\n\n###### CommonJS的模块规范\n分为模块引用、模块定义和模块标识\n1. 模块引用\n在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中\n\n2. 模块定义\n在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式\n\n3. 模块标识\n模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。\n\n###### Node 的模块实现\n在Node中引入模块，需要经历如下3个步骤。\n(1) 路径分析\n(2) 文件定位\n(3) 编译执行\n\n在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。\n- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的\n- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢\n\n*Node缓存编译和执行之后的对象*\n不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查\n\n*路径分析和文件定位*\n1. 模块标识符分析\n- 核心模块，如http、fs、path等。\n  - 核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。\n  - 如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。\n- .或..开始的相对路径文件模块。\n  - 由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块\n- 以/开始的绝对路径文件模块。\n- 非路径形式的文件模块，如自定义的connect模块。\n  - 自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。\n*模块路径*\n模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组\n模块路径的生成规则：\n- 当前文件目录下的node_modules目录。\n- 父目录下的node_modules目录。\n- 父目录的父目录下的node_modules目录。\n- 沿路径向上逐级递归，直到根目录下的node_modules目录。\n它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。\n2. 文件定位\n- 文件扩展名分析\nrequire()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。\n小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名\n另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。\n- 目录分析和包\n在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。\n在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。\n如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。\n\n*模块编译*\n编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。\n对于不同的文件扩展名，其载入方法也有所不同：\n- .js文件。通过fs模块同步读取文件后编译执行\n- .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件\n- .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果\n- 其余扩展名文件。它们都被当做.js文件载入\n\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能\n\n1. JavaScript模块的编译\n在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});\nexports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值\n如果要达到require引入一个类的效果，请赋值给module.exports对象。\n2. C/C++模块的编译\n.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程\n3. JSON文件的编译\n.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用\n\n###### 核心模块\n(1)JavaScript核心模块的编译过程\n1. 转存为C/C++代码\n2. 编译JavaScript核心模块\n与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置\nJavaScript核心模块，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上\n(2)C/C++核心模块的编译过程\n将那些由纯C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的\n1. 内建模块的组织形式\n每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员\nnode_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有：\n- node_buffer \n- node_crypto \n- node_evals \n- node_fs \n- node_http_parser \n- node_os \n- node_zlib \n- node_timer_wrap \n- node_tcp_wrap \n- node_udp_wrap\n- node_pipe_wrap \n- node_cares_wrap \n- node_tty_wrap \n- node_process_wrap \n- node_fs_event_wrap \n- node_signal_watcher \n内建模块的优势在于：\n- 首先，它们本身由C/C++编写，性能上优于脚本语言；\n- 其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。\n2. 内建模块的导出\n在Node的所有模块类型中，存在着一种依赖层级关系，即文件模块可能会依赖核心模块(javascript)，核心模块可能会依赖内建模块(C/C++)\n通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块\n在加载内建模块时，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出\n(3)核心模块的引入流程\n\n###### C/C++扩展模块\n(1)前提条件\n- GYP项目生成工具\n- V8引擎C++库\n- libuv库\n- Node内部库\n- 其他库\n以.node为扩展名的文件，Node将会调用process.dlopen()方法去加载文件：\n//Native extension for .node \nModule._extensions['.node'] = process.dlopen;\n\nrequire()在引入.node文件的过程中，实际上经历了4个层面上的调用：\n![require调用](./images/node-require.png)\n\n###### 模块调用栈\n- C/C++内建模块\n  - 属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果不是非常了解要调用的C/C++内建模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的\n- JavaScript核心模块\n  - 主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要\n- 文件模块\n  - 通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块\n![node模块](./images/node-modules.png)\n\n#### 包与NPM\n![包](./images/package.png)\n\n###### 包结构\n包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原\n为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。\n- package.json：包描述文件。\n- bin：用于存放可执行二进制文件的目录。\n- lib：用于存放JavaScript代码的目录。\n- doc：用于存放文档的目录。\n- test：用于存放单元测试用例的代码。\n\n###### 包描述文件与NPM\n包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分\nCommonJS为package.json文件定义了如下一些必需的字段。\n- name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。\n- description。包简介。\n- version。版本号。一个语义化的版本号，这在http://semver.org/上有详细定义，通常为major.minor.revision格式。该版本号十分重要，常常用于一些版本控制的场合。\n- keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。 \n- maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。示例如下：\"maintainers\": [{ \"name\": \"Jackson Tian\", \"email\": \"shyvo1987@gmail.com\", \"web\": \"http://html5ify.com\" }], NPM通过该属性进行权限认证\n- contributors。贡献者列表。在开源社区中，为开源项目提供代码是经常出现的事情，如果名字能出现在知名项目的contributors列表中，是一件比较有荣誉感的事。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。\n- bugs。一个可以反馈bug的网页地址或邮件地址。\n- licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。它的格式如下：\"licenses\": [{ \"type\": \"GPLv2\", \"url\": \"http://www.example.com/licenses/gpl.html\", }] \n- repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。\n- dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。 除了必选字段外，规范还定义了一部分可选字段，具体如下所示。\n- homepage。当前包的网站地址。\n- os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。\n- cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。\n- engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。\n- builtin。标志当前包是否是内建在底层系统的标准组件。\n- directories。包目录说明。\n- implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。\n- scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。示例如下：\n\"scripts\": { \"install\": \"install.js\", \n \"uninstall\": \"uninstall.js\", \n \"build\": \"build.js\", \n \"doc\": \"make-doc.js\", \n \"test\": \"test.js\" } \n\n包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies\n与包规范的区别在于多了author、bin、main和devDependencies这4个字段，下面补充说明一下。\n- author。包作者。\n- bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前\n面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。\n- main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。\n- devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包\n\n###### 发布包\n- 编写模块\n- 初始化包描述文件\n  - npm init\n- 注册包仓库账号\n  - npm adduser\n- 上传包\n  - npm publish .\n- 安装包\n  - npm install XXXX\n- 管理包权限\n  - npm owner ls <package name>\n  - npm owner add <user> <package name> \n  - npm owner rm <user> <package name> \n\n包的标准：\n- 具备良好的测试。\n- 具备良好的文档（README、API）。\n- 具备良好的测试覆盖率。\n- 具备良好的编码规范。\n- 更多条件\n\n###### AMD规范\nAMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：\ndefine(id?, dependencies?, factory); \n它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容\nAMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。\n\n###### CMD规范\n与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：\ndefine(['dep1', 'dep2'], function (dep1, dep2) { \n return function () {}; \n}); \n与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义：\ndefine(factory); \n在依赖部分，CMD支持动态引入，示例如下：\ndefine(function(require, exports, module) { \n // The module code goes here \n}); \nrequire、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。\n\n","source":"nodejs/nodejs-note-1.md","raw":"---\ntitle: nodejs基础知识 & 深入浅出nodejs阅读笔记(1)\ndate: 2022-10-19 19:12:12\ntags: [node, docs]\n---\n\n###### nodejs是什么\n脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。\n\n每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。\n\n###### nodejs的安装\n官网地址：https://nodejs.org/en/\n\n直接从官网下载nodejs安装包，使用默认安装即可\n安装完成后打开dos，输入 *node -v*，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下\n\n**注意**\n1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）\n2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置\n3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 *npm -v*，查看npm版本\n\n根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发\n\n**nodejs官网地址：https://nodejs.org/zh-cn/docs/**\n**nodejs中文文档地址：https://www.nodeapp.cn/documentation.html**\n\n###### node的特点\n(1)异步I/O\n![异步调用](./images/async-call.png)\n在Node中，绝大多数的操作都以异步的方式进行调用\n(2)事件与回调函数\n(3)单线程\n在Node中，JavaScript与其余线程是无法共享任何状态的。\n单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。\n*单线程弱点*\n- 无法利用多核CPU\n- 错误会引起整个应用退出，应用的健壮性值得考验\n- 大量计算占用CPU导致无法继续调用异步I/O\n\nnode使用子进程的方式解决以上问题\n(4)跨平台\nNode基于libuv实现跨平台\n![跨平台](./images/cross-platform.png)\n\n###### Node 的应用场景\n(1)I/O密集型\nNode面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。\nI/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。\n(2)是否不擅长CPU密集型业务\nnode优秀的运算能力主要来自V8的深度性能优化\n*CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。*\n\nnode充分利用CPU的方式：\n- Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。\n- 如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。\n(3)与遗留系统和平共处\n(4)分布式应用\n\n###### Node 的使用者\n- 前后端编程语言环境统一\n- Node带来的高性能I/O用于实时应用\n- 并行I/O使得使用者可以更高效地利用分布式环境\n- 并行I/O，有效利用稳定接口提升Web渲染能力\n- 云计算平台提供Node支持\n- 游戏开发领域\n- 工具类应用\n\n#### 模块机制\n\n###### CommonJS\nCommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。\n\n过去javascript缺陷：\n- 没有模块系统。\n- 标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。\n- 没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。\n- 缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。\n\n![commonjs与node、浏览器的生态系统](./images/commonjs-node-relation.png)\n\n###### CommonJS的模块规范\n分为模块引用、模块定义和模块标识\n1. 模块引用\n在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中\n\n2. 模块定义\n在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式\n\n3. 模块标识\n模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。\n\n###### Node 的模块实现\n在Node中引入模块，需要经历如下3个步骤。\n(1) 路径分析\n(2) 文件定位\n(3) 编译执行\n\n在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。\n- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的\n- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢\n\n*Node缓存编译和执行之后的对象*\n不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查\n\n*路径分析和文件定位*\n1. 模块标识符分析\n- 核心模块，如http、fs、path等。\n  - 核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。\n  - 如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。\n- .或..开始的相对路径文件模块。\n  - 由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块\n- 以/开始的绝对路径文件模块。\n- 非路径形式的文件模块，如自定义的connect模块。\n  - 自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。\n*模块路径*\n模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组\n模块路径的生成规则：\n- 当前文件目录下的node_modules目录。\n- 父目录下的node_modules目录。\n- 父目录的父目录下的node_modules目录。\n- 沿路径向上逐级递归，直到根目录下的node_modules目录。\n它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。\n2. 文件定位\n- 文件扩展名分析\nrequire()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。\n小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名\n另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。\n- 目录分析和包\n在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。\n在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。\n如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。\n\n*模块编译*\n编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。\n对于不同的文件扩展名，其载入方法也有所不同：\n- .js文件。通过fs模块同步读取文件后编译执行\n- .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件\n- .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果\n- 其余扩展名文件。它们都被当做.js文件载入\n\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能\n\n1. JavaScript模块的编译\n在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});\nexports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值\n如果要达到require引入一个类的效果，请赋值给module.exports对象。\n2. C/C++模块的编译\n.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程\n3. JSON文件的编译\n.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用\n\n###### 核心模块\n(1)JavaScript核心模块的编译过程\n1. 转存为C/C++代码\n2. 编译JavaScript核心模块\n与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置\nJavaScript核心模块，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上\n(2)C/C++核心模块的编译过程\n将那些由纯C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的\n1. 内建模块的组织形式\n每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员\nnode_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有：\n- node_buffer \n- node_crypto \n- node_evals \n- node_fs \n- node_http_parser \n- node_os \n- node_zlib \n- node_timer_wrap \n- node_tcp_wrap \n- node_udp_wrap\n- node_pipe_wrap \n- node_cares_wrap \n- node_tty_wrap \n- node_process_wrap \n- node_fs_event_wrap \n- node_signal_watcher \n内建模块的优势在于：\n- 首先，它们本身由C/C++编写，性能上优于脚本语言；\n- 其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。\n2. 内建模块的导出\n在Node的所有模块类型中，存在着一种依赖层级关系，即文件模块可能会依赖核心模块(javascript)，核心模块可能会依赖内建模块(C/C++)\n通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块\n在加载内建模块时，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出\n(3)核心模块的引入流程\n\n###### C/C++扩展模块\n(1)前提条件\n- GYP项目生成工具\n- V8引擎C++库\n- libuv库\n- Node内部库\n- 其他库\n以.node为扩展名的文件，Node将会调用process.dlopen()方法去加载文件：\n//Native extension for .node \nModule._extensions['.node'] = process.dlopen;\n\nrequire()在引入.node文件的过程中，实际上经历了4个层面上的调用：\n![require调用](./images/node-require.png)\n\n###### 模块调用栈\n- C/C++内建模块\n  - 属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果不是非常了解要调用的C/C++内建模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的\n- JavaScript核心模块\n  - 主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要\n- 文件模块\n  - 通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块\n![node模块](./images/node-modules.png)\n\n#### 包与NPM\n![包](./images/package.png)\n\n###### 包结构\n包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原\n为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。\n- package.json：包描述文件。\n- bin：用于存放可执行二进制文件的目录。\n- lib：用于存放JavaScript代码的目录。\n- doc：用于存放文档的目录。\n- test：用于存放单元测试用例的代码。\n\n###### 包描述文件与NPM\n包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分\nCommonJS为package.json文件定义了如下一些必需的字段。\n- name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。\n- description。包简介。\n- version。版本号。一个语义化的版本号，这在http://semver.org/上有详细定义，通常为major.minor.revision格式。该版本号十分重要，常常用于一些版本控制的场合。\n- keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。 \n- maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。示例如下：\"maintainers\": [{ \"name\": \"Jackson Tian\", \"email\": \"shyvo1987@gmail.com\", \"web\": \"http://html5ify.com\" }], NPM通过该属性进行权限认证\n- contributors。贡献者列表。在开源社区中，为开源项目提供代码是经常出现的事情，如果名字能出现在知名项目的contributors列表中，是一件比较有荣誉感的事。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。\n- bugs。一个可以反馈bug的网页地址或邮件地址。\n- licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。它的格式如下：\"licenses\": [{ \"type\": \"GPLv2\", \"url\": \"http://www.example.com/licenses/gpl.html\", }] \n- repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。\n- dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。 除了必选字段外，规范还定义了一部分可选字段，具体如下所示。\n- homepage。当前包的网站地址。\n- os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。\n- cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。\n- engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。\n- builtin。标志当前包是否是内建在底层系统的标准组件。\n- directories。包目录说明。\n- implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。\n- scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。示例如下：\n\"scripts\": { \"install\": \"install.js\", \n \"uninstall\": \"uninstall.js\", \n \"build\": \"build.js\", \n \"doc\": \"make-doc.js\", \n \"test\": \"test.js\" } \n\n包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies\n与包规范的区别在于多了author、bin、main和devDependencies这4个字段，下面补充说明一下。\n- author。包作者。\n- bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前\n面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。\n- main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。\n- devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包\n\n###### 发布包\n- 编写模块\n- 初始化包描述文件\n  - npm init\n- 注册包仓库账号\n  - npm adduser\n- 上传包\n  - npm publish .\n- 安装包\n  - npm install XXXX\n- 管理包权限\n  - npm owner ls <package name>\n  - npm owner add <user> <package name> \n  - npm owner rm <user> <package name> \n\n包的标准：\n- 具备良好的测试。\n- 具备良好的文档（README、API）。\n- 具备良好的测试覆盖率。\n- 具备良好的编码规范。\n- 更多条件\n\n###### AMD规范\nAMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：\ndefine(id?, dependencies?, factory); \n它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容\nAMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。\n\n###### CMD规范\n与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：\ndefine(['dep1', 'dep2'], function (dep1, dep2) { \n return function () {}; \n}); \n与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义：\ndefine(factory); \n在依赖部分，CMD支持动态引入，示例如下：\ndefine(function(require, exports, module) { \n // The module code goes here \n}); \nrequire、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。\n\n","updated":"2022-12-20T09:27:11.300Z","path":"nodejs/nodejs-note-1.html","comments":1,"layout":"page","_id":"clchh4gwl000ackttb6rtft56","content":"<h6 id=\"nodejs是什么\"><a href=\"#nodejs是什么\" class=\"headerlink\" title=\"nodejs是什么\"></a>nodejs是什么</h6><p>脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。</p>\n<p>每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。</p>\n<h6 id=\"nodejs的安装\"><a href=\"#nodejs的安装\" class=\"headerlink\" title=\"nodejs的安装\"></a>nodejs的安装</h6><p>官网地址：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n<p>直接从官网下载nodejs安装包，使用默认安装即可<br>安装完成后打开dos，输入 <em>node -v</em>，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下</p>\n<p><strong>注意</strong><br>1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）<br>2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置<br>3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 <em>npm -v</em>，查看npm版本</p>\n<p>根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发</p>\n<p><strong>nodejs官网地址：<a href=\"https://nodejs.org/zh-cn/docs/\">https://nodejs.org/zh-cn/docs/</a></strong><br><strong>nodejs中文文档地址：<a href=\"https://www.nodeapp.cn/documentation.html\">https://www.nodeapp.cn/documentation.html</a></strong></p>\n<h6 id=\"node的特点\"><a href=\"#node的特点\" class=\"headerlink\" title=\"node的特点\"></a>node的特点</h6><p>(1)异步I/O<br><img src=\"/nodejs/images/async-call.png\" alt=\"异步调用\"><br>在Node中，绝大多数的操作都以异步的方式进行调用<br>(2)事件与回调函数<br>(3)单线程<br>在Node中，JavaScript与其余线程是无法共享任何状态的。<br>单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。<br><em>单线程弱点</em></p>\n<ul>\n<li>无法利用多核CPU</li>\n<li>错误会引起整个应用退出，应用的健壮性值得考验</li>\n<li>大量计算占用CPU导致无法继续调用异步I/O</li>\n</ul>\n<p>node使用子进程的方式解决以上问题<br>(4)跨平台<br>Node基于libuv实现跨平台<br><img src=\"/nodejs/images/cross-platform.png\" alt=\"跨平台\"></p>\n<h6 id=\"Node-的应用场景\"><a href=\"#Node-的应用场景\" class=\"headerlink\" title=\"Node 的应用场景\"></a>Node 的应用场景</h6><p>(1)I/O密集型<br>Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。<br>I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。<br>(2)是否不擅长CPU密集型业务<br>node优秀的运算能力主要来自V8的深度性能优化<br><em>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。</em></p>\n<p>node充分利用CPU的方式：</p>\n<ul>\n<li>Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。</li>\n<li>如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。<br>(3)与遗留系统和平共处<br>(4)分布式应用</li>\n</ul>\n<h6 id=\"Node-的使用者\"><a href=\"#Node-的使用者\" class=\"headerlink\" title=\"Node 的使用者\"></a>Node 的使用者</h6><ul>\n<li>前后端编程语言环境统一</li>\n<li>Node带来的高性能I/O用于实时应用</li>\n<li>并行I/O使得使用者可以更高效地利用分布式环境</li>\n<li>并行I/O，有效利用稳定接口提升Web渲染能力</li>\n<li>云计算平台提供Node支持</li>\n<li>游戏开发领域</li>\n<li>工具类应用</li>\n</ul>\n<h4 id=\"模块机制\"><a href=\"#模块机制\" class=\"headerlink\" title=\"模块机制\"></a>模块机制</h4><h6 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h6><p>CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。</p>\n<p>过去javascript缺陷：</p>\n<ul>\n<li>没有模块系统。</li>\n<li>标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。</li>\n<li>没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。</li>\n<li>缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。</li>\n</ul>\n<p><img src=\"/nodejs/images/commonjs-node-relation.png\" alt=\"commonjs与node、浏览器的生态系统\"></p>\n<h6 id=\"CommonJS的模块规范\"><a href=\"#CommonJS的模块规范\" class=\"headerlink\" title=\"CommonJS的模块规范\"></a>CommonJS的模块规范</h6><p>分为模块引用、模块定义和模块标识</p>\n<ol>\n<li><p>模块引用<br>在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中</p>\n</li>\n<li><p>模块定义<br>在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式</p>\n</li>\n<li><p>模块标识<br>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。</p>\n</li>\n</ol>\n<h6 id=\"Node-的模块实现\"><a href=\"#Node-的模块实现\" class=\"headerlink\" title=\"Node 的模块实现\"></a>Node 的模块实现</h6><p>在Node中引入模块，需要经历如下3个步骤。<br>(1) 路径分析<br>(2) 文件定位<br>(3) 编译执行</p>\n<p>在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p>\n<ul>\n<li>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的</li>\n<li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢</li>\n</ul>\n<p><em>Node缓存编译和执行之后的对象</em><br>不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查</p>\n<p><em>路径分析和文件定位</em></p>\n<ol>\n<li>模块标识符分析</li>\n</ol>\n<ul>\n<li>核心模块，如http、fs、path等。<ul>\n<li>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。</li>\n<li>如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。</li>\n</ul>\n</li>\n<li>.或..开始的相对路径文件模块。<ul>\n<li>由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块</li>\n</ul>\n</li>\n<li>以/开始的绝对路径文件模块。</li>\n<li>非路径形式的文件模块，如自定义的connect模块。<ul>\n<li>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</li>\n</ul>\n</li>\n</ul>\n<p><em>模块路径</em><br>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组<br>模块路径的生成规则：</p>\n<ul>\n<li>当前文件目录下的node_modules目录。</li>\n<li>父目录下的node_modules目录。</li>\n<li>父目录的父目录下的node_modules目录。</li>\n<li>沿路径向上逐级递归，直到根目录下的node_modules目录。<br>它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。</li>\n</ul>\n<ol start=\"2\">\n<li>文件定位</li>\n</ol>\n<ul>\n<li>文件扩展名分析<br>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。<br>小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名<br>另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。</li>\n<li>目录分析和包<br>在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。<br>在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。<br>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</li>\n</ul>\n<p><em>模块编译</em><br>编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。<br>对于不同的文件扩展名，其载入方法也有所不同：</p>\n<ul>\n<li>.js文件。通过fs模块同步读取文件后编译执行</li>\n<li>.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件</li>\n<li>.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果</li>\n<li>其余扩展名文件。它们都被当做.js文件载入</li>\n</ul>\n<p>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能</p>\n<ol>\n<li>JavaScript模块的编译<br>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});<br>exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值<br>如果要达到require引入一个类的效果，请赋值给module.exports对象。</li>\n<li>C/C++模块的编译<br>.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程</li>\n<li>JSON文件的编译<br>.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用</li>\n</ol>\n<h6 id=\"核心模块\"><a href=\"#核心模块\" class=\"headerlink\" title=\"核心模块\"></a>核心模块</h6><p>(1)JavaScript核心模块的编译过程</p>\n<ol>\n<li>转存为C/C++代码</li>\n<li>编译JavaScript核心模块<br>与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置<br>JavaScript核心模块，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上<br>(2)C/C++核心模块的编译过程<br>将那些由纯C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的</li>\n<li>内建模块的组织形式<br>每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有：</li>\n</ol>\n<ul>\n<li>node_buffer </li>\n<li>node_crypto </li>\n<li>node_evals </li>\n<li>node_fs </li>\n<li>node_http_parser </li>\n<li>node_os </li>\n<li>node_zlib </li>\n<li>node_timer_wrap </li>\n<li>node_tcp_wrap </li>\n<li>node_udp_wrap</li>\n<li>node_pipe_wrap </li>\n<li>node_cares_wrap </li>\n<li>node_tty_wrap </li>\n<li>node_process_wrap </li>\n<li>node_fs_event_wrap </li>\n<li>node_signal_watcher<br>内建模块的优势在于：</li>\n<li>首先，它们本身由C/C++编写，性能上优于脚本语言；</li>\n<li>其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。</li>\n</ul>\n<ol start=\"2\">\n<li>内建模块的导出<br>在Node的所有模块类型中，存在着一种依赖层级关系，即文件模块可能会依赖核心模块(javascript)，核心模块可能会依赖内建模块(C/C++)<br>通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块<br>在加载内建模块时，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出<br>(3)核心模块的引入流程</li>\n</ol>\n<h6 id=\"C-C-扩展模块\"><a href=\"#C-C-扩展模块\" class=\"headerlink\" title=\"C/C++扩展模块\"></a>C/C++扩展模块</h6><p>(1)前提条件</p>\n<ul>\n<li>GYP项目生成工具</li>\n<li>V8引擎C++库</li>\n<li>libuv库</li>\n<li>Node内部库</li>\n<li>其他库<br>以.node为扩展名的文件，Node将会调用process.dlopen()方法去加载文件：<br>//Native extension for .node<br>Module._extensions[‘.node’] = process.dlopen;</li>\n</ul>\n<p>require()在引入.node文件的过程中，实际上经历了4个层面上的调用：<br><img src=\"/nodejs/images/node-require.png\" alt=\"require调用\"></p>\n<h6 id=\"模块调用栈\"><a href=\"#模块调用栈\" class=\"headerlink\" title=\"模块调用栈\"></a>模块调用栈</h6><ul>\n<li>C/C++内建模块<ul>\n<li>属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果不是非常了解要调用的C/C++内建模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的</li>\n</ul>\n</li>\n<li>JavaScript核心模块<ul>\n<li>主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要</li>\n</ul>\n</li>\n<li>文件模块<ul>\n<li>通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块<br><img src=\"/nodejs/images/node-modules.png\" alt=\"node模块\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"包与NPM\"><a href=\"#包与NPM\" class=\"headerlink\" title=\"包与NPM\"></a>包与NPM</h4><p><img src=\"/nodejs/images/package.png\" alt=\"包\"></p>\n<h6 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h6><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原<br>为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。</p>\n<ul>\n<li>package.json：包描述文件。</li>\n<li>bin：用于存放可执行二进制文件的目录。</li>\n<li>lib：用于存放JavaScript代码的目录。</li>\n<li>doc：用于存放文档的目录。</li>\n<li>test：用于存放单元测试用例的代码。</li>\n</ul>\n<h6 id=\"包描述文件与NPM\"><a href=\"#包描述文件与NPM\" class=\"headerlink\" title=\"包描述文件与NPM\"></a>包描述文件与NPM</h6><p>包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分<br>CommonJS为package.json文件定义了如下一些必需的字段。</p>\n<ul>\n<li>name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。</li>\n<li>description。包简介。</li>\n<li>version。版本号。一个语义化的版本号，这在<a href=\"http://semver.org/%E4%B8%8A%E6%9C%89%E8%AF%A6%E7%BB%86%E5%AE%9A%E4%B9%89%EF%BC%8C%E9%80%9A%E5%B8%B8%E4%B8%BAmajor.minor.revision%E6%A0%BC%E5%BC%8F%E3%80%82%E8%AF%A5%E7%89%88%E6%9C%AC%E5%8F%B7%E5%8D%81%E5%88%86%E9%87%8D%E8%A6%81%EF%BC%8C%E5%B8%B8%E5%B8%B8%E7%94%A8%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%9C%BA%E5%90%88%E3%80%82\">http://semver.org/上有详细定义，通常为major.minor.revision格式。该版本号十分重要，常常用于一些版本控制的场合。</a></li>\n<li>keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。 </li>\n<li>maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。示例如下：”maintainers”: [{ “name”: “Jackson Tian”, “email”: “<a href=\"mailto:&#x73;&#x68;&#x79;&#x76;&#111;&#x31;&#57;&#56;&#55;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;\">&#x73;&#x68;&#x79;&#x76;&#111;&#x31;&#57;&#56;&#55;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a>“, “web”: “<a href=\"http://html5ify.com&quot;/\">http://html5ify.com&quot;</a> }], NPM通过该属性进行权限认证</li>\n<li>contributors。贡献者列表。在开源社区中，为开源项目提供代码是经常出现的事情，如果名字能出现在知名项目的contributors列表中，是一件比较有荣誉感的事。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。</li>\n<li>bugs。一个可以反馈bug的网页地址或邮件地址。</li>\n<li>licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。它的格式如下：”licenses”: [{ “type”: “GPLv2”, “url”: “<a href=\"http://www.example.com/licenses/gpl.html&quot;\">http://www.example.com/licenses/gpl.html&quot;</a>, }] </li>\n<li>repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。</li>\n<li>dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。 除了必选字段外，规范还定义了一部分可选字段，具体如下所示。</li>\n<li>homepage。当前包的网站地址。</li>\n<li>os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。</li>\n<li>cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。</li>\n<li>engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。</li>\n<li>builtin。标志当前包是否是内建在底层系统的标准组件。</li>\n<li>directories。包目录说明。</li>\n<li>implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。</li>\n<li>scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。示例如下：<br>“scripts”: { “install”: “install.js”,<br>“uninstall”: “uninstall.js”,<br>“build”: “build.js”,<br>“doc”: “make-doc.js”,<br>“test”: “test.js” } </li>\n</ul>\n<p>包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies<br>与包规范的区别在于多了author、bin、main和devDependencies这4个字段，下面补充说明一下。</p>\n<ul>\n<li>author。包作者。</li>\n<li>bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前<br>面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。</li>\n<li>main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。</li>\n<li>devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包</li>\n</ul>\n<h6 id=\"发布包\"><a href=\"#发布包\" class=\"headerlink\" title=\"发布包\"></a>发布包</h6><ul>\n<li>编写模块</li>\n<li>初始化包描述文件<ul>\n<li>npm init</li>\n</ul>\n</li>\n<li>注册包仓库账号<ul>\n<li>npm adduser</li>\n</ul>\n</li>\n<li>上传包<ul>\n<li>npm publish .</li>\n</ul>\n</li>\n<li>安装包<ul>\n<li>npm install XXXX</li>\n</ul>\n</li>\n<li>管理包权限<ul>\n<li>npm owner ls <package name></package></li>\n<li>npm owner add <user> <package name> </package></user></li>\n<li>npm owner rm <user> <package name> </package></user></li>\n</ul>\n</li>\n</ul>\n<p>包的标准：</p>\n<ul>\n<li>具备良好的测试。</li>\n<li>具备良好的文档（README、API）。</li>\n<li>具备良好的测试覆盖率。</li>\n<li>具备良好的编码规范。</li>\n<li>更多条件</li>\n</ul>\n<h6 id=\"AMD规范\"><a href=\"#AMD规范\" class=\"headerlink\" title=\"AMD规范\"></a>AMD规范</h6><p>AMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：<br>define(id?, dependencies?, factory);<br>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容<br>AMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。</p>\n<h6 id=\"CMD规范\"><a href=\"#CMD规范\" class=\"headerlink\" title=\"CMD规范\"></a>CMD规范</h6><p>与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：<br>define([‘dep1’, ‘dep2’], function (dep1, dep2) {<br> return function () {};<br>});<br>与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义：<br>define(factory);<br>在依赖部分，CMD支持动态引入，示例如下：<br>define(function(require, exports, module) {<br> // The module code goes here<br>});<br>require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"nodejs是什么\"><a href=\"#nodejs是什么\" class=\"headerlink\" title=\"nodejs是什么\"></a>nodejs是什么</h6><p>脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。</p>\n<p>每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。</p>\n<h6 id=\"nodejs的安装\"><a href=\"#nodejs的安装\" class=\"headerlink\" title=\"nodejs的安装\"></a>nodejs的安装</h6><p>官网地址：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n<p>直接从官网下载nodejs安装包，使用默认安装即可<br>安装完成后打开dos，输入 <em>node -v</em>，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下</p>\n<p><strong>注意</strong><br>1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）<br>2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置<br>3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 <em>npm -v</em>，查看npm版本</p>\n<p>根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发</p>\n<p><strong>nodejs官网地址：<a href=\"https://nodejs.org/zh-cn/docs/\">https://nodejs.org/zh-cn/docs/</a></strong><br><strong>nodejs中文文档地址：<a href=\"https://www.nodeapp.cn/documentation.html\">https://www.nodeapp.cn/documentation.html</a></strong></p>\n<h6 id=\"node的特点\"><a href=\"#node的特点\" class=\"headerlink\" title=\"node的特点\"></a>node的特点</h6><p>(1)异步I/O<br><img src=\"/nodejs/images/async-call.png\" alt=\"异步调用\"><br>在Node中，绝大多数的操作都以异步的方式进行调用<br>(2)事件与回调函数<br>(3)单线程<br>在Node中，JavaScript与其余线程是无法共享任何状态的。<br>单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。<br><em>单线程弱点</em></p>\n<ul>\n<li>无法利用多核CPU</li>\n<li>错误会引起整个应用退出，应用的健壮性值得考验</li>\n<li>大量计算占用CPU导致无法继续调用异步I/O</li>\n</ul>\n<p>node使用子进程的方式解决以上问题<br>(4)跨平台<br>Node基于libuv实现跨平台<br><img src=\"/nodejs/images/cross-platform.png\" alt=\"跨平台\"></p>\n<h6 id=\"Node-的应用场景\"><a href=\"#Node-的应用场景\" class=\"headerlink\" title=\"Node 的应用场景\"></a>Node 的应用场景</h6><p>(1)I/O密集型<br>Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。<br>I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。<br>(2)是否不擅长CPU密集型业务<br>node优秀的运算能力主要来自V8的深度性能优化<br><em>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。</em></p>\n<p>node充分利用CPU的方式：</p>\n<ul>\n<li>Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。</li>\n<li>如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。<br>(3)与遗留系统和平共处<br>(4)分布式应用</li>\n</ul>\n<h6 id=\"Node-的使用者\"><a href=\"#Node-的使用者\" class=\"headerlink\" title=\"Node 的使用者\"></a>Node 的使用者</h6><ul>\n<li>前后端编程语言环境统一</li>\n<li>Node带来的高性能I/O用于实时应用</li>\n<li>并行I/O使得使用者可以更高效地利用分布式环境</li>\n<li>并行I/O，有效利用稳定接口提升Web渲染能力</li>\n<li>云计算平台提供Node支持</li>\n<li>游戏开发领域</li>\n<li>工具类应用</li>\n</ul>\n<h4 id=\"模块机制\"><a href=\"#模块机制\" class=\"headerlink\" title=\"模块机制\"></a>模块机制</h4><h6 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h6><p>CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。</p>\n<p>过去javascript缺陷：</p>\n<ul>\n<li>没有模块系统。</li>\n<li>标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。</li>\n<li>没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。</li>\n<li>缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。</li>\n</ul>\n<p><img src=\"/nodejs/images/commonjs-node-relation.png\" alt=\"commonjs与node、浏览器的生态系统\"></p>\n<h6 id=\"CommonJS的模块规范\"><a href=\"#CommonJS的模块规范\" class=\"headerlink\" title=\"CommonJS的模块规范\"></a>CommonJS的模块规范</h6><p>分为模块引用、模块定义和模块标识</p>\n<ol>\n<li><p>模块引用<br>在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中</p>\n</li>\n<li><p>模块定义<br>在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式</p>\n</li>\n<li><p>模块标识<br>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。</p>\n</li>\n</ol>\n<h6 id=\"Node-的模块实现\"><a href=\"#Node-的模块实现\" class=\"headerlink\" title=\"Node 的模块实现\"></a>Node 的模块实现</h6><p>在Node中引入模块，需要经历如下3个步骤。<br>(1) 路径分析<br>(2) 文件定位<br>(3) 编译执行</p>\n<p>在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p>\n<ul>\n<li>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的</li>\n<li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢</li>\n</ul>\n<p><em>Node缓存编译和执行之后的对象</em><br>不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查</p>\n<p><em>路径分析和文件定位</em></p>\n<ol>\n<li>模块标识符分析</li>\n</ol>\n<ul>\n<li>核心模块，如http、fs、path等。<ul>\n<li>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。</li>\n<li>如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。</li>\n</ul>\n</li>\n<li>.或..开始的相对路径文件模块。<ul>\n<li>由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块</li>\n</ul>\n</li>\n<li>以/开始的绝对路径文件模块。</li>\n<li>非路径形式的文件模块，如自定义的connect模块。<ul>\n<li>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</li>\n</ul>\n</li>\n</ul>\n<p><em>模块路径</em><br>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组<br>模块路径的生成规则：</p>\n<ul>\n<li>当前文件目录下的node_modules目录。</li>\n<li>父目录下的node_modules目录。</li>\n<li>父目录的父目录下的node_modules目录。</li>\n<li>沿路径向上逐级递归，直到根目录下的node_modules目录。<br>它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。</li>\n</ul>\n<ol start=\"2\">\n<li>文件定位</li>\n</ol>\n<ul>\n<li>文件扩展名分析<br>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。<br>小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名<br>另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。</li>\n<li>目录分析和包<br>在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。<br>在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。<br>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</li>\n</ul>\n<p><em>模块编译</em><br>编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。<br>对于不同的文件扩展名，其载入方法也有所不同：</p>\n<ul>\n<li>.js文件。通过fs模块同步读取文件后编译执行</li>\n<li>.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件</li>\n<li>.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果</li>\n<li>其余扩展名文件。它们都被当做.js文件载入</li>\n</ul>\n<p>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能</p>\n<ol>\n<li>JavaScript模块的编译<br>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});<br>exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值<br>如果要达到require引入一个类的效果，请赋值给module.exports对象。</li>\n<li>C/C++模块的编译<br>.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程</li>\n<li>JSON文件的编译<br>.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用</li>\n</ol>\n<h6 id=\"核心模块\"><a href=\"#核心模块\" class=\"headerlink\" title=\"核心模块\"></a>核心模块</h6><p>(1)JavaScript核心模块的编译过程</p>\n<ol>\n<li>转存为C/C++代码</li>\n<li>编译JavaScript核心模块<br>与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置<br>JavaScript核心模块，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上<br>(2)C/C++核心模块的编译过程<br>将那些由纯C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的</li>\n<li>内建模块的组织形式<br>每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有：</li>\n</ol>\n<ul>\n<li>node_buffer </li>\n<li>node_crypto </li>\n<li>node_evals </li>\n<li>node_fs </li>\n<li>node_http_parser </li>\n<li>node_os </li>\n<li>node_zlib </li>\n<li>node_timer_wrap </li>\n<li>node_tcp_wrap </li>\n<li>node_udp_wrap</li>\n<li>node_pipe_wrap </li>\n<li>node_cares_wrap </li>\n<li>node_tty_wrap </li>\n<li>node_process_wrap </li>\n<li>node_fs_event_wrap </li>\n<li>node_signal_watcher<br>内建模块的优势在于：</li>\n<li>首先，它们本身由C/C++编写，性能上优于脚本语言；</li>\n<li>其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。</li>\n</ul>\n<ol start=\"2\">\n<li>内建模块的导出<br>在Node的所有模块类型中，存在着一种依赖层级关系，即文件模块可能会依赖核心模块(javascript)，核心模块可能会依赖内建模块(C/C++)<br>通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块<br>在加载内建模块时，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出<br>(3)核心模块的引入流程</li>\n</ol>\n<h6 id=\"C-C-扩展模块\"><a href=\"#C-C-扩展模块\" class=\"headerlink\" title=\"C/C++扩展模块\"></a>C/C++扩展模块</h6><p>(1)前提条件</p>\n<ul>\n<li>GYP项目生成工具</li>\n<li>V8引擎C++库</li>\n<li>libuv库</li>\n<li>Node内部库</li>\n<li>其他库<br>以.node为扩展名的文件，Node将会调用process.dlopen()方法去加载文件：<br>//Native extension for .node<br>Module._extensions[‘.node’] = process.dlopen;</li>\n</ul>\n<p>require()在引入.node文件的过程中，实际上经历了4个层面上的调用：<br><img src=\"/nodejs/images/node-require.png\" alt=\"require调用\"></p>\n<h6 id=\"模块调用栈\"><a href=\"#模块调用栈\" class=\"headerlink\" title=\"模块调用栈\"></a>模块调用栈</h6><ul>\n<li>C/C++内建模块<ul>\n<li>属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果不是非常了解要调用的C/C++内建模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的</li>\n</ul>\n</li>\n<li>JavaScript核心模块<ul>\n<li>主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要</li>\n</ul>\n</li>\n<li>文件模块<ul>\n<li>通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块<br><img src=\"/nodejs/images/node-modules.png\" alt=\"node模块\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"包与NPM\"><a href=\"#包与NPM\" class=\"headerlink\" title=\"包与NPM\"></a>包与NPM</h4><p><img src=\"/nodejs/images/package.png\" alt=\"包\"></p>\n<h6 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h6><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原<br>为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。</p>\n<ul>\n<li>package.json：包描述文件。</li>\n<li>bin：用于存放可执行二进制文件的目录。</li>\n<li>lib：用于存放JavaScript代码的目录。</li>\n<li>doc：用于存放文档的目录。</li>\n<li>test：用于存放单元测试用例的代码。</li>\n</ul>\n<h6 id=\"包描述文件与NPM\"><a href=\"#包描述文件与NPM\" class=\"headerlink\" title=\"包描述文件与NPM\"></a>包描述文件与NPM</h6><p>包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分<br>CommonJS为package.json文件定义了如下一些必需的字段。</p>\n<ul>\n<li>name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。</li>\n<li>description。包简介。</li>\n<li>version。版本号。一个语义化的版本号，这在<a href=\"http://semver.org/%E4%B8%8A%E6%9C%89%E8%AF%A6%E7%BB%86%E5%AE%9A%E4%B9%89%EF%BC%8C%E9%80%9A%E5%B8%B8%E4%B8%BAmajor.minor.revision%E6%A0%BC%E5%BC%8F%E3%80%82%E8%AF%A5%E7%89%88%E6%9C%AC%E5%8F%B7%E5%8D%81%E5%88%86%E9%87%8D%E8%A6%81%EF%BC%8C%E5%B8%B8%E5%B8%B8%E7%94%A8%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%9C%BA%E5%90%88%E3%80%82\">http://semver.org/上有详细定义，通常为major.minor.revision格式。该版本号十分重要，常常用于一些版本控制的场合。</a></li>\n<li>keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。 </li>\n<li>maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。示例如下：”maintainers”: [{ “name”: “Jackson Tian”, “email”: “<a href=\"mailto:&#x73;&#x68;&#x79;&#x76;&#111;&#x31;&#57;&#56;&#55;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;\">&#x73;&#x68;&#x79;&#x76;&#111;&#x31;&#57;&#56;&#55;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a>“, “web”: “<a href=\"http://html5ify.com&quot;/\">http://html5ify.com&quot;</a> }], NPM通过该属性进行权限认证</li>\n<li>contributors。贡献者列表。在开源社区中，为开源项目提供代码是经常出现的事情，如果名字能出现在知名项目的contributors列表中，是一件比较有荣誉感的事。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。</li>\n<li>bugs。一个可以反馈bug的网页地址或邮件地址。</li>\n<li>licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。它的格式如下：”licenses”: [{ “type”: “GPLv2”, “url”: “<a href=\"http://www.example.com/licenses/gpl.html&quot;\">http://www.example.com/licenses/gpl.html&quot;</a>, }] </li>\n<li>repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。</li>\n<li>dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。 除了必选字段外，规范还定义了一部分可选字段，具体如下所示。</li>\n<li>homepage。当前包的网站地址。</li>\n<li>os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。</li>\n<li>cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。</li>\n<li>engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。</li>\n<li>builtin。标志当前包是否是内建在底层系统的标准组件。</li>\n<li>directories。包目录说明。</li>\n<li>implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。</li>\n<li>scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。示例如下：<br>“scripts”: { “install”: “install.js”,<br>“uninstall”: “uninstall.js”,<br>“build”: “build.js”,<br>“doc”: “make-doc.js”,<br>“test”: “test.js” } </li>\n</ul>\n<p>包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies<br>与包规范的区别在于多了author、bin、main和devDependencies这4个字段，下面补充说明一下。</p>\n<ul>\n<li>author。包作者。</li>\n<li>bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前<br>面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。</li>\n<li>main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。</li>\n<li>devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包</li>\n</ul>\n<h6 id=\"发布包\"><a href=\"#发布包\" class=\"headerlink\" title=\"发布包\"></a>发布包</h6><ul>\n<li>编写模块</li>\n<li>初始化包描述文件<ul>\n<li>npm init</li>\n</ul>\n</li>\n<li>注册包仓库账号<ul>\n<li>npm adduser</li>\n</ul>\n</li>\n<li>上传包<ul>\n<li>npm publish .</li>\n</ul>\n</li>\n<li>安装包<ul>\n<li>npm install XXXX</li>\n</ul>\n</li>\n<li>管理包权限<ul>\n<li>npm owner ls <package name></package></li>\n<li>npm owner add <user> <package name> </package></user></li>\n<li>npm owner rm <user> <package name> </package></user></li>\n</ul>\n</li>\n</ul>\n<p>包的标准：</p>\n<ul>\n<li>具备良好的测试。</li>\n<li>具备良好的文档（README、API）。</li>\n<li>具备良好的测试覆盖率。</li>\n<li>具备良好的编码规范。</li>\n<li>更多条件</li>\n</ul>\n<h6 id=\"AMD规范\"><a href=\"#AMD规范\" class=\"headerlink\" title=\"AMD规范\"></a>AMD规范</h6><p>AMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：<br>define(id?, dependencies?, factory);<br>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容<br>AMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。</p>\n<h6 id=\"CMD规范\"><a href=\"#CMD规范\" class=\"headerlink\" title=\"CMD规范\"></a>CMD规范</h6><p>与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：<br>define([‘dep1’, ‘dep2’], function (dep1, dep2) {<br> return function () {};<br>});<br>与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义：<br>define(factory);<br>在依赖部分，CMD支持动态引入，示例如下：<br>define(function(require, exports, module) {<br> // The module code goes here<br>});<br>require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。</p>\n"},{"title":"nodejs笔记","date":"2022-11-01T03:08:33.000Z","_content":"\n- [nvm安装不同版本node](/nodejs/install-diff-version-node-by-nvm.html)\n- [nodejs笔记1-基础知识 & 深入浅出nodejs阅读笔记-1](/nodejs/nodejs-note-1.html)\n- [nodejs笔记2-深入浅出nodejs阅读笔记-2](/nodejs/nodejs-note-2.html)\n- [nodejs笔记3-深入浅出nodejs阅读笔记-3](/nodejs/nodejs-note-3.html)\n- [nodejs笔记4-深入浅出nodejs阅读笔记-4](/nodejs/nodejs-note-4.html)\n- [nodejs笔记5-深入浅出nodejs阅读笔记-5](/nodejs/nodejs-note-5.html)\n- [nodejs笔记6-assert & asyncHooks](/nodejs/nodejs-note-6.html)\n- [nodejs笔记7-buffer-1](/nodejs/nodejs-note-7.html)\n- [nodejs笔记8-buffer-2](/nodejs/nodejs-note-8.html)\n- [nodejs笔记9-C++ 插件](/nodejs/nodejs-note-9.html)\n- [nodejs笔记10-child_process子进程](/nodejs/nodejs-note-10.html)\n- [nodejs笔记11-cluster集群](/nodejs/nodejs-note-11.html)\n- [nodejs笔记12-命令行选项 & console (控制台)](/nodejs/nodejs-note-12.html)\n- [nodejs笔记13-crypto (加密)](/nodejs/nodejs-note-13.html)\n- [nodejs笔记14](/nodejs/nodejs-note-14.html)\n- [nodejs笔记15](/nodejs/nodejs-note-15.html)","source":"nodejs/index.md","raw":"---\ntitle: nodejs笔记\ndate: 2022-11-01 11:08:33\n---\n\n- [nvm安装不同版本node](/nodejs/install-diff-version-node-by-nvm.html)\n- [nodejs笔记1-基础知识 & 深入浅出nodejs阅读笔记-1](/nodejs/nodejs-note-1.html)\n- [nodejs笔记2-深入浅出nodejs阅读笔记-2](/nodejs/nodejs-note-2.html)\n- [nodejs笔记3-深入浅出nodejs阅读笔记-3](/nodejs/nodejs-note-3.html)\n- [nodejs笔记4-深入浅出nodejs阅读笔记-4](/nodejs/nodejs-note-4.html)\n- [nodejs笔记5-深入浅出nodejs阅读笔记-5](/nodejs/nodejs-note-5.html)\n- [nodejs笔记6-assert & asyncHooks](/nodejs/nodejs-note-6.html)\n- [nodejs笔记7-buffer-1](/nodejs/nodejs-note-7.html)\n- [nodejs笔记8-buffer-2](/nodejs/nodejs-note-8.html)\n- [nodejs笔记9-C++ 插件](/nodejs/nodejs-note-9.html)\n- [nodejs笔记10-child_process子进程](/nodejs/nodejs-note-10.html)\n- [nodejs笔记11-cluster集群](/nodejs/nodejs-note-11.html)\n- [nodejs笔记12-命令行选项 & console (控制台)](/nodejs/nodejs-note-12.html)\n- [nodejs笔记13-crypto (加密)](/nodejs/nodejs-note-13.html)\n- [nodejs笔记14](/nodejs/nodejs-note-14.html)\n- [nodejs笔记15](/nodejs/nodejs-note-15.html)","updated":"2023-01-04T08:12:48.576Z","path":"nodejs/index.html","comments":1,"layout":"page","_id":"clchh4gwm000cckttfu2ffsoy","content":"<ul>\n<li><a href=\"/nodejs/install-diff-version-node-by-nvm.html\">nvm安装不同版本node</a></li>\n<li><a href=\"/nodejs/nodejs-note-1.html\">nodejs笔记1-基础知识 &amp; 深入浅出nodejs阅读笔记-1</a></li>\n<li><a href=\"/nodejs/nodejs-note-2.html\">nodejs笔记2-深入浅出nodejs阅读笔记-2</a></li>\n<li><a href=\"/nodejs/nodejs-note-3.html\">nodejs笔记3-深入浅出nodejs阅读笔记-3</a></li>\n<li><a href=\"/nodejs/nodejs-note-4.html\">nodejs笔记4-深入浅出nodejs阅读笔记-4</a></li>\n<li><a href=\"/nodejs/nodejs-note-5.html\">nodejs笔记5-深入浅出nodejs阅读笔记-5</a></li>\n<li><a href=\"/nodejs/nodejs-note-6.html\">nodejs笔记6-assert &amp; asyncHooks</a></li>\n<li><a href=\"/nodejs/nodejs-note-7.html\">nodejs笔记7-buffer-1</a></li>\n<li><a href=\"/nodejs/nodejs-note-8.html\">nodejs笔记8-buffer-2</a></li>\n<li><a href=\"/nodejs/nodejs-note-9.html\">nodejs笔记9-C++ 插件</a></li>\n<li><a href=\"/nodejs/nodejs-note-10.html\">nodejs笔记10-child_process子进程</a></li>\n<li><a href=\"/nodejs/nodejs-note-11.html\">nodejs笔记11-cluster集群</a></li>\n<li><a href=\"/nodejs/nodejs-note-12.html\">nodejs笔记12-命令行选项 &amp; console (控制台)</a></li>\n<li><a href=\"/nodejs/nodejs-note-13.html\">nodejs笔记13-crypto (加密)</a></li>\n<li><a href=\"/nodejs/nodejs-note-14.html\">nodejs笔记14</a></li>\n<li><a href=\"/nodejs/nodejs-note-15.html\">nodejs笔记15</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"/nodejs/install-diff-version-node-by-nvm.html\">nvm安装不同版本node</a></li>\n<li><a href=\"/nodejs/nodejs-note-1.html\">nodejs笔记1-基础知识 &amp; 深入浅出nodejs阅读笔记-1</a></li>\n<li><a href=\"/nodejs/nodejs-note-2.html\">nodejs笔记2-深入浅出nodejs阅读笔记-2</a></li>\n<li><a href=\"/nodejs/nodejs-note-3.html\">nodejs笔记3-深入浅出nodejs阅读笔记-3</a></li>\n<li><a href=\"/nodejs/nodejs-note-4.html\">nodejs笔记4-深入浅出nodejs阅读笔记-4</a></li>\n<li><a href=\"/nodejs/nodejs-note-5.html\">nodejs笔记5-深入浅出nodejs阅读笔记-5</a></li>\n<li><a href=\"/nodejs/nodejs-note-6.html\">nodejs笔记6-assert &amp; asyncHooks</a></li>\n<li><a href=\"/nodejs/nodejs-note-7.html\">nodejs笔记7-buffer-1</a></li>\n<li><a href=\"/nodejs/nodejs-note-8.html\">nodejs笔记8-buffer-2</a></li>\n<li><a href=\"/nodejs/nodejs-note-9.html\">nodejs笔记9-C++ 插件</a></li>\n<li><a href=\"/nodejs/nodejs-note-10.html\">nodejs笔记10-child_process子进程</a></li>\n<li><a href=\"/nodejs/nodejs-note-11.html\">nodejs笔记11-cluster集群</a></li>\n<li><a href=\"/nodejs/nodejs-note-12.html\">nodejs笔记12-命令行选项 &amp; console (控制台)</a></li>\n<li><a href=\"/nodejs/nodejs-note-13.html\">nodejs笔记13-crypto (加密)</a></li>\n<li><a href=\"/nodejs/nodejs-note-14.html\">nodejs笔记14</a></li>\n<li><a href=\"/nodejs/nodejs-note-15.html\">nodejs笔记15</a></li>\n</ul>\n"},{"title":"nodejs基础知识(3)","date":"2022-12-29T03:32:45.000Z","tags":["node","child_process - 子进程"],"_content":"\nchild_process 模块提供了衍生子进程的功能，它与 [popen(3)](https://man7.org/linux/man-pages/man3/popen.3.html) 类似，但不完全相同。 这个功能主要由 [child_process.spawn()] 函数提供\n```nodejs\nconst { spawn } = require('child_process');\nconst ls = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', (data) => {\n  console.log(`输出：${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.log(`错误：${data}`);\n});\n\nls.on('close', (code) => {\n  console.log(`子进程退出码：${code}`);\n});\n```\n默认情况下，Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。 数据能以非阻塞的方式在管道中流通。 有些程序会在内部使用行缓冲 I/O，虽然这并不影响 Node.js，但发送到子进程的数据可能无法被立即使用。\n\n- [child_process.spawn()] 函数会异步地衍生子进程，且不会阻塞 Node.js 事件循环。 \n- [child_process.spawnSync()] 函数则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或被终止。\n- [child_process.exec()]: 衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。\n- [child_process.execFile()]: 类似 [child_process.exec()]，但直接衍生命令，且无需先衍生 shell。\n- [child_process.fork()]: 衍生一个新的 Node.js 进程，并通过建立 IPC 通讯通道来调用指定的模块，该通道允许父进程与子进程之间相互发送信息。\n- [child_process.execSync()]: [child_process.exec()] 的同步函数，会阻塞 Node.js 事件循环。\n- [child_process.execFileSync()]: [child_process.execFile()] 的同步函数，会阻塞 Node.js 事件循环。\n\n*注：后续函数都是基于 [child_process.spawn()] 或 [child_process.spawnSync()] 实现的。*\n\n**创建异步进程**\n[child_process.spawn()]、[child_process.fork()]、[child_process.exec()] 和 [child_process.execFile()] 函数都遵循 Node.js API 惯用的异步编程模式。\n\n每个函数都返回 [ChildProcess] 实例。 这些实例实现了 Node.js [EventEmitter] API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。\n\n[child_process.exec()] 和 [child_process.execFile()] 函数可以额外指定一个可选的 callback 函数，当子进程结束时会被调用。\n\n**在 Windows 上衍生 .bat 和 .cmd 文件**\n[child_process.exec()] 和 [child_process.execFile()] 之间的区别会因平台而不同。 在类 Unix 操作系统（Unix、 Linux、 macOS）上，[child_process.execFile()] 效率更高，因为它不需要衍生 shell。 但在 Windows 上，.bat 和 .cmd 文件在没有终端的情况下是不可执行的，因此不能使用 [child_process.execFile()] 启动。 可以使用设置了 shell 选项的 [child_process.spawn()]、或使用 [child_process.exec()]、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 [child_process.exec()] 所做的工作）。 如果脚本文件名包含空格，则需要加上引号。\n```\n// 仅限 Windows 系统\nconst { spawn } = require('child_process');\nconst bat = spawn('cmd.exe', ['/c', 'my.bat']);\n\nbat.stdout.on('data', (data) => {\n  console.log(data.toString());\n});\n\nbat.stderr.on('data', (data) => {\n  console.log(data.toString());\n});\n\nbat.on('exit', (code) => {\n  console.log(`子进程退出码：${code}`);\n});\n\n// 或\nconst { exec } = require('child_process');\nexec('my.bat', (err, stdout, stderr) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(stdout);\n});\n\n// 文件名带有空格的脚本：\nconst bat = spawn('\"my script.cmd\"', ['a', 'b'], { shell: true });\n// 或：\nexec('\"my script.cmd\" a b', (err, stdout, stderr) => {\n  // ...\n});\n```\n\n**child_process.exec(command[, options][, callback])**\n- command <string> 运行的命令，参数使用空格分隔。\n- options <Object>\n - cwd <string> 子进程的当前工作目录。\n - env <Object> 环境变量键值对。\n - encoding <string> 默认为 'utf8'。\n - shell <string> 执行命令的 shell。在 UNIX 上默认为 '/bin/sh'，在 Windows 上默认为 process.env.ComSpec。详见Shell的要求与Windows默认的Shell。\n - timeout <number> 默认为 0。\n - maxBuffer <number> stdout 或 stderr 允许的最大字节数。默认为 200*1024。如果超过限制，则子进程会被终止。详见 maxBuffer与Unicode。\n - killSignal <string> | <integer> 默认为 'SIGTERM'。\n - uid <number> 设置进程的用户标识，详见 setuid(2)。\n - gid <number> 设置进程的组标识，详见 setgid(2)。\n - windowsHide <boolean> 隐藏子进程的控制台窗口，常用于 Windows 系统。默认为 false。\n- callback <Function> 进程终止时调用。\n - error <Error>\n - stdout <string> | <Buffer>\n - stderr <string> | <Buffer>\n返回: <ChildProcess>\n\n衍生一个 shell 并在 shell 中执行 command，且缓冲任何产生的输出。 传入函数的 command 字符串会被 shell 直接处理，特殊字符（因shell而异）需要相应处理：\n```\nexec('\"/path/to/test file/test.sh\" arg1 arg2');\n// 使用双引号使路径中的空格不会被理解为多个参数。\n\nexec('echo \"The \\\\$HOME variable is $HOME\"');\n// 第一个 $HOME 会被转义，而第二个不会。\n```\n\n注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。\n```\nconst { exec } = require('child_process');\nexec('cat *.js bad_file | wc -l', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n});\n```\n\n如果提供了一个 callback 函数，则它被调用时会带上参数 (error, stdout, stderr)。 当成功时，error 会是 null。 当失败时，error 会是一个 [Error] 实例。 error.code 属性会是子进程的退出码，error.signal 会被设为终止进程的信号。 除 0 以外的任何退出码都被认为是一个错误。\n\n传给回调的 stdout 和 stderr 参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 encoding 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果 encoding 是 'buffer'、或一个无法识别的字符编码，则传入 Buffer 对象到回调函数。\n\noptions 参数可以作为第二个参数传入，用于自定义如何衍生进程。\n\n如果 timeout 大于 0，当子进程运行超过 timeout 毫秒时，父进程就会发送由 killSignal 属性标识的信号（默认为 'SIGTERM'）。\n\n如果调用该方法的 [util.promisify()][] 版本，将会返回一个包含 stdout 和 stderr 的 Promise 对象。在出现错误的情况下，将返回 rejected 状态的 promise，拥有与回调函数一样的 error 对象，但附加了 stdout 和 stderr 属性。\n```\nconst util = require('util');\nconst exec = util.promisify(require('child_process').exec);\n\nasync function lsExample() {\n  const { stdout, stderr } = await exec('ls');\n  console.log('stdout:', stdout);\n  console.log('stderr:', stderr);\n}\nlsExample();\n```\n\n**child_process.execFile(file[, args][, options][, callback])**\n- file <string> 要运行的可执行文件的名称或路径。\n- args <string[]> 字符串参数列表。\n- options <Object>\n  - cwd <string> 子进程的当前工作目录。\n  - env <Object> 环境变量键值对。\n  - encoding <string> 默认为 'utf8'。\n  - timeout <number> 默认为 0。\n  - maxBuffer <number> stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 \n  - killSignal <string> | <integer> 默认为 'SIGTERM'。\n  - uid <number> 设置该进程的用户标识。（详见 setuid(2)）\n  - gid <number> 设置该进程的组标识。（详见 setgid(2)）\n  - windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。\n  - windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认为: false。\n- callback <Function> 当进程终止时调用，并带上输出。\n  - error <Error>\n  - stdout <string> | <Buffer>\n  - stderr <string> | <Buffer>\n返回: <ChildProcess>\nchild_process.execFile() 函数类似 [child_process.exec()]，除了不衍生一个 shell。 而是，指定的可执行的 file 被直接衍生为一个新进程，这使得它比 [child_process.exec()] 更高效。\n\n它支持和 [child_process.exec()] 一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。\n```\nconst { execFile } = require('child_process');\nconst child = execFile('node', ['--version'], (error, stdout, stderr) => {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n```\n\n**child_process.fork(modulePath[, args][, options])**\n- modulePath <string> 要在子进程中运行的模块。\n- args <Array> 字符串参数列表。\n- options <Object>\n  - cwd <string> 子进程的当前工作目录。\n  - env <Object> 环境变量键值对。\n  - execPath <string> 用来创建子进程的执行路径。\n  - execArgv <Array> 要传给执行路径的字符串参数列表。默认为 process.execArgv。\n  - silent <boolean> 如果为 true，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [child_process.spawn()] 的 [stdio] 中的 'pipe' 和 'inherit' 选项。 默认: false。\n  - stdio <Array> | <string> 详见 [child_process.spawn()] 的 [stdio]。 当提供了该选项，则它会覆盖 silent。 如果使用了数组变量，则该数组必须包含一个值为 'ipc' 的子项，否则会抛出错误。 例如 [0, 1, 2, 'ipc']。\n  - windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略。默认值: false。\n  - uid <number> 设置该进程的用户标识。（详见 setuid(2)）\n  - gid <number> 设置该进程的组标识。（详见 setgid(2)）\n返回: <ChildProcess>\nchild_process.fork() 方法是 [child_process.spawn()] 的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟 [child_process.spawn()] 一样返回一个 [ChildProcess] 对象。 返回的 [ChildProcess] 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见 [subprocess.send()]。\n\n衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。\n\n默认情况下，child_process.fork() 会使用父进程中的 [process.execPath] 衍生新的 Node.js 实例。 options 对象中的 execPath 属性可以替换要使用的执行路径。\n\n使用自定义的 execPath 启动的 Node.js 进程，会使用子进程的环境变量 NODE_CHANNEL_FD 中指定的文件描述符（fd）与父进程通信。\n\n注意，不像 POSIX 系统回调中的 fork(2)，child_process.fork() 不会克隆当前进程。\n\n提示: 在使用child_process.fork() 产生的子进程内，使用 [child_process.spawn()][] 会自动忽略掉其中的shell 配置选项并不会生效。\n\n**child_process.spawn(command[, args][, options])**\n- command <string> 要运行的命令。\n- args <Array> 字符串参数列表。\n- options <Object>\n  - cwd <string> 子进程的当前工作目录。\n  - env <Object> 环境变量键值对。\n  - argv0 <string> 显式地设置要发给子进程的 argv[0] 的值。 如果未指定，则设为 command。\n  - stdio <Array> | <string> 子进程的 stdio 配置。 \n  - detached <boolean> 准备将子进程独立于父进程运行。 具体行为取决于平台。\n  - uid <number> 设置该进程的用户标识。\n  - gid <number> 设置该进程的组标识。\n  - shell <boolean> | <string> 如果为 true，则在一个 shell 中运行 command。 在 UNIX 上使用 '/bin/sh'，在 Windows 上使用 process.env.ComSpec。 一个不同的 shell 可以被指定为字符串。 默认为 false（没有 shell）。\n  - windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认值: false。\n  - windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。\n返回: <ChildProcess>\n\n**child_process.execFileSync(file[, args][, options])**\nchild_process.execFileSync() 方法与 [child_process.execFile()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。\n\n注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。\n\n如果进程超时，或有一个非零的退出码，则该方法会抛出一个 [Error]，这个错误对象包含了底层 [child_process.spawnSync()] 的完整结果。\n\n**child_process.execSync(command[, options])**\nchild_process.execSync() 方法与 [child_process.exec()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。\n\n如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 [Error] 对象会包含从 [child_process.spawnSync()] 返回的整个结果。\n\n注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。\n\n**child_process.spawnSync(command[, args][, options])**\nchild_process.spawnSync() 方法与 [child_process.spawn()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。\n\n注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。\n\n**ChildProcess 类**\nChildProcess 类的实例是 [EventEmitter]，代表衍生的子进程。\n\nChildProcess 的实例不被直接创建。 而是，使用 [child_process.spawn()]、[child_process.exec()]、[child_process.execFile()] 或 [child_process.fork()] 方法创建 ChildProcess 实例。\n\n**'close' 事件**\ncode <number> 如果子进程退出自身，则该值是退出码。\nsignal <string> 子进程被终止时的信号。\n当子进程的 stdio 流被关闭时会触发 'close' 事件。 这与 ['exit'] 事件不同，因为多个进程可能共享同一 stdio 流。\n\n**'disconnect' 事件**\n在父进程中调用 [subprocess.disconnect()] 或在子进程中调用 [process.disconnect()] 后会触发 'disconnect' 事件。 断开后就不能再发送或接收信息，且 [subprocess.connected] 属性会被设为 false。\n\n**'error' 事件**\nerr <Error> 错误对象。\n每当出现以下情况时触发 'error' 事件：\n- 进程无法被衍生；\n- 进程无法被杀死；\n- 向子进程发送信息失败。\n注意，在错误发生后，'exit' 事件可能会也可能不会触发。 当同时监听了 'exit' 和 'error' 事件，谨防处理函数被多次调用。\n详见 [subprocess.kill()] 和 [subprocess.send()]。\n\n**'exit' 事件**\ncode <number> 如果子进程退出自身，则该值是退出码。\nsignal <string> 子进程被终止时的信号。\n子进程结束后会触发 'exit' 事件。 如果进程退出了，则 code 是进程的最终退出码，否则为 null。 \n如果进程是收到的信号而终止的，则 signal 是信号的字符串名称，否则为 null。 \n*这两个总有一个是非空的。*\n\n注意，当 'exit' 事件被触发时，子进程的 stdio 流可能依然是打开的。\n\n另外，还要注意，Node.js 建立了 SIGINT 和 SIGTERM 的信号处理程序，且 Node.js 进程收到这些信号也不会立即终止。 相反，Node.js 会执行一系列的清理操作后重新引发处理信号。\n\n**'message' 事件**\nmessage <Object> 一个已解析的 JSON 对象或原始值。\nsendHandle <Handle> 一个 [net.Socket] 或 [net.Server] 对象 或 undefined。\n当一个子进程使用 [process.send()] 发送消息时会触发 'message' 事件。\n\n注意: 消息通过序列化和解析传递，结果就是消息可能跟开始发送的不完全一样。\n\n**subprocess.channel**\n<Object> 代表子进程的IPC通道的管道。\nsubprocess.channel 属性是当前子进程的 IPC 通道的引用。如果当前没有 IPC 通道，则该属性为 undefined。\n\n**subprocess.connected**\n<boolean> 调用 subprocess.disconnect() 后会被设为 false\nsubprocess.connected 属性表明是否仍可以从一个子进程发送和接收消息。 当 subprocess.connected 为 false 时，则不能再发送或接收的消息。\n\n**subprocess.disconnect()**\n关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。 调用该方法后，父进程和子进程上各自的 subprocess.connected 和 process.connected 属性都会被设为 false，且进程之间不能再传递消息。\n\n当正在接收的进程中没有消息时，就会触发 'disconnect' 事件。 这经常在调用 subprocess.disconnect() 后立即被触发。\n\n注意，当子进程是一个 Node.js 实例时（例如通过 [child_process.fork()] 衍生的），可以在子进程内调用 process.disconnect() 方法来关闭 IPC 通道。\n\n**subprocess.kill([signal])**\nsignal <string>\nsubprocess.kill() 方法向子进程发送一个信号。 如果没有给定参数，则进程会发送 'SIGTERM' 信号。\n```\nconst { spawn } = require('child_process');\nconst grep = spawn('grep', ['ssh']);\n\ngrep.on('close', (code, signal) => {\n  console.log(`子进程收到信号 ${signal} 而终止`);\n});\n\n// 发送 SIGHUP 到进程\ngrep.kill('SIGHUP');\n```\n如果信号没有被送达，[ChildProcess] 对象可能会触发一个 ['error'] 事件。 向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。 特别是，如果进程的 PID 已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。\n\n注意，当函数被调用 kill 时，已发送到子进程的信号可能没有实际终止该进程。\n\n**subprocess.killed**\n<boolean> 当 subprocess.kill() 已成功发送信号给子进程后会被设置为 true。\nsubprocess.killed 属性表明该子进程是否已成功接收到 subprocess.kill() 的信号。 该属性不代表子进程是否已被终止。\n\n**subprocess.pid**\n<number> 整数\n返回子进程的进程标识（PID）。\n\n**subprocess.send(message[, sendHandle[, options]][, callback])**\n当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 [child_process.fork()]），subprocess.send() 方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 [process.on('message')] 事件接收。\n\n注意: 消息通过序列化和解析进行传递，结果就是消息可能跟开始发送的不完全一样。\n\n**subprocess.stderr**\n<stream.Readable>\n一个代表子进程的 stderr 的可读流。\n如果子进程被衍生时 stdio[2] 被设为任何不是 'pipe' 的值，则这会是 null。\nsubprocess.stderr 是 subprocess.stdio[2] 的一个别名。 这两个属性指向相同的值。\n\n**subprocess.stdin**\n<stream.Writable>\n一个代表子进程的 stdin 的可写流。\n注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 end() 关闭。\n如果子进程被衍生时 stdio[0] 被设为任何不是 'pipe' 的值，则这会是 null。\nsubprocess.stdin 是 subprocess.stdio[0] 的一个别名。 这两个属性指向相同的值。\n\n**subprocess.stdio**\n<Array>\n一个到子进程的管道的稀疏数组，对应着传给 [child_process.spawn()] 的选项中值被设为 'pipe' 的 [stdio]。 注意，subprocess.stdio[0]、subprocess.stdio[1] 和 subprocess.stdio[2] 分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr。\n\n**subprocess.stdout**\n<stream.Readable>\n一个代表子进程的 stdout 的可读流。\n如果子进程被衍生时 stdio[1] 被设为任何不是 'pipe' 的值，则这会是 null。\nsubprocess.stdout 是 subprocess.stdio[1] 的一个别名。 这两个属性指向相同的值。\n\n**maxBuffer 与 Unicode**\nmaxBuffer 选项指定了 stdout 或 stderr 上允许的字节数的最大值。 如果超过这个值，则子进程会被终止。 这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。 例如，console.log('中文测试') 会发送 13 个 UTF-8 编码的字节到 stdout，尽管只有 4 个字符。","source":"nodejs/nodejs-note-10.md","raw":"---\ntitle: nodejs基础知识(3)\ndate: 2022-12-29 11:32:45\ntags: [node, child_process - 子进程]\n---\n\nchild_process 模块提供了衍生子进程的功能，它与 [popen(3)](https://man7.org/linux/man-pages/man3/popen.3.html) 类似，但不完全相同。 这个功能主要由 [child_process.spawn()] 函数提供\n```nodejs\nconst { spawn } = require('child_process');\nconst ls = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', (data) => {\n  console.log(`输出：${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.log(`错误：${data}`);\n});\n\nls.on('close', (code) => {\n  console.log(`子进程退出码：${code}`);\n});\n```\n默认情况下，Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。 数据能以非阻塞的方式在管道中流通。 有些程序会在内部使用行缓冲 I/O，虽然这并不影响 Node.js，但发送到子进程的数据可能无法被立即使用。\n\n- [child_process.spawn()] 函数会异步地衍生子进程，且不会阻塞 Node.js 事件循环。 \n- [child_process.spawnSync()] 函数则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或被终止。\n- [child_process.exec()]: 衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。\n- [child_process.execFile()]: 类似 [child_process.exec()]，但直接衍生命令，且无需先衍生 shell。\n- [child_process.fork()]: 衍生一个新的 Node.js 进程，并通过建立 IPC 通讯通道来调用指定的模块，该通道允许父进程与子进程之间相互发送信息。\n- [child_process.execSync()]: [child_process.exec()] 的同步函数，会阻塞 Node.js 事件循环。\n- [child_process.execFileSync()]: [child_process.execFile()] 的同步函数，会阻塞 Node.js 事件循环。\n\n*注：后续函数都是基于 [child_process.spawn()] 或 [child_process.spawnSync()] 实现的。*\n\n**创建异步进程**\n[child_process.spawn()]、[child_process.fork()]、[child_process.exec()] 和 [child_process.execFile()] 函数都遵循 Node.js API 惯用的异步编程模式。\n\n每个函数都返回 [ChildProcess] 实例。 这些实例实现了 Node.js [EventEmitter] API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。\n\n[child_process.exec()] 和 [child_process.execFile()] 函数可以额外指定一个可选的 callback 函数，当子进程结束时会被调用。\n\n**在 Windows 上衍生 .bat 和 .cmd 文件**\n[child_process.exec()] 和 [child_process.execFile()] 之间的区别会因平台而不同。 在类 Unix 操作系统（Unix、 Linux、 macOS）上，[child_process.execFile()] 效率更高，因为它不需要衍生 shell。 但在 Windows 上，.bat 和 .cmd 文件在没有终端的情况下是不可执行的，因此不能使用 [child_process.execFile()] 启动。 可以使用设置了 shell 选项的 [child_process.spawn()]、或使用 [child_process.exec()]、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 [child_process.exec()] 所做的工作）。 如果脚本文件名包含空格，则需要加上引号。\n```\n// 仅限 Windows 系统\nconst { spawn } = require('child_process');\nconst bat = spawn('cmd.exe', ['/c', 'my.bat']);\n\nbat.stdout.on('data', (data) => {\n  console.log(data.toString());\n});\n\nbat.stderr.on('data', (data) => {\n  console.log(data.toString());\n});\n\nbat.on('exit', (code) => {\n  console.log(`子进程退出码：${code}`);\n});\n\n// 或\nconst { exec } = require('child_process');\nexec('my.bat', (err, stdout, stderr) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(stdout);\n});\n\n// 文件名带有空格的脚本：\nconst bat = spawn('\"my script.cmd\"', ['a', 'b'], { shell: true });\n// 或：\nexec('\"my script.cmd\" a b', (err, stdout, stderr) => {\n  // ...\n});\n```\n\n**child_process.exec(command[, options][, callback])**\n- command <string> 运行的命令，参数使用空格分隔。\n- options <Object>\n - cwd <string> 子进程的当前工作目录。\n - env <Object> 环境变量键值对。\n - encoding <string> 默认为 'utf8'。\n - shell <string> 执行命令的 shell。在 UNIX 上默认为 '/bin/sh'，在 Windows 上默认为 process.env.ComSpec。详见Shell的要求与Windows默认的Shell。\n - timeout <number> 默认为 0。\n - maxBuffer <number> stdout 或 stderr 允许的最大字节数。默认为 200*1024。如果超过限制，则子进程会被终止。详见 maxBuffer与Unicode。\n - killSignal <string> | <integer> 默认为 'SIGTERM'。\n - uid <number> 设置进程的用户标识，详见 setuid(2)。\n - gid <number> 设置进程的组标识，详见 setgid(2)。\n - windowsHide <boolean> 隐藏子进程的控制台窗口，常用于 Windows 系统。默认为 false。\n- callback <Function> 进程终止时调用。\n - error <Error>\n - stdout <string> | <Buffer>\n - stderr <string> | <Buffer>\n返回: <ChildProcess>\n\n衍生一个 shell 并在 shell 中执行 command，且缓冲任何产生的输出。 传入函数的 command 字符串会被 shell 直接处理，特殊字符（因shell而异）需要相应处理：\n```\nexec('\"/path/to/test file/test.sh\" arg1 arg2');\n// 使用双引号使路径中的空格不会被理解为多个参数。\n\nexec('echo \"The \\\\$HOME variable is $HOME\"');\n// 第一个 $HOME 会被转义，而第二个不会。\n```\n\n注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。\n```\nconst { exec } = require('child_process');\nexec('cat *.js bad_file | wc -l', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n});\n```\n\n如果提供了一个 callback 函数，则它被调用时会带上参数 (error, stdout, stderr)。 当成功时，error 会是 null。 当失败时，error 会是一个 [Error] 实例。 error.code 属性会是子进程的退出码，error.signal 会被设为终止进程的信号。 除 0 以外的任何退出码都被认为是一个错误。\n\n传给回调的 stdout 和 stderr 参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 encoding 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果 encoding 是 'buffer'、或一个无法识别的字符编码，则传入 Buffer 对象到回调函数。\n\noptions 参数可以作为第二个参数传入，用于自定义如何衍生进程。\n\n如果 timeout 大于 0，当子进程运行超过 timeout 毫秒时，父进程就会发送由 killSignal 属性标识的信号（默认为 'SIGTERM'）。\n\n如果调用该方法的 [util.promisify()][] 版本，将会返回一个包含 stdout 和 stderr 的 Promise 对象。在出现错误的情况下，将返回 rejected 状态的 promise，拥有与回调函数一样的 error 对象，但附加了 stdout 和 stderr 属性。\n```\nconst util = require('util');\nconst exec = util.promisify(require('child_process').exec);\n\nasync function lsExample() {\n  const { stdout, stderr } = await exec('ls');\n  console.log('stdout:', stdout);\n  console.log('stderr:', stderr);\n}\nlsExample();\n```\n\n**child_process.execFile(file[, args][, options][, callback])**\n- file <string> 要运行的可执行文件的名称或路径。\n- args <string[]> 字符串参数列表。\n- options <Object>\n  - cwd <string> 子进程的当前工作目录。\n  - env <Object> 环境变量键值对。\n  - encoding <string> 默认为 'utf8'。\n  - timeout <number> 默认为 0。\n  - maxBuffer <number> stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 \n  - killSignal <string> | <integer> 默认为 'SIGTERM'。\n  - uid <number> 设置该进程的用户标识。（详见 setuid(2)）\n  - gid <number> 设置该进程的组标识。（详见 setgid(2)）\n  - windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。\n  - windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认为: false。\n- callback <Function> 当进程终止时调用，并带上输出。\n  - error <Error>\n  - stdout <string> | <Buffer>\n  - stderr <string> | <Buffer>\n返回: <ChildProcess>\nchild_process.execFile() 函数类似 [child_process.exec()]，除了不衍生一个 shell。 而是，指定的可执行的 file 被直接衍生为一个新进程，这使得它比 [child_process.exec()] 更高效。\n\n它支持和 [child_process.exec()] 一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。\n```\nconst { execFile } = require('child_process');\nconst child = execFile('node', ['--version'], (error, stdout, stderr) => {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n```\n\n**child_process.fork(modulePath[, args][, options])**\n- modulePath <string> 要在子进程中运行的模块。\n- args <Array> 字符串参数列表。\n- options <Object>\n  - cwd <string> 子进程的当前工作目录。\n  - env <Object> 环境变量键值对。\n  - execPath <string> 用来创建子进程的执行路径。\n  - execArgv <Array> 要传给执行路径的字符串参数列表。默认为 process.execArgv。\n  - silent <boolean> 如果为 true，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [child_process.spawn()] 的 [stdio] 中的 'pipe' 和 'inherit' 选项。 默认: false。\n  - stdio <Array> | <string> 详见 [child_process.spawn()] 的 [stdio]。 当提供了该选项，则它会覆盖 silent。 如果使用了数组变量，则该数组必须包含一个值为 'ipc' 的子项，否则会抛出错误。 例如 [0, 1, 2, 'ipc']。\n  - windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略。默认值: false。\n  - uid <number> 设置该进程的用户标识。（详见 setuid(2)）\n  - gid <number> 设置该进程的组标识。（详见 setgid(2)）\n返回: <ChildProcess>\nchild_process.fork() 方法是 [child_process.spawn()] 的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟 [child_process.spawn()] 一样返回一个 [ChildProcess] 对象。 返回的 [ChildProcess] 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见 [subprocess.send()]。\n\n衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。\n\n默认情况下，child_process.fork() 会使用父进程中的 [process.execPath] 衍生新的 Node.js 实例。 options 对象中的 execPath 属性可以替换要使用的执行路径。\n\n使用自定义的 execPath 启动的 Node.js 进程，会使用子进程的环境变量 NODE_CHANNEL_FD 中指定的文件描述符（fd）与父进程通信。\n\n注意，不像 POSIX 系统回调中的 fork(2)，child_process.fork() 不会克隆当前进程。\n\n提示: 在使用child_process.fork() 产生的子进程内，使用 [child_process.spawn()][] 会自动忽略掉其中的shell 配置选项并不会生效。\n\n**child_process.spawn(command[, args][, options])**\n- command <string> 要运行的命令。\n- args <Array> 字符串参数列表。\n- options <Object>\n  - cwd <string> 子进程的当前工作目录。\n  - env <Object> 环境变量键值对。\n  - argv0 <string> 显式地设置要发给子进程的 argv[0] 的值。 如果未指定，则设为 command。\n  - stdio <Array> | <string> 子进程的 stdio 配置。 \n  - detached <boolean> 准备将子进程独立于父进程运行。 具体行为取决于平台。\n  - uid <number> 设置该进程的用户标识。\n  - gid <number> 设置该进程的组标识。\n  - shell <boolean> | <string> 如果为 true，则在一个 shell 中运行 command。 在 UNIX 上使用 '/bin/sh'，在 Windows 上使用 process.env.ComSpec。 一个不同的 shell 可以被指定为字符串。 默认为 false（没有 shell）。\n  - windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认值: false。\n  - windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。\n返回: <ChildProcess>\n\n**child_process.execFileSync(file[, args][, options])**\nchild_process.execFileSync() 方法与 [child_process.execFile()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。\n\n注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。\n\n如果进程超时，或有一个非零的退出码，则该方法会抛出一个 [Error]，这个错误对象包含了底层 [child_process.spawnSync()] 的完整结果。\n\n**child_process.execSync(command[, options])**\nchild_process.execSync() 方法与 [child_process.exec()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。\n\n如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 [Error] 对象会包含从 [child_process.spawnSync()] 返回的整个结果。\n\n注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。\n\n**child_process.spawnSync(command[, args][, options])**\nchild_process.spawnSync() 方法与 [child_process.spawn()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。\n\n注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。\n\n**ChildProcess 类**\nChildProcess 类的实例是 [EventEmitter]，代表衍生的子进程。\n\nChildProcess 的实例不被直接创建。 而是，使用 [child_process.spawn()]、[child_process.exec()]、[child_process.execFile()] 或 [child_process.fork()] 方法创建 ChildProcess 实例。\n\n**'close' 事件**\ncode <number> 如果子进程退出自身，则该值是退出码。\nsignal <string> 子进程被终止时的信号。\n当子进程的 stdio 流被关闭时会触发 'close' 事件。 这与 ['exit'] 事件不同，因为多个进程可能共享同一 stdio 流。\n\n**'disconnect' 事件**\n在父进程中调用 [subprocess.disconnect()] 或在子进程中调用 [process.disconnect()] 后会触发 'disconnect' 事件。 断开后就不能再发送或接收信息，且 [subprocess.connected] 属性会被设为 false。\n\n**'error' 事件**\nerr <Error> 错误对象。\n每当出现以下情况时触发 'error' 事件：\n- 进程无法被衍生；\n- 进程无法被杀死；\n- 向子进程发送信息失败。\n注意，在错误发生后，'exit' 事件可能会也可能不会触发。 当同时监听了 'exit' 和 'error' 事件，谨防处理函数被多次调用。\n详见 [subprocess.kill()] 和 [subprocess.send()]。\n\n**'exit' 事件**\ncode <number> 如果子进程退出自身，则该值是退出码。\nsignal <string> 子进程被终止时的信号。\n子进程结束后会触发 'exit' 事件。 如果进程退出了，则 code 是进程的最终退出码，否则为 null。 \n如果进程是收到的信号而终止的，则 signal 是信号的字符串名称，否则为 null。 \n*这两个总有一个是非空的。*\n\n注意，当 'exit' 事件被触发时，子进程的 stdio 流可能依然是打开的。\n\n另外，还要注意，Node.js 建立了 SIGINT 和 SIGTERM 的信号处理程序，且 Node.js 进程收到这些信号也不会立即终止。 相反，Node.js 会执行一系列的清理操作后重新引发处理信号。\n\n**'message' 事件**\nmessage <Object> 一个已解析的 JSON 对象或原始值。\nsendHandle <Handle> 一个 [net.Socket] 或 [net.Server] 对象 或 undefined。\n当一个子进程使用 [process.send()] 发送消息时会触发 'message' 事件。\n\n注意: 消息通过序列化和解析传递，结果就是消息可能跟开始发送的不完全一样。\n\n**subprocess.channel**\n<Object> 代表子进程的IPC通道的管道。\nsubprocess.channel 属性是当前子进程的 IPC 通道的引用。如果当前没有 IPC 通道，则该属性为 undefined。\n\n**subprocess.connected**\n<boolean> 调用 subprocess.disconnect() 后会被设为 false\nsubprocess.connected 属性表明是否仍可以从一个子进程发送和接收消息。 当 subprocess.connected 为 false 时，则不能再发送或接收的消息。\n\n**subprocess.disconnect()**\n关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。 调用该方法后，父进程和子进程上各自的 subprocess.connected 和 process.connected 属性都会被设为 false，且进程之间不能再传递消息。\n\n当正在接收的进程中没有消息时，就会触发 'disconnect' 事件。 这经常在调用 subprocess.disconnect() 后立即被触发。\n\n注意，当子进程是一个 Node.js 实例时（例如通过 [child_process.fork()] 衍生的），可以在子进程内调用 process.disconnect() 方法来关闭 IPC 通道。\n\n**subprocess.kill([signal])**\nsignal <string>\nsubprocess.kill() 方法向子进程发送一个信号。 如果没有给定参数，则进程会发送 'SIGTERM' 信号。\n```\nconst { spawn } = require('child_process');\nconst grep = spawn('grep', ['ssh']);\n\ngrep.on('close', (code, signal) => {\n  console.log(`子进程收到信号 ${signal} 而终止`);\n});\n\n// 发送 SIGHUP 到进程\ngrep.kill('SIGHUP');\n```\n如果信号没有被送达，[ChildProcess] 对象可能会触发一个 ['error'] 事件。 向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。 特别是，如果进程的 PID 已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。\n\n注意，当函数被调用 kill 时，已发送到子进程的信号可能没有实际终止该进程。\n\n**subprocess.killed**\n<boolean> 当 subprocess.kill() 已成功发送信号给子进程后会被设置为 true。\nsubprocess.killed 属性表明该子进程是否已成功接收到 subprocess.kill() 的信号。 该属性不代表子进程是否已被终止。\n\n**subprocess.pid**\n<number> 整数\n返回子进程的进程标识（PID）。\n\n**subprocess.send(message[, sendHandle[, options]][, callback])**\n当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 [child_process.fork()]），subprocess.send() 方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 [process.on('message')] 事件接收。\n\n注意: 消息通过序列化和解析进行传递，结果就是消息可能跟开始发送的不完全一样。\n\n**subprocess.stderr**\n<stream.Readable>\n一个代表子进程的 stderr 的可读流。\n如果子进程被衍生时 stdio[2] 被设为任何不是 'pipe' 的值，则这会是 null。\nsubprocess.stderr 是 subprocess.stdio[2] 的一个别名。 这两个属性指向相同的值。\n\n**subprocess.stdin**\n<stream.Writable>\n一个代表子进程的 stdin 的可写流。\n注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 end() 关闭。\n如果子进程被衍生时 stdio[0] 被设为任何不是 'pipe' 的值，则这会是 null。\nsubprocess.stdin 是 subprocess.stdio[0] 的一个别名。 这两个属性指向相同的值。\n\n**subprocess.stdio**\n<Array>\n一个到子进程的管道的稀疏数组，对应着传给 [child_process.spawn()] 的选项中值被设为 'pipe' 的 [stdio]。 注意，subprocess.stdio[0]、subprocess.stdio[1] 和 subprocess.stdio[2] 分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr。\n\n**subprocess.stdout**\n<stream.Readable>\n一个代表子进程的 stdout 的可读流。\n如果子进程被衍生时 stdio[1] 被设为任何不是 'pipe' 的值，则这会是 null。\nsubprocess.stdout 是 subprocess.stdio[1] 的一个别名。 这两个属性指向相同的值。\n\n**maxBuffer 与 Unicode**\nmaxBuffer 选项指定了 stdout 或 stderr 上允许的字节数的最大值。 如果超过这个值，则子进程会被终止。 这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。 例如，console.log('中文测试') 会发送 13 个 UTF-8 编码的字节到 stdout，尽管只有 4 个字符。","updated":"2022-12-30T08:26:58.409Z","path":"nodejs/nodejs-note-10.html","comments":1,"layout":"page","_id":"clchh4gwn000ecktt24mxcjkd","content":"<p>child_process 模块提供了衍生子进程的功能，它与 <a href=\"https://man7.org/linux/man-pages/man3/popen.3.html\">popen(3)</a> 类似，但不完全相同。 这个功能主要由 [child_process.spawn()] 函数提供</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const ls = spawn(&#x27;ls&#x27;, [&#x27;-lh&#x27;, &#x27;/usr&#x27;]);</span><br><span class=\"line\"></span><br><span class=\"line\">ls.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(`输出：$&#123;data&#125;`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ls.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(`错误：$&#123;data&#125;`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ls.on(&#x27;close&#x27;, (code) =&gt; &#123;</span><br><span class=\"line\">  console.log(`子进程退出码：$&#123;code&#125;`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。 数据能以非阻塞的方式在管道中流通。 有些程序会在内部使用行缓冲 I/O，虽然这并不影响 Node.js，但发送到子进程的数据可能无法被立即使用。</p>\n<ul>\n<li>[child_process.spawn()] 函数会异步地衍生子进程，且不会阻塞 Node.js 事件循环。 </li>\n<li>[child_process.spawnSync()] 函数则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或被终止。</li>\n<li>[child_process.exec()]: 衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。</li>\n<li>[child_process.execFile()]: 类似 [child_process.exec()]，但直接衍生命令，且无需先衍生 shell。</li>\n<li>[child_process.fork()]: 衍生一个新的 Node.js 进程，并通过建立 IPC 通讯通道来调用指定的模块，该通道允许父进程与子进程之间相互发送信息。</li>\n<li>[child_process.execSync()]: [child_process.exec()] 的同步函数，会阻塞 Node.js 事件循环。</li>\n<li>[child_process.execFileSync()]: [child_process.execFile()] 的同步函数，会阻塞 Node.js 事件循环。</li>\n</ul>\n<p><em>注：后续函数都是基于 [child_process.spawn()] 或 [child_process.spawnSync()] 实现的。</em></p>\n<p><strong>创建异步进程</strong><br>[child_process.spawn()]、[child_process.fork()]、[child_process.exec()] 和 [child_process.execFile()] 函数都遵循 Node.js API 惯用的异步编程模式。</p>\n<p>每个函数都返回 [ChildProcess] 实例。 这些实例实现了 Node.js [EventEmitter] API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。</p>\n<p>[child_process.exec()] 和 [child_process.execFile()] 函数可以额外指定一个可选的 callback 函数，当子进程结束时会被调用。</p>\n<p><strong>在 Windows 上衍生 .bat 和 .cmd 文件</strong><br>[child_process.exec()] 和 [child_process.execFile()] 之间的区别会因平台而不同。 在类 Unix 操作系统（Unix、 Linux、 macOS）上，[child_process.execFile()] 效率更高，因为它不需要衍生 shell。 但在 Windows 上，.bat 和 .cmd 文件在没有终端的情况下是不可执行的，因此不能使用 [child_process.execFile()] 启动。 可以使用设置了 shell 选项的 [child_process.spawn()]、或使用 [child_process.exec()]、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 [child_process.exec()] 所做的工作）。 如果脚本文件名包含空格，则需要加上引号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 仅限 Windows 系统</span><br><span class=\"line\">const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const bat = spawn(&#x27;cmd.exe&#x27;, [&#x27;/c&#x27;, &#x27;my.bat&#x27;]);</span><br><span class=\"line\"></span><br><span class=\"line\">bat.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">bat.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">bat.on(&#x27;exit&#x27;, (code) =&gt; &#123;</span><br><span class=\"line\">  console.log(`子进程退出码：$&#123;code&#125;`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或</span><br><span class=\"line\">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">exec(&#x27;my.bat&#x27;, (err, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(stdout);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件名带有空格的脚本：</span><br><span class=\"line\">const bat = spawn(&#x27;&quot;my script.cmd&quot;&#x27;, [&#x27;a&#x27;, &#x27;b&#x27;], &#123; shell: true &#125;);</span><br><span class=\"line\">// 或：</span><br><span class=\"line\">exec(&#x27;&quot;my script.cmd&quot; a b&#x27;, (err, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>child_process.exec(command[, options][, callback])</strong></p>\n<ul>\n<li>command <string> 运行的命令，参数使用空格分隔。</string></li>\n<li>options <Object></Object></li>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>encoding <string> 默认为 ‘utf8’。</string></li>\n<li>shell <string> 执行命令的 shell。在 UNIX 上默认为 ‘/bin/sh’，在 Windows 上默认为 process.env.ComSpec。详见Shell的要求与Windows默认的Shell。</string></li>\n<li>timeout <number> 默认为 0。</number></li>\n<li>maxBuffer <number> stdout 或 stderr 允许的最大字节数。默认为 200*1024。如果超过限制，则子进程会被终止。详见 maxBuffer与Unicode。</number></li>\n<li>killSignal <string> | <integer> 默认为 ‘SIGTERM’。</integer></string></li>\n<li>uid <number> 设置进程的用户标识，详见 setuid(2)。</number></li>\n<li>gid <number> 设置进程的组标识，详见 setgid(2)。</number></li>\n<li>windowsHide <boolean> 隐藏子进程的控制台窗口，常用于 Windows 系统。默认为 false。</boolean></li>\n<li>callback <Function> 进程终止时调用。</Function></li>\n<li>error <Error></Error></li>\n<li>stdout <string> | <Buffer></Buffer></string></li>\n<li>stderr <string> | <Buffer><br>返回: <ChildProcess></ChildProcess></Buffer></string></li>\n</ul>\n<p>衍生一个 shell 并在 shell 中执行 command，且缓冲任何产生的输出。 传入函数的 command 字符串会被 shell 直接处理，特殊字符（因shell而异）需要相应处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec(&#x27;&quot;/path/to/test file/test.sh&quot; arg1 arg2&#x27;);</span><br><span class=\"line\">// 使用双引号使路径中的空格不会被理解为多个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">exec(&#x27;echo &quot;The \\\\$HOME variable is $HOME&quot;&#x27;);</span><br><span class=\"line\">// 第一个 $HOME 会被转义，而第二个不会。</span><br></pre></td></tr></table></figure>\n\n<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">exec(&#x27;cat *.js bad_file | wc -l&#x27;, (error, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  if (error) &#123;</span><br><span class=\"line\">    console.error(`exec error: $&#123;error&#125;`);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class=\"line\">  console.log(`stderr: $&#123;stderr&#125;`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果提供了一个 callback 函数，则它被调用时会带上参数 (error, stdout, stderr)。 当成功时，error 会是 null。 当失败时，error 会是一个 [Error] 实例。 error.code 属性会是子进程的退出码，error.signal 会被设为终止进程的信号。 除 0 以外的任何退出码都被认为是一个错误。</p>\n<p>传给回调的 stdout 和 stderr 参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 encoding 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果 encoding 是 ‘buffer’、或一个无法识别的字符编码，则传入 Buffer 对象到回调函数。</p>\n<p>options 参数可以作为第二个参数传入，用于自定义如何衍生进程。</p>\n<p>如果 timeout 大于 0，当子进程运行超过 timeout 毫秒时，父进程就会发送由 killSignal 属性标识的信号（默认为 ‘SIGTERM’）。</p>\n<p>如果调用该方法的 [util.promisify()][] 版本，将会返回一个包含 stdout 和 stderr 的 Promise 对象。在出现错误的情况下，将返回 rejected 状态的 promise，拥有与回调函数一样的 error 对象，但附加了 stdout 和 stderr 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const util = require(&#x27;util&#x27;);</span><br><span class=\"line\">const exec = util.promisify(require(&#x27;child_process&#x27;).exec);</span><br><span class=\"line\"></span><br><span class=\"line\">async function lsExample() &#123;</span><br><span class=\"line\">  const &#123; stdout, stderr &#125; = await exec(&#x27;ls&#x27;);</span><br><span class=\"line\">  console.log(&#x27;stdout:&#x27;, stdout);</span><br><span class=\"line\">  console.log(&#x27;stderr:&#x27;, stderr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lsExample();</span><br></pre></td></tr></table></figure>\n\n<p><strong>child_process.execFile(file[, args][, options][, callback])</strong></p>\n<ul>\n<li>file <string> 要运行的可执行文件的名称或路径。</string></li>\n<li>args &lt;string[]&gt; 字符串参数列表。</li>\n<li>options <Object><ul>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>encoding <string> 默认为 ‘utf8’。</string></li>\n<li>timeout <number> 默认为 0。</number></li>\n<li>maxBuffer <number> stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 </number></li>\n<li>killSignal <string> | <integer> 默认为 ‘SIGTERM’。</integer></string></li>\n<li>uid <number> 设置该进程的用户标识。（详见 setuid(2)）</number></li>\n<li>gid <number> 设置该进程的组标识。（详见 setgid(2)）</number></li>\n<li>windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。</boolean></li>\n<li>windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认为: false。</boolean></li>\n</ul>\n</Object></li>\n<li>callback <Function> 当进程终止时调用，并带上输出。<ul>\n<li>error <Error></Error></li>\n<li>stdout <string> | <Buffer></Buffer></string></li>\n<li>stderr <string> | <Buffer><br>返回: <ChildProcess><br>child_process.execFile() 函数类似 [child_process.exec()]，除了不衍生一个 shell。 而是，指定的可执行的 file 被直接衍生为一个新进程，这使得它比 [child_process.exec()] 更高效。</ChildProcess></Buffer></string></li>\n</ul>\n</Function></li>\n</ul>\n<p>它支持和 [child_process.exec()] 一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; execFile &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const child = execFile(&#x27;node&#x27;, [&#x27;--version&#x27;], (error, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  if (error) &#123;</span><br><span class=\"line\">    throw error;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(stdout);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>child_process.fork(modulePath[, args][, options])</strong></p>\n<ul>\n<li>modulePath <string> 要在子进程中运行的模块。</string></li>\n<li>args <Array> 字符串参数列表。</Array></li>\n<li>options <Object><ul>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>execPath <string> 用来创建子进程的执行路径。</string></li>\n<li>execArgv <Array> 要传给执行路径的字符串参数列表。默认为 process.execArgv。</Array></li>\n<li>silent <boolean> 如果为 true，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [child_process.spawn()] 的 [stdio] 中的 ‘pipe’ 和 ‘inherit’ 选项。 默认: false。</boolean></li>\n<li>stdio <Array> | <string> 详见 [child_process.spawn()] 的 [stdio]。 当提供了该选项，则它会覆盖 silent。 如果使用了数组变量，则该数组必须包含一个值为 ‘ipc’ 的子项，否则会抛出错误。 例如 [0, 1, 2, ‘ipc’]。</string></Array></li>\n<li>windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略。默认值: false。</boolean></li>\n<li>uid <number> 设置该进程的用户标识。（详见 setuid(2)）</number></li>\n<li>gid <number> 设置该进程的组标识。（详见 setgid(2)）<br>返回: <ChildProcess><br>child_process.fork() 方法是 [child_process.spawn()] 的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟 [child_process.spawn()] 一样返回一个 [ChildProcess] 对象。 返回的 [ChildProcess] 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见 [subprocess.send()]。</ChildProcess></number></li>\n</ul>\n</Object></li>\n</ul>\n<p>衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。</p>\n<p>默认情况下，child_process.fork() 会使用父进程中的 [process.execPath] 衍生新的 Node.js 实例。 options 对象中的 execPath 属性可以替换要使用的执行路径。</p>\n<p>使用自定义的 execPath 启动的 Node.js 进程，会使用子进程的环境变量 NODE_CHANNEL_FD 中指定的文件描述符（fd）与父进程通信。</p>\n<p>注意，不像 POSIX 系统回调中的 fork(2)，child_process.fork() 不会克隆当前进程。</p>\n<p>提示: 在使用child_process.fork() 产生的子进程内，使用 [child_process.spawn()][] 会自动忽略掉其中的shell 配置选项并不会生效。</p>\n<p><strong>child_process.spawn(command[, args][, options])</strong></p>\n<ul>\n<li>command <string> 要运行的命令。</string></li>\n<li>args <Array> 字符串参数列表。</Array></li>\n<li>options <Object><ul>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>argv0 <string> 显式地设置要发给子进程的 argv[0] 的值。 如果未指定，则设为 command。</string></li>\n<li>stdio <Array> | <string> 子进程的 stdio 配置。 </string></Array></li>\n<li>detached <boolean> 准备将子进程独立于父进程运行。 具体行为取决于平台。</boolean></li>\n<li>uid <number> 设置该进程的用户标识。</number></li>\n<li>gid <number> 设置该进程的组标识。</number></li>\n<li>shell <boolean> | <string> 如果为 true，则在一个 shell 中运行 command。 在 UNIX 上使用 ‘/bin/sh’，在 Windows 上使用 process.env.ComSpec。 一个不同的 shell 可以被指定为字符串。 默认为 false（没有 shell）。</string></boolean></li>\n<li>windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认值: false。</boolean></li>\n<li>windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。<br>返回: <ChildProcess></ChildProcess></boolean></li>\n</ul>\n</Object></li>\n</ul>\n<p><strong>child_process.execFileSync(file[, args][, options])</strong><br>child_process.execFileSync() 方法与 [child_process.execFile()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。</p>\n<p>注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>如果进程超时，或有一个非零的退出码，则该方法会抛出一个 [Error]，这个错误对象包含了底层 [child_process.spawnSync()] 的完整结果。</p>\n<p><strong>child_process.execSync(command[, options])</strong><br>child_process.execSync() 方法与 [child_process.exec()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 [Error] 对象会包含从 [child_process.spawnSync()] 返回的整个结果。</p>\n<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>\n<p><strong>child_process.spawnSync(command[, args][, options])</strong><br>child_process.spawnSync() 方法与 [child_process.spawn()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>\n<p><strong>ChildProcess 类</strong><br>ChildProcess 类的实例是 [EventEmitter]，代表衍生的子进程。</p>\n<p>ChildProcess 的实例不被直接创建。 而是，使用 [child_process.spawn()]、[child_process.exec()]、[child_process.execFile()] 或 [child_process.fork()] 方法创建 ChildProcess 实例。</p>\n<p><strong>‘close’ 事件</strong><br>code <number> 如果子进程退出自身，则该值是退出码。<br>signal <string> 子进程被终止时的信号。<br>当子进程的 stdio 流被关闭时会触发 ‘close’ 事件。 这与 [‘exit’] 事件不同，因为多个进程可能共享同一 stdio 流。</string></number></p>\n<p><strong>‘disconnect’ 事件</strong><br>在父进程中调用 [subprocess.disconnect()] 或在子进程中调用 [process.disconnect()] 后会触发 ‘disconnect’ 事件。 断开后就不能再发送或接收信息，且 [subprocess.connected] 属性会被设为 false。</p>\n<p><strong>‘error’ 事件</strong><br>err <Error> 错误对象。<br>每当出现以下情况时触发 ‘error’ 事件：</Error></p>\n<ul>\n<li>进程无法被衍生；</li>\n<li>进程无法被杀死；</li>\n<li>向子进程发送信息失败。<br>注意，在错误发生后，’exit’ 事件可能会也可能不会触发。 当同时监听了 ‘exit’ 和 ‘error’ 事件，谨防处理函数被多次调用。<br>详见 [subprocess.kill()] 和 [subprocess.send()]。</li>\n</ul>\n<p><strong>‘exit’ 事件</strong><br>code <number> 如果子进程退出自身，则该值是退出码。<br>signal <string> 子进程被终止时的信号。<br>子进程结束后会触发 ‘exit’ 事件。 如果进程退出了，则 code 是进程的最终退出码，否则为 null。<br>如果进程是收到的信号而终止的，则 signal 是信号的字符串名称，否则为 null。<br><em>这两个总有一个是非空的。</em></string></number></p>\n<p>注意，当 ‘exit’ 事件被触发时，子进程的 stdio 流可能依然是打开的。</p>\n<p>另外，还要注意，Node.js 建立了 SIGINT 和 SIGTERM 的信号处理程序，且 Node.js 进程收到这些信号也不会立即终止。 相反，Node.js 会执行一系列的清理操作后重新引发处理信号。</p>\n<p><strong>‘message’ 事件</strong><br>message <Object> 一个已解析的 JSON 对象或原始值。<br>sendHandle <Handle> 一个 [net.Socket] 或 [net.Server] 对象 或 undefined。<br>当一个子进程使用 [process.send()] 发送消息时会触发 ‘message’ 事件。</Handle></Object></p>\n<p>注意: 消息通过序列化和解析传递，结果就是消息可能跟开始发送的不完全一样。</p>\n<p><strong>subprocess.channel</strong><br><Object> 代表子进程的IPC通道的管道。<br>subprocess.channel 属性是当前子进程的 IPC 通道的引用。如果当前没有 IPC 通道，则该属性为 undefined。</Object></p>\n<p><strong>subprocess.connected</strong><br><boolean> 调用 subprocess.disconnect() 后会被设为 false<br>subprocess.connected 属性表明是否仍可以从一个子进程发送和接收消息。 当 subprocess.connected 为 false 时，则不能再发送或接收的消息。</boolean></p>\n<p><strong>subprocess.disconnect()</strong><br>关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。 调用该方法后，父进程和子进程上各自的 subprocess.connected 和 process.connected 属性都会被设为 false，且进程之间不能再传递消息。</p>\n<p>当正在接收的进程中没有消息时，就会触发 ‘disconnect’ 事件。 这经常在调用 subprocess.disconnect() 后立即被触发。</p>\n<p>注意，当子进程是一个 Node.js 实例时（例如通过 [child_process.fork()] 衍生的），可以在子进程内调用 process.disconnect() 方法来关闭 IPC 通道。</p>\n<p><strong>subprocess.kill([signal])</strong><br>signal <string><br>subprocess.kill() 方法向子进程发送一个信号。 如果没有给定参数，则进程会发送 ‘SIGTERM’ 信号。</string></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const grep = spawn(&#x27;grep&#x27;, [&#x27;ssh&#x27;]);</span><br><span class=\"line\"></span><br><span class=\"line\">grep.on(&#x27;close&#x27;, (code, signal) =&gt; &#123;</span><br><span class=\"line\">  console.log(`子进程收到信号 $&#123;signal&#125; 而终止`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送 SIGHUP 到进程</span><br><span class=\"line\">grep.kill(&#x27;SIGHUP&#x27;);</span><br></pre></td></tr></table></figure>\n<p>如果信号没有被送达，[ChildProcess] 对象可能会触发一个 [‘error’] 事件。 向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。 特别是，如果进程的 PID 已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。</p>\n<p>注意，当函数被调用 kill 时，已发送到子进程的信号可能没有实际终止该进程。</p>\n<p><strong>subprocess.killed</strong><br><boolean> 当 subprocess.kill() 已成功发送信号给子进程后会被设置为 true。<br>subprocess.killed 属性表明该子进程是否已成功接收到 subprocess.kill() 的信号。 该属性不代表子进程是否已被终止。</boolean></p>\n<p><strong>subprocess.pid</strong><br><number> 整数<br>返回子进程的进程标识（PID）。</number></p>\n<p><strong>subprocess.send(message[, sendHandle[, options]][, callback])</strong><br>当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 [child_process.fork()]），subprocess.send() 方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 [process.on(‘message’)] 事件接收。</p>\n<p>注意: 消息通过序列化和解析进行传递，结果就是消息可能跟开始发送的不完全一样。</p>\n<p><strong>subprocess.stderr</strong><br>&lt;stream.Readable&gt;<br>一个代表子进程的 stderr 的可读流。<br>如果子进程被衍生时 stdio[2] 被设为任何不是 ‘pipe’ 的值，则这会是 null。<br>subprocess.stderr 是 subprocess.stdio[2] 的一个别名。 这两个属性指向相同的值。</p>\n<p><strong>subprocess.stdin</strong><br>&lt;stream.Writable&gt;<br>一个代表子进程的 stdin 的可写流。<br>注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 end() 关闭。<br>如果子进程被衍生时 stdio[0] 被设为任何不是 ‘pipe’ 的值，则这会是 null。<br>subprocess.stdin 是 subprocess.stdio[0] 的一个别名。 这两个属性指向相同的值。</p>\n<p><strong>subprocess.stdio</strong><br><Array><br>一个到子进程的管道的稀疏数组，对应着传给 [child_process.spawn()] 的选项中值被设为 ‘pipe’ 的 [stdio]。 注意，subprocess.stdio[0]、subprocess.stdio[1] 和 subprocess.stdio[2] 分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr。</Array></p>\n<p><strong>subprocess.stdout</strong><br>&lt;stream.Readable&gt;<br>一个代表子进程的 stdout 的可读流。<br>如果子进程被衍生时 stdio[1] 被设为任何不是 ‘pipe’ 的值，则这会是 null。<br>subprocess.stdout 是 subprocess.stdio[1] 的一个别名。 这两个属性指向相同的值。</p>\n<p><strong>maxBuffer 与 Unicode</strong><br>maxBuffer 选项指定了 stdout 或 stderr 上允许的字节数的最大值。 如果超过这个值，则子进程会被终止。 这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。 例如，console.log(‘中文测试’) 会发送 13 个 UTF-8 编码的字节到 stdout，尽管只有 4 个字符。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>child_process 模块提供了衍生子进程的功能，它与 <a href=\"https://man7.org/linux/man-pages/man3/popen.3.html\">popen(3)</a> 类似，但不完全相同。 这个功能主要由 [child_process.spawn()] 函数提供</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const ls = spawn(&#x27;ls&#x27;, [&#x27;-lh&#x27;, &#x27;/usr&#x27;]);</span><br><span class=\"line\"></span><br><span class=\"line\">ls.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(`输出：$&#123;data&#125;`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ls.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(`错误：$&#123;data&#125;`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ls.on(&#x27;close&#x27;, (code) =&gt; &#123;</span><br><span class=\"line\">  console.log(`子进程退出码：$&#123;code&#125;`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。 数据能以非阻塞的方式在管道中流通。 有些程序会在内部使用行缓冲 I/O，虽然这并不影响 Node.js，但发送到子进程的数据可能无法被立即使用。</p>\n<ul>\n<li>[child_process.spawn()] 函数会异步地衍生子进程，且不会阻塞 Node.js 事件循环。 </li>\n<li>[child_process.spawnSync()] 函数则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或被终止。</li>\n<li>[child_process.exec()]: 衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。</li>\n<li>[child_process.execFile()]: 类似 [child_process.exec()]，但直接衍生命令，且无需先衍生 shell。</li>\n<li>[child_process.fork()]: 衍生一个新的 Node.js 进程，并通过建立 IPC 通讯通道来调用指定的模块，该通道允许父进程与子进程之间相互发送信息。</li>\n<li>[child_process.execSync()]: [child_process.exec()] 的同步函数，会阻塞 Node.js 事件循环。</li>\n<li>[child_process.execFileSync()]: [child_process.execFile()] 的同步函数，会阻塞 Node.js 事件循环。</li>\n</ul>\n<p><em>注：后续函数都是基于 [child_process.spawn()] 或 [child_process.spawnSync()] 实现的。</em></p>\n<p><strong>创建异步进程</strong><br>[child_process.spawn()]、[child_process.fork()]、[child_process.exec()] 和 [child_process.execFile()] 函数都遵循 Node.js API 惯用的异步编程模式。</p>\n<p>每个函数都返回 [ChildProcess] 实例。 这些实例实现了 Node.js [EventEmitter] API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。</p>\n<p>[child_process.exec()] 和 [child_process.execFile()] 函数可以额外指定一个可选的 callback 函数，当子进程结束时会被调用。</p>\n<p><strong>在 Windows 上衍生 .bat 和 .cmd 文件</strong><br>[child_process.exec()] 和 [child_process.execFile()] 之间的区别会因平台而不同。 在类 Unix 操作系统（Unix、 Linux、 macOS）上，[child_process.execFile()] 效率更高，因为它不需要衍生 shell。 但在 Windows 上，.bat 和 .cmd 文件在没有终端的情况下是不可执行的，因此不能使用 [child_process.execFile()] 启动。 可以使用设置了 shell 选项的 [child_process.spawn()]、或使用 [child_process.exec()]、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 [child_process.exec()] 所做的工作）。 如果脚本文件名包含空格，则需要加上引号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 仅限 Windows 系统</span><br><span class=\"line\">const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const bat = spawn(&#x27;cmd.exe&#x27;, [&#x27;/c&#x27;, &#x27;my.bat&#x27;]);</span><br><span class=\"line\"></span><br><span class=\"line\">bat.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">bat.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">bat.on(&#x27;exit&#x27;, (code) =&gt; &#123;</span><br><span class=\"line\">  console.log(`子进程退出码：$&#123;code&#125;`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或</span><br><span class=\"line\">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">exec(&#x27;my.bat&#x27;, (err, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(stdout);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件名带有空格的脚本：</span><br><span class=\"line\">const bat = spawn(&#x27;&quot;my script.cmd&quot;&#x27;, [&#x27;a&#x27;, &#x27;b&#x27;], &#123; shell: true &#125;);</span><br><span class=\"line\">// 或：</span><br><span class=\"line\">exec(&#x27;&quot;my script.cmd&quot; a b&#x27;, (err, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>child_process.exec(command[, options][, callback])</strong></p>\n<ul>\n<li>command <string> 运行的命令，参数使用空格分隔。</string></li>\n<li>options <Object></Object></li>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>encoding <string> 默认为 ‘utf8’。</string></li>\n<li>shell <string> 执行命令的 shell。在 UNIX 上默认为 ‘/bin/sh’，在 Windows 上默认为 process.env.ComSpec。详见Shell的要求与Windows默认的Shell。</string></li>\n<li>timeout <number> 默认为 0。</number></li>\n<li>maxBuffer <number> stdout 或 stderr 允许的最大字节数。默认为 200*1024。如果超过限制，则子进程会被终止。详见 maxBuffer与Unicode。</number></li>\n<li>killSignal <string> | <integer> 默认为 ‘SIGTERM’。</integer></string></li>\n<li>uid <number> 设置进程的用户标识，详见 setuid(2)。</number></li>\n<li>gid <number> 设置进程的组标识，详见 setgid(2)。</number></li>\n<li>windowsHide <boolean> 隐藏子进程的控制台窗口，常用于 Windows 系统。默认为 false。</boolean></li>\n<li>callback <Function> 进程终止时调用。</Function></li>\n<li>error <Error></Error></li>\n<li>stdout <string> | <Buffer></Buffer></string></li>\n<li>stderr <string> | <Buffer><br>返回: <ChildProcess></ChildProcess></Buffer></string></li>\n</ul>\n<p>衍生一个 shell 并在 shell 中执行 command，且缓冲任何产生的输出。 传入函数的 command 字符串会被 shell 直接处理，特殊字符（因shell而异）需要相应处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec(&#x27;&quot;/path/to/test file/test.sh&quot; arg1 arg2&#x27;);</span><br><span class=\"line\">// 使用双引号使路径中的空格不会被理解为多个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">exec(&#x27;echo &quot;The \\\\$HOME variable is $HOME&quot;&#x27;);</span><br><span class=\"line\">// 第一个 $HOME 会被转义，而第二个不会。</span><br></pre></td></tr></table></figure>\n\n<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">exec(&#x27;cat *.js bad_file | wc -l&#x27;, (error, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  if (error) &#123;</span><br><span class=\"line\">    console.error(`exec error: $&#123;error&#125;`);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class=\"line\">  console.log(`stderr: $&#123;stderr&#125;`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果提供了一个 callback 函数，则它被调用时会带上参数 (error, stdout, stderr)。 当成功时，error 会是 null。 当失败时，error 会是一个 [Error] 实例。 error.code 属性会是子进程的退出码，error.signal 会被设为终止进程的信号。 除 0 以外的任何退出码都被认为是一个错误。</p>\n<p>传给回调的 stdout 和 stderr 参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 encoding 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果 encoding 是 ‘buffer’、或一个无法识别的字符编码，则传入 Buffer 对象到回调函数。</p>\n<p>options 参数可以作为第二个参数传入，用于自定义如何衍生进程。</p>\n<p>如果 timeout 大于 0，当子进程运行超过 timeout 毫秒时，父进程就会发送由 killSignal 属性标识的信号（默认为 ‘SIGTERM’）。</p>\n<p>如果调用该方法的 [util.promisify()][] 版本，将会返回一个包含 stdout 和 stderr 的 Promise 对象。在出现错误的情况下，将返回 rejected 状态的 promise，拥有与回调函数一样的 error 对象，但附加了 stdout 和 stderr 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const util = require(&#x27;util&#x27;);</span><br><span class=\"line\">const exec = util.promisify(require(&#x27;child_process&#x27;).exec);</span><br><span class=\"line\"></span><br><span class=\"line\">async function lsExample() &#123;</span><br><span class=\"line\">  const &#123; stdout, stderr &#125; = await exec(&#x27;ls&#x27;);</span><br><span class=\"line\">  console.log(&#x27;stdout:&#x27;, stdout);</span><br><span class=\"line\">  console.log(&#x27;stderr:&#x27;, stderr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lsExample();</span><br></pre></td></tr></table></figure>\n\n<p><strong>child_process.execFile(file[, args][, options][, callback])</strong></p>\n<ul>\n<li>file <string> 要运行的可执行文件的名称或路径。</string></li>\n<li>args &lt;string[]&gt; 字符串参数列表。</li>\n<li>options <Object><ul>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>encoding <string> 默认为 ‘utf8’。</string></li>\n<li>timeout <number> 默认为 0。</number></li>\n<li>maxBuffer <number> stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 </number></li>\n<li>killSignal <string> | <integer> 默认为 ‘SIGTERM’。</integer></string></li>\n<li>uid <number> 设置该进程的用户标识。（详见 setuid(2)）</number></li>\n<li>gid <number> 设置该进程的组标识。（详见 setgid(2)）</number></li>\n<li>windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。</boolean></li>\n<li>windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认为: false。</boolean></li>\n</ul>\n</Object></li>\n<li>callback <Function> 当进程终止时调用，并带上输出。<ul>\n<li>error <Error></Error></li>\n<li>stdout <string> | <Buffer></Buffer></string></li>\n<li>stderr <string> | <Buffer><br>返回: <ChildProcess><br>child_process.execFile() 函数类似 [child_process.exec()]，除了不衍生一个 shell。 而是，指定的可执行的 file 被直接衍生为一个新进程，这使得它比 [child_process.exec()] 更高效。</ChildProcess></Buffer></string></li>\n</ul>\n</Function></li>\n</ul>\n<p>它支持和 [child_process.exec()] 一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; execFile &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const child = execFile(&#x27;node&#x27;, [&#x27;--version&#x27;], (error, stdout, stderr) =&gt; &#123;</span><br><span class=\"line\">  if (error) &#123;</span><br><span class=\"line\">    throw error;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(stdout);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>child_process.fork(modulePath[, args][, options])</strong></p>\n<ul>\n<li>modulePath <string> 要在子进程中运行的模块。</string></li>\n<li>args <Array> 字符串参数列表。</Array></li>\n<li>options <Object><ul>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>execPath <string> 用来创建子进程的执行路径。</string></li>\n<li>execArgv <Array> 要传给执行路径的字符串参数列表。默认为 process.execArgv。</Array></li>\n<li>silent <boolean> 如果为 true，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [child_process.spawn()] 的 [stdio] 中的 ‘pipe’ 和 ‘inherit’ 选项。 默认: false。</boolean></li>\n<li>stdio <Array> | <string> 详见 [child_process.spawn()] 的 [stdio]。 当提供了该选项，则它会覆盖 silent。 如果使用了数组变量，则该数组必须包含一个值为 ‘ipc’ 的子项，否则会抛出错误。 例如 [0, 1, 2, ‘ipc’]。</string></Array></li>\n<li>windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略。默认值: false。</boolean></li>\n<li>uid <number> 设置该进程的用户标识。（详见 setuid(2)）</number></li>\n<li>gid <number> 设置该进程的组标识。（详见 setgid(2)）<br>返回: <ChildProcess><br>child_process.fork() 方法是 [child_process.spawn()] 的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟 [child_process.spawn()] 一样返回一个 [ChildProcess] 对象。 返回的 [ChildProcess] 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见 [subprocess.send()]。</ChildProcess></number></li>\n</ul>\n</Object></li>\n</ul>\n<p>衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。</p>\n<p>默认情况下，child_process.fork() 会使用父进程中的 [process.execPath] 衍生新的 Node.js 实例。 options 对象中的 execPath 属性可以替换要使用的执行路径。</p>\n<p>使用自定义的 execPath 启动的 Node.js 进程，会使用子进程的环境变量 NODE_CHANNEL_FD 中指定的文件描述符（fd）与父进程通信。</p>\n<p>注意，不像 POSIX 系统回调中的 fork(2)，child_process.fork() 不会克隆当前进程。</p>\n<p>提示: 在使用child_process.fork() 产生的子进程内，使用 [child_process.spawn()][] 会自动忽略掉其中的shell 配置选项并不会生效。</p>\n<p><strong>child_process.spawn(command[, args][, options])</strong></p>\n<ul>\n<li>command <string> 要运行的命令。</string></li>\n<li>args <Array> 字符串参数列表。</Array></li>\n<li>options <Object><ul>\n<li>cwd <string> 子进程的当前工作目录。</string></li>\n<li>env <Object> 环境变量键值对。</Object></li>\n<li>argv0 <string> 显式地设置要发给子进程的 argv[0] 的值。 如果未指定，则设为 command。</string></li>\n<li>stdio <Array> | <string> 子进程的 stdio 配置。 </string></Array></li>\n<li>detached <boolean> 准备将子进程独立于父进程运行。 具体行为取决于平台。</boolean></li>\n<li>uid <number> 设置该进程的用户标识。</number></li>\n<li>gid <number> 设置该进程的组标识。</number></li>\n<li>shell <boolean> | <string> 如果为 true，则在一个 shell 中运行 command。 在 UNIX 上使用 ‘/bin/sh’，在 Windows 上使用 process.env.ComSpec。 一个不同的 shell 可以被指定为字符串。 默认为 false（没有 shell）。</string></boolean></li>\n<li>windowsVerbatimArguments <boolean> 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认值: false。</boolean></li>\n<li>windowsHide <boolean> 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。<br>返回: <ChildProcess></ChildProcess></boolean></li>\n</ul>\n</Object></li>\n</ul>\n<p><strong>child_process.execFileSync(file[, args][, options])</strong><br>child_process.execFileSync() 方法与 [child_process.execFile()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。</p>\n<p>注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>如果进程超时，或有一个非零的退出码，则该方法会抛出一个 [Error]，这个错误对象包含了底层 [child_process.spawnSync()] 的完整结果。</p>\n<p><strong>child_process.execSync(command[, options])</strong><br>child_process.execSync() 方法与 [child_process.exec()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 [Error] 对象会包含从 [child_process.spawnSync()] 返回的整个结果。</p>\n<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>\n<p><strong>child_process.spawnSync(command[, args][, options])</strong><br>child_process.spawnSync() 方法与 [child_process.spawn()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>\n<p><strong>ChildProcess 类</strong><br>ChildProcess 类的实例是 [EventEmitter]，代表衍生的子进程。</p>\n<p>ChildProcess 的实例不被直接创建。 而是，使用 [child_process.spawn()]、[child_process.exec()]、[child_process.execFile()] 或 [child_process.fork()] 方法创建 ChildProcess 实例。</p>\n<p><strong>‘close’ 事件</strong><br>code <number> 如果子进程退出自身，则该值是退出码。<br>signal <string> 子进程被终止时的信号。<br>当子进程的 stdio 流被关闭时会触发 ‘close’ 事件。 这与 [‘exit’] 事件不同，因为多个进程可能共享同一 stdio 流。</string></number></p>\n<p><strong>‘disconnect’ 事件</strong><br>在父进程中调用 [subprocess.disconnect()] 或在子进程中调用 [process.disconnect()] 后会触发 ‘disconnect’ 事件。 断开后就不能再发送或接收信息，且 [subprocess.connected] 属性会被设为 false。</p>\n<p><strong>‘error’ 事件</strong><br>err <Error> 错误对象。<br>每当出现以下情况时触发 ‘error’ 事件：</Error></p>\n<ul>\n<li>进程无法被衍生；</li>\n<li>进程无法被杀死；</li>\n<li>向子进程发送信息失败。<br>注意，在错误发生后，’exit’ 事件可能会也可能不会触发。 当同时监听了 ‘exit’ 和 ‘error’ 事件，谨防处理函数被多次调用。<br>详见 [subprocess.kill()] 和 [subprocess.send()]。</li>\n</ul>\n<p><strong>‘exit’ 事件</strong><br>code <number> 如果子进程退出自身，则该值是退出码。<br>signal <string> 子进程被终止时的信号。<br>子进程结束后会触发 ‘exit’ 事件。 如果进程退出了，则 code 是进程的最终退出码，否则为 null。<br>如果进程是收到的信号而终止的，则 signal 是信号的字符串名称，否则为 null。<br><em>这两个总有一个是非空的。</em></string></number></p>\n<p>注意，当 ‘exit’ 事件被触发时，子进程的 stdio 流可能依然是打开的。</p>\n<p>另外，还要注意，Node.js 建立了 SIGINT 和 SIGTERM 的信号处理程序，且 Node.js 进程收到这些信号也不会立即终止。 相反，Node.js 会执行一系列的清理操作后重新引发处理信号。</p>\n<p><strong>‘message’ 事件</strong><br>message <Object> 一个已解析的 JSON 对象或原始值。<br>sendHandle <Handle> 一个 [net.Socket] 或 [net.Server] 对象 或 undefined。<br>当一个子进程使用 [process.send()] 发送消息时会触发 ‘message’ 事件。</Handle></Object></p>\n<p>注意: 消息通过序列化和解析传递，结果就是消息可能跟开始发送的不完全一样。</p>\n<p><strong>subprocess.channel</strong><br><Object> 代表子进程的IPC通道的管道。<br>subprocess.channel 属性是当前子进程的 IPC 通道的引用。如果当前没有 IPC 通道，则该属性为 undefined。</Object></p>\n<p><strong>subprocess.connected</strong><br><boolean> 调用 subprocess.disconnect() 后会被设为 false<br>subprocess.connected 属性表明是否仍可以从一个子进程发送和接收消息。 当 subprocess.connected 为 false 时，则不能再发送或接收的消息。</boolean></p>\n<p><strong>subprocess.disconnect()</strong><br>关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。 调用该方法后，父进程和子进程上各自的 subprocess.connected 和 process.connected 属性都会被设为 false，且进程之间不能再传递消息。</p>\n<p>当正在接收的进程中没有消息时，就会触发 ‘disconnect’ 事件。 这经常在调用 subprocess.disconnect() 后立即被触发。</p>\n<p>注意，当子进程是一个 Node.js 实例时（例如通过 [child_process.fork()] 衍生的），可以在子进程内调用 process.disconnect() 方法来关闭 IPC 通道。</p>\n<p><strong>subprocess.kill([signal])</strong><br>signal <string><br>subprocess.kill() 方法向子进程发送一个信号。 如果没有给定参数，则进程会发送 ‘SIGTERM’ 信号。</string></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; spawn &#125; = require(&#x27;child_process&#x27;);</span><br><span class=\"line\">const grep = spawn(&#x27;grep&#x27;, [&#x27;ssh&#x27;]);</span><br><span class=\"line\"></span><br><span class=\"line\">grep.on(&#x27;close&#x27;, (code, signal) =&gt; &#123;</span><br><span class=\"line\">  console.log(`子进程收到信号 $&#123;signal&#125; 而终止`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送 SIGHUP 到进程</span><br><span class=\"line\">grep.kill(&#x27;SIGHUP&#x27;);</span><br></pre></td></tr></table></figure>\n<p>如果信号没有被送达，[ChildProcess] 对象可能会触发一个 [‘error’] 事件。 向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。 特别是，如果进程的 PID 已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。</p>\n<p>注意，当函数被调用 kill 时，已发送到子进程的信号可能没有实际终止该进程。</p>\n<p><strong>subprocess.killed</strong><br><boolean> 当 subprocess.kill() 已成功发送信号给子进程后会被设置为 true。<br>subprocess.killed 属性表明该子进程是否已成功接收到 subprocess.kill() 的信号。 该属性不代表子进程是否已被终止。</boolean></p>\n<p><strong>subprocess.pid</strong><br><number> 整数<br>返回子进程的进程标识（PID）。</number></p>\n<p><strong>subprocess.send(message[, sendHandle[, options]][, callback])</strong><br>当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 [child_process.fork()]），subprocess.send() 方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 [process.on(‘message’)] 事件接收。</p>\n<p>注意: 消息通过序列化和解析进行传递，结果就是消息可能跟开始发送的不完全一样。</p>\n<p><strong>subprocess.stderr</strong><br>&lt;stream.Readable&gt;<br>一个代表子进程的 stderr 的可读流。<br>如果子进程被衍生时 stdio[2] 被设为任何不是 ‘pipe’ 的值，则这会是 null。<br>subprocess.stderr 是 subprocess.stdio[2] 的一个别名。 这两个属性指向相同的值。</p>\n<p><strong>subprocess.stdin</strong><br>&lt;stream.Writable&gt;<br>一个代表子进程的 stdin 的可写流。<br>注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 end() 关闭。<br>如果子进程被衍生时 stdio[0] 被设为任何不是 ‘pipe’ 的值，则这会是 null。<br>subprocess.stdin 是 subprocess.stdio[0] 的一个别名。 这两个属性指向相同的值。</p>\n<p><strong>subprocess.stdio</strong><br><Array><br>一个到子进程的管道的稀疏数组，对应着传给 [child_process.spawn()] 的选项中值被设为 ‘pipe’ 的 [stdio]。 注意，subprocess.stdio[0]、subprocess.stdio[1] 和 subprocess.stdio[2] 分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr。</Array></p>\n<p><strong>subprocess.stdout</strong><br>&lt;stream.Readable&gt;<br>一个代表子进程的 stdout 的可读流。<br>如果子进程被衍生时 stdio[1] 被设为任何不是 ‘pipe’ 的值，则这会是 null。<br>subprocess.stdout 是 subprocess.stdio[1] 的一个别名。 这两个属性指向相同的值。</p>\n<p><strong>maxBuffer 与 Unicode</strong><br>maxBuffer 选项指定了 stdout 或 stderr 上允许的字节数的最大值。 如果超过这个值，则子进程会被终止。 这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。 例如，console.log(‘中文测试’) 会发送 13 个 UTF-8 编码的字节到 stdout，尽管只有 4 个字符。</p>\n"},{"title":"nodejs基础知识(6)","date":"2023-01-03T10:04:15.000Z","tags":["node","crypto (加密)"],"_content":"\ncrypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。\n\n使用 require('crypto') 来访问该模块。\n```javascript\nconst crypto = require('crypto');\n```\n\n###### Class: Certificate\nSPKAC 最初是由 Netscape 实现的一种证书签名请求机制, 现在正式成为 HTML5's keygen element 的一部分.\ncrypto 模块提供 Certificate 类用于处理 SPKAC 数据. 最普遍的用法是处理 HTML5 keygen 元素 产生的输出. Node.js 内部使用 OpenSSL's SPKAC implementation 处理.\n\nnew crypto.Certificate()#\n可以使用 new 关键字或者调用 crypto.Certificate() 方法创建 Certificate 类的实例:\n```javascript\nconst crypto = require('crypto');\nconst cert1 = new crypto.Certificate();\nconst cert2 = crypto.Certificate();\n```\n\ncertificate.exportChallenge(spkac)\nspkac <string> | <Buffer> | <TypedArray> | <DataView>\n返回 <Buffer> 返回 spkac 数据结构的 challenge 部分，spkac 包含一个公钥和一个 challange。\n```javascript\nconst cert = require('crypto').Certificate();\nconst spkac = getSpkacSomehow();// 生成过程省略了，不存在这个函数，只是一种象征意义\nconst challenge = cert.exportChallenge(spkac);\nconsole.log(challenge.toString('utf8'));\n// Prints: the challenge as a UTF8 string\n```\n\ncertificate.exportPublicKey(spkac)\nspkac <string> | <Buffer> | <TypedArray> | <DataView>\n返回 <Buffer> 数据结构的公钥部分，spkac 包含一个公钥和一个 challange。\n```javascript\nconst cert = require('crypto').Certificate();\nconst spkac = getSpkacSomehow();// 生成过程省略了，不存在这个函数，只是一种象征意义\nconst publicKey = cert.exportPublicKey(spkac);\nconsole.log(publicKey);\n// Prints: the public key as <Buffer ...>\n```\n\ncertificate.verifySpkac(spkac)\nspkac <Buffer> | <TypedArray> | <DataView>\n返回 <boolean> 如果 spkac 数据结构是有效的返回 true，否则返回 false。\n```javascript\nconst cert = require('crypto').Certificate();\nconst spkac = getSpkacSomehow();\nconsole.log(cert.verifySpkac(Buffer.from(spkac)));\n// Prints: true 或者 false\n```\n\n###### Class: Cipher\nCipher类的实例用于加密数据。这个类可以用在以下两种方法中的一种:\n- 作为stream，既可读又可写，未加密数据的编写是为了在可读的方面生成加密的数据\n- 使用cipher.update()和cipher.final()方法产生加密的数据。\ncrypto.createCipher()或crypto.createCipheriv()方法用于创建Cipher实例。Cipher对象不能直接使用new关键字创建。\n```javascript\n// 使用Cipher对象作为流\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = '';\ncipher.on('readable', () => {\n  const data = cipher.read();\n  if (data)\n    encrypted += data.toString('hex');\n});\ncipher.on('end', () => {\n  console.log(encrypted);\n  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n});\n\ncipher.write('some clear text data');\ncipher.end();\n\n// 使用Cipher和管道流\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nconst input = fs.createReadStream('test.js');\nconst output = fs.createWriteStream('test.enc');\n\ninput.pipe(cipher).pipe(output);\n\n// 使用cipher.update()和cipher.final()方法\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = cipher.update('some clear text data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n```\n\ncipher.final([outputEncoding])\noutputEncoding <string>\n返回任何加密的内容。如果 outputEncoding 参数是'latin1', 'base64' 或者 'hex'，返回字符串。 如果没有提供 outputEncoding，则返回Buffer。\n*一旦cipher.final()方法已被调用，Cipher 对象就不能再用于加密数据。如果试图再次调用cipher.final()，将会抛出一个错误。*\n\ncipher.setAAD(buffer)\nbuffer <Buffer>\n返回<Cipher>方法链。\n当使用经过验证的加密模式(目前只支持GCM)时，cipher.setAAD()方法设置用于additional authenticated data(附加验证的data(AAD))输入参数的值。\n*cipher.setAAD()法必须在cipher.update()之前调用。*\n\ncipher.getAuthTag()#\n当使用经验证的加密模式时(目前只有GCM支持),cipher.getAuthTag()方法返回一个Buffer，此Buffer包含已从给定数据计算后的authentication tag。 \n*cipher.getAuthTag()方法只能在使用cipher.final()方法完全加密后调用。*\n\ncipher.setAutoPadding([autoPadding])\nautoPadding <boolean> 默认为 true.\n返回<Cipher>方法链。\n当使用块加密算法时，Cipher类会自动添加padding到输入数据中，来适配相应块大小。可调用cipher.setAutoPadding(false)禁用默认padding。\n当autoPadding是false时，整个输入数据的长度必须是cipher块大小的倍数，否则cipher.final()将抛出一个错误。 禁用自动填充对于非标准填充是有用的，例如使用0x0代替PKCS填充。\n*cipher.setAutoPadding()必须在cipher.final()之前被调用。*\n\ncipher.update(data[, inputEncoding][, outputEncoding])\n用data更新密码。如果给出了inputEncoding的论证，它的值必须是'utf8', 'ascii', 或者'latin1'，而data参数是使用指定编码的字符串。如果不给出inputEncoding的参数，则data必须是Buffer，TypedArray， 或者DataView。如果data是一个Buffer，TypedArray， 或者 DataView， 那么inputEncoding就被忽略了。\noutputEncoding指定了加密数据的输出格式，可以是'latin1'， 'base64' 或者 'hex'。如果指定了outputEncoding，则返回使用指定编码的字符串。如果没有outputEncoding被提供，会返回Buffer。\n*cipher.update()方法可以用新数据多次调用，直到cipher.final()被调用。在cipher.final()之后调用cipher.update()将抛出错误。*\n\n","source":"nodejs/nodejs-note-13.md","raw":"---\ntitle: nodejs基础知识(6)\ndate: 2023-01-03 18:04:15\ntags: [node, crypto (加密)]\n---\n\ncrypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。\n\n使用 require('crypto') 来访问该模块。\n```javascript\nconst crypto = require('crypto');\n```\n\n###### Class: Certificate\nSPKAC 最初是由 Netscape 实现的一种证书签名请求机制, 现在正式成为 HTML5's keygen element 的一部分.\ncrypto 模块提供 Certificate 类用于处理 SPKAC 数据. 最普遍的用法是处理 HTML5 keygen 元素 产生的输出. Node.js 内部使用 OpenSSL's SPKAC implementation 处理.\n\nnew crypto.Certificate()#\n可以使用 new 关键字或者调用 crypto.Certificate() 方法创建 Certificate 类的实例:\n```javascript\nconst crypto = require('crypto');\nconst cert1 = new crypto.Certificate();\nconst cert2 = crypto.Certificate();\n```\n\ncertificate.exportChallenge(spkac)\nspkac <string> | <Buffer> | <TypedArray> | <DataView>\n返回 <Buffer> 返回 spkac 数据结构的 challenge 部分，spkac 包含一个公钥和一个 challange。\n```javascript\nconst cert = require('crypto').Certificate();\nconst spkac = getSpkacSomehow();// 生成过程省略了，不存在这个函数，只是一种象征意义\nconst challenge = cert.exportChallenge(spkac);\nconsole.log(challenge.toString('utf8'));\n// Prints: the challenge as a UTF8 string\n```\n\ncertificate.exportPublicKey(spkac)\nspkac <string> | <Buffer> | <TypedArray> | <DataView>\n返回 <Buffer> 数据结构的公钥部分，spkac 包含一个公钥和一个 challange。\n```javascript\nconst cert = require('crypto').Certificate();\nconst spkac = getSpkacSomehow();// 生成过程省略了，不存在这个函数，只是一种象征意义\nconst publicKey = cert.exportPublicKey(spkac);\nconsole.log(publicKey);\n// Prints: the public key as <Buffer ...>\n```\n\ncertificate.verifySpkac(spkac)\nspkac <Buffer> | <TypedArray> | <DataView>\n返回 <boolean> 如果 spkac 数据结构是有效的返回 true，否则返回 false。\n```javascript\nconst cert = require('crypto').Certificate();\nconst spkac = getSpkacSomehow();\nconsole.log(cert.verifySpkac(Buffer.from(spkac)));\n// Prints: true 或者 false\n```\n\n###### Class: Cipher\nCipher类的实例用于加密数据。这个类可以用在以下两种方法中的一种:\n- 作为stream，既可读又可写，未加密数据的编写是为了在可读的方面生成加密的数据\n- 使用cipher.update()和cipher.final()方法产生加密的数据。\ncrypto.createCipher()或crypto.createCipheriv()方法用于创建Cipher实例。Cipher对象不能直接使用new关键字创建。\n```javascript\n// 使用Cipher对象作为流\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = '';\ncipher.on('readable', () => {\n  const data = cipher.read();\n  if (data)\n    encrypted += data.toString('hex');\n});\ncipher.on('end', () => {\n  console.log(encrypted);\n  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n});\n\ncipher.write('some clear text data');\ncipher.end();\n\n// 使用Cipher和管道流\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nconst input = fs.createReadStream('test.js');\nconst output = fs.createWriteStream('test.enc');\n\ninput.pipe(cipher).pipe(output);\n\n// 使用cipher.update()和cipher.final()方法\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = cipher.update('some clear text data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n```\n\ncipher.final([outputEncoding])\noutputEncoding <string>\n返回任何加密的内容。如果 outputEncoding 参数是'latin1', 'base64' 或者 'hex'，返回字符串。 如果没有提供 outputEncoding，则返回Buffer。\n*一旦cipher.final()方法已被调用，Cipher 对象就不能再用于加密数据。如果试图再次调用cipher.final()，将会抛出一个错误。*\n\ncipher.setAAD(buffer)\nbuffer <Buffer>\n返回<Cipher>方法链。\n当使用经过验证的加密模式(目前只支持GCM)时，cipher.setAAD()方法设置用于additional authenticated data(附加验证的data(AAD))输入参数的值。\n*cipher.setAAD()法必须在cipher.update()之前调用。*\n\ncipher.getAuthTag()#\n当使用经验证的加密模式时(目前只有GCM支持),cipher.getAuthTag()方法返回一个Buffer，此Buffer包含已从给定数据计算后的authentication tag。 \n*cipher.getAuthTag()方法只能在使用cipher.final()方法完全加密后调用。*\n\ncipher.setAutoPadding([autoPadding])\nautoPadding <boolean> 默认为 true.\n返回<Cipher>方法链。\n当使用块加密算法时，Cipher类会自动添加padding到输入数据中，来适配相应块大小。可调用cipher.setAutoPadding(false)禁用默认padding。\n当autoPadding是false时，整个输入数据的长度必须是cipher块大小的倍数，否则cipher.final()将抛出一个错误。 禁用自动填充对于非标准填充是有用的，例如使用0x0代替PKCS填充。\n*cipher.setAutoPadding()必须在cipher.final()之前被调用。*\n\ncipher.update(data[, inputEncoding][, outputEncoding])\n用data更新密码。如果给出了inputEncoding的论证，它的值必须是'utf8', 'ascii', 或者'latin1'，而data参数是使用指定编码的字符串。如果不给出inputEncoding的参数，则data必须是Buffer，TypedArray， 或者DataView。如果data是一个Buffer，TypedArray， 或者 DataView， 那么inputEncoding就被忽略了。\noutputEncoding指定了加密数据的输出格式，可以是'latin1'， 'base64' 或者 'hex'。如果指定了outputEncoding，则返回使用指定编码的字符串。如果没有outputEncoding被提供，会返回Buffer。\n*cipher.update()方法可以用新数据多次调用，直到cipher.final()被调用。在cipher.final()之后调用cipher.update()将抛出错误。*\n\n","updated":"2023-01-04T09:37:40.464Z","path":"nodejs/nodejs-note-13.html","comments":1,"layout":"page","_id":"clchh4gwn000gcktt9sec782o","content":"<p>crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。</p>\n<p>使用 require(‘crypto’) 来访问该模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Class-Certificate\"><a href=\"#Class-Certificate\" class=\"headerlink\" title=\"Class: Certificate\"></a>Class: Certificate</h6><p>SPKAC 最初是由 Netscape 实现的一种证书签名请求机制, 现在正式成为 HTML5’s keygen element 的一部分.<br>crypto 模块提供 Certificate 类用于处理 SPKAC 数据. 最普遍的用法是处理 HTML5 keygen 元素 产生的输出. Node.js 内部使用 OpenSSL’s SPKAC implementation 处理.</p>\n<p>new crypto.Certificate()#<br>可以使用 new 关键字或者调用 crypto.Certificate() 方法创建 Certificate 类的实例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cert1 = <span class=\"keyword\">new</span> crypto.Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> cert2 = crypto.Certificate();</span><br></pre></td></tr></table></figure>\n\n<p>certificate.exportChallenge(spkac)<br>spkac <string> | <Buffer> | <TypedArray> | <DataView><br>返回 <Buffer> 返回 spkac 数据结构的 challenge 部分，spkac 包含一个公钥和一个 challange。</Buffer></DataView></TypedArray></Buffer></string></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>).Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> spkac = getSpkacSomehow();<span class=\"comment\">// 生成过程省略了，不存在这个函数，只是一种象征意义</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> challenge = cert.exportChallenge(spkac);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(challenge.toString(<span class=\"string\">&#x27;utf8&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// Prints: the challenge as a UTF8 string</span></span><br></pre></td></tr></table></figure>\n\n<p>certificate.exportPublicKey(spkac)<br>spkac <string> | <Buffer> | <TypedArray> | <DataView><br>返回 <Buffer> 数据结构的公钥部分，spkac 包含一个公钥和一个 challange。</Buffer></DataView></TypedArray></Buffer></string></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>).Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> spkac = getSpkacSomehow();<span class=\"comment\">// 生成过程省略了，不存在这个函数，只是一种象征意义</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> publicKey = cert.exportPublicKey(spkac);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(publicKey);</span><br><span class=\"line\"><span class=\"comment\">// Prints: the public key as &lt;Buffer ...&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>certificate.verifySpkac(spkac)<br>spkac <Buffer> | <TypedArray> | <DataView><br>返回 <boolean> 如果 spkac 数据结构是有效的返回 true，否则返回 false。</boolean></DataView></TypedArray></Buffer></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>).Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> spkac = getSpkacSomehow();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cert.verifySpkac(Buffer.from(spkac)));</span><br><span class=\"line\"><span class=\"comment\">// Prints: true 或者 false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Class-Cipher\"><a href=\"#Class-Cipher\" class=\"headerlink\" title=\"Class: Cipher\"></a>Class: Cipher</h6><p>Cipher类的实例用于加密数据。这个类可以用在以下两种方法中的一种:</p>\n<ul>\n<li>作为stream，既可读又可写，未加密数据的编写是为了在可读的方面生成加密的数据</li>\n<li>使用cipher.update()和cipher.final()方法产生加密的数据。<br>crypto.createCipher()或crypto.createCipheriv()方法用于创建Cipher实例。Cipher对象不能直接使用new关键字创建。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Cipher对象作为流</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cipher = crypto.createCipher(<span class=\"string\">&#x27;aes192&#x27;</span>, <span class=\"string\">&#x27;a password&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> encrypted = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">cipher.on(<span class=\"string\">&#x27;readable&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = cipher.read();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data)</span><br><span class=\"line\">    encrypted += data.toString(<span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cipher.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(encrypted);</span><br><span class=\"line\">  <span class=\"comment\">// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">cipher.write(<span class=\"string\">&#x27;some clear text data&#x27;</span>);</span><br><span class=\"line\">cipher.end();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Cipher和管道流</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cipher = crypto.createCipher(<span class=\"string\">&#x27;aes192&#x27;</span>, <span class=\"string\">&#x27;a password&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.createReadStream(<span class=\"string\">&#x27;test.js&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = fs.createWriteStream(<span class=\"string\">&#x27;test.enc&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">input.pipe(cipher).pipe(output);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用cipher.update()和cipher.final()方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cipher = crypto.createCipher(<span class=\"string\">&#x27;aes192&#x27;</span>, <span class=\"string\">&#x27;a password&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> encrypted = cipher.update(<span class=\"string\">&#x27;some clear text data&#x27;</span>, <span class=\"string\">&#x27;utf8&#x27;</span>, <span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\">encrypted += cipher.final(<span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(encrypted);</span><br><span class=\"line\"><span class=\"comment\">// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>cipher.final([outputEncoding])<br>outputEncoding <string><br>返回任何加密的内容。如果 outputEncoding 参数是’latin1’, ‘base64’ 或者 ‘hex’，返回字符串。 如果没有提供 outputEncoding，则返回Buffer。<br><em>一旦cipher.final()方法已被调用，Cipher 对象就不能再用于加密数据。如果试图再次调用cipher.final()，将会抛出一个错误。</em></string></p>\n<p>cipher.setAAD(buffer)<br>buffer <Buffer><br>返回<Cipher>方法链。<br>当使用经过验证的加密模式(目前只支持GCM)时，cipher.setAAD()方法设置用于additional authenticated data(附加验证的data(AAD))输入参数的值。<br><em>cipher.setAAD()法必须在cipher.update()之前调用。</em></Cipher></Buffer></p>\n<p>cipher.getAuthTag()#<br>当使用经验证的加密模式时(目前只有GCM支持),cipher.getAuthTag()方法返回一个Buffer，此Buffer包含已从给定数据计算后的authentication tag。<br><em>cipher.getAuthTag()方法只能在使用cipher.final()方法完全加密后调用。</em></p>\n<p>cipher.setAutoPadding([autoPadding])<br>autoPadding <boolean> 默认为 true.<br>返回<Cipher>方法链。<br>当使用块加密算法时，Cipher类会自动添加padding到输入数据中，来适配相应块大小。可调用cipher.setAutoPadding(false)禁用默认padding。<br>当autoPadding是false时，整个输入数据的长度必须是cipher块大小的倍数，否则cipher.final()将抛出一个错误。 禁用自动填充对于非标准填充是有用的，例如使用0x0代替PKCS填充。<br><em>cipher.setAutoPadding()必须在cipher.final()之前被调用。</em></Cipher></boolean></p>\n<p>cipher.update(data[, inputEncoding][, outputEncoding])<br>用data更新密码。如果给出了inputEncoding的论证，它的值必须是’utf8’, ‘ascii’, 或者’latin1’，而data参数是使用指定编码的字符串。如果不给出inputEncoding的参数，则data必须是Buffer，TypedArray， 或者DataView。如果data是一个Buffer，TypedArray， 或者 DataView， 那么inputEncoding就被忽略了。<br>outputEncoding指定了加密数据的输出格式，可以是’latin1’， ‘base64’ 或者 ‘hex’。如果指定了outputEncoding，则返回使用指定编码的字符串。如果没有outputEncoding被提供，会返回Buffer。<br><em>cipher.update()方法可以用新数据多次调用，直到cipher.final()被调用。在cipher.final()之后调用cipher.update()将抛出错误。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。</p>\n<p>使用 require(‘crypto’) 来访问该模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Class-Certificate\"><a href=\"#Class-Certificate\" class=\"headerlink\" title=\"Class: Certificate\"></a>Class: Certificate</h6><p>SPKAC 最初是由 Netscape 实现的一种证书签名请求机制, 现在正式成为 HTML5’s keygen element 的一部分.<br>crypto 模块提供 Certificate 类用于处理 SPKAC 数据. 最普遍的用法是处理 HTML5 keygen 元素 产生的输出. Node.js 内部使用 OpenSSL’s SPKAC implementation 处理.</p>\n<p>new crypto.Certificate()#<br>可以使用 new 关键字或者调用 crypto.Certificate() 方法创建 Certificate 类的实例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cert1 = <span class=\"keyword\">new</span> crypto.Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> cert2 = crypto.Certificate();</span><br></pre></td></tr></table></figure>\n\n<p>certificate.exportChallenge(spkac)<br>spkac <string> | <Buffer> | <TypedArray> | <DataView><br>返回 <Buffer> 返回 spkac 数据结构的 challenge 部分，spkac 包含一个公钥和一个 challange。</Buffer></DataView></TypedArray></Buffer></string></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>).Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> spkac = getSpkacSomehow();<span class=\"comment\">// 生成过程省略了，不存在这个函数，只是一种象征意义</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> challenge = cert.exportChallenge(spkac);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(challenge.toString(<span class=\"string\">&#x27;utf8&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// Prints: the challenge as a UTF8 string</span></span><br></pre></td></tr></table></figure>\n\n<p>certificate.exportPublicKey(spkac)<br>spkac <string> | <Buffer> | <TypedArray> | <DataView><br>返回 <Buffer> 数据结构的公钥部分，spkac 包含一个公钥和一个 challange。</Buffer></DataView></TypedArray></Buffer></string></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>).Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> spkac = getSpkacSomehow();<span class=\"comment\">// 生成过程省略了，不存在这个函数，只是一种象征意义</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> publicKey = cert.exportPublicKey(spkac);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(publicKey);</span><br><span class=\"line\"><span class=\"comment\">// Prints: the public key as &lt;Buffer ...&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>certificate.verifySpkac(spkac)<br>spkac <Buffer> | <TypedArray> | <DataView><br>返回 <boolean> 如果 spkac 数据结构是有效的返回 true，否则返回 false。</boolean></DataView></TypedArray></Buffer></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>).Certificate();</span><br><span class=\"line\"><span class=\"keyword\">const</span> spkac = getSpkacSomehow();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cert.verifySpkac(Buffer.from(spkac)));</span><br><span class=\"line\"><span class=\"comment\">// Prints: true 或者 false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Class-Cipher\"><a href=\"#Class-Cipher\" class=\"headerlink\" title=\"Class: Cipher\"></a>Class: Cipher</h6><p>Cipher类的实例用于加密数据。这个类可以用在以下两种方法中的一种:</p>\n<ul>\n<li>作为stream，既可读又可写，未加密数据的编写是为了在可读的方面生成加密的数据</li>\n<li>使用cipher.update()和cipher.final()方法产生加密的数据。<br>crypto.createCipher()或crypto.createCipheriv()方法用于创建Cipher实例。Cipher对象不能直接使用new关键字创建。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Cipher对象作为流</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cipher = crypto.createCipher(<span class=\"string\">&#x27;aes192&#x27;</span>, <span class=\"string\">&#x27;a password&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> encrypted = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">cipher.on(<span class=\"string\">&#x27;readable&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = cipher.read();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data)</span><br><span class=\"line\">    encrypted += data.toString(<span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cipher.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(encrypted);</span><br><span class=\"line\">  <span class=\"comment\">// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">cipher.write(<span class=\"string\">&#x27;some clear text data&#x27;</span>);</span><br><span class=\"line\">cipher.end();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Cipher和管道流</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cipher = crypto.createCipher(<span class=\"string\">&#x27;aes192&#x27;</span>, <span class=\"string\">&#x27;a password&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = fs.createReadStream(<span class=\"string\">&#x27;test.js&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = fs.createWriteStream(<span class=\"string\">&#x27;test.enc&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">input.pipe(cipher).pipe(output);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用cipher.update()和cipher.final()方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> crypto = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;crypto&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cipher = crypto.createCipher(<span class=\"string\">&#x27;aes192&#x27;</span>, <span class=\"string\">&#x27;a password&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> encrypted = cipher.update(<span class=\"string\">&#x27;some clear text data&#x27;</span>, <span class=\"string\">&#x27;utf8&#x27;</span>, <span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\">encrypted += cipher.final(<span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(encrypted);</span><br><span class=\"line\"><span class=\"comment\">// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>cipher.final([outputEncoding])<br>outputEncoding <string><br>返回任何加密的内容。如果 outputEncoding 参数是’latin1’, ‘base64’ 或者 ‘hex’，返回字符串。 如果没有提供 outputEncoding，则返回Buffer。<br><em>一旦cipher.final()方法已被调用，Cipher 对象就不能再用于加密数据。如果试图再次调用cipher.final()，将会抛出一个错误。</em></string></p>\n<p>cipher.setAAD(buffer)<br>buffer <Buffer><br>返回<Cipher>方法链。<br>当使用经过验证的加密模式(目前只支持GCM)时，cipher.setAAD()方法设置用于additional authenticated data(附加验证的data(AAD))输入参数的值。<br><em>cipher.setAAD()法必须在cipher.update()之前调用。</em></Cipher></Buffer></p>\n<p>cipher.getAuthTag()#<br>当使用经验证的加密模式时(目前只有GCM支持),cipher.getAuthTag()方法返回一个Buffer，此Buffer包含已从给定数据计算后的authentication tag。<br><em>cipher.getAuthTag()方法只能在使用cipher.final()方法完全加密后调用。</em></p>\n<p>cipher.setAutoPadding([autoPadding])<br>autoPadding <boolean> 默认为 true.<br>返回<Cipher>方法链。<br>当使用块加密算法时，Cipher类会自动添加padding到输入数据中，来适配相应块大小。可调用cipher.setAutoPadding(false)禁用默认padding。<br>当autoPadding是false时，整个输入数据的长度必须是cipher块大小的倍数，否则cipher.final()将抛出一个错误。 禁用自动填充对于非标准填充是有用的，例如使用0x0代替PKCS填充。<br><em>cipher.setAutoPadding()必须在cipher.final()之前被调用。</em></Cipher></boolean></p>\n<p>cipher.update(data[, inputEncoding][, outputEncoding])<br>用data更新密码。如果给出了inputEncoding的论证，它的值必须是’utf8’, ‘ascii’, 或者’latin1’，而data参数是使用指定编码的字符串。如果不给出inputEncoding的参数，则data必须是Buffer，TypedArray， 或者DataView。如果data是一个Buffer，TypedArray， 或者 DataView， 那么inputEncoding就被忽略了。<br>outputEncoding指定了加密数据的输出格式，可以是’latin1’， ‘base64’ 或者 ‘hex’。如果指定了outputEncoding，则返回使用指定编码的字符串。如果没有outputEncoding被提供，会返回Buffer。<br><em>cipher.update()方法可以用新数据多次调用，直到cipher.final()被调用。在cipher.final()之后调用cipher.update()将抛出错误。</em></p>\n"},{"title":"nodejs基础知识(4)","date":"2022-12-30T08:27:30.000Z","tags":["node","cluster - 集群"],"_content":"\nNode.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。\n\ncluster 模块允许简单容易的创建共享服务器端口的子进程。\n```\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`主进程 ${process.pid} 正在运行`);\n\n  // 衍生工作进程。\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`工作进程 ${worker.process.pid} 已退出`);\n  });\n} else {\n  // 工作进程可以共享任何 TCP 连接。\n  // 在本例子中，共享的是一个 HTTP 服务器。\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('你好世界\\n');\n  }).listen(8000);\n\n  console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\ncluster模块支持两种连接分发模式（将新连接安排给某一工作进程处理）。\n\n第一种方法（也是除Windows外所有平台的默认方法），是循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程。在分发中使用了一些内置技巧防止工作进程任务过载。\n\n第二种方法是，主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接。\n\n理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。我们遇到过这种情况：8个进程中的2个，分担了70%的负载。\n\n**Class: Worker**\nWorker对象包含了关于工作进程的所有public信息和方法。\n在一个主进程里，可以使用cluster.workers来获取Worker对象。\n在一个工作进程里，可以使用cluster.worker来获取Worker对象。\n\n**Event: 'disconnect'**\n虽然与 cluster.on('disconnect')事件 是相似的,但是这个进程又有其他特征。\n```\ncluster.fork().on('disconnect', () => {\n  // Worker has disconnected\n});\n```\n\n**Event: 'error'**\n此事件和 child_process.fork()提供的error事件相同。\n在一个工作进程中，可以使用process.on('error')\n\n**Event: 'exit'**\n- code <number> 若正常退出，表示退出代码.\n- signal <string> 引发进程被kill的信号名称（如'SIGHUP'）.\n和cluster.on('exit')事件类似，但针对特定的工作进程。\n```\nconst worker = cluster.fork();\nworker.on('exit', (code, signal) => {\n  if (signal) {\n    console.log(`worker was killed by signal: ${signal}`);\n  } else if (code !== 0) {\n    console.log(`worker exited with error code: ${code}`);\n  } else {\n    console.log('worker success!');\n  }\n});\n```\n\n**Event: 'listening'**\naddress <Object>\n和cluster.on('listening')事件类似，但针对特定的工作进程。\n本事件不会在工作进程内触发。\n\n**Event: 'message'**\nmessage <Object>\nhandle <undefined> | <Object>\n和cluster.on('message')事件类似，但针对特定的工作进程。\n在工作进程内，可以使用process.on('message')\n```\nconst cluster = require('cluster');\nconst http = require('http');\n\nif (cluster.isMaster) {\n\n  // 跟踪 http 请求\n  let numReqs = 0;\n  setInterval(() => {\n    console.log(`numReqs = ${numReqs}`);\n  }, 1000);\n\n  // 计算请求数目\n  function messageHandler(msg) {\n    if (msg.cmd && msg.cmd === 'notifyRequest') {\n      numReqs += 1;\n    }\n  }\n\n  // 启动 worker 并监听包含 notifyRequest 的消息\n  const numCPUs = require('os').cpus().length;\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  for (const id in cluster.workers) {\n    cluster.workers[id].on('message', messageHandler);\n  }\n\n} else {\n\n  // Worker 进程有一个http服务器\n  http.Server((req, res) => {\n    res.writeHead(200);\n    res.end('hello world\\n');\n\n    // 通知 master 进程接收到了请求\n    process.send({ cmd: 'notifyRequest' });\n  }).listen(8000);\n}\n```\n\n**Event: 'online'**\n和cluster.on('online')事件类似，但针对特定的工作进程。\n本事件不会在工作进程内部被触发。\n\n**worker.disconnect()**\nReturns: <Worker> 一个 worker 的引用。\n在一个工作进程内，调用此方法会关闭所有的server，并等待这些server的 'close'事件执行，然后关闭IPC管道。\n\n在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用.disconnect()。\n\n会设置.exitedAfterDisconnect 。\n\n需要注意的是，当一个server关闭后，它将不再接收新的连接，但新连接会被其他正在监听的工作进程接收。已建立的连接可以正常关闭。当所有连接都关闭后，通往该工作进程的IPC管道将会关闭，允许工作进程优雅地死掉\n\n需要注意的是，我们这里的方法是disconnect，同时还有一个不一样的方法process.disconnect，大家不要混淆了\n\n**worker.exitedAfterDisconnect**\n<boolean>\n当调用 .kill() 或者 .disconnect()方法时被设置，在这之前都是 undefined。\nworker.exitedAfterDisconnect可以用于区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程。\n*与worker.suicide等价*\n\n**worker.id**\n<number>\n每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在id里面。\n当工作进程还存活时，id可以作为在cluster.workers中的索引。\n\n**worker.isConnected()**\n当工作进程通过IPC管道连接至主进程时，这个方法返回true，否则返回false。\n一个工作进程在创建后会自动连接到它的主进程，当'disconnect' 事件被触发时才会断开连接。\n\n**worker.isDead()**\n当工作进程被终止时（包括自动退出或被发送信号），这个方法返回true ，否则返回false。\n\n**worker.kill([signal='SIGTERM'])**\nsignal <string> 被发送kill信号的工作进程名称。\n这个方法将会kill工作进程。在主进程中，通过断开与worker.process的连接来实现，一旦断开连接后，通过signal来杀死工作进程。在工作进程中，通过断开IPC管道来实现，然后以代码0退出进程。\n将导致.exitedAfterDisconnect被设置。\n为向后兼容，这个方法与worker.destroy()等义。\n需要注意的是，在工作进程中有一个方法process.kill() ，这个方法本方法不同，本方法是kill。\n\n**worker.process**\n<ChildProcess>\n所有的工作进程都是通过child_process.fork()来创建的，这个方法返回的对象被存储为.process。在工作进程中， process属于全局对象。\n需要注意：当process上发生 'disconnect'事件，并且.exitedAfterDisconnect的值不是true时，工作进程会调用 process.exit(0)。这样就可以防止连接意外断开。\n\n**worker.send(message[, sendHandle][, callback])**\n发送一个消息给工作进程或主进程，也可以附带发送一个handle。\n主进程调用这个方法会发送消息给具体的工作进程。还有一个等价的方法是ChildProcess.send()。\n工作进程调用这个方法会发送消息给主进程。还有一个等价方法是process.send()。\n\n**Event: 'disconnect'**\nworker <cluster.Worker>\n在工作进程的IPC管道被断开后触发本事件。可能导致事件触发的原因包括：工作进程优雅地退出、被kill或手动断开连接（如调用worker.disconnect()）。\n'disconnect' 和 'exit'事件之间可能存在延迟。这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。\n\n**Event: 'exit'**\nworker <cluster.Worker>\ncode <number> 正常退出情况下，是退出代码.\nsignal <string> 导致进程被kill的信号名称 (例如 'SIGHUP')\n当任何一个工作进程关闭的时候，cluster模块都将触发'exit'事件。\n可以被用来重启工作进程（通过调用.fork()）\n```\ncluster.on('exit', (worker, code, signal) => {\n  console.log('worker %d died (%s). restarting...',\n              worker.process.pid, signal || code);\n  cluster.fork();\n});\n```\n\n**Event: 'fork'**\nworker <cluster.Worker>\n当新的工作进程被fork时，cluster模块将触发'fork'事件。 可以被用来记录工作进程活动，产生一个自定义的timeout。\n\n**Event: 'listening'**\nworker <cluster.Worker>\naddress <Object>\n当一个工作进程调用listen()后，工作进程上的server会触发'listening' 事件，同时主进程上的 cluster 也会被触发'listening'事件。\n事件处理器使用两个参数来执行，其中worker包含了工作进程对象，address 包含了以下连接属性： address、port 和 addressType。当工作进程同时监听多个地址时，这些参数非常有用。\naddressType 可选值包括:\n- 4 (TCPv4)\n- 6 (TCPv6)\n- -1 (unix domain socket)\n- \"udp4\" or \"udp6\" (UDP v4 or v6)\n\n**Event: 'message'**\nworker <cluster.Worker>\nmessage <Object>\nhandle <undefined> | <Object>\n当cluster主进程接收任意工作进程发送的消息后被触发。\n\n**Event: 'online'**\nworker <cluster.Worker>\n当新建一个工作进程后，工作进程应当响应一个online消息给主进程。当主进程收到online消息后触发这个事件。 'fork' 事件和 'online'事件的不同之处在于，前者是在主进程新建工作进程后触发，而后者是在工作进程运行的时候触发。\n\n**Event: 'setup'**\nsettings <Object>\n每当 .setupMaster() 被调用的时候触发。\nsettings 对象是 setupMaster() 被调用时的 cluster.settings 对象，并且只能查询，因为在一个 tick 内 .setupMaster() 可以被调用多次。\n如果精确度十分重要，请使用 cluster.settings。\n\n**cluster.disconnect([callback])**\ncallback <Function> 当所有工作进程都断开连接并且所有handle关闭的时候调用。\n在cluster.workers的每个工作进程中调用 .disconnect()。\n当所有工作进程断开连接后，所有内部handle将会关闭，这个时候如果没有等待事件的话，运行主进程优雅地关闭。\n这个方法可以选择添加一个回调参数，当结束时会调用这个回调函数。\n这个方法只能由主进程调用。\n\n**cluster.fork([env])**\nenv <Object> 增加进程环境变量，以Key/value对的形式。\nreturn <cluster.Worker>\n衍生出一个新的工作进程。\n只能通过主进程调用。\n\n**cluster.isMaster**\n<boolean>\n当该进程是主进程时，返回 true。这是由process.env.NODE_UNIQUE_ID决定的，当process.env.NODE_UNIQUE_ID未定义时，isMaster为true。\n\n**cluster.isWorker**\n<boolean>\n当进程不是主进程时，返回 true。（和cluster.isMaster刚好相反）\n\n**cluster.schedulingPolicy**\n调度策略，包括循环计数的 cluster.SCHED_RR，以及由操作系统决定的cluster.SCHED_NONE。 这是一个全局设置，当第一个工作进程被衍生或者调动cluster.setupMaster()时，都将第一时间生效。\n\n**cluster.settings**\n<Object>\nexecArgv <Array> 传递给Node.js可执行文件的参数列表。 (Default=process.execArgv)\nexec <string> worker文件路径。 (Default=process.argv[1])\nargs <Array> 传递给worker的参数。(Default=process.argv.slice(2))\nsilent <boolean> 是否需要发送输出值父进程的stdio。(Default=false)\nstdio <Array> 配置fork进程的stdio。 由于cluster模块运行依赖于IPC，这个配置必须包含'ipc'。当提供了这个选项后，将撤销silent。\nuid <number> 设置进程的user标识符。 (见 setuid(2).)\ngid <number> 设置进程的group标识符。 (见 setgid(2).)\ninspectPort <number> | <function> Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number. By default each worker gets its own port, incremented from the master's process.debugPort.\n调用.setupMaster() (或 .fork())后，这个settings对象将会包含这些设置项，包括默认值。\n这个对象不打算被修改或手动设置。\n\n**cluster.setupMaster([settings])**\nsettings <Object> 详见 cluster.settings。\n用于修改默认'fork' 行为。一旦调用，将会按照cluster.settings进行设置。\n*只能由主进程调用*\n注意:\n- 所有的设置只对后来的 .fork()调用有效，对之前的工作进程无影响。\n- 唯一无法通过 .setupMaster()设置的属性是传递给.fork()的env属性。\n- 上述的默认值只在第一次调用时有效，当后续调用时，将采用cluster.setupMaster()调用时的当前值。\n```\nconst cluster = require('cluster');\ncluster.setupMaster({\n  exec: 'worker.js',\n  args: ['--use', 'https'],\n  silent: true\n});\ncluster.fork(); // https worker\ncluster.setupMaster({\n  exec: 'worker.js',\n  args: ['--use', 'http']\n});\ncluster.fork(); // http worker\n```\n\n**cluster.worker**\n<Object>\n当前工作进程对象的引用，对于主进程则无效。\n\n**cluster.workers**\n<Object>\n这是一个哈希表，储存了活跃的工作进程对象，id作为key。有了它，可以方便地遍历所有工作进程。只能在主进程中调用。\n\n工作进程断开连接以及退出后，将会从cluster.workers里面移除。这两个事件的先后顺序并不能预先确定，但可以保证的是， cluster.workers的移除工作在'disconnect' 和 'exit'两个事件中的最后一个触发之前完成。","source":"nodejs/nodejs-note-11.md","raw":"---\ntitle: nodejs基础知识(4)\ndate: 2022-12-30 16:27:30\ntags: [node, cluster - 集群]\n---\n\nNode.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。\n\ncluster 模块允许简单容易的创建共享服务器端口的子进程。\n```\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`主进程 ${process.pid} 正在运行`);\n\n  // 衍生工作进程。\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`工作进程 ${worker.process.pid} 已退出`);\n  });\n} else {\n  // 工作进程可以共享任何 TCP 连接。\n  // 在本例子中，共享的是一个 HTTP 服务器。\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('你好世界\\n');\n  }).listen(8000);\n\n  console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\ncluster模块支持两种连接分发模式（将新连接安排给某一工作进程处理）。\n\n第一种方法（也是除Windows外所有平台的默认方法），是循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程。在分发中使用了一些内置技巧防止工作进程任务过载。\n\n第二种方法是，主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接。\n\n理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。我们遇到过这种情况：8个进程中的2个，分担了70%的负载。\n\n**Class: Worker**\nWorker对象包含了关于工作进程的所有public信息和方法。\n在一个主进程里，可以使用cluster.workers来获取Worker对象。\n在一个工作进程里，可以使用cluster.worker来获取Worker对象。\n\n**Event: 'disconnect'**\n虽然与 cluster.on('disconnect')事件 是相似的,但是这个进程又有其他特征。\n```\ncluster.fork().on('disconnect', () => {\n  // Worker has disconnected\n});\n```\n\n**Event: 'error'**\n此事件和 child_process.fork()提供的error事件相同。\n在一个工作进程中，可以使用process.on('error')\n\n**Event: 'exit'**\n- code <number> 若正常退出，表示退出代码.\n- signal <string> 引发进程被kill的信号名称（如'SIGHUP'）.\n和cluster.on('exit')事件类似，但针对特定的工作进程。\n```\nconst worker = cluster.fork();\nworker.on('exit', (code, signal) => {\n  if (signal) {\n    console.log(`worker was killed by signal: ${signal}`);\n  } else if (code !== 0) {\n    console.log(`worker exited with error code: ${code}`);\n  } else {\n    console.log('worker success!');\n  }\n});\n```\n\n**Event: 'listening'**\naddress <Object>\n和cluster.on('listening')事件类似，但针对特定的工作进程。\n本事件不会在工作进程内触发。\n\n**Event: 'message'**\nmessage <Object>\nhandle <undefined> | <Object>\n和cluster.on('message')事件类似，但针对特定的工作进程。\n在工作进程内，可以使用process.on('message')\n```\nconst cluster = require('cluster');\nconst http = require('http');\n\nif (cluster.isMaster) {\n\n  // 跟踪 http 请求\n  let numReqs = 0;\n  setInterval(() => {\n    console.log(`numReqs = ${numReqs}`);\n  }, 1000);\n\n  // 计算请求数目\n  function messageHandler(msg) {\n    if (msg.cmd && msg.cmd === 'notifyRequest') {\n      numReqs += 1;\n    }\n  }\n\n  // 启动 worker 并监听包含 notifyRequest 的消息\n  const numCPUs = require('os').cpus().length;\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  for (const id in cluster.workers) {\n    cluster.workers[id].on('message', messageHandler);\n  }\n\n} else {\n\n  // Worker 进程有一个http服务器\n  http.Server((req, res) => {\n    res.writeHead(200);\n    res.end('hello world\\n');\n\n    // 通知 master 进程接收到了请求\n    process.send({ cmd: 'notifyRequest' });\n  }).listen(8000);\n}\n```\n\n**Event: 'online'**\n和cluster.on('online')事件类似，但针对特定的工作进程。\n本事件不会在工作进程内部被触发。\n\n**worker.disconnect()**\nReturns: <Worker> 一个 worker 的引用。\n在一个工作进程内，调用此方法会关闭所有的server，并等待这些server的 'close'事件执行，然后关闭IPC管道。\n\n在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用.disconnect()。\n\n会设置.exitedAfterDisconnect 。\n\n需要注意的是，当一个server关闭后，它将不再接收新的连接，但新连接会被其他正在监听的工作进程接收。已建立的连接可以正常关闭。当所有连接都关闭后，通往该工作进程的IPC管道将会关闭，允许工作进程优雅地死掉\n\n需要注意的是，我们这里的方法是disconnect，同时还有一个不一样的方法process.disconnect，大家不要混淆了\n\n**worker.exitedAfterDisconnect**\n<boolean>\n当调用 .kill() 或者 .disconnect()方法时被设置，在这之前都是 undefined。\nworker.exitedAfterDisconnect可以用于区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程。\n*与worker.suicide等价*\n\n**worker.id**\n<number>\n每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在id里面。\n当工作进程还存活时，id可以作为在cluster.workers中的索引。\n\n**worker.isConnected()**\n当工作进程通过IPC管道连接至主进程时，这个方法返回true，否则返回false。\n一个工作进程在创建后会自动连接到它的主进程，当'disconnect' 事件被触发时才会断开连接。\n\n**worker.isDead()**\n当工作进程被终止时（包括自动退出或被发送信号），这个方法返回true ，否则返回false。\n\n**worker.kill([signal='SIGTERM'])**\nsignal <string> 被发送kill信号的工作进程名称。\n这个方法将会kill工作进程。在主进程中，通过断开与worker.process的连接来实现，一旦断开连接后，通过signal来杀死工作进程。在工作进程中，通过断开IPC管道来实现，然后以代码0退出进程。\n将导致.exitedAfterDisconnect被设置。\n为向后兼容，这个方法与worker.destroy()等义。\n需要注意的是，在工作进程中有一个方法process.kill() ，这个方法本方法不同，本方法是kill。\n\n**worker.process**\n<ChildProcess>\n所有的工作进程都是通过child_process.fork()来创建的，这个方法返回的对象被存储为.process。在工作进程中， process属于全局对象。\n需要注意：当process上发生 'disconnect'事件，并且.exitedAfterDisconnect的值不是true时，工作进程会调用 process.exit(0)。这样就可以防止连接意外断开。\n\n**worker.send(message[, sendHandle][, callback])**\n发送一个消息给工作进程或主进程，也可以附带发送一个handle。\n主进程调用这个方法会发送消息给具体的工作进程。还有一个等价的方法是ChildProcess.send()。\n工作进程调用这个方法会发送消息给主进程。还有一个等价方法是process.send()。\n\n**Event: 'disconnect'**\nworker <cluster.Worker>\n在工作进程的IPC管道被断开后触发本事件。可能导致事件触发的原因包括：工作进程优雅地退出、被kill或手动断开连接（如调用worker.disconnect()）。\n'disconnect' 和 'exit'事件之间可能存在延迟。这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。\n\n**Event: 'exit'**\nworker <cluster.Worker>\ncode <number> 正常退出情况下，是退出代码.\nsignal <string> 导致进程被kill的信号名称 (例如 'SIGHUP')\n当任何一个工作进程关闭的时候，cluster模块都将触发'exit'事件。\n可以被用来重启工作进程（通过调用.fork()）\n```\ncluster.on('exit', (worker, code, signal) => {\n  console.log('worker %d died (%s). restarting...',\n              worker.process.pid, signal || code);\n  cluster.fork();\n});\n```\n\n**Event: 'fork'**\nworker <cluster.Worker>\n当新的工作进程被fork时，cluster模块将触发'fork'事件。 可以被用来记录工作进程活动，产生一个自定义的timeout。\n\n**Event: 'listening'**\nworker <cluster.Worker>\naddress <Object>\n当一个工作进程调用listen()后，工作进程上的server会触发'listening' 事件，同时主进程上的 cluster 也会被触发'listening'事件。\n事件处理器使用两个参数来执行，其中worker包含了工作进程对象，address 包含了以下连接属性： address、port 和 addressType。当工作进程同时监听多个地址时，这些参数非常有用。\naddressType 可选值包括:\n- 4 (TCPv4)\n- 6 (TCPv6)\n- -1 (unix domain socket)\n- \"udp4\" or \"udp6\" (UDP v4 or v6)\n\n**Event: 'message'**\nworker <cluster.Worker>\nmessage <Object>\nhandle <undefined> | <Object>\n当cluster主进程接收任意工作进程发送的消息后被触发。\n\n**Event: 'online'**\nworker <cluster.Worker>\n当新建一个工作进程后，工作进程应当响应一个online消息给主进程。当主进程收到online消息后触发这个事件。 'fork' 事件和 'online'事件的不同之处在于，前者是在主进程新建工作进程后触发，而后者是在工作进程运行的时候触发。\n\n**Event: 'setup'**\nsettings <Object>\n每当 .setupMaster() 被调用的时候触发。\nsettings 对象是 setupMaster() 被调用时的 cluster.settings 对象，并且只能查询，因为在一个 tick 内 .setupMaster() 可以被调用多次。\n如果精确度十分重要，请使用 cluster.settings。\n\n**cluster.disconnect([callback])**\ncallback <Function> 当所有工作进程都断开连接并且所有handle关闭的时候调用。\n在cluster.workers的每个工作进程中调用 .disconnect()。\n当所有工作进程断开连接后，所有内部handle将会关闭，这个时候如果没有等待事件的话，运行主进程优雅地关闭。\n这个方法可以选择添加一个回调参数，当结束时会调用这个回调函数。\n这个方法只能由主进程调用。\n\n**cluster.fork([env])**\nenv <Object> 增加进程环境变量，以Key/value对的形式。\nreturn <cluster.Worker>\n衍生出一个新的工作进程。\n只能通过主进程调用。\n\n**cluster.isMaster**\n<boolean>\n当该进程是主进程时，返回 true。这是由process.env.NODE_UNIQUE_ID决定的，当process.env.NODE_UNIQUE_ID未定义时，isMaster为true。\n\n**cluster.isWorker**\n<boolean>\n当进程不是主进程时，返回 true。（和cluster.isMaster刚好相反）\n\n**cluster.schedulingPolicy**\n调度策略，包括循环计数的 cluster.SCHED_RR，以及由操作系统决定的cluster.SCHED_NONE。 这是一个全局设置，当第一个工作进程被衍生或者调动cluster.setupMaster()时，都将第一时间生效。\n\n**cluster.settings**\n<Object>\nexecArgv <Array> 传递给Node.js可执行文件的参数列表。 (Default=process.execArgv)\nexec <string> worker文件路径。 (Default=process.argv[1])\nargs <Array> 传递给worker的参数。(Default=process.argv.slice(2))\nsilent <boolean> 是否需要发送输出值父进程的stdio。(Default=false)\nstdio <Array> 配置fork进程的stdio。 由于cluster模块运行依赖于IPC，这个配置必须包含'ipc'。当提供了这个选项后，将撤销silent。\nuid <number> 设置进程的user标识符。 (见 setuid(2).)\ngid <number> 设置进程的group标识符。 (见 setgid(2).)\ninspectPort <number> | <function> Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number. By default each worker gets its own port, incremented from the master's process.debugPort.\n调用.setupMaster() (或 .fork())后，这个settings对象将会包含这些设置项，包括默认值。\n这个对象不打算被修改或手动设置。\n\n**cluster.setupMaster([settings])**\nsettings <Object> 详见 cluster.settings。\n用于修改默认'fork' 行为。一旦调用，将会按照cluster.settings进行设置。\n*只能由主进程调用*\n注意:\n- 所有的设置只对后来的 .fork()调用有效，对之前的工作进程无影响。\n- 唯一无法通过 .setupMaster()设置的属性是传递给.fork()的env属性。\n- 上述的默认值只在第一次调用时有效，当后续调用时，将采用cluster.setupMaster()调用时的当前值。\n```\nconst cluster = require('cluster');\ncluster.setupMaster({\n  exec: 'worker.js',\n  args: ['--use', 'https'],\n  silent: true\n});\ncluster.fork(); // https worker\ncluster.setupMaster({\n  exec: 'worker.js',\n  args: ['--use', 'http']\n});\ncluster.fork(); // http worker\n```\n\n**cluster.worker**\n<Object>\n当前工作进程对象的引用，对于主进程则无效。\n\n**cluster.workers**\n<Object>\n这是一个哈希表，储存了活跃的工作进程对象，id作为key。有了它，可以方便地遍历所有工作进程。只能在主进程中调用。\n\n工作进程断开连接以及退出后，将会从cluster.workers里面移除。这两个事件的先后顺序并不能预先确定，但可以保证的是， cluster.workers的移除工作在'disconnect' 和 'exit'两个事件中的最后一个触发之前完成。","updated":"2022-12-30T09:51:16.757Z","path":"nodejs/nodejs-note-11.html","comments":1,"layout":"page","_id":"clchh4gwo000ickttfo8takwp","content":"<p>Node.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。</p>\n<p>cluster 模块允许简单容易的创建共享服务器端口的子进程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;);</span><br><span class=\"line\">const http = require(&#x27;http&#x27;);</span><br><span class=\"line\">const numCPUs = require(&#x27;os&#x27;).cpus().length;</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\">  console.log(`主进程 $&#123;process.pid&#125; 正在运行`);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 衍生工作进程。</span><br><span class=\"line\">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class=\"line\">    cluster.fork();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class=\"line\">    console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  // 工作进程可以共享任何 TCP 连接。</span><br><span class=\"line\">  // 在本例子中，共享的是一个 HTTP 服务器。</span><br><span class=\"line\">  http.createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">    res.writeHead(200);</span><br><span class=\"line\">    res.end(&#x27;你好世界\\n&#x27;);</span><br><span class=\"line\">  &#125;).listen(8000);</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(`工作进程 $&#123;process.pid&#125; 已启动`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>cluster模块支持两种连接分发模式（将新连接安排给某一工作进程处理）。</p>\n<p>第一种方法（也是除Windows外所有平台的默认方法），是循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程。在分发中使用了一些内置技巧防止工作进程任务过载。</p>\n<p>第二种方法是，主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接。</p>\n<p>理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。我们遇到过这种情况：8个进程中的2个，分担了70%的负载。</p>\n<p><strong>Class: Worker</strong><br>Worker对象包含了关于工作进程的所有public信息和方法。<br>在一个主进程里，可以使用cluster.workers来获取Worker对象。<br>在一个工作进程里，可以使用cluster.worker来获取Worker对象。</p>\n<p><strong>Event: ‘disconnect’</strong><br>虽然与 cluster.on(‘disconnect’)事件 是相似的,但是这个进程又有其他特征。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.fork().on(&#x27;disconnect&#x27;, () =&gt; &#123;</span><br><span class=\"line\">  // Worker has disconnected</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Event: ‘error’</strong><br>此事件和 child_process.fork()提供的error事件相同。<br>在一个工作进程中，可以使用process.on(‘error’)</p>\n<p><strong>Event: ‘exit’</strong></p>\n<ul>\n<li>code <number> 若正常退出，表示退出代码.</number></li>\n<li>signal <string> 引发进程被kill的信号名称（如’SIGHUP’）.<br>和cluster.on(‘exit’)事件类似，但针对特定的工作进程。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const worker = cluster.fork();</span><br><span class=\"line\">worker.on(&#x27;exit&#x27;, (code, signal) =&gt; &#123;</span><br><span class=\"line\">  if (signal) &#123;</span><br><span class=\"line\">    console.log(`worker was killed by signal: $&#123;signal&#125;`);</span><br><span class=\"line\">  &#125; else if (code !== 0) &#123;</span><br><span class=\"line\">    console.log(`worker exited with error code: $&#123;code&#125;`);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&#x27;worker success!&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></string></li>\n</ul>\n<p><strong>Event: ‘listening’</strong><br>address <Object><br>和cluster.on(‘listening’)事件类似，但针对特定的工作进程。<br>本事件不会在工作进程内触发。</Object></p>\n<p><strong>Event: ‘message’</strong><br>message <Object><br>handle <undefined> | <Object><br>和cluster.on(‘message’)事件类似，但针对特定的工作进程。<br>在工作进程内，可以使用process.on(‘message’)</Object></undefined></Object></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;);</span><br><span class=\"line\">const http = require(&#x27;http&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 跟踪 http 请求</span><br><span class=\"line\">  let numReqs = 0;</span><br><span class=\"line\">  setInterval(() =&gt; &#123;</span><br><span class=\"line\">    console.log(`numReqs = $&#123;numReqs&#125;`);</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 计算请求数目</span><br><span class=\"line\">  function messageHandler(msg) &#123;</span><br><span class=\"line\">    if (msg.cmd &amp;&amp; msg.cmd === &#x27;notifyRequest&#x27;) &#123;</span><br><span class=\"line\">      numReqs += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 启动 worker 并监听包含 notifyRequest 的消息</span><br><span class=\"line\">  const numCPUs = require(&#x27;os&#x27;).cpus().length;</span><br><span class=\"line\">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class=\"line\">    cluster.fork();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (const id in cluster.workers) &#123;</span><br><span class=\"line\">    cluster.workers[id].on(&#x27;message&#x27;, messageHandler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Worker 进程有一个http服务器</span><br><span class=\"line\">  http.Server((req, res) =&gt; &#123;</span><br><span class=\"line\">    res.writeHead(200);</span><br><span class=\"line\">    res.end(&#x27;hello world\\n&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通知 master 进程接收到了请求</span><br><span class=\"line\">    process.send(&#123; cmd: &#x27;notifyRequest&#x27; &#125;);</span><br><span class=\"line\">  &#125;).listen(8000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Event: ‘online’</strong><br>和cluster.on(‘online’)事件类似，但针对特定的工作进程。<br>本事件不会在工作进程内部被触发。</p>\n<p><strong>worker.disconnect()</strong><br>Returns: <Worker> 一个 worker 的引用。<br>在一个工作进程内，调用此方法会关闭所有的server，并等待这些server的 ‘close’事件执行，然后关闭IPC管道。</Worker></p>\n<p>在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用.disconnect()。</p>\n<p>会设置.exitedAfterDisconnect 。</p>\n<p>需要注意的是，当一个server关闭后，它将不再接收新的连接，但新连接会被其他正在监听的工作进程接收。已建立的连接可以正常关闭。当所有连接都关闭后，通往该工作进程的IPC管道将会关闭，允许工作进程优雅地死掉</p>\n<p>需要注意的是，我们这里的方法是disconnect，同时还有一个不一样的方法process.disconnect，大家不要混淆了</p>\n<p><strong>worker.exitedAfterDisconnect</strong><br><boolean><br>当调用 .kill() 或者 .disconnect()方法时被设置，在这之前都是 undefined。<br>worker.exitedAfterDisconnect可以用于区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程。<br><em>与worker.suicide等价</em></boolean></p>\n<p><strong>worker.id</strong><br><number><br>每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在id里面。<br>当工作进程还存活时，id可以作为在cluster.workers中的索引。</number></p>\n<p><strong>worker.isConnected()</strong><br>当工作进程通过IPC管道连接至主进程时，这个方法返回true，否则返回false。<br>一个工作进程在创建后会自动连接到它的主进程，当’disconnect’ 事件被触发时才会断开连接。</p>\n<p><strong>worker.isDead()</strong><br>当工作进程被终止时（包括自动退出或被发送信号），这个方法返回true ，否则返回false。</p>\n<p><strong>worker.kill([signal=’SIGTERM’])</strong><br>signal <string> 被发送kill信号的工作进程名称。<br>这个方法将会kill工作进程。在主进程中，通过断开与worker.process的连接来实现，一旦断开连接后，通过signal来杀死工作进程。在工作进程中，通过断开IPC管道来实现，然后以代码0退出进程。<br>将导致.exitedAfterDisconnect被设置。<br>为向后兼容，这个方法与worker.destroy()等义。<br>需要注意的是，在工作进程中有一个方法process.kill() ，这个方法本方法不同，本方法是kill。</string></p>\n<p><strong>worker.process</strong><br><ChildProcess><br>所有的工作进程都是通过child_process.fork()来创建的，这个方法返回的对象被存储为.process。在工作进程中， process属于全局对象。<br>需要注意：当process上发生 ‘disconnect’事件，并且.exitedAfterDisconnect的值不是true时，工作进程会调用 process.exit(0)。这样就可以防止连接意外断开。</ChildProcess></p>\n<p><strong>worker.send(message[, sendHandle][, callback])</strong><br>发送一个消息给工作进程或主进程，也可以附带发送一个handle。<br>主进程调用这个方法会发送消息给具体的工作进程。还有一个等价的方法是ChildProcess.send()。<br>工作进程调用这个方法会发送消息给主进程。还有一个等价方法是process.send()。</p>\n<p><strong>Event: ‘disconnect’</strong><br>worker &lt;cluster.Worker&gt;<br>在工作进程的IPC管道被断开后触发本事件。可能导致事件触发的原因包括：工作进程优雅地退出、被kill或手动断开连接（如调用worker.disconnect()）。<br>‘disconnect’ 和 ‘exit’事件之间可能存在延迟。这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。</p>\n<p><strong>Event: ‘exit’</strong><br>worker &lt;cluster.Worker&gt;<br>code <number> 正常退出情况下，是退出代码.<br>signal <string> 导致进程被kill的信号名称 (例如 ‘SIGHUP’)<br>当任何一个工作进程关闭的时候，cluster模块都将触发’exit’事件。<br>可以被用来重启工作进程（通过调用.fork()）</string></number></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;worker %d died (%s). restarting...&#x27;,</span><br><span class=\"line\">              worker.process.pid, signal || code);</span><br><span class=\"line\">  cluster.fork();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Event: ‘fork’</strong><br>worker &lt;cluster.Worker&gt;<br>当新的工作进程被fork时，cluster模块将触发’fork’事件。 可以被用来记录工作进程活动，产生一个自定义的timeout。</p>\n<p><strong>Event: ‘listening’</strong><br>worker &lt;cluster.Worker&gt;<br>address <Object><br>当一个工作进程调用listen()后，工作进程上的server会触发’listening’ 事件，同时主进程上的 cluster 也会被触发’listening’事件。<br>事件处理器使用两个参数来执行，其中worker包含了工作进程对象，address 包含了以下连接属性： address、port 和 addressType。当工作进程同时监听多个地址时，这些参数非常有用。<br>addressType 可选值包括:</Object></p>\n<ul>\n<li>4 (TCPv4)</li>\n<li>6 (TCPv6)</li>\n<li>-1 (unix domain socket)</li>\n<li>“udp4” or “udp6” (UDP v4 or v6)</li>\n</ul>\n<p><strong>Event: ‘message’</strong><br>worker &lt;cluster.Worker&gt;<br>message <Object><br>handle <undefined> | <Object><br>当cluster主进程接收任意工作进程发送的消息后被触发。</Object></undefined></Object></p>\n<p><strong>Event: ‘online’</strong><br>worker &lt;cluster.Worker&gt;<br>当新建一个工作进程后，工作进程应当响应一个online消息给主进程。当主进程收到online消息后触发这个事件。 ‘fork’ 事件和 ‘online’事件的不同之处在于，前者是在主进程新建工作进程后触发，而后者是在工作进程运行的时候触发。</p>\n<p><strong>Event: ‘setup’</strong><br>settings <Object><br>每当 .setupMaster() 被调用的时候触发。<br>settings 对象是 setupMaster() 被调用时的 cluster.settings 对象，并且只能查询，因为在一个 tick 内 .setupMaster() 可以被调用多次。<br>如果精确度十分重要，请使用 cluster.settings。</Object></p>\n<p><strong>cluster.disconnect([callback])</strong><br>callback <Function> 当所有工作进程都断开连接并且所有handle关闭的时候调用。<br>在cluster.workers的每个工作进程中调用 .disconnect()。<br>当所有工作进程断开连接后，所有内部handle将会关闭，这个时候如果没有等待事件的话，运行主进程优雅地关闭。<br>这个方法可以选择添加一个回调参数，当结束时会调用这个回调函数。<br>这个方法只能由主进程调用。</Function></p>\n<p><strong>cluster.fork([env])</strong><br>env <Object> 增加进程环境变量，以Key/value对的形式。<br>return &lt;cluster.Worker&gt;<br>衍生出一个新的工作进程。<br>只能通过主进程调用。</Object></p>\n<p><strong>cluster.isMaster</strong><br><boolean><br>当该进程是主进程时，返回 true。这是由process.env.NODE_UNIQUE_ID决定的，当process.env.NODE_UNIQUE_ID未定义时，isMaster为true。</boolean></p>\n<p><strong>cluster.isWorker</strong><br><boolean><br>当进程不是主进程时，返回 true。（和cluster.isMaster刚好相反）</boolean></p>\n<p><strong>cluster.schedulingPolicy</strong><br>调度策略，包括循环计数的 cluster.SCHED_RR，以及由操作系统决定的cluster.SCHED_NONE。 这是一个全局设置，当第一个工作进程被衍生或者调动cluster.setupMaster()时，都将第一时间生效。</p>\n<p><strong>cluster.settings</strong><br><Object><br>execArgv <Array> 传递给Node.js可执行文件的参数列表。 (Default=process.execArgv)<br>exec <string> worker文件路径。 (Default=process.argv[1])<br>args <Array> 传递给worker的参数。(Default=process.argv.slice(2))<br>silent <boolean> 是否需要发送输出值父进程的stdio。(Default=false)<br>stdio <Array> 配置fork进程的stdio。 由于cluster模块运行依赖于IPC，这个配置必须包含’ipc’。当提供了这个选项后，将撤销silent。<br>uid <number> 设置进程的user标识符。 (见 setuid(2).)<br>gid <number> 设置进程的group标识符。 (见 setgid(2).)<br>inspectPort <number> | <function> Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number. By default each worker gets its own port, incremented from the master’s process.debugPort.<br>调用.setupMaster() (或 .fork())后，这个settings对象将会包含这些设置项，包括默认值。<br>这个对象不打算被修改或手动设置。</function></number></number></number></Array></boolean></Array></string></Array></Object></p>\n<p><strong>cluster.setupMaster([settings])</strong><br>settings <Object> 详见 cluster.settings。<br>用于修改默认’fork’ 行为。一旦调用，将会按照cluster.settings进行设置。<br><em>只能由主进程调用</em><br>注意:</Object></p>\n<ul>\n<li>所有的设置只对后来的 .fork()调用有效，对之前的工作进程无影响。</li>\n<li>唯一无法通过 .setupMaster()设置的属性是传递给.fork()的env属性。</li>\n<li>上述的默认值只在第一次调用时有效，当后续调用时，将采用cluster.setupMaster()调用时的当前值。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;);</span><br><span class=\"line\">cluster.setupMaster(&#123;</span><br><span class=\"line\">  exec: &#x27;worker.js&#x27;,</span><br><span class=\"line\">  args: [&#x27;--use&#x27;, &#x27;https&#x27;],</span><br><span class=\"line\">  silent: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cluster.fork(); // https worker</span><br><span class=\"line\">cluster.setupMaster(&#123;</span><br><span class=\"line\">  exec: &#x27;worker.js&#x27;,</span><br><span class=\"line\">  args: [&#x27;--use&#x27;, &#x27;http&#x27;]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cluster.fork(); // http worker</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>cluster.worker</strong><br><Object><br>当前工作进程对象的引用，对于主进程则无效。</Object></p>\n<p><strong>cluster.workers</strong><br><Object><br>这是一个哈希表，储存了活跃的工作进程对象，id作为key。有了它，可以方便地遍历所有工作进程。只能在主进程中调用。</Object></p>\n<p>工作进程断开连接以及退出后，将会从cluster.workers里面移除。这两个事件的先后顺序并不能预先确定，但可以保证的是， cluster.workers的移除工作在’disconnect’ 和 ‘exit’两个事件中的最后一个触发之前完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Node.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。</p>\n<p>cluster 模块允许简单容易的创建共享服务器端口的子进程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;);</span><br><span class=\"line\">const http = require(&#x27;http&#x27;);</span><br><span class=\"line\">const numCPUs = require(&#x27;os&#x27;).cpus().length;</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\">  console.log(`主进程 $&#123;process.pid&#125; 正在运行`);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 衍生工作进程。</span><br><span class=\"line\">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class=\"line\">    cluster.fork();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class=\"line\">    console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  // 工作进程可以共享任何 TCP 连接。</span><br><span class=\"line\">  // 在本例子中，共享的是一个 HTTP 服务器。</span><br><span class=\"line\">  http.createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">    res.writeHead(200);</span><br><span class=\"line\">    res.end(&#x27;你好世界\\n&#x27;);</span><br><span class=\"line\">  &#125;).listen(8000);</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(`工作进程 $&#123;process.pid&#125; 已启动`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>cluster模块支持两种连接分发模式（将新连接安排给某一工作进程处理）。</p>\n<p>第一种方法（也是除Windows外所有平台的默认方法），是循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程。在分发中使用了一些内置技巧防止工作进程任务过载。</p>\n<p>第二种方法是，主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接。</p>\n<p>理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。我们遇到过这种情况：8个进程中的2个，分担了70%的负载。</p>\n<p><strong>Class: Worker</strong><br>Worker对象包含了关于工作进程的所有public信息和方法。<br>在一个主进程里，可以使用cluster.workers来获取Worker对象。<br>在一个工作进程里，可以使用cluster.worker来获取Worker对象。</p>\n<p><strong>Event: ‘disconnect’</strong><br>虽然与 cluster.on(‘disconnect’)事件 是相似的,但是这个进程又有其他特征。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.fork().on(&#x27;disconnect&#x27;, () =&gt; &#123;</span><br><span class=\"line\">  // Worker has disconnected</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Event: ‘error’</strong><br>此事件和 child_process.fork()提供的error事件相同。<br>在一个工作进程中，可以使用process.on(‘error’)</p>\n<p><strong>Event: ‘exit’</strong></p>\n<ul>\n<li>code <number> 若正常退出，表示退出代码.</number></li>\n<li>signal <string> 引发进程被kill的信号名称（如’SIGHUP’）.<br>和cluster.on(‘exit’)事件类似，但针对特定的工作进程。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const worker = cluster.fork();</span><br><span class=\"line\">worker.on(&#x27;exit&#x27;, (code, signal) =&gt; &#123;</span><br><span class=\"line\">  if (signal) &#123;</span><br><span class=\"line\">    console.log(`worker was killed by signal: $&#123;signal&#125;`);</span><br><span class=\"line\">  &#125; else if (code !== 0) &#123;</span><br><span class=\"line\">    console.log(`worker exited with error code: $&#123;code&#125;`);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&#x27;worker success!&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></string></li>\n</ul>\n<p><strong>Event: ‘listening’</strong><br>address <Object><br>和cluster.on(‘listening’)事件类似，但针对特定的工作进程。<br>本事件不会在工作进程内触发。</Object></p>\n<p><strong>Event: ‘message’</strong><br>message <Object><br>handle <undefined> | <Object><br>和cluster.on(‘message’)事件类似，但针对特定的工作进程。<br>在工作进程内，可以使用process.on(‘message’)</Object></undefined></Object></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;);</span><br><span class=\"line\">const http = require(&#x27;http&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 跟踪 http 请求</span><br><span class=\"line\">  let numReqs = 0;</span><br><span class=\"line\">  setInterval(() =&gt; &#123;</span><br><span class=\"line\">    console.log(`numReqs = $&#123;numReqs&#125;`);</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 计算请求数目</span><br><span class=\"line\">  function messageHandler(msg) &#123;</span><br><span class=\"line\">    if (msg.cmd &amp;&amp; msg.cmd === &#x27;notifyRequest&#x27;) &#123;</span><br><span class=\"line\">      numReqs += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 启动 worker 并监听包含 notifyRequest 的消息</span><br><span class=\"line\">  const numCPUs = require(&#x27;os&#x27;).cpus().length;</span><br><span class=\"line\">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class=\"line\">    cluster.fork();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (const id in cluster.workers) &#123;</span><br><span class=\"line\">    cluster.workers[id].on(&#x27;message&#x27;, messageHandler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Worker 进程有一个http服务器</span><br><span class=\"line\">  http.Server((req, res) =&gt; &#123;</span><br><span class=\"line\">    res.writeHead(200);</span><br><span class=\"line\">    res.end(&#x27;hello world\\n&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通知 master 进程接收到了请求</span><br><span class=\"line\">    process.send(&#123; cmd: &#x27;notifyRequest&#x27; &#125;);</span><br><span class=\"line\">  &#125;).listen(8000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Event: ‘online’</strong><br>和cluster.on(‘online’)事件类似，但针对特定的工作进程。<br>本事件不会在工作进程内部被触发。</p>\n<p><strong>worker.disconnect()</strong><br>Returns: <Worker> 一个 worker 的引用。<br>在一个工作进程内，调用此方法会关闭所有的server，并等待这些server的 ‘close’事件执行，然后关闭IPC管道。</Worker></p>\n<p>在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用.disconnect()。</p>\n<p>会设置.exitedAfterDisconnect 。</p>\n<p>需要注意的是，当一个server关闭后，它将不再接收新的连接，但新连接会被其他正在监听的工作进程接收。已建立的连接可以正常关闭。当所有连接都关闭后，通往该工作进程的IPC管道将会关闭，允许工作进程优雅地死掉</p>\n<p>需要注意的是，我们这里的方法是disconnect，同时还有一个不一样的方法process.disconnect，大家不要混淆了</p>\n<p><strong>worker.exitedAfterDisconnect</strong><br><boolean><br>当调用 .kill() 或者 .disconnect()方法时被设置，在这之前都是 undefined。<br>worker.exitedAfterDisconnect可以用于区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程。<br><em>与worker.suicide等价</em></boolean></p>\n<p><strong>worker.id</strong><br><number><br>每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在id里面。<br>当工作进程还存活时，id可以作为在cluster.workers中的索引。</number></p>\n<p><strong>worker.isConnected()</strong><br>当工作进程通过IPC管道连接至主进程时，这个方法返回true，否则返回false。<br>一个工作进程在创建后会自动连接到它的主进程，当’disconnect’ 事件被触发时才会断开连接。</p>\n<p><strong>worker.isDead()</strong><br>当工作进程被终止时（包括自动退出或被发送信号），这个方法返回true ，否则返回false。</p>\n<p><strong>worker.kill([signal=’SIGTERM’])</strong><br>signal <string> 被发送kill信号的工作进程名称。<br>这个方法将会kill工作进程。在主进程中，通过断开与worker.process的连接来实现，一旦断开连接后，通过signal来杀死工作进程。在工作进程中，通过断开IPC管道来实现，然后以代码0退出进程。<br>将导致.exitedAfterDisconnect被设置。<br>为向后兼容，这个方法与worker.destroy()等义。<br>需要注意的是，在工作进程中有一个方法process.kill() ，这个方法本方法不同，本方法是kill。</string></p>\n<p><strong>worker.process</strong><br><ChildProcess><br>所有的工作进程都是通过child_process.fork()来创建的，这个方法返回的对象被存储为.process。在工作进程中， process属于全局对象。<br>需要注意：当process上发生 ‘disconnect’事件，并且.exitedAfterDisconnect的值不是true时，工作进程会调用 process.exit(0)。这样就可以防止连接意外断开。</ChildProcess></p>\n<p><strong>worker.send(message[, sendHandle][, callback])</strong><br>发送一个消息给工作进程或主进程，也可以附带发送一个handle。<br>主进程调用这个方法会发送消息给具体的工作进程。还有一个等价的方法是ChildProcess.send()。<br>工作进程调用这个方法会发送消息给主进程。还有一个等价方法是process.send()。</p>\n<p><strong>Event: ‘disconnect’</strong><br>worker &lt;cluster.Worker&gt;<br>在工作进程的IPC管道被断开后触发本事件。可能导致事件触发的原因包括：工作进程优雅地退出、被kill或手动断开连接（如调用worker.disconnect()）。<br>‘disconnect’ 和 ‘exit’事件之间可能存在延迟。这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。</p>\n<p><strong>Event: ‘exit’</strong><br>worker &lt;cluster.Worker&gt;<br>code <number> 正常退出情况下，是退出代码.<br>signal <string> 导致进程被kill的信号名称 (例如 ‘SIGHUP’)<br>当任何一个工作进程关闭的时候，cluster模块都将触发’exit’事件。<br>可以被用来重启工作进程（通过调用.fork()）</string></number></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;worker %d died (%s). restarting...&#x27;,</span><br><span class=\"line\">              worker.process.pid, signal || code);</span><br><span class=\"line\">  cluster.fork();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Event: ‘fork’</strong><br>worker &lt;cluster.Worker&gt;<br>当新的工作进程被fork时，cluster模块将触发’fork’事件。 可以被用来记录工作进程活动，产生一个自定义的timeout。</p>\n<p><strong>Event: ‘listening’</strong><br>worker &lt;cluster.Worker&gt;<br>address <Object><br>当一个工作进程调用listen()后，工作进程上的server会触发’listening’ 事件，同时主进程上的 cluster 也会被触发’listening’事件。<br>事件处理器使用两个参数来执行，其中worker包含了工作进程对象，address 包含了以下连接属性： address、port 和 addressType。当工作进程同时监听多个地址时，这些参数非常有用。<br>addressType 可选值包括:</Object></p>\n<ul>\n<li>4 (TCPv4)</li>\n<li>6 (TCPv6)</li>\n<li>-1 (unix domain socket)</li>\n<li>“udp4” or “udp6” (UDP v4 or v6)</li>\n</ul>\n<p><strong>Event: ‘message’</strong><br>worker &lt;cluster.Worker&gt;<br>message <Object><br>handle <undefined> | <Object><br>当cluster主进程接收任意工作进程发送的消息后被触发。</Object></undefined></Object></p>\n<p><strong>Event: ‘online’</strong><br>worker &lt;cluster.Worker&gt;<br>当新建一个工作进程后，工作进程应当响应一个online消息给主进程。当主进程收到online消息后触发这个事件。 ‘fork’ 事件和 ‘online’事件的不同之处在于，前者是在主进程新建工作进程后触发，而后者是在工作进程运行的时候触发。</p>\n<p><strong>Event: ‘setup’</strong><br>settings <Object><br>每当 .setupMaster() 被调用的时候触发。<br>settings 对象是 setupMaster() 被调用时的 cluster.settings 对象，并且只能查询，因为在一个 tick 内 .setupMaster() 可以被调用多次。<br>如果精确度十分重要，请使用 cluster.settings。</Object></p>\n<p><strong>cluster.disconnect([callback])</strong><br>callback <Function> 当所有工作进程都断开连接并且所有handle关闭的时候调用。<br>在cluster.workers的每个工作进程中调用 .disconnect()。<br>当所有工作进程断开连接后，所有内部handle将会关闭，这个时候如果没有等待事件的话，运行主进程优雅地关闭。<br>这个方法可以选择添加一个回调参数，当结束时会调用这个回调函数。<br>这个方法只能由主进程调用。</Function></p>\n<p><strong>cluster.fork([env])</strong><br>env <Object> 增加进程环境变量，以Key/value对的形式。<br>return &lt;cluster.Worker&gt;<br>衍生出一个新的工作进程。<br>只能通过主进程调用。</Object></p>\n<p><strong>cluster.isMaster</strong><br><boolean><br>当该进程是主进程时，返回 true。这是由process.env.NODE_UNIQUE_ID决定的，当process.env.NODE_UNIQUE_ID未定义时，isMaster为true。</boolean></p>\n<p><strong>cluster.isWorker</strong><br><boolean><br>当进程不是主进程时，返回 true。（和cluster.isMaster刚好相反）</boolean></p>\n<p><strong>cluster.schedulingPolicy</strong><br>调度策略，包括循环计数的 cluster.SCHED_RR，以及由操作系统决定的cluster.SCHED_NONE。 这是一个全局设置，当第一个工作进程被衍生或者调动cluster.setupMaster()时，都将第一时间生效。</p>\n<p><strong>cluster.settings</strong><br><Object><br>execArgv <Array> 传递给Node.js可执行文件的参数列表。 (Default=process.execArgv)<br>exec <string> worker文件路径。 (Default=process.argv[1])<br>args <Array> 传递给worker的参数。(Default=process.argv.slice(2))<br>silent <boolean> 是否需要发送输出值父进程的stdio。(Default=false)<br>stdio <Array> 配置fork进程的stdio。 由于cluster模块运行依赖于IPC，这个配置必须包含’ipc’。当提供了这个选项后，将撤销silent。<br>uid <number> 设置进程的user标识符。 (见 setuid(2).)<br>gid <number> 设置进程的group标识符。 (见 setgid(2).)<br>inspectPort <number> | <function> Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number. By default each worker gets its own port, incremented from the master’s process.debugPort.<br>调用.setupMaster() (或 .fork())后，这个settings对象将会包含这些设置项，包括默认值。<br>这个对象不打算被修改或手动设置。</function></number></number></number></Array></boolean></Array></string></Array></Object></p>\n<p><strong>cluster.setupMaster([settings])</strong><br>settings <Object> 详见 cluster.settings。<br>用于修改默认’fork’ 行为。一旦调用，将会按照cluster.settings进行设置。<br><em>只能由主进程调用</em><br>注意:</Object></p>\n<ul>\n<li>所有的设置只对后来的 .fork()调用有效，对之前的工作进程无影响。</li>\n<li>唯一无法通过 .setupMaster()设置的属性是传递给.fork()的env属性。</li>\n<li>上述的默认值只在第一次调用时有效，当后续调用时，将采用cluster.setupMaster()调用时的当前值。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;);</span><br><span class=\"line\">cluster.setupMaster(&#123;</span><br><span class=\"line\">  exec: &#x27;worker.js&#x27;,</span><br><span class=\"line\">  args: [&#x27;--use&#x27;, &#x27;https&#x27;],</span><br><span class=\"line\">  silent: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cluster.fork(); // https worker</span><br><span class=\"line\">cluster.setupMaster(&#123;</span><br><span class=\"line\">  exec: &#x27;worker.js&#x27;,</span><br><span class=\"line\">  args: [&#x27;--use&#x27;, &#x27;http&#x27;]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cluster.fork(); // http worker</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>cluster.worker</strong><br><Object><br>当前工作进程对象的引用，对于主进程则无效。</Object></p>\n<p><strong>cluster.workers</strong><br><Object><br>这是一个哈希表，储存了活跃的工作进程对象，id作为key。有了它，可以方便地遍历所有工作进程。只能在主进程中调用。</Object></p>\n<p>工作进程断开连接以及退出后，将会从cluster.workers里面移除。这两个事件的先后顺序并不能预先确定，但可以保证的是， cluster.workers的移除工作在’disconnect’ 和 ‘exit’两个事件中的最后一个触发之前完成。</p>\n"},{"title":"使用nvm安装多版本node","date":"2022-12-16T05:21:49.000Z","tags":null,"_content":"\n###### 前言\n大家在日常开发中，偶尔会遇到因为node不兼容导致的问题，这时候怎么办？相信大家常用的解决手段是卸载当前用的node，去[官网](https://nodejs.org/zh-cn/)重新下一个新的可兼容的版本重新安装。确实，这种方法可以解决遇到的问题，但是如果兼容版本是低版本怎么办？切换一个项目，兼容版本又不兼容了怎么办？或许会有人说再卸载再换。。。。。。但是不觉得这样太繁琐了吗？下面为大家介绍一种使用版本管理工具，安装不同版本的方式，实现不用手动卸载，紧靠命令即可下载、安装、切换、卸载不同版本的node。\n\n###### nvm--node版本管理工具\n**注意：安装nvm之前一定要先将原本安装的node卸载，删除node相关文件**\n1、下载nvm\n[nvm下载地址](https://github.com/coreybutler/nvm-windows/releases)\n![下载nvm](images/nvm-download.png)\ngithub上有不同的安装包，大家可以根据自己的需要进行下载安装\n\n2、安装nvm\n*注意：安装目录不能出现中文、空格等，否则可能导致安装失败或者安装后找不到nvm等问题*\n\n安装成功之后，使用cmd打开命令提示符，输入nvm，出现下图中的信息，表示安装成功\n![安装成功](images/nvm-install.png)\n\n3、修改配置\n找到nvm的安装目录，找到setting.txt文件，打开文件后，将下面的地址增加到文件中\n![配置文件](images/nvm-setting.png)\n```\nnode_mirror: https://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n```\n![配置文件内容](images/nvm-setting-content.png)\n\n4、使用nvm\n- 安装指定版本node\n```javascript\nnvm install [--version]\n// eg: nvm install 18.12\n```\n- 使用/切换指定版本node\n```javascript\nnvm use [--version]\n// eg: nvm use 18.12\n```\n- 卸载指定版本node\n```javascript\nnvm uninstall [--version]\n// eg: nvm uninstall 18.12\n```\n- 查看已下载及当前使用node版本\n```javascript\nnvm ls\n```\n\n###### 错误处理\n1、安装nvm之后，查看node版本，提示拒绝访问\n解决办法：卸载nvm，查看时候有nodejs文件残留，将残留文件删除\n\n2、使用nvm use切换不同版本的node失败\n解决办法：使用管理员权限运行命令提示符\n\n3、安装nvm成功，可以正常切换不同版本node，但是在vscode的终端里查看node版本，提示node不是内部或外部命令。。。。\n解决办法：em...本人遇到这个问题是因为安装nvm之前卸载node之后，把git也卸载了，不过安装git之后，重新安装nvm还是有这个问题，一段时间后重新安装nvm，安装成功了。。。。。。本人猜测是因为卸载了git导致的问题，注意：*安装nvm之前，卸载node就行了，不要卸载git*","source":"nodejs/install-diff-version-node-by-nvm.md","raw":"---\ntitle: 使用nvm安装多版本node\ndate: 2022-12-16 13:21:49\ntags:\n---\n\n###### 前言\n大家在日常开发中，偶尔会遇到因为node不兼容导致的问题，这时候怎么办？相信大家常用的解决手段是卸载当前用的node，去[官网](https://nodejs.org/zh-cn/)重新下一个新的可兼容的版本重新安装。确实，这种方法可以解决遇到的问题，但是如果兼容版本是低版本怎么办？切换一个项目，兼容版本又不兼容了怎么办？或许会有人说再卸载再换。。。。。。但是不觉得这样太繁琐了吗？下面为大家介绍一种使用版本管理工具，安装不同版本的方式，实现不用手动卸载，紧靠命令即可下载、安装、切换、卸载不同版本的node。\n\n###### nvm--node版本管理工具\n**注意：安装nvm之前一定要先将原本安装的node卸载，删除node相关文件**\n1、下载nvm\n[nvm下载地址](https://github.com/coreybutler/nvm-windows/releases)\n![下载nvm](images/nvm-download.png)\ngithub上有不同的安装包，大家可以根据自己的需要进行下载安装\n\n2、安装nvm\n*注意：安装目录不能出现中文、空格等，否则可能导致安装失败或者安装后找不到nvm等问题*\n\n安装成功之后，使用cmd打开命令提示符，输入nvm，出现下图中的信息，表示安装成功\n![安装成功](images/nvm-install.png)\n\n3、修改配置\n找到nvm的安装目录，找到setting.txt文件，打开文件后，将下面的地址增加到文件中\n![配置文件](images/nvm-setting.png)\n```\nnode_mirror: https://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n```\n![配置文件内容](images/nvm-setting-content.png)\n\n4、使用nvm\n- 安装指定版本node\n```javascript\nnvm install [--version]\n// eg: nvm install 18.12\n```\n- 使用/切换指定版本node\n```javascript\nnvm use [--version]\n// eg: nvm use 18.12\n```\n- 卸载指定版本node\n```javascript\nnvm uninstall [--version]\n// eg: nvm uninstall 18.12\n```\n- 查看已下载及当前使用node版本\n```javascript\nnvm ls\n```\n\n###### 错误处理\n1、安装nvm之后，查看node版本，提示拒绝访问\n解决办法：卸载nvm，查看时候有nodejs文件残留，将残留文件删除\n\n2、使用nvm use切换不同版本的node失败\n解决办法：使用管理员权限运行命令提示符\n\n3、安装nvm成功，可以正常切换不同版本node，但是在vscode的终端里查看node版本，提示node不是内部或外部命令。。。。\n解决办法：em...本人遇到这个问题是因为安装nvm之前卸载node之后，把git也卸载了，不过安装git之后，重新安装nvm还是有这个问题，一段时间后重新安装nvm，安装成功了。。。。。。本人猜测是因为卸载了git导致的问题，注意：*安装nvm之前，卸载node就行了，不要卸载git*","updated":"2022-12-16T06:57:06.867Z","path":"nodejs/install-diff-version-node-by-nvm.html","comments":1,"layout":"page","_id":"clchh4gwq000kcktt4w2nfl2r","content":"<h6 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h6><p>大家在日常开发中，偶尔会遇到因为node不兼容导致的问题，这时候怎么办？相信大家常用的解决手段是卸载当前用的node，去<a href=\"https://nodejs.org/zh-cn/\">官网</a>重新下一个新的可兼容的版本重新安装。确实，这种方法可以解决遇到的问题，但是如果兼容版本是低版本怎么办？切换一个项目，兼容版本又不兼容了怎么办？或许会有人说再卸载再换。。。。。。但是不觉得这样太繁琐了吗？下面为大家介绍一种使用版本管理工具，安装不同版本的方式，实现不用手动卸载，紧靠命令即可下载、安装、切换、卸载不同版本的node。</p>\n<h6 id=\"nvm–node版本管理工具\"><a href=\"#nvm–node版本管理工具\" class=\"headerlink\" title=\"nvm–node版本管理工具\"></a>nvm–node版本管理工具</h6><p><strong>注意：安装nvm之前一定要先将原本安装的node卸载，删除node相关文件</strong><br>1、下载nvm<br><a href=\"https://github.com/coreybutler/nvm-windows/releases\">nvm下载地址</a><br><img src=\"/nodejs/images/nvm-download.png\" alt=\"下载nvm\"><br>github上有不同的安装包，大家可以根据自己的需要进行下载安装</p>\n<p>2、安装nvm<br><em>注意：安装目录不能出现中文、空格等，否则可能导致安装失败或者安装后找不到nvm等问题</em></p>\n<p>安装成功之后，使用cmd打开命令提示符，输入nvm，出现下图中的信息，表示安装成功<br><img src=\"/nodejs/images/nvm-install.png\" alt=\"安装成功\"></p>\n<p>3、修改配置<br>找到nvm的安装目录，找到setting.txt文件，打开文件后，将下面的地址增加到文件中<br><img src=\"/nodejs/images/nvm-setting.png\" alt=\"配置文件\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class=\"line\">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/nvm-setting-content.png\" alt=\"配置文件内容\"></p>\n<p>4、使用nvm</p>\n<ul>\n<li>安装指定版本node<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install [--version]</span><br><span class=\"line\"><span class=\"comment\">// eg: nvm install 18.12</span></span><br></pre></td></tr></table></figure></li>\n<li>使用/切换指定版本node<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use [--version]</span><br><span class=\"line\"><span class=\"comment\">// eg: nvm use 18.12</span></span><br></pre></td></tr></table></figure></li>\n<li>卸载指定版本node<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm uninstall [--version]</span><br><span class=\"line\"><span class=\"comment\">// eg: nvm uninstall 18.12</span></span><br></pre></td></tr></table></figure></li>\n<li>查看已下载及当前使用node版本<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm ls</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h6><p>1、安装nvm之后，查看node版本，提示拒绝访问<br>解决办法：卸载nvm，查看时候有nodejs文件残留，将残留文件删除</p>\n<p>2、使用nvm use切换不同版本的node失败<br>解决办法：使用管理员权限运行命令提示符</p>\n<p>3、安装nvm成功，可以正常切换不同版本node，但是在vscode的终端里查看node版本，提示node不是内部或外部命令。。。。<br>解决办法：em…本人遇到这个问题是因为安装nvm之前卸载node之后，把git也卸载了，不过安装git之后，重新安装nvm还是有这个问题，一段时间后重新安装nvm，安装成功了。。。。。。本人猜测是因为卸载了git导致的问题，注意：<em>安装nvm之前，卸载node就行了，不要卸载git</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h6><p>大家在日常开发中，偶尔会遇到因为node不兼容导致的问题，这时候怎么办？相信大家常用的解决手段是卸载当前用的node，去<a href=\"https://nodejs.org/zh-cn/\">官网</a>重新下一个新的可兼容的版本重新安装。确实，这种方法可以解决遇到的问题，但是如果兼容版本是低版本怎么办？切换一个项目，兼容版本又不兼容了怎么办？或许会有人说再卸载再换。。。。。。但是不觉得这样太繁琐了吗？下面为大家介绍一种使用版本管理工具，安装不同版本的方式，实现不用手动卸载，紧靠命令即可下载、安装、切换、卸载不同版本的node。</p>\n<h6 id=\"nvm–node版本管理工具\"><a href=\"#nvm–node版本管理工具\" class=\"headerlink\" title=\"nvm–node版本管理工具\"></a>nvm–node版本管理工具</h6><p><strong>注意：安装nvm之前一定要先将原本安装的node卸载，删除node相关文件</strong><br>1、下载nvm<br><a href=\"https://github.com/coreybutler/nvm-windows/releases\">nvm下载地址</a><br><img src=\"/nodejs/images/nvm-download.png\" alt=\"下载nvm\"><br>github上有不同的安装包，大家可以根据自己的需要进行下载安装</p>\n<p>2、安装nvm<br><em>注意：安装目录不能出现中文、空格等，否则可能导致安装失败或者安装后找不到nvm等问题</em></p>\n<p>安装成功之后，使用cmd打开命令提示符，输入nvm，出现下图中的信息，表示安装成功<br><img src=\"/nodejs/images/nvm-install.png\" alt=\"安装成功\"></p>\n<p>3、修改配置<br>找到nvm的安装目录，找到setting.txt文件，打开文件后，将下面的地址增加到文件中<br><img src=\"/nodejs/images/nvm-setting.png\" alt=\"配置文件\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class=\"line\">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/nvm-setting-content.png\" alt=\"配置文件内容\"></p>\n<p>4、使用nvm</p>\n<ul>\n<li>安装指定版本node<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install [--version]</span><br><span class=\"line\"><span class=\"comment\">// eg: nvm install 18.12</span></span><br></pre></td></tr></table></figure></li>\n<li>使用/切换指定版本node<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use [--version]</span><br><span class=\"line\"><span class=\"comment\">// eg: nvm use 18.12</span></span><br></pre></td></tr></table></figure></li>\n<li>卸载指定版本node<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm uninstall [--version]</span><br><span class=\"line\"><span class=\"comment\">// eg: nvm uninstall 18.12</span></span><br></pre></td></tr></table></figure></li>\n<li>查看已下载及当前使用node版本<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm ls</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h6><p>1、安装nvm之后，查看node版本，提示拒绝访问<br>解决办法：卸载nvm，查看时候有nodejs文件残留，将残留文件删除</p>\n<p>2、使用nvm use切换不同版本的node失败<br>解决办法：使用管理员权限运行命令提示符</p>\n<p>3、安装nvm成功，可以正常切换不同版本node，但是在vscode的终端里查看node版本，提示node不是内部或外部命令。。。。<br>解决办法：em…本人遇到这个问题是因为安装nvm之前卸载node之后，把git也卸载了，不过安装git之后，重新安装nvm还是有这个问题，一段时间后重新安装nvm，安装成功了。。。。。。本人猜测是因为卸载了git导致的问题，注意：<em>安装nvm之前，卸载node就行了，不要卸载git</em></p>\n"},{"title":"nodejs基础知识(5)","date":"2023-01-03T10:04:15.000Z","tags":["node","命令行选项","console (控制台)"],"_content":"\nnode [options] [V8 options] [script.js | -e \"script\" | -] [--] [arguments]\n\nnode debug [script.js | -e \"script\" | <host>:<port>] …\n\nnode --v8-options\n\n执行时不带参数，会启动 [REPL]。\n\n###### 选项\n-v, --version\n打印 node 的版本号。\n\n-h, --help\n打印 node 的命令行选项。 \n\n-e, --eval \"script\"\n把跟随的参数作为 JavaScript 来执行。 在 REPL 中预定义的模块也可以在 script 中使用。\n*在windows的cmd中，使用单引号无法将参数作为javascript执行，仅双引号可正常执行，powershell和git bash中可以使用单引号和双引号*\n\n-p, --print \"script\"\n与 -e 相同，但会打印结果。\n\n-c, --check\n在不执行的情况下，对脚本进行语法检查。\n\n-i, --interactive\n打开 REPL，即使 stdin 看起来不像终端。\n\n-r, --require module\n在启动时预加载指定的模块。\n遵循 require() 的模块解析规则。 module 可以是一个文件的路径，或一个 node 模块名称。\n\n--inspect[=[host:]port]\n在主机端口上激活检查器。默认为127.0.0.1:9229。\nV8检查器集成允许Chrome DevTools和IDE等工具调试和配置Node.js实例。 这些工具通过tcp端口附加到Node.js实例，并使用[Chrome Debugging Protocol][]调试协议进行通信\n\n--inspect-brk[=[host:]port]\n在主机上激活检查器：端口并在用户脚本开始时中断，默认为127.0.0.1:9229。\n\n--inspect-port=[host:]port\n设置激活检查器时要使用的主机：端口。通过发送SIGUSR1信号激活检查器时有用。默认主机为：127.0.0.1。\n\n--no-deprecation\n静默废弃的警告。\n\n--trace-deprecation\n打印废弃的堆栈跟踪。\n\n--throw-deprecation\n抛出废弃的错误。\n\n--pending-deprecation\n发出挂起的弃用警告\nNote: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the --pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective \"early warning\" mechanism that developers may leverage to detect deprecated API usage.\n（注意：挂起的弃用通常与运行时弃用相同，但值得注意的是，它们在默认情况下被关闭，除非设置了--Pending弃用命令行标志或NODE_Pending_deprecation=1环境变量，否则不会发出。待定弃用用于提供一种选择性的“预警”机制，开发人员可以利用该机制来检测弃用的API使用情况。）\n\n--no-warnings\n静默一切进程警告（包括废弃警告）。\n\n--expose-http2\nEnable the experimental 'http2' module.（启用实验“http2”模块。）\n\n--abort-on-uncaught-exception\nAborting instead of exiting causes a core file to be generated for post-mortem analysis using a debugger (such as lldb, gdb, and mdb)\n(中止而不是退出会导致使用调试器(如lldb、gdb和mdb)生成一个用于事后分析的核心文件。)\n\n--trace-warnings\n打印进程警告的堆栈跟踪（包括废弃警告）。\n\n--redirect-warnings=file\nWrite process warnings to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead.\n(将进程警告写入给定文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。)\n\n--trace-sync-io\n每当事件循环的第一帧之后检测到同步 I/O 时，打印堆栈跟踪。\n\n--force-async-hooks-checks\nEnables runtime checks for async_hooks. These can also be enabled dynamically by enabling one of the async_hooks hooks.\n(启用async_hooks的运行时检查。也可以通过启用async_hooks钩子之一来动态启用这些钩子。)\n\n--trace-events-enabled\nEnables the collection of trace event tracing information.\n(启用跟踪事件跟踪信息的收集。)\n\n--trace-event-categories\nA comma separated list of categories that should be traced when trace event tracing is enabled using --trace-events-enabled.\n(当使用——trace-events-enabled启用跟踪事件跟踪时，应该跟踪的类别列表，以逗号分隔。)\n\n--zero-fill-buffers\n自动用 0 填充所有新分配的 [Buffer] 和 [SlowBuffer] 实例。\n\n--preserve-symlinks\n当解析和缓存模块时，命令模块加载器保持符号连接。\n默认情况下，当 Node.js 从一个被符号连接到另一块磁盘位置的路径加载一个模块时，Node.js 会解引用该连接，并使用模块的真实磁盘的实际路径，作为定位其他依赖模块的标识符和根路径。 大多数情况下，默认行为是可接受的。 但是，当使用符号连接的同行依赖，如下例子所描述的，如果 moduleA 试图引入 moduleB 作为一个同行依赖，默认行为就会抛出异常：\n![symlinks](./images/symlinks.png)\n--preserve-symlinks 命令行标志命令 Node.js 使用模块的符号路径而不是真实路径，是符号连接的同行依赖能被找到。\n注意，使用 --preserve-symlinks 会有其他方面的影响。 比如，如果符号连接的原生模块在依赖树里来自超过一个位置，它们会加载失败。 （Node.js 会将它们视为两个独立的模块，且会试图多次加载模块，造成抛出异常。）\n\n--track-heap-objects\n为堆快照追踪堆栈对象的分配。\n\n--prof-process\n处理 V8 分析器的输出，通过使用 V8 选项 --prof 生成。\n\n--v8-options\n打印 V8 命令行选项。\n注意，V8 选项允许单词使用破折号（-）或下划线（_）分隔。\n例如，--stack-trace-limit 等同于 --stack_trace_limit。\n\n--tls-cipher-list=list\n指定备用的默认 TLS 加密列表。 （需要 Node.js 被构建为支持加密。（默认））\n\n--enable-fips\n启动时启用符合 FIPS 标准的加密。 （需要 Node.js 使用 ./configure --openssl-fips 构建）\n\n--force-fips\n启动时强制使用符合 FIPS 标准的加密。 （无法通过脚本代码禁用。） （需要 Node.js 使用 ./configure --openssl-fips 构建）\n\n--openssl-config=file\n启动时加载 OpenSSL 配置文件。 在其他用途中，如果 Node.js 使用 ./configure --openssl-fips 构建，它可以用于启用符合 FIPS 标准的加密。\n\n--use-openssl-ca, --use-bundled-ca\nUse OpenSSL's default CA store or use bundled Mozilla CA store as supplied by current Node.js version. The default store is selectable at build-time.\n\nUsing OpenSSL store allows for external modifications of the store. For most Linux and BSD distributions, this store is maintained by the distribution maintainers and system administrators. OpenSSL CA store location is dependent on configuration of the OpenSSL library but this can be altered at runtime using environment variables.\n\nThe bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store that is fixed at release time. It is identical on all supported platforms.\n\nSee SSL_CERT_DIR and SSL_CERT_FILE.\n(使用OpenSSL的默认CA存储或使用当前Node.js版本提供的捆绑Mozilla CA存储。默认存储在构建时是可选择的。\n使用OpenSSL存储允许对存储进行外部修改。对于大多数Linux和BSD发行版，这个存储区由发行版维护人员和系统管理员维护。OpenSSL CA存储位置依赖于OpenSSL库的配置，但这可以在运行时使用环境变量更改。\n由Node.js提供的捆绑CA存储是发布时固定的Mozilla CA存储的快照。它在所有支持的平台上都是相同的。\n请参阅SSL_CERT_DIR和SSL_CERT_FILE。)\n\n--icu-data-dir=file\n指定 ICU 数据的加载路径。 （覆盖 NODE_ICU_DATA）\n\n-\nAlias for stdin, analogous to the use of - in other command line utilities, meaning that the script will be read from stdin, and the rest of the options are passed to that script.\n(stdin的别名，类似于-在其他命令行实用程序中的使用，这意味着脚本将从stdin读取，其余选项将传递给该脚本。)\n\n--\nIndicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.\n(指示节点选项的结束。将其余参数传递给脚本。如果在此之前没有提供脚本文件名或eval/print脚本，则下一个参数将用作脚本文件名。)\n\n###### 环境变量\nNODE_DEBUG=module[,…]\n以 ',' 分隔的应该打印调试信息的核心模块列表。\n\nNODE_PATH=path[:…]\n以 ':' 分隔的有模块搜索路径作前缀的目录列表。\n注意，在 Windows 中，列表是用 ';' 分隔的。\n\nNODE_DISABLE_COLORS=1\n当设为 1 时，不会在 REPL 中使用颜色。\n\nNODE_ICU_DATA=file\nICU（Intl 对象）数据的数据路径。 当使用 small-icu 编译时，扩展链接的数据。\n\nNODE_NO_WARNINGS=1\nWhen set to 1, process warnings are silenced.\n(当设置为1时，进程警告将被静音。)\n\nNODE_NO_HTTP2=1\nWhen set to 1, the http2 module is suppressed.\n(当设置为1时，http2模块将被抑制。)\n\nNODE_OPTIONS=options...\nA space-separated list of command line options.  options...  are interpreted as if they had been specified on the command line before the actual command line (so they can be overridden).  Node will exit with an error if an option that is not allowed in the environment is used, such as -p or a script file.\n(以空格分隔的命令行选项列表。选择……将它们解释为在实际命令行之前在命令行上指定的(因此可以覆盖它们)。如果使用了环境中不允许的选项，例如-p或脚本文件，则Node将退出并报错。)\nnode选项如下：\n- --enable-fips\n- --force-fips\n- --icu-data-dir\n- --inspect-brk\n- --inspect-port\n- --inspect\n- --no-deprecation\n- --no-warnings\n- --openssl-config\n- --redirect-warnings\n- --require, -r\n- --throw-deprecation\n- --tls-cipher-list\n- --trace-deprecation\n- --trace-events-categories\n- --trace-events-enabled\n- --trace-sync-io\n- --trace-warnings\n- --track-heap-objects\n- --use-bundled-ca\n- --use-openssl-ca\n- --v8-pool-size\n- --zero-fill-buffers\nV8选项如下:\n- --abort-on-uncaught-exception\n- --max-old-space-size\n- --stack-trace-limit\n\nNODE_PENDING_DEPRECATION=1\nWhen set to 1, emit pending deprecation warnings.\n\nNote: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the --pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective \"early warning\" mechanism that developers may leverage to detect deprecated API usage.\n(当设置为1时，发出挂起的弃用警告。注意:挂起的弃用通常与运行时弃用相同，有一个显著的例外:它们在默认情况下是关闭的，除非设置了--pending -deprecation命令行标志或NODE_PENDING_DEPRECATION=1环境变量，否则不会被触发。未决弃用用于提供一种选择性的“早期预警”机制，开发人员可以利用这种机制来检测弃用API的使用情况。)\n\nNODE_PRESERVE_SYMLINKS=1\nWhen set to 1, instructs the module loader to preserve symbolic links when resolving and caching modules.\n(当设置为1时，指示模块加载器在解析和缓存模块时保留符号链接。)\n\nNODE_REPL_HISTORY=file\n用于存储持久性的 REPL 历史记录的文件的路径。 默认路径是 ~/.node_repl_history，可被该变量覆盖。 将值设为空字符串（\"\" 或 \" \"）会禁用持久性的 REPL 历史记录。\n\nNODE_EXTRA_CA_CERTS=file\n当设置了此选项时，根 CA 证书（如 VeriSign）会被 file 指定的证书扩展。 文件应该包括一个或多个可信的 PEM 格式的证书。 如果文件丢失或有缺陷，则 process.emitWarning() 会触发一个消息。\n注意，当一个 TLS 或 HTTPS 的客户端或服务器的 ca 选项的属性被显式地指定时，则指定的证书不会被使用。\n\nOPENSSL_CONF=file\nLoad an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with ./configure --openssl-fips.\nIf the [--openssl-config][] command line option is used, the environment variable is ignored.\n(启动时加载OpenSSL配置文件。在其他用途中，如果Node.js使用./configure --openssl-fips构建，则可以使用它来启用符合fips的加密。如果使用[--openssl-config][]命令行选项，则忽略环境变量。)\n\nSSL_CERT_DIR=dir\nIf --use-openssl-ca is enabled, this overrides and sets OpenSSL's directory containing trusted certificates.\nNote: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.\n(如果启用了--use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL目录。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)\n\nSSL_CERT_FILE=file\nIf --use-openssl-ca is enabled, this overrides and sets OpenSSL's file containing trusted certificates.\nNote: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.\n(如果启用了--use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL文件。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)\n\nNODE_REDIRECT_WARNINGS=file\nWhen set, process warnings will be emitted to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. This is equivalent to using the --redirect-warnings=file command-line flag.\n(设置后，进程警告将被发送到给定的文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。这相当于使用--redirect-warnings=file命令行标志。)\n\nUV_THREADPOOL_SIZE=size\nSet the number of threads used in libuv's threadpool to size threads.\nAsynchronous system APIs are used by Node.js whenever possible, but where they do not exist, libuv's threadpool is used to create asynchronous node APIs based on synchronous system APIs. Node.js APIs that use the threadpool are:\n- all fs APIs, other than the file watcher APIs and those that are explicitly synchronous\n- crypto.pbkdf2()\n- crypto.randomBytes(), unless it is used without a callback\n- crypto.randomFill()\n- dns.lookup()\n- all zlib APIs, other than those that are explicitly synchronous\nBecause libuv's threadpool has a fixed size, it means that if for whatever reason any of these APIs takes a long time, other (seemingly unrelated) APIs that run in libuv's threadpool will experience degraded performance. In order to mitigate this issue, one potential solution is to increase the size of libuv's threadpool by setting the 'UV_THREADPOOL_SIZE' environment variable to a value greater than 4 (its current default value). For more information, see the [libuv threadpool documentation][]. [--openssl-config]: #cli_openssl_config_file [Buffer]: buffer.html#buffer_buffer [Chrome Debugging Protocol]: https://chromedevtools.github.io/debugger-protocol-viewer [REPL]: repl.html [SlowBuffer]: buffer.html#buffer_class_slowbuffer [debugger]: debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv threadpool documentation]: http://docs.libuv.org/en/latest/threadpool.html\n\n将libuv线程池中使用的线程数设置为线程大小。\nnode .js尽可能使用异步系统api，但在不存在异步系统api的地方，libuv的线程池用于基于同步系统api创建异步节点api。使用线程池的Node.js api有:\n- 所有的fs api，除了文件监视器api和那些显式同步的api\n- crypto.pbkdf2()\n- crypt.randombytes()，除非它在没有回调的情况下使用\n- crypto.randomFill()\n- dns.lookup()\n- 所有的zlib api，除了那些显式同步的\n因为libuv的线程池大小是固定的，这意味着无论出于什么原因，如果这些api中的任何一个需要很长时间，在libuv的线程池中运行的其他(看似无关的)api将会经历性能下降。为了缓解这个问题，一个潜在的解决方案是通过将“UV_THREADPOOL_SIZE”环境变量设置为大于4(当前的默认值)来增加libuv线程池的大小。有关更多信息，请参阅[libuv线程池文档][]。[——openssl-config]: #cli_openssl_config_file [Buffer]: Buffer .html#buffer_buffer [Chrome调试协议]:https://chromedevtools.github.io/debugger-protocol-viewer [REPL]: REPL .html [SlowBuffer]: Buffer .html#buffer_class_slowbuffer[调试器]:debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv线程池文档]:http://docs.libuv.org/en/latest/threadpool.html\n\n\n#### console (控制台)\nconsole 模块提供了一个简单的调试控制台，类似于 Web 浏览器提供的 JavaScript 控制台。\n该模块导出了两个特定的组件：\n- 一个 Console 类，包含 console.log() 、 console.error() 和 console.warn() 等方法，可以被用于写入到任何 Node.js 流。\n- 一个全局的 console 实例，可被用于写入到 process.stdout 和 process.stderr。 全局的 console 使用时无需调用 require('console')。\n注意：全局的 console 对象的方法既不总是同步的（如浏览器中类似的 API），也不总是异步的（如其他 Node.js 流）。 详见 进程 I/O。\n\n```javascript\n// 使用全局的 console\nconsole.log('你好世界');\n// 打印: '你好世界'到 stdout。\nconsole.log('你好%s', '世界');\n// 打印: '你好世界'到 stdout。\nconsole.error(new Error('错误信息'));\n// 打印: [Error: 错误信息]到 stderr。\nconst name = '描述';\nconsole.warn(`警告${name}`);\n// 打印: '警告描述'到 stderr。\n\n// 使用 Console 类\nconst out = getStreamSomehow();\nconst err = getStreamSomehow();\nconst myConsole = new console.Console(out, err);\nmyConsole.log('你好世界');\n// 打印: '你好世界'到 out。\nmyConsole.log('你好%s', '世界');\n// 打印: '你好世界'到 out。\nmyConsole.error(new Error('错误信息'));\n// 打印: [Error: 错误信息]到 err。\nconst name = '描述';\nmyConsole.warn(`警告${name}`);\n// 打印: '警告描述'到 err。\n```\n\n###### Console 类\nConsole 类可用于创建一个具有可配置的输出流的简单记录器，可以通过 require('console').Console 或 console.Console 使用：\n```javascript\nconst { Console } = require('console');\nconst { Console } = console;\n```\n全局的 console 是一个特殊的 Console 实例，它的输出会发送到 process.stdout 和 process.stderr。 相当于调用：\n```javascript\nnew Console(process.stdout, process.stderr);\n```\n\nconsole.assert(value[, message][, ...args])\n一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。\n```javascript\nconsole.assert(true, 'does nothing');\n// 通过\nconsole.assert(false, 'Whoops %s', 'didn\\'t work');\n// AssertionError: Whoops didn't work\n```\n注意：Node.js 中的 console.assert() 方法与在浏览器中的 console.assert() 方法的实现是不一样的。\n具体地说，在浏览器中，用非真的断言调用 console.assert() 会导致 message 被打印到控制台但不会中断后续代码的执行。 在 Node.js v10.0.0 之前，一个值为假的断言也将会导致一个AssertionError被抛出，使得代码执行被打断。v10.0.0 修复了此差异，所以现在console.assert()在 Node 和浏览器中执行行为相同。\n可以通过扩展 Node.js 的 console 并重写 console.assert() 方法来实现与浏览器中类似的功能。\n*console.assert 在不同浏览器中可能获得不同的效果*\n```javascript\n'use strict';\n\n// 用一个新的不带补丁的 assert 实现来创建一个简单的 console 扩展。\nconst myConsole = Object.create(console, {\n  assert: {\n    value: function assert(assertion, message, ...args) {\n      try {\n        console.assert(assertion, message, ...args);\n      } catch (err) {\n        console.error(err.stack);\n      }\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true,\n  },\n});\n\nmodule.exports = myConsole;\n\nconst console = require('./myConsole');\nconsole.assert(false, '会打印这个消息，但不会抛出错误');\nconsole.log('这个也会打印');\n```\n\nconsole.clear()\n当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。\n注意：console.clear() 的具体行为可能因操作系统和终端类型而异。 对于大多数Linux操作系统，console.clear() 与 clear shell 命令行为类似。 在Windows上，console.clear() 将只清除当前终端视图中Node.js二进制文件的输出。\n\nconsole.count([label])\n- label <string> 计数器的显示标签。 默认为 'default'。\n维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。\n```javascript\n> console.count()\ndefault: 1\nundefined\n> console.count('default')\ndefault: 2\nundefined\n> console.count('abc')\nabc: 1\nundefined\n> console.count('xyz')\nxyz: 1\nundefined\n> console.count('abc')\nabc: 2\nundefined\n> console.count()\ndefault: 3\nundefined\n>\n```\n\nconsole.countReset([label='default'])\n- label <string> 计数器的显示标签。 默认为 'default'。\n重置指定 label 的内部计数器。\n\nconsole.debug(data[, ...args])\nconsole.debug()函数是console.log()的别名。\n\nconsole.dir(obj[, options])\n在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。(在控制台中显示指定对象的属性，并通过类似文件树样式的交互列表显示。)\n该函数会绕过任何定义在 obj 上的自定义的 inspect() 函数。\n可选的 options 对象可以传入用于改变被格式化的字符串：\n- showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。\n- depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。\n- colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。\n\nconsole.error([data][, ...args])\n打印到 stderr，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。\n如果在第一个字符串中没有找到格式化元素（如 %d），则在每个参数上调用 util.inspect() 并将结果字符串值拼在一起。 详见 [util.format()](https://www.nodeapp.cn/util.html#util_util_format_format_args)。\n\n\nconsole.group([...label])#\n...label <any>\n将后续行的缩进增加两个空格。\n如果提供了一个或多个 labels，则首先打印这些 labels，而不需要额外的缩进。\n\nconsole.groupCollapsed()\nconsole.group()的一个别名.\n\nconsole.groupEnd()\n将后续行的缩进减少两个空格。\n\nconsole.info([data][, ...args])\nconsole.info() 函数是 console.log() 的一个别名。\n\nconsole.log([data][, ...args])\n打印到 stdout，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。\n\nconsole.time(label)\n启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。\n\nconsole.timeEnd(label)\n停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout：\n```javascript\nconsole.time('100-elements');\nfor (let i = 0; i < 100; i++) {}\nconsole.timeEnd('100-elements');\n// 打印 100-elements: 225.438ms\n```\n该方法在使用时不会将输出的时间返回到 js，它只能用于控制台调试。请勿将该方法作为普通计时器或性能数据收集器的一部分。\n\nconsole.trace([message][, ...args])\n打印字符串 'Trace :' 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。\n\nconsole.warn([data][, ...args])\nconsole.warn() 函数是 console.error() 的一个别名。","source":"nodejs/nodejs-note-12.md","raw":"---\ntitle: nodejs基础知识(5)\ndate: 2023-01-03 18:04:15\ntags: [node, 命令行选项, console (控制台)]\n---\n\nnode [options] [V8 options] [script.js | -e \"script\" | -] [--] [arguments]\n\nnode debug [script.js | -e \"script\" | <host>:<port>] …\n\nnode --v8-options\n\n执行时不带参数，会启动 [REPL]。\n\n###### 选项\n-v, --version\n打印 node 的版本号。\n\n-h, --help\n打印 node 的命令行选项。 \n\n-e, --eval \"script\"\n把跟随的参数作为 JavaScript 来执行。 在 REPL 中预定义的模块也可以在 script 中使用。\n*在windows的cmd中，使用单引号无法将参数作为javascript执行，仅双引号可正常执行，powershell和git bash中可以使用单引号和双引号*\n\n-p, --print \"script\"\n与 -e 相同，但会打印结果。\n\n-c, --check\n在不执行的情况下，对脚本进行语法检查。\n\n-i, --interactive\n打开 REPL，即使 stdin 看起来不像终端。\n\n-r, --require module\n在启动时预加载指定的模块。\n遵循 require() 的模块解析规则。 module 可以是一个文件的路径，或一个 node 模块名称。\n\n--inspect[=[host:]port]\n在主机端口上激活检查器。默认为127.0.0.1:9229。\nV8检查器集成允许Chrome DevTools和IDE等工具调试和配置Node.js实例。 这些工具通过tcp端口附加到Node.js实例，并使用[Chrome Debugging Protocol][]调试协议进行通信\n\n--inspect-brk[=[host:]port]\n在主机上激活检查器：端口并在用户脚本开始时中断，默认为127.0.0.1:9229。\n\n--inspect-port=[host:]port\n设置激活检查器时要使用的主机：端口。通过发送SIGUSR1信号激活检查器时有用。默认主机为：127.0.0.1。\n\n--no-deprecation\n静默废弃的警告。\n\n--trace-deprecation\n打印废弃的堆栈跟踪。\n\n--throw-deprecation\n抛出废弃的错误。\n\n--pending-deprecation\n发出挂起的弃用警告\nNote: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the --pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective \"early warning\" mechanism that developers may leverage to detect deprecated API usage.\n（注意：挂起的弃用通常与运行时弃用相同，但值得注意的是，它们在默认情况下被关闭，除非设置了--Pending弃用命令行标志或NODE_Pending_deprecation=1环境变量，否则不会发出。待定弃用用于提供一种选择性的“预警”机制，开发人员可以利用该机制来检测弃用的API使用情况。）\n\n--no-warnings\n静默一切进程警告（包括废弃警告）。\n\n--expose-http2\nEnable the experimental 'http2' module.（启用实验“http2”模块。）\n\n--abort-on-uncaught-exception\nAborting instead of exiting causes a core file to be generated for post-mortem analysis using a debugger (such as lldb, gdb, and mdb)\n(中止而不是退出会导致使用调试器(如lldb、gdb和mdb)生成一个用于事后分析的核心文件。)\n\n--trace-warnings\n打印进程警告的堆栈跟踪（包括废弃警告）。\n\n--redirect-warnings=file\nWrite process warnings to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead.\n(将进程警告写入给定文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。)\n\n--trace-sync-io\n每当事件循环的第一帧之后检测到同步 I/O 时，打印堆栈跟踪。\n\n--force-async-hooks-checks\nEnables runtime checks for async_hooks. These can also be enabled dynamically by enabling one of the async_hooks hooks.\n(启用async_hooks的运行时检查。也可以通过启用async_hooks钩子之一来动态启用这些钩子。)\n\n--trace-events-enabled\nEnables the collection of trace event tracing information.\n(启用跟踪事件跟踪信息的收集。)\n\n--trace-event-categories\nA comma separated list of categories that should be traced when trace event tracing is enabled using --trace-events-enabled.\n(当使用——trace-events-enabled启用跟踪事件跟踪时，应该跟踪的类别列表，以逗号分隔。)\n\n--zero-fill-buffers\n自动用 0 填充所有新分配的 [Buffer] 和 [SlowBuffer] 实例。\n\n--preserve-symlinks\n当解析和缓存模块时，命令模块加载器保持符号连接。\n默认情况下，当 Node.js 从一个被符号连接到另一块磁盘位置的路径加载一个模块时，Node.js 会解引用该连接，并使用模块的真实磁盘的实际路径，作为定位其他依赖模块的标识符和根路径。 大多数情况下，默认行为是可接受的。 但是，当使用符号连接的同行依赖，如下例子所描述的，如果 moduleA 试图引入 moduleB 作为一个同行依赖，默认行为就会抛出异常：\n![symlinks](./images/symlinks.png)\n--preserve-symlinks 命令行标志命令 Node.js 使用模块的符号路径而不是真实路径，是符号连接的同行依赖能被找到。\n注意，使用 --preserve-symlinks 会有其他方面的影响。 比如，如果符号连接的原生模块在依赖树里来自超过一个位置，它们会加载失败。 （Node.js 会将它们视为两个独立的模块，且会试图多次加载模块，造成抛出异常。）\n\n--track-heap-objects\n为堆快照追踪堆栈对象的分配。\n\n--prof-process\n处理 V8 分析器的输出，通过使用 V8 选项 --prof 生成。\n\n--v8-options\n打印 V8 命令行选项。\n注意，V8 选项允许单词使用破折号（-）或下划线（_）分隔。\n例如，--stack-trace-limit 等同于 --stack_trace_limit。\n\n--tls-cipher-list=list\n指定备用的默认 TLS 加密列表。 （需要 Node.js 被构建为支持加密。（默认））\n\n--enable-fips\n启动时启用符合 FIPS 标准的加密。 （需要 Node.js 使用 ./configure --openssl-fips 构建）\n\n--force-fips\n启动时强制使用符合 FIPS 标准的加密。 （无法通过脚本代码禁用。） （需要 Node.js 使用 ./configure --openssl-fips 构建）\n\n--openssl-config=file\n启动时加载 OpenSSL 配置文件。 在其他用途中，如果 Node.js 使用 ./configure --openssl-fips 构建，它可以用于启用符合 FIPS 标准的加密。\n\n--use-openssl-ca, --use-bundled-ca\nUse OpenSSL's default CA store or use bundled Mozilla CA store as supplied by current Node.js version. The default store is selectable at build-time.\n\nUsing OpenSSL store allows for external modifications of the store. For most Linux and BSD distributions, this store is maintained by the distribution maintainers and system administrators. OpenSSL CA store location is dependent on configuration of the OpenSSL library but this can be altered at runtime using environment variables.\n\nThe bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store that is fixed at release time. It is identical on all supported platforms.\n\nSee SSL_CERT_DIR and SSL_CERT_FILE.\n(使用OpenSSL的默认CA存储或使用当前Node.js版本提供的捆绑Mozilla CA存储。默认存储在构建时是可选择的。\n使用OpenSSL存储允许对存储进行外部修改。对于大多数Linux和BSD发行版，这个存储区由发行版维护人员和系统管理员维护。OpenSSL CA存储位置依赖于OpenSSL库的配置，但这可以在运行时使用环境变量更改。\n由Node.js提供的捆绑CA存储是发布时固定的Mozilla CA存储的快照。它在所有支持的平台上都是相同的。\n请参阅SSL_CERT_DIR和SSL_CERT_FILE。)\n\n--icu-data-dir=file\n指定 ICU 数据的加载路径。 （覆盖 NODE_ICU_DATA）\n\n-\nAlias for stdin, analogous to the use of - in other command line utilities, meaning that the script will be read from stdin, and the rest of the options are passed to that script.\n(stdin的别名，类似于-在其他命令行实用程序中的使用，这意味着脚本将从stdin读取，其余选项将传递给该脚本。)\n\n--\nIndicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.\n(指示节点选项的结束。将其余参数传递给脚本。如果在此之前没有提供脚本文件名或eval/print脚本，则下一个参数将用作脚本文件名。)\n\n###### 环境变量\nNODE_DEBUG=module[,…]\n以 ',' 分隔的应该打印调试信息的核心模块列表。\n\nNODE_PATH=path[:…]\n以 ':' 分隔的有模块搜索路径作前缀的目录列表。\n注意，在 Windows 中，列表是用 ';' 分隔的。\n\nNODE_DISABLE_COLORS=1\n当设为 1 时，不会在 REPL 中使用颜色。\n\nNODE_ICU_DATA=file\nICU（Intl 对象）数据的数据路径。 当使用 small-icu 编译时，扩展链接的数据。\n\nNODE_NO_WARNINGS=1\nWhen set to 1, process warnings are silenced.\n(当设置为1时，进程警告将被静音。)\n\nNODE_NO_HTTP2=1\nWhen set to 1, the http2 module is suppressed.\n(当设置为1时，http2模块将被抑制。)\n\nNODE_OPTIONS=options...\nA space-separated list of command line options.  options...  are interpreted as if they had been specified on the command line before the actual command line (so they can be overridden).  Node will exit with an error if an option that is not allowed in the environment is used, such as -p or a script file.\n(以空格分隔的命令行选项列表。选择……将它们解释为在实际命令行之前在命令行上指定的(因此可以覆盖它们)。如果使用了环境中不允许的选项，例如-p或脚本文件，则Node将退出并报错。)\nnode选项如下：\n- --enable-fips\n- --force-fips\n- --icu-data-dir\n- --inspect-brk\n- --inspect-port\n- --inspect\n- --no-deprecation\n- --no-warnings\n- --openssl-config\n- --redirect-warnings\n- --require, -r\n- --throw-deprecation\n- --tls-cipher-list\n- --trace-deprecation\n- --trace-events-categories\n- --trace-events-enabled\n- --trace-sync-io\n- --trace-warnings\n- --track-heap-objects\n- --use-bundled-ca\n- --use-openssl-ca\n- --v8-pool-size\n- --zero-fill-buffers\nV8选项如下:\n- --abort-on-uncaught-exception\n- --max-old-space-size\n- --stack-trace-limit\n\nNODE_PENDING_DEPRECATION=1\nWhen set to 1, emit pending deprecation warnings.\n\nNote: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the --pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective \"early warning\" mechanism that developers may leverage to detect deprecated API usage.\n(当设置为1时，发出挂起的弃用警告。注意:挂起的弃用通常与运行时弃用相同，有一个显著的例外:它们在默认情况下是关闭的，除非设置了--pending -deprecation命令行标志或NODE_PENDING_DEPRECATION=1环境变量，否则不会被触发。未决弃用用于提供一种选择性的“早期预警”机制，开发人员可以利用这种机制来检测弃用API的使用情况。)\n\nNODE_PRESERVE_SYMLINKS=1\nWhen set to 1, instructs the module loader to preserve symbolic links when resolving and caching modules.\n(当设置为1时，指示模块加载器在解析和缓存模块时保留符号链接。)\n\nNODE_REPL_HISTORY=file\n用于存储持久性的 REPL 历史记录的文件的路径。 默认路径是 ~/.node_repl_history，可被该变量覆盖。 将值设为空字符串（\"\" 或 \" \"）会禁用持久性的 REPL 历史记录。\n\nNODE_EXTRA_CA_CERTS=file\n当设置了此选项时，根 CA 证书（如 VeriSign）会被 file 指定的证书扩展。 文件应该包括一个或多个可信的 PEM 格式的证书。 如果文件丢失或有缺陷，则 process.emitWarning() 会触发一个消息。\n注意，当一个 TLS 或 HTTPS 的客户端或服务器的 ca 选项的属性被显式地指定时，则指定的证书不会被使用。\n\nOPENSSL_CONF=file\nLoad an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with ./configure --openssl-fips.\nIf the [--openssl-config][] command line option is used, the environment variable is ignored.\n(启动时加载OpenSSL配置文件。在其他用途中，如果Node.js使用./configure --openssl-fips构建，则可以使用它来启用符合fips的加密。如果使用[--openssl-config][]命令行选项，则忽略环境变量。)\n\nSSL_CERT_DIR=dir\nIf --use-openssl-ca is enabled, this overrides and sets OpenSSL's directory containing trusted certificates.\nNote: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.\n(如果启用了--use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL目录。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)\n\nSSL_CERT_FILE=file\nIf --use-openssl-ca is enabled, this overrides and sets OpenSSL's file containing trusted certificates.\nNote: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.\n(如果启用了--use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL文件。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)\n\nNODE_REDIRECT_WARNINGS=file\nWhen set, process warnings will be emitted to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. This is equivalent to using the --redirect-warnings=file command-line flag.\n(设置后，进程警告将被发送到给定的文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。这相当于使用--redirect-warnings=file命令行标志。)\n\nUV_THREADPOOL_SIZE=size\nSet the number of threads used in libuv's threadpool to size threads.\nAsynchronous system APIs are used by Node.js whenever possible, but where they do not exist, libuv's threadpool is used to create asynchronous node APIs based on synchronous system APIs. Node.js APIs that use the threadpool are:\n- all fs APIs, other than the file watcher APIs and those that are explicitly synchronous\n- crypto.pbkdf2()\n- crypto.randomBytes(), unless it is used without a callback\n- crypto.randomFill()\n- dns.lookup()\n- all zlib APIs, other than those that are explicitly synchronous\nBecause libuv's threadpool has a fixed size, it means that if for whatever reason any of these APIs takes a long time, other (seemingly unrelated) APIs that run in libuv's threadpool will experience degraded performance. In order to mitigate this issue, one potential solution is to increase the size of libuv's threadpool by setting the 'UV_THREADPOOL_SIZE' environment variable to a value greater than 4 (its current default value). For more information, see the [libuv threadpool documentation][]. [--openssl-config]: #cli_openssl_config_file [Buffer]: buffer.html#buffer_buffer [Chrome Debugging Protocol]: https://chromedevtools.github.io/debugger-protocol-viewer [REPL]: repl.html [SlowBuffer]: buffer.html#buffer_class_slowbuffer [debugger]: debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv threadpool documentation]: http://docs.libuv.org/en/latest/threadpool.html\n\n将libuv线程池中使用的线程数设置为线程大小。\nnode .js尽可能使用异步系统api，但在不存在异步系统api的地方，libuv的线程池用于基于同步系统api创建异步节点api。使用线程池的Node.js api有:\n- 所有的fs api，除了文件监视器api和那些显式同步的api\n- crypto.pbkdf2()\n- crypt.randombytes()，除非它在没有回调的情况下使用\n- crypto.randomFill()\n- dns.lookup()\n- 所有的zlib api，除了那些显式同步的\n因为libuv的线程池大小是固定的，这意味着无论出于什么原因，如果这些api中的任何一个需要很长时间，在libuv的线程池中运行的其他(看似无关的)api将会经历性能下降。为了缓解这个问题，一个潜在的解决方案是通过将“UV_THREADPOOL_SIZE”环境变量设置为大于4(当前的默认值)来增加libuv线程池的大小。有关更多信息，请参阅[libuv线程池文档][]。[——openssl-config]: #cli_openssl_config_file [Buffer]: Buffer .html#buffer_buffer [Chrome调试协议]:https://chromedevtools.github.io/debugger-protocol-viewer [REPL]: REPL .html [SlowBuffer]: Buffer .html#buffer_class_slowbuffer[调试器]:debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv线程池文档]:http://docs.libuv.org/en/latest/threadpool.html\n\n\n#### console (控制台)\nconsole 模块提供了一个简单的调试控制台，类似于 Web 浏览器提供的 JavaScript 控制台。\n该模块导出了两个特定的组件：\n- 一个 Console 类，包含 console.log() 、 console.error() 和 console.warn() 等方法，可以被用于写入到任何 Node.js 流。\n- 一个全局的 console 实例，可被用于写入到 process.stdout 和 process.stderr。 全局的 console 使用时无需调用 require('console')。\n注意：全局的 console 对象的方法既不总是同步的（如浏览器中类似的 API），也不总是异步的（如其他 Node.js 流）。 详见 进程 I/O。\n\n```javascript\n// 使用全局的 console\nconsole.log('你好世界');\n// 打印: '你好世界'到 stdout。\nconsole.log('你好%s', '世界');\n// 打印: '你好世界'到 stdout。\nconsole.error(new Error('错误信息'));\n// 打印: [Error: 错误信息]到 stderr。\nconst name = '描述';\nconsole.warn(`警告${name}`);\n// 打印: '警告描述'到 stderr。\n\n// 使用 Console 类\nconst out = getStreamSomehow();\nconst err = getStreamSomehow();\nconst myConsole = new console.Console(out, err);\nmyConsole.log('你好世界');\n// 打印: '你好世界'到 out。\nmyConsole.log('你好%s', '世界');\n// 打印: '你好世界'到 out。\nmyConsole.error(new Error('错误信息'));\n// 打印: [Error: 错误信息]到 err。\nconst name = '描述';\nmyConsole.warn(`警告${name}`);\n// 打印: '警告描述'到 err。\n```\n\n###### Console 类\nConsole 类可用于创建一个具有可配置的输出流的简单记录器，可以通过 require('console').Console 或 console.Console 使用：\n```javascript\nconst { Console } = require('console');\nconst { Console } = console;\n```\n全局的 console 是一个特殊的 Console 实例，它的输出会发送到 process.stdout 和 process.stderr。 相当于调用：\n```javascript\nnew Console(process.stdout, process.stderr);\n```\n\nconsole.assert(value[, message][, ...args])\n一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。\n```javascript\nconsole.assert(true, 'does nothing');\n// 通过\nconsole.assert(false, 'Whoops %s', 'didn\\'t work');\n// AssertionError: Whoops didn't work\n```\n注意：Node.js 中的 console.assert() 方法与在浏览器中的 console.assert() 方法的实现是不一样的。\n具体地说，在浏览器中，用非真的断言调用 console.assert() 会导致 message 被打印到控制台但不会中断后续代码的执行。 在 Node.js v10.0.0 之前，一个值为假的断言也将会导致一个AssertionError被抛出，使得代码执行被打断。v10.0.0 修复了此差异，所以现在console.assert()在 Node 和浏览器中执行行为相同。\n可以通过扩展 Node.js 的 console 并重写 console.assert() 方法来实现与浏览器中类似的功能。\n*console.assert 在不同浏览器中可能获得不同的效果*\n```javascript\n'use strict';\n\n// 用一个新的不带补丁的 assert 实现来创建一个简单的 console 扩展。\nconst myConsole = Object.create(console, {\n  assert: {\n    value: function assert(assertion, message, ...args) {\n      try {\n        console.assert(assertion, message, ...args);\n      } catch (err) {\n        console.error(err.stack);\n      }\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true,\n  },\n});\n\nmodule.exports = myConsole;\n\nconst console = require('./myConsole');\nconsole.assert(false, '会打印这个消息，但不会抛出错误');\nconsole.log('这个也会打印');\n```\n\nconsole.clear()\n当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。\n注意：console.clear() 的具体行为可能因操作系统和终端类型而异。 对于大多数Linux操作系统，console.clear() 与 clear shell 命令行为类似。 在Windows上，console.clear() 将只清除当前终端视图中Node.js二进制文件的输出。\n\nconsole.count([label])\n- label <string> 计数器的显示标签。 默认为 'default'。\n维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。\n```javascript\n> console.count()\ndefault: 1\nundefined\n> console.count('default')\ndefault: 2\nundefined\n> console.count('abc')\nabc: 1\nundefined\n> console.count('xyz')\nxyz: 1\nundefined\n> console.count('abc')\nabc: 2\nundefined\n> console.count()\ndefault: 3\nundefined\n>\n```\n\nconsole.countReset([label='default'])\n- label <string> 计数器的显示标签。 默认为 'default'。\n重置指定 label 的内部计数器。\n\nconsole.debug(data[, ...args])\nconsole.debug()函数是console.log()的别名。\n\nconsole.dir(obj[, options])\n在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。(在控制台中显示指定对象的属性，并通过类似文件树样式的交互列表显示。)\n该函数会绕过任何定义在 obj 上的自定义的 inspect() 函数。\n可选的 options 对象可以传入用于改变被格式化的字符串：\n- showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。\n- depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。\n- colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。\n\nconsole.error([data][, ...args])\n打印到 stderr，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。\n如果在第一个字符串中没有找到格式化元素（如 %d），则在每个参数上调用 util.inspect() 并将结果字符串值拼在一起。 详见 [util.format()](https://www.nodeapp.cn/util.html#util_util_format_format_args)。\n\n\nconsole.group([...label])#\n...label <any>\n将后续行的缩进增加两个空格。\n如果提供了一个或多个 labels，则首先打印这些 labels，而不需要额外的缩进。\n\nconsole.groupCollapsed()\nconsole.group()的一个别名.\n\nconsole.groupEnd()\n将后续行的缩进减少两个空格。\n\nconsole.info([data][, ...args])\nconsole.info() 函数是 console.log() 的一个别名。\n\nconsole.log([data][, ...args])\n打印到 stdout，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。\n\nconsole.time(label)\n启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。\n\nconsole.timeEnd(label)\n停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout：\n```javascript\nconsole.time('100-elements');\nfor (let i = 0; i < 100; i++) {}\nconsole.timeEnd('100-elements');\n// 打印 100-elements: 225.438ms\n```\n该方法在使用时不会将输出的时间返回到 js，它只能用于控制台调试。请勿将该方法作为普通计时器或性能数据收集器的一部分。\n\nconsole.trace([message][, ...args])\n打印字符串 'Trace :' 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。\n\nconsole.warn([data][, ...args])\nconsole.warn() 函数是 console.error() 的一个别名。","updated":"2023-01-04T07:34:36.290Z","path":"nodejs/nodejs-note-12.html","comments":1,"layout":"page","_id":"clchh4gwr000mcktt57fn9n9s","content":"<p>node [options] [V8 options] [script.js | -e “script” | -] [–] [arguments]</p>\n<p>node debug [script.js | -e “script” | <host>:<port>] …</port></host></p>\n<p>node –v8-options</p>\n<p>执行时不带参数，会启动 [REPL]。</p>\n<h6 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h6><p>-v, –version<br>打印 node 的版本号。</p>\n<p>-h, –help<br>打印 node 的命令行选项。 </p>\n<p>-e, –eval “script”<br>把跟随的参数作为 JavaScript 来执行。 在 REPL 中预定义的模块也可以在 script 中使用。<br><em>在windows的cmd中，使用单引号无法将参数作为javascript执行，仅双引号可正常执行，powershell和git bash中可以使用单引号和双引号</em></p>\n<p>-p, –print “script”<br>与 -e 相同，但会打印结果。</p>\n<p>-c, –check<br>在不执行的情况下，对脚本进行语法检查。</p>\n<p>-i, –interactive<br>打开 REPL，即使 stdin 看起来不像终端。</p>\n<p>-r, –require module<br>在启动时预加载指定的模块。<br>遵循 require() 的模块解析规则。 module 可以是一个文件的路径，或一个 node 模块名称。</p>\n<p>–inspect[=[host:]port]<br>在主机端口上激活检查器。默认为127.0.0.1:9229。<br>V8检查器集成允许Chrome DevTools和IDE等工具调试和配置Node.js实例。 这些工具通过tcp端口附加到Node.js实例，并使用[Chrome Debugging Protocol][]调试协议进行通信</p>\n<p>–inspect-brk[=[host:]port]<br>在主机上激活检查器：端口并在用户脚本开始时中断，默认为127.0.0.1:9229。</p>\n<p>–inspect-port=[host:]port<br>设置激活检查器时要使用的主机：端口。通过发送SIGUSR1信号激活检查器时有用。默认主机为：127.0.0.1。</p>\n<p>–no-deprecation<br>静默废弃的警告。</p>\n<p>–trace-deprecation<br>打印废弃的堆栈跟踪。</p>\n<p>–throw-deprecation<br>抛出废弃的错误。</p>\n<p>–pending-deprecation<br>发出挂起的弃用警告<br>Note: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the –pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective “early warning” mechanism that developers may leverage to detect deprecated API usage.<br>（注意：挂起的弃用通常与运行时弃用相同，但值得注意的是，它们在默认情况下被关闭，除非设置了–Pending弃用命令行标志或NODE_Pending_deprecation=1环境变量，否则不会发出。待定弃用用于提供一种选择性的“预警”机制，开发人员可以利用该机制来检测弃用的API使用情况。）</p>\n<p>–no-warnings<br>静默一切进程警告（包括废弃警告）。</p>\n<p>–expose-http2<br>Enable the experimental ‘http2’ module.（启用实验“http2”模块。）</p>\n<p>–abort-on-uncaught-exception<br>Aborting instead of exiting causes a core file to be generated for post-mortem analysis using a debugger (such as lldb, gdb, and mdb)<br>(中止而不是退出会导致使用调试器(如lldb、gdb和mdb)生成一个用于事后分析的核心文件。)</p>\n<p>–trace-warnings<br>打印进程警告的堆栈跟踪（包括废弃警告）。</p>\n<p>–redirect-warnings=file<br>Write process warnings to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead.<br>(将进程警告写入给定文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。)</p>\n<p>–trace-sync-io<br>每当事件循环的第一帧之后检测到同步 I/O 时，打印堆栈跟踪。</p>\n<p>–force-async-hooks-checks<br>Enables runtime checks for async_hooks. These can also be enabled dynamically by enabling one of the async_hooks hooks.<br>(启用async_hooks的运行时检查。也可以通过启用async_hooks钩子之一来动态启用这些钩子。)</p>\n<p>–trace-events-enabled<br>Enables the collection of trace event tracing information.<br>(启用跟踪事件跟踪信息的收集。)</p>\n<p>–trace-event-categories<br>A comma separated list of categories that should be traced when trace event tracing is enabled using –trace-events-enabled.<br>(当使用——trace-events-enabled启用跟踪事件跟踪时，应该跟踪的类别列表，以逗号分隔。)</p>\n<p>–zero-fill-buffers<br>自动用 0 填充所有新分配的 [Buffer] 和 [SlowBuffer] 实例。</p>\n<p>–preserve-symlinks<br>当解析和缓存模块时，命令模块加载器保持符号连接。<br>默认情况下，当 Node.js 从一个被符号连接到另一块磁盘位置的路径加载一个模块时，Node.js 会解引用该连接，并使用模块的真实磁盘的实际路径，作为定位其他依赖模块的标识符和根路径。 大多数情况下，默认行为是可接受的。 但是，当使用符号连接的同行依赖，如下例子所描述的，如果 moduleA 试图引入 moduleB 作为一个同行依赖，默认行为就会抛出异常：<br><img src=\"/nodejs/images/symlinks.png\" alt=\"symlinks\"><br>–preserve-symlinks 命令行标志命令 Node.js 使用模块的符号路径而不是真实路径，是符号连接的同行依赖能被找到。<br>注意，使用 –preserve-symlinks 会有其他方面的影响。 比如，如果符号连接的原生模块在依赖树里来自超过一个位置，它们会加载失败。 （Node.js 会将它们视为两个独立的模块，且会试图多次加载模块，造成抛出异常。）</p>\n<p>–track-heap-objects<br>为堆快照追踪堆栈对象的分配。</p>\n<p>–prof-process<br>处理 V8 分析器的输出，通过使用 V8 选项 –prof 生成。</p>\n<p>–v8-options<br>打印 V8 命令行选项。<br>注意，V8 选项允许单词使用破折号（-）或下划线（_）分隔。<br>例如，–stack-trace-limit 等同于 –stack_trace_limit。</p>\n<p>–tls-cipher-list=list<br>指定备用的默认 TLS 加密列表。 （需要 Node.js 被构建为支持加密。（默认））</p>\n<p>–enable-fips<br>启动时启用符合 FIPS 标准的加密。 （需要 Node.js 使用 ./configure –openssl-fips 构建）</p>\n<p>–force-fips<br>启动时强制使用符合 FIPS 标准的加密。 （无法通过脚本代码禁用。） （需要 Node.js 使用 ./configure –openssl-fips 构建）</p>\n<p>–openssl-config=file<br>启动时加载 OpenSSL 配置文件。 在其他用途中，如果 Node.js 使用 ./configure –openssl-fips 构建，它可以用于启用符合 FIPS 标准的加密。</p>\n<p>–use-openssl-ca, –use-bundled-ca<br>Use OpenSSL’s default CA store or use bundled Mozilla CA store as supplied by current Node.js version. The default store is selectable at build-time.</p>\n<p>Using OpenSSL store allows for external modifications of the store. For most Linux and BSD distributions, this store is maintained by the distribution maintainers and system administrators. OpenSSL CA store location is dependent on configuration of the OpenSSL library but this can be altered at runtime using environment variables.</p>\n<p>The bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store that is fixed at release time. It is identical on all supported platforms.</p>\n<p>See SSL_CERT_DIR and SSL_CERT_FILE.<br>(使用OpenSSL的默认CA存储或使用当前Node.js版本提供的捆绑Mozilla CA存储。默认存储在构建时是可选择的。<br>使用OpenSSL存储允许对存储进行外部修改。对于大多数Linux和BSD发行版，这个存储区由发行版维护人员和系统管理员维护。OpenSSL CA存储位置依赖于OpenSSL库的配置，但这可以在运行时使用环境变量更改。<br>由Node.js提供的捆绑CA存储是发布时固定的Mozilla CA存储的快照。它在所有支持的平台上都是相同的。<br>请参阅SSL_CERT_DIR和SSL_CERT_FILE。)</p>\n<p>–icu-data-dir=file<br>指定 ICU 数据的加载路径。 （覆盖 NODE_ICU_DATA）</p>\n<p>-<br>Alias for stdin, analogous to the use of - in other command line utilities, meaning that the script will be read from stdin, and the rest of the options are passed to that script.<br>(stdin的别名，类似于-在其他命令行实用程序中的使用，这意味着脚本将从stdin读取，其余选项将传递给该脚本。)</p>\n<p>–<br>Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.<br>(指示节点选项的结束。将其余参数传递给脚本。如果在此之前没有提供脚本文件名或eval/print脚本，则下一个参数将用作脚本文件名。)</p>\n<h6 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h6><p>NODE_DEBUG=module[,…]<br>以 ‘,’ 分隔的应该打印调试信息的核心模块列表。</p>\n<p>NODE_PATH=path[:…]<br>以 ‘:’ 分隔的有模块搜索路径作前缀的目录列表。<br>注意，在 Windows 中，列表是用 ‘;’ 分隔的。</p>\n<p>NODE_DISABLE_COLORS=1<br>当设为 1 时，不会在 REPL 中使用颜色。</p>\n<p>NODE_ICU_DATA=file<br>ICU（Intl 对象）数据的数据路径。 当使用 small-icu 编译时，扩展链接的数据。</p>\n<p>NODE_NO_WARNINGS=1<br>When set to 1, process warnings are silenced.<br>(当设置为1时，进程警告将被静音。)</p>\n<p>NODE_NO_HTTP2=1<br>When set to 1, the http2 module is suppressed.<br>(当设置为1时，http2模块将被抑制。)</p>\n<p>NODE_OPTIONS=options…<br>A space-separated list of command line options.  options…  are interpreted as if they had been specified on the command line before the actual command line (so they can be overridden).  Node will exit with an error if an option that is not allowed in the environment is used, such as -p or a script file.<br>(以空格分隔的命令行选项列表。选择……将它们解释为在实际命令行之前在命令行上指定的(因此可以覆盖它们)。如果使用了环境中不允许的选项，例如-p或脚本文件，则Node将退出并报错。)<br>node选项如下：</p>\n<ul>\n<li>–enable-fips</li>\n<li>–force-fips</li>\n<li>–icu-data-dir</li>\n<li>–inspect-brk</li>\n<li>–inspect-port</li>\n<li>–inspect</li>\n<li>–no-deprecation</li>\n<li>–no-warnings</li>\n<li>–openssl-config</li>\n<li>–redirect-warnings</li>\n<li>–require, -r</li>\n<li>–throw-deprecation</li>\n<li>–tls-cipher-list</li>\n<li>–trace-deprecation</li>\n<li>–trace-events-categories</li>\n<li>–trace-events-enabled</li>\n<li>–trace-sync-io</li>\n<li>–trace-warnings</li>\n<li>–track-heap-objects</li>\n<li>–use-bundled-ca</li>\n<li>–use-openssl-ca</li>\n<li>–v8-pool-size</li>\n<li>–zero-fill-buffers<br>V8选项如下:</li>\n<li>–abort-on-uncaught-exception</li>\n<li>–max-old-space-size</li>\n<li>–stack-trace-limit</li>\n</ul>\n<p>NODE_PENDING_DEPRECATION=1<br>When set to 1, emit pending deprecation warnings.</p>\n<p>Note: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the –pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective “early warning” mechanism that developers may leverage to detect deprecated API usage.<br>(当设置为1时，发出挂起的弃用警告。注意:挂起的弃用通常与运行时弃用相同，有一个显著的例外:它们在默认情况下是关闭的，除非设置了–pending -deprecation命令行标志或NODE_PENDING_DEPRECATION=1环境变量，否则不会被触发。未决弃用用于提供一种选择性的“早期预警”机制，开发人员可以利用这种机制来检测弃用API的使用情况。)</p>\n<p>NODE_PRESERVE_SYMLINKS=1<br>When set to 1, instructs the module loader to preserve symbolic links when resolving and caching modules.<br>(当设置为1时，指示模块加载器在解析和缓存模块时保留符号链接。)</p>\n<p>NODE_REPL_HISTORY=file<br>用于存储持久性的 REPL 历史记录的文件的路径。 默认路径是 ~/.node_repl_history，可被该变量覆盖。 将值设为空字符串（”” 或 “ “）会禁用持久性的 REPL 历史记录。</p>\n<p>NODE_EXTRA_CA_CERTS=file<br>当设置了此选项时，根 CA 证书（如 VeriSign）会被 file 指定的证书扩展。 文件应该包括一个或多个可信的 PEM 格式的证书。 如果文件丢失或有缺陷，则 process.emitWarning() 会触发一个消息。<br>注意，当一个 TLS 或 HTTPS 的客户端或服务器的 ca 选项的属性被显式地指定时，则指定的证书不会被使用。</p>\n<p>OPENSSL_CONF=file<br>Load an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with ./configure –openssl-fips.<br>If the [–openssl-config][] command line option is used, the environment variable is ignored.<br>(启动时加载OpenSSL配置文件。在其他用途中，如果Node.js使用./configure –openssl-fips构建，则可以使用它来启用符合fips的加密。如果使用[–openssl-config][]命令行选项，则忽略环境变量。)</p>\n<p>SSL_CERT_DIR=dir<br>If –use-openssl-ca is enabled, this overrides and sets OpenSSL’s directory containing trusted certificates.<br>Note: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.<br>(如果启用了–use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL目录。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)</p>\n<p>SSL_CERT_FILE=file<br>If –use-openssl-ca is enabled, this overrides and sets OpenSSL’s file containing trusted certificates.<br>Note: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.<br>(如果启用了–use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL文件。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)</p>\n<p>NODE_REDIRECT_WARNINGS=file<br>When set, process warnings will be emitted to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. This is equivalent to using the –redirect-warnings=file command-line flag.<br>(设置后，进程警告将被发送到给定的文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。这相当于使用–redirect-warnings=file命令行标志。)</p>\n<p>UV_THREADPOOL_SIZE=size<br>Set the number of threads used in libuv’s threadpool to size threads.<br>Asynchronous system APIs are used by Node.js whenever possible, but where they do not exist, libuv’s threadpool is used to create asynchronous node APIs based on synchronous system APIs. Node.js APIs that use the threadpool are:</p>\n<ul>\n<li>all fs APIs, other than the file watcher APIs and those that are explicitly synchronous</li>\n<li>crypto.pbkdf2()</li>\n<li>crypto.randomBytes(), unless it is used without a callback</li>\n<li>crypto.randomFill()</li>\n<li>dns.lookup()</li>\n<li>all zlib APIs, other than those that are explicitly synchronous<br>Because libuv’s threadpool has a fixed size, it means that if for whatever reason any of these APIs takes a long time, other (seemingly unrelated) APIs that run in libuv’s threadpool will experience degraded performance. In order to mitigate this issue, one potential solution is to increase the size of libuv’s threadpool by setting the ‘UV_THREADPOOL_SIZE’ environment variable to a value greater than 4 (its current default value). For more information, see the [libuv threadpool documentation][]. [–openssl-config]: #cli_openssl_config_file [Buffer]: buffer.html#buffer_buffer [Chrome Debugging Protocol]: <a href=\"https://chromedevtools.github.io/debugger-protocol-viewer\">https://chromedevtools.github.io/debugger-protocol-viewer</a> [REPL]: repl.html [SlowBuffer]: buffer.html#buffer_class_slowbuffer [debugger]: debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv threadpool documentation]: <a href=\"http://docs.libuv.org/en/latest/threadpool.html\">http://docs.libuv.org/en/latest/threadpool.html</a></li>\n</ul>\n<p>将libuv线程池中使用的线程数设置为线程大小。<br>node .js尽可能使用异步系统api，但在不存在异步系统api的地方，libuv的线程池用于基于同步系统api创建异步节点api。使用线程池的Node.js api有:</p>\n<ul>\n<li>所有的fs api，除了文件监视器api和那些显式同步的api</li>\n<li>crypto.pbkdf2()</li>\n<li>crypt.randombytes()，除非它在没有回调的情况下使用</li>\n<li>crypto.randomFill()</li>\n<li>dns.lookup()</li>\n<li>所有的zlib api，除了那些显式同步的<br>因为libuv的线程池大小是固定的，这意味着无论出于什么原因，如果这些api中的任何一个需要很长时间，在libuv的线程池中运行的其他(看似无关的)api将会经历性能下降。为了缓解这个问题，一个潜在的解决方案是通过将“UV_THREADPOOL_SIZE”环境变量设置为大于4(当前的默认值)来增加libuv线程池的大小。有关更多信息，请参阅[libuv线程池文档][]。[——openssl-config]: #cli_openssl_config_file [Buffer]: Buffer .html#buffer_buffer [Chrome调试协议]:<a href=\"https://chromedevtools.github.io/debugger-protocol-viewer\">https://chromedevtools.github.io/debugger-protocol-viewer</a> [REPL]: REPL .html [SlowBuffer]: Buffer .html#buffer_class_slowbuffer[调试器]:debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv线程池文档]:<a href=\"http://docs.libuv.org/en/latest/threadpool.html\">http://docs.libuv.org/en/latest/threadpool.html</a></li>\n</ul>\n<h4 id=\"console-控制台\"><a href=\"#console-控制台\" class=\"headerlink\" title=\"console (控制台)\"></a>console (控制台)</h4><p>console 模块提供了一个简单的调试控制台，类似于 Web 浏览器提供的 JavaScript 控制台。<br>该模块导出了两个特定的组件：</p>\n<ul>\n<li>一个 Console 类，包含 console.log() 、 console.error() 和 console.warn() 等方法，可以被用于写入到任何 Node.js 流。</li>\n<li>一个全局的 console 实例，可被用于写入到 process.stdout 和 process.stderr。 全局的 console 使用时无需调用 require(‘console’)。<br>注意：全局的 console 对象的方法既不总是同步的（如浏览器中类似的 API），也不总是异步的（如其他 Node.js 流）。 详见 进程 I/O。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用全局的 console</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;你好世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 stdout。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;你好%s&#x27;</span>, <span class=\"string\">&#x27;世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 stdout。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;错误信息&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 打印: [Error: 错误信息]到 stderr。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;描述&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(<span class=\"string\">`警告<span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;警告描述&#x27;到 stderr。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Console 类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> out = getStreamSomehow();</span><br><span class=\"line\"><span class=\"keyword\">const</span> err = getStreamSomehow();</span><br><span class=\"line\"><span class=\"keyword\">const</span> myConsole = <span class=\"keyword\">new</span> <span class=\"built_in\">console</span>.Console(out, err);</span><br><span class=\"line\">myConsole.log(<span class=\"string\">&#x27;你好世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 out。</span></span><br><span class=\"line\">myConsole.log(<span class=\"string\">&#x27;你好%s&#x27;</span>, <span class=\"string\">&#x27;世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 out。</span></span><br><span class=\"line\">myConsole.error(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;错误信息&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 打印: [Error: 错误信息]到 err。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;描述&#x27;</span>;</span><br><span class=\"line\">myConsole.warn(<span class=\"string\">`警告<span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;警告描述&#x27;到 err。</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Console-类\"><a href=\"#Console-类\" class=\"headerlink\" title=\"Console 类\"></a>Console 类</h6><p>Console 类可用于创建一个具有可配置的输出流的简单记录器，可以通过 require(‘console’).Console 或 console.Console 使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; Console &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;console&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Console &#125; = <span class=\"built_in\">console</span>;</span><br></pre></td></tr></table></figure>\n<p>全局的 console 是一个特殊的 Console 实例，它的输出会发送到 process.stdout 和 process.stderr。 相当于调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Console(process.stdout, process.stderr);</span><br></pre></td></tr></table></figure>\n\n<p>console.assert(value[, message][, …args])<br>一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">true</span>, <span class=\"string\">&#x27;does nothing&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 通过</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">false</span>, <span class=\"string\">&#x27;Whoops %s&#x27;</span>, <span class=\"string\">&#x27;didn\\&#x27;t work&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// AssertionError: Whoops didn&#x27;t work</span></span><br></pre></td></tr></table></figure>\n<p>注意：Node.js 中的 console.assert() 方法与在浏览器中的 console.assert() 方法的实现是不一样的。<br>具体地说，在浏览器中，用非真的断言调用 console.assert() 会导致 message 被打印到控制台但不会中断后续代码的执行。 在 Node.js v10.0.0 之前，一个值为假的断言也将会导致一个AssertionError被抛出，使得代码执行被打断。v10.0.0 修复了此差异，所以现在console.assert()在 Node 和浏览器中执行行为相同。<br>可以通过扩展 Node.js 的 console 并重写 console.assert() 方法来实现与浏览器中类似的功能。<br><em>console.assert 在不同浏览器中可能获得不同的效果</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用一个新的不带补丁的 assert 实现来创建一个简单的 console 扩展。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myConsole = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">console</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">assert</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span>(<span class=\"params\">assertion, message, ...args</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.assert(assertion, message, ...args);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(err.stack);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = myConsole;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">console</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./myConsole&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">false</span>, <span class=\"string\">&#x27;会打印这个消息，但不会抛出错误&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这个也会打印&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>console.clear()<br>当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。<br>注意：console.clear() 的具体行为可能因操作系统和终端类型而异。 对于大多数Linux操作系统，console.clear() 与 clear shell 命令行为类似。 在Windows上，console.clear() 将只清除当前终端视图中Node.js二进制文件的输出。</p>\n<p>console.count([label])</p>\n<ul>\n<li>label <string> 计数器的显示标签。 默认为 ‘default’。<br>维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count()</span><br><span class=\"line\"><span class=\"attr\">default</span>: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;default&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">default</span>: <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">abc</span>: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;xyz&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">xyz</span>: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">abc</span>: <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count()</span><br><span class=\"line\"><span class=\"attr\">default</span>: <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></string></li>\n</ul>\n<p>console.countReset([label=’default’])</p>\n<ul>\n<li>label <string> 计数器的显示标签。 默认为 ‘default’。<br>重置指定 label 的内部计数器。</string></li>\n</ul>\n<p>console.debug(data[, …args])<br>console.debug()函数是console.log()的别名。</p>\n<p>console.dir(obj[, options])<br>在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。(在控制台中显示指定对象的属性，并通过类似文件树样式的交互列表显示。)<br>该函数会绕过任何定义在 obj 上的自定义的 inspect() 函数。<br>可选的 options 对象可以传入用于改变被格式化的字符串：</p>\n<ul>\n<li>showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。</li>\n<li>depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。</li>\n<li>colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。</li>\n</ul>\n<p>console.error([data][, …args])<br>打印到 stderr，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。<br>如果在第一个字符串中没有找到格式化元素（如 %d），则在每个参数上调用 util.inspect() 并将结果字符串值拼在一起。 详见 <a href=\"https://www.nodeapp.cn/util.html#util_util_format_format_args\">util.format()</a>。</p>\n<p>console.group([…label])#<br>…label <any><br>将后续行的缩进增加两个空格。<br>如果提供了一个或多个 labels，则首先打印这些 labels，而不需要额外的缩进。</any></p>\n<p>console.groupCollapsed()<br>console.group()的一个别名.</p>\n<p>console.groupEnd()<br>将后续行的缩进减少两个空格。</p>\n<p>console.info([data][, …args])<br>console.info() 函数是 console.log() 的一个别名。</p>\n<p>console.log([data][, …args])<br>打印到 stdout，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。</p>\n<p>console.time(label)<br>启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。</p>\n<p>console.timeEnd(label)<br>停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">&#x27;100-elements&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">&#x27;100-elements&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印 100-elements: 225.438ms</span></span><br></pre></td></tr></table></figure>\n<p>该方法在使用时不会将输出的时间返回到 js，它只能用于控制台调试。请勿将该方法作为普通计时器或性能数据收集器的一部分。</p>\n<p>console.trace([message][, …args])<br>打印字符串 ‘Trace :’ 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。</p>\n<p>console.warn([data][, …args])<br>console.warn() 函数是 console.error() 的一个别名。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>node [options] [V8 options] [script.js | -e “script” | -] [–] [arguments]</p>\n<p>node debug [script.js | -e “script” | <host>:<port>] …</port></host></p>\n<p>node –v8-options</p>\n<p>执行时不带参数，会启动 [REPL]。</p>\n<h6 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h6><p>-v, –version<br>打印 node 的版本号。</p>\n<p>-h, –help<br>打印 node 的命令行选项。 </p>\n<p>-e, –eval “script”<br>把跟随的参数作为 JavaScript 来执行。 在 REPL 中预定义的模块也可以在 script 中使用。<br><em>在windows的cmd中，使用单引号无法将参数作为javascript执行，仅双引号可正常执行，powershell和git bash中可以使用单引号和双引号</em></p>\n<p>-p, –print “script”<br>与 -e 相同，但会打印结果。</p>\n<p>-c, –check<br>在不执行的情况下，对脚本进行语法检查。</p>\n<p>-i, –interactive<br>打开 REPL，即使 stdin 看起来不像终端。</p>\n<p>-r, –require module<br>在启动时预加载指定的模块。<br>遵循 require() 的模块解析规则。 module 可以是一个文件的路径，或一个 node 模块名称。</p>\n<p>–inspect[=[host:]port]<br>在主机端口上激活检查器。默认为127.0.0.1:9229。<br>V8检查器集成允许Chrome DevTools和IDE等工具调试和配置Node.js实例。 这些工具通过tcp端口附加到Node.js实例，并使用[Chrome Debugging Protocol][]调试协议进行通信</p>\n<p>–inspect-brk[=[host:]port]<br>在主机上激活检查器：端口并在用户脚本开始时中断，默认为127.0.0.1:9229。</p>\n<p>–inspect-port=[host:]port<br>设置激活检查器时要使用的主机：端口。通过发送SIGUSR1信号激活检查器时有用。默认主机为：127.0.0.1。</p>\n<p>–no-deprecation<br>静默废弃的警告。</p>\n<p>–trace-deprecation<br>打印废弃的堆栈跟踪。</p>\n<p>–throw-deprecation<br>抛出废弃的错误。</p>\n<p>–pending-deprecation<br>发出挂起的弃用警告<br>Note: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the –pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective “early warning” mechanism that developers may leverage to detect deprecated API usage.<br>（注意：挂起的弃用通常与运行时弃用相同，但值得注意的是，它们在默认情况下被关闭，除非设置了–Pending弃用命令行标志或NODE_Pending_deprecation=1环境变量，否则不会发出。待定弃用用于提供一种选择性的“预警”机制，开发人员可以利用该机制来检测弃用的API使用情况。）</p>\n<p>–no-warnings<br>静默一切进程警告（包括废弃警告）。</p>\n<p>–expose-http2<br>Enable the experimental ‘http2’ module.（启用实验“http2”模块。）</p>\n<p>–abort-on-uncaught-exception<br>Aborting instead of exiting causes a core file to be generated for post-mortem analysis using a debugger (such as lldb, gdb, and mdb)<br>(中止而不是退出会导致使用调试器(如lldb、gdb和mdb)生成一个用于事后分析的核心文件。)</p>\n<p>–trace-warnings<br>打印进程警告的堆栈跟踪（包括废弃警告）。</p>\n<p>–redirect-warnings=file<br>Write process warnings to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead.<br>(将进程警告写入给定文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。)</p>\n<p>–trace-sync-io<br>每当事件循环的第一帧之后检测到同步 I/O 时，打印堆栈跟踪。</p>\n<p>–force-async-hooks-checks<br>Enables runtime checks for async_hooks. These can also be enabled dynamically by enabling one of the async_hooks hooks.<br>(启用async_hooks的运行时检查。也可以通过启用async_hooks钩子之一来动态启用这些钩子。)</p>\n<p>–trace-events-enabled<br>Enables the collection of trace event tracing information.<br>(启用跟踪事件跟踪信息的收集。)</p>\n<p>–trace-event-categories<br>A comma separated list of categories that should be traced when trace event tracing is enabled using –trace-events-enabled.<br>(当使用——trace-events-enabled启用跟踪事件跟踪时，应该跟踪的类别列表，以逗号分隔。)</p>\n<p>–zero-fill-buffers<br>自动用 0 填充所有新分配的 [Buffer] 和 [SlowBuffer] 实例。</p>\n<p>–preserve-symlinks<br>当解析和缓存模块时，命令模块加载器保持符号连接。<br>默认情况下，当 Node.js 从一个被符号连接到另一块磁盘位置的路径加载一个模块时，Node.js 会解引用该连接，并使用模块的真实磁盘的实际路径，作为定位其他依赖模块的标识符和根路径。 大多数情况下，默认行为是可接受的。 但是，当使用符号连接的同行依赖，如下例子所描述的，如果 moduleA 试图引入 moduleB 作为一个同行依赖，默认行为就会抛出异常：<br><img src=\"/nodejs/images/symlinks.png\" alt=\"symlinks\"><br>–preserve-symlinks 命令行标志命令 Node.js 使用模块的符号路径而不是真实路径，是符号连接的同行依赖能被找到。<br>注意，使用 –preserve-symlinks 会有其他方面的影响。 比如，如果符号连接的原生模块在依赖树里来自超过一个位置，它们会加载失败。 （Node.js 会将它们视为两个独立的模块，且会试图多次加载模块，造成抛出异常。）</p>\n<p>–track-heap-objects<br>为堆快照追踪堆栈对象的分配。</p>\n<p>–prof-process<br>处理 V8 分析器的输出，通过使用 V8 选项 –prof 生成。</p>\n<p>–v8-options<br>打印 V8 命令行选项。<br>注意，V8 选项允许单词使用破折号（-）或下划线（_）分隔。<br>例如，–stack-trace-limit 等同于 –stack_trace_limit。</p>\n<p>–tls-cipher-list=list<br>指定备用的默认 TLS 加密列表。 （需要 Node.js 被构建为支持加密。（默认））</p>\n<p>–enable-fips<br>启动时启用符合 FIPS 标准的加密。 （需要 Node.js 使用 ./configure –openssl-fips 构建）</p>\n<p>–force-fips<br>启动时强制使用符合 FIPS 标准的加密。 （无法通过脚本代码禁用。） （需要 Node.js 使用 ./configure –openssl-fips 构建）</p>\n<p>–openssl-config=file<br>启动时加载 OpenSSL 配置文件。 在其他用途中，如果 Node.js 使用 ./configure –openssl-fips 构建，它可以用于启用符合 FIPS 标准的加密。</p>\n<p>–use-openssl-ca, –use-bundled-ca<br>Use OpenSSL’s default CA store or use bundled Mozilla CA store as supplied by current Node.js version. The default store is selectable at build-time.</p>\n<p>Using OpenSSL store allows for external modifications of the store. For most Linux and BSD distributions, this store is maintained by the distribution maintainers and system administrators. OpenSSL CA store location is dependent on configuration of the OpenSSL library but this can be altered at runtime using environment variables.</p>\n<p>The bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store that is fixed at release time. It is identical on all supported platforms.</p>\n<p>See SSL_CERT_DIR and SSL_CERT_FILE.<br>(使用OpenSSL的默认CA存储或使用当前Node.js版本提供的捆绑Mozilla CA存储。默认存储在构建时是可选择的。<br>使用OpenSSL存储允许对存储进行外部修改。对于大多数Linux和BSD发行版，这个存储区由发行版维护人员和系统管理员维护。OpenSSL CA存储位置依赖于OpenSSL库的配置，但这可以在运行时使用环境变量更改。<br>由Node.js提供的捆绑CA存储是发布时固定的Mozilla CA存储的快照。它在所有支持的平台上都是相同的。<br>请参阅SSL_CERT_DIR和SSL_CERT_FILE。)</p>\n<p>–icu-data-dir=file<br>指定 ICU 数据的加载路径。 （覆盖 NODE_ICU_DATA）</p>\n<p>-<br>Alias for stdin, analogous to the use of - in other command line utilities, meaning that the script will be read from stdin, and the rest of the options are passed to that script.<br>(stdin的别名，类似于-在其他命令行实用程序中的使用，这意味着脚本将从stdin读取，其余选项将传递给该脚本。)</p>\n<p>–<br>Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.<br>(指示节点选项的结束。将其余参数传递给脚本。如果在此之前没有提供脚本文件名或eval/print脚本，则下一个参数将用作脚本文件名。)</p>\n<h6 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h6><p>NODE_DEBUG=module[,…]<br>以 ‘,’ 分隔的应该打印调试信息的核心模块列表。</p>\n<p>NODE_PATH=path[:…]<br>以 ‘:’ 分隔的有模块搜索路径作前缀的目录列表。<br>注意，在 Windows 中，列表是用 ‘;’ 分隔的。</p>\n<p>NODE_DISABLE_COLORS=1<br>当设为 1 时，不会在 REPL 中使用颜色。</p>\n<p>NODE_ICU_DATA=file<br>ICU（Intl 对象）数据的数据路径。 当使用 small-icu 编译时，扩展链接的数据。</p>\n<p>NODE_NO_WARNINGS=1<br>When set to 1, process warnings are silenced.<br>(当设置为1时，进程警告将被静音。)</p>\n<p>NODE_NO_HTTP2=1<br>When set to 1, the http2 module is suppressed.<br>(当设置为1时，http2模块将被抑制。)</p>\n<p>NODE_OPTIONS=options…<br>A space-separated list of command line options.  options…  are interpreted as if they had been specified on the command line before the actual command line (so they can be overridden).  Node will exit with an error if an option that is not allowed in the environment is used, such as -p or a script file.<br>(以空格分隔的命令行选项列表。选择……将它们解释为在实际命令行之前在命令行上指定的(因此可以覆盖它们)。如果使用了环境中不允许的选项，例如-p或脚本文件，则Node将退出并报错。)<br>node选项如下：</p>\n<ul>\n<li>–enable-fips</li>\n<li>–force-fips</li>\n<li>–icu-data-dir</li>\n<li>–inspect-brk</li>\n<li>–inspect-port</li>\n<li>–inspect</li>\n<li>–no-deprecation</li>\n<li>–no-warnings</li>\n<li>–openssl-config</li>\n<li>–redirect-warnings</li>\n<li>–require, -r</li>\n<li>–throw-deprecation</li>\n<li>–tls-cipher-list</li>\n<li>–trace-deprecation</li>\n<li>–trace-events-categories</li>\n<li>–trace-events-enabled</li>\n<li>–trace-sync-io</li>\n<li>–trace-warnings</li>\n<li>–track-heap-objects</li>\n<li>–use-bundled-ca</li>\n<li>–use-openssl-ca</li>\n<li>–v8-pool-size</li>\n<li>–zero-fill-buffers<br>V8选项如下:</li>\n<li>–abort-on-uncaught-exception</li>\n<li>–max-old-space-size</li>\n<li>–stack-trace-limit</li>\n</ul>\n<p>NODE_PENDING_DEPRECATION=1<br>When set to 1, emit pending deprecation warnings.</p>\n<p>Note: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the –pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective “early warning” mechanism that developers may leverage to detect deprecated API usage.<br>(当设置为1时，发出挂起的弃用警告。注意:挂起的弃用通常与运行时弃用相同，有一个显著的例外:它们在默认情况下是关闭的，除非设置了–pending -deprecation命令行标志或NODE_PENDING_DEPRECATION=1环境变量，否则不会被触发。未决弃用用于提供一种选择性的“早期预警”机制，开发人员可以利用这种机制来检测弃用API的使用情况。)</p>\n<p>NODE_PRESERVE_SYMLINKS=1<br>When set to 1, instructs the module loader to preserve symbolic links when resolving and caching modules.<br>(当设置为1时，指示模块加载器在解析和缓存模块时保留符号链接。)</p>\n<p>NODE_REPL_HISTORY=file<br>用于存储持久性的 REPL 历史记录的文件的路径。 默认路径是 ~/.node_repl_history，可被该变量覆盖。 将值设为空字符串（”” 或 “ “）会禁用持久性的 REPL 历史记录。</p>\n<p>NODE_EXTRA_CA_CERTS=file<br>当设置了此选项时，根 CA 证书（如 VeriSign）会被 file 指定的证书扩展。 文件应该包括一个或多个可信的 PEM 格式的证书。 如果文件丢失或有缺陷，则 process.emitWarning() 会触发一个消息。<br>注意，当一个 TLS 或 HTTPS 的客户端或服务器的 ca 选项的属性被显式地指定时，则指定的证书不会被使用。</p>\n<p>OPENSSL_CONF=file<br>Load an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with ./configure –openssl-fips.<br>If the [–openssl-config][] command line option is used, the environment variable is ignored.<br>(启动时加载OpenSSL配置文件。在其他用途中，如果Node.js使用./configure –openssl-fips构建，则可以使用它来启用符合fips的加密。如果使用[–openssl-config][]命令行选项，则忽略环境变量。)</p>\n<p>SSL_CERT_DIR=dir<br>If –use-openssl-ca is enabled, this overrides and sets OpenSSL’s directory containing trusted certificates.<br>Note: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.<br>(如果启用了–use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL目录。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)</p>\n<p>SSL_CERT_FILE=file<br>If –use-openssl-ca is enabled, this overrides and sets OpenSSL’s file containing trusted certificates.<br>Note: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.<br>(如果启用了–use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL文件。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。)</p>\n<p>NODE_REDIRECT_WARNINGS=file<br>When set, process warnings will be emitted to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. This is equivalent to using the –redirect-warnings=file command-line flag.<br>(设置后，进程警告将被发送到给定的文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。这相当于使用–redirect-warnings=file命令行标志。)</p>\n<p>UV_THREADPOOL_SIZE=size<br>Set the number of threads used in libuv’s threadpool to size threads.<br>Asynchronous system APIs are used by Node.js whenever possible, but where they do not exist, libuv’s threadpool is used to create asynchronous node APIs based on synchronous system APIs. Node.js APIs that use the threadpool are:</p>\n<ul>\n<li>all fs APIs, other than the file watcher APIs and those that are explicitly synchronous</li>\n<li>crypto.pbkdf2()</li>\n<li>crypto.randomBytes(), unless it is used without a callback</li>\n<li>crypto.randomFill()</li>\n<li>dns.lookup()</li>\n<li>all zlib APIs, other than those that are explicitly synchronous<br>Because libuv’s threadpool has a fixed size, it means that if for whatever reason any of these APIs takes a long time, other (seemingly unrelated) APIs that run in libuv’s threadpool will experience degraded performance. In order to mitigate this issue, one potential solution is to increase the size of libuv’s threadpool by setting the ‘UV_THREADPOOL_SIZE’ environment variable to a value greater than 4 (its current default value). For more information, see the [libuv threadpool documentation][]. [–openssl-config]: #cli_openssl_config_file [Buffer]: buffer.html#buffer_buffer [Chrome Debugging Protocol]: <a href=\"https://chromedevtools.github.io/debugger-protocol-viewer\">https://chromedevtools.github.io/debugger-protocol-viewer</a> [REPL]: repl.html [SlowBuffer]: buffer.html#buffer_class_slowbuffer [debugger]: debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv threadpool documentation]: <a href=\"http://docs.libuv.org/en/latest/threadpool.html\">http://docs.libuv.org/en/latest/threadpool.html</a></li>\n</ul>\n<p>将libuv线程池中使用的线程数设置为线程大小。<br>node .js尽可能使用异步系统api，但在不存在异步系统api的地方，libuv的线程池用于基于同步系统api创建异步节点api。使用线程池的Node.js api有:</p>\n<ul>\n<li>所有的fs api，除了文件监视器api和那些显式同步的api</li>\n<li>crypto.pbkdf2()</li>\n<li>crypt.randombytes()，除非它在没有回调的情况下使用</li>\n<li>crypto.randomFill()</li>\n<li>dns.lookup()</li>\n<li>所有的zlib api，除了那些显式同步的<br>因为libuv的线程池大小是固定的，这意味着无论出于什么原因，如果这些api中的任何一个需要很长时间，在libuv的线程池中运行的其他(看似无关的)api将会经历性能下降。为了缓解这个问题，一个潜在的解决方案是通过将“UV_THREADPOOL_SIZE”环境变量设置为大于4(当前的默认值)来增加libuv线程池的大小。有关更多信息，请参阅[libuv线程池文档][]。[——openssl-config]: #cli_openssl_config_file [Buffer]: Buffer .html#buffer_buffer [Chrome调试协议]:<a href=\"https://chromedevtools.github.io/debugger-protocol-viewer\">https://chromedevtools.github.io/debugger-protocol-viewer</a> [REPL]: REPL .html [SlowBuffer]: Buffer .html#buffer_class_slowbuffer[调试器]:debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv线程池文档]:<a href=\"http://docs.libuv.org/en/latest/threadpool.html\">http://docs.libuv.org/en/latest/threadpool.html</a></li>\n</ul>\n<h4 id=\"console-控制台\"><a href=\"#console-控制台\" class=\"headerlink\" title=\"console (控制台)\"></a>console (控制台)</h4><p>console 模块提供了一个简单的调试控制台，类似于 Web 浏览器提供的 JavaScript 控制台。<br>该模块导出了两个特定的组件：</p>\n<ul>\n<li>一个 Console 类，包含 console.log() 、 console.error() 和 console.warn() 等方法，可以被用于写入到任何 Node.js 流。</li>\n<li>一个全局的 console 实例，可被用于写入到 process.stdout 和 process.stderr。 全局的 console 使用时无需调用 require(‘console’)。<br>注意：全局的 console 对象的方法既不总是同步的（如浏览器中类似的 API），也不总是异步的（如其他 Node.js 流）。 详见 进程 I/O。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用全局的 console</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;你好世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 stdout。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;你好%s&#x27;</span>, <span class=\"string\">&#x27;世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 stdout。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;错误信息&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 打印: [Error: 错误信息]到 stderr。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;描述&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(<span class=\"string\">`警告<span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;警告描述&#x27;到 stderr。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Console 类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> out = getStreamSomehow();</span><br><span class=\"line\"><span class=\"keyword\">const</span> err = getStreamSomehow();</span><br><span class=\"line\"><span class=\"keyword\">const</span> myConsole = <span class=\"keyword\">new</span> <span class=\"built_in\">console</span>.Console(out, err);</span><br><span class=\"line\">myConsole.log(<span class=\"string\">&#x27;你好世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 out。</span></span><br><span class=\"line\">myConsole.log(<span class=\"string\">&#x27;你好%s&#x27;</span>, <span class=\"string\">&#x27;世界&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;你好世界&#x27;到 out。</span></span><br><span class=\"line\">myConsole.error(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;错误信息&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 打印: [Error: 错误信息]到 err。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;描述&#x27;</span>;</span><br><span class=\"line\">myConsole.warn(<span class=\"string\">`警告<span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印: &#x27;警告描述&#x27;到 err。</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Console-类\"><a href=\"#Console-类\" class=\"headerlink\" title=\"Console 类\"></a>Console 类</h6><p>Console 类可用于创建一个具有可配置的输出流的简单记录器，可以通过 require(‘console’).Console 或 console.Console 使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; Console &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;console&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Console &#125; = <span class=\"built_in\">console</span>;</span><br></pre></td></tr></table></figure>\n<p>全局的 console 是一个特殊的 Console 实例，它的输出会发送到 process.stdout 和 process.stderr。 相当于调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Console(process.stdout, process.stderr);</span><br></pre></td></tr></table></figure>\n\n<p>console.assert(value[, message][, …args])<br>一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">true</span>, <span class=\"string\">&#x27;does nothing&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 通过</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">false</span>, <span class=\"string\">&#x27;Whoops %s&#x27;</span>, <span class=\"string\">&#x27;didn\\&#x27;t work&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// AssertionError: Whoops didn&#x27;t work</span></span><br></pre></td></tr></table></figure>\n<p>注意：Node.js 中的 console.assert() 方法与在浏览器中的 console.assert() 方法的实现是不一样的。<br>具体地说，在浏览器中，用非真的断言调用 console.assert() 会导致 message 被打印到控制台但不会中断后续代码的执行。 在 Node.js v10.0.0 之前，一个值为假的断言也将会导致一个AssertionError被抛出，使得代码执行被打断。v10.0.0 修复了此差异，所以现在console.assert()在 Node 和浏览器中执行行为相同。<br>可以通过扩展 Node.js 的 console 并重写 console.assert() 方法来实现与浏览器中类似的功能。<br><em>console.assert 在不同浏览器中可能获得不同的效果</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用一个新的不带补丁的 assert 实现来创建一个简单的 console 扩展。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myConsole = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">console</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">assert</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span>(<span class=\"params\">assertion, message, ...args</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.assert(assertion, message, ...args);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(err.stack);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = myConsole;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">console</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./myConsole&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"literal\">false</span>, <span class=\"string\">&#x27;会打印这个消息，但不会抛出错误&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;这个也会打印&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>console.clear()<br>当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。<br>注意：console.clear() 的具体行为可能因操作系统和终端类型而异。 对于大多数Linux操作系统，console.clear() 与 clear shell 命令行为类似。 在Windows上，console.clear() 将只清除当前终端视图中Node.js二进制文件的输出。</p>\n<p>console.count([label])</p>\n<ul>\n<li>label <string> 计数器的显示标签。 默认为 ‘default’。<br>维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count()</span><br><span class=\"line\"><span class=\"attr\">default</span>: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;default&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">default</span>: <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">abc</span>: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;xyz&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">xyz</span>: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count(<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\"><span class=\"attr\">abc</span>: <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">console</span>.count()</span><br><span class=\"line\"><span class=\"attr\">default</span>: <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></string></li>\n</ul>\n<p>console.countReset([label=’default’])</p>\n<ul>\n<li>label <string> 计数器的显示标签。 默认为 ‘default’。<br>重置指定 label 的内部计数器。</string></li>\n</ul>\n<p>console.debug(data[, …args])<br>console.debug()函数是console.log()的别名。</p>\n<p>console.dir(obj[, options])<br>在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。(在控制台中显示指定对象的属性，并通过类似文件树样式的交互列表显示。)<br>该函数会绕过任何定义在 obj 上的自定义的 inspect() 函数。<br>可选的 options 对象可以传入用于改变被格式化的字符串：</p>\n<ul>\n<li>showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。</li>\n<li>depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。</li>\n<li>colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。</li>\n</ul>\n<p>console.error([data][, …args])<br>打印到 stderr，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。<br>如果在第一个字符串中没有找到格式化元素（如 %d），则在每个参数上调用 util.inspect() 并将结果字符串值拼在一起。 详见 <a href=\"https://www.nodeapp.cn/util.html#util_util_format_format_args\">util.format()</a>。</p>\n<p>console.group([…label])#<br>…label <any><br>将后续行的缩进增加两个空格。<br>如果提供了一个或多个 labels，则首先打印这些 labels，而不需要额外的缩进。</any></p>\n<p>console.groupCollapsed()<br>console.group()的一个别名.</p>\n<p>console.groupEnd()<br>将后续行的缩进减少两个空格。</p>\n<p>console.info([data][, …args])<br>console.info() 函数是 console.log() 的一个别名。</p>\n<p>console.log([data][, …args])<br>打印到 stdout，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。</p>\n<p>console.time(label)<br>启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。</p>\n<p>console.timeEnd(label)<br>停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">&#x27;100-elements&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">&#x27;100-elements&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印 100-elements: 225.438ms</span></span><br></pre></td></tr></table></figure>\n<p>该方法在使用时不会将输出的时间返回到 js，它只能用于控制台调试。请勿将该方法作为普通计时器或性能数据收集器的一部分。</p>\n<p>console.trace([message][, …args])<br>打印字符串 ‘Trace :’ 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。</p>\n<p>console.warn([data][, …args])<br>console.warn() 函数是 console.error() 的一个别名。</p>\n"},{"_content":"","source":"nodejs/nodejs-note-14.md","raw":"","date":"2023-01-04T08:07:35.798Z","updated":"2023-01-04T08:07:35.798Z","path":"nodejs/nodejs-note-14.html","title":"","comments":1,"layout":"page","_id":"clchh4gws000ockttehk8fubz","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"nodejs/nodejs-note-15.md","raw":"","date":"2023-01-04T08:07:47.764Z","updated":"2023-01-04T08:07:47.764Z","path":"nodejs/nodejs-note-15.html","title":"","comments":1,"layout":"page","_id":"clchh4gws000qcktthcxfastz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"深入浅出nodejs阅读笔记(2)","date":"2022-11-19T13:10:12.000Z","tags":["node","docs"],"_content":"\n#### 为什么要异步 I/O \n- 用户体验\n  - ![i/o花费](./images/async-experience.png)\n- 资源分配\n  - ![i/o花费](./images/how-to-call-async.png)\n\n*异步I/O与非阻塞I/O*\n操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果\n![调用阻塞i/o的过程](./images/jam.png)\n阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。\n\n阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回\n![调用非阻塞i/o的过程](./images/no-jam.png)\n\n*操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取*\n\n阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费\n现存的轮询技术主要有以下这些：\n- read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。\n![read轮询](./images/read-loop.png)\n- select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断\n![select轮询](./images/select-loop.png)\n*select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符*\n- poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。\n![poll轮询](./images/poll-loop.png)\n- epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高\n![epoll轮询](./images/epoll-loop.png)\n- kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在\n\n###### Node 的异步 I/O\n1. 事件循环\n   进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程\n2. 观察者\n   每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件\n3. 请求对象\n   请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理\n![异步i/o流程](./images/async-progress.png)\n\n*事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。*\nWindows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事\n件循环，以此完成异步I/O的过程。\nLinux下通过epoll实现这个过程\nFreeBSD下通过kqueue实现\nSolaris下通过Event ports实现\n\n不同的是线程池在Windows下由内核（IOCP）直接提供，*nix系列下由libuv自行实现\n\n###### 非 I/O 的异步 API \n- 定时器\n调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。\n\n定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒\n\n![定时器](./images/settimeout.png)\n- process.nextTick()\n```javascript\nprocess.nextTick = function(callback) { \n // on the way out, don't bother. \n // it won't get fired anyway \n if (process._exiting) return; \n if (tickDepth >= process.maxTickDepth) \n maxTickWarn(); \n var tock = { callback: callback }; \n if (process.domain) tock.domain = process.domain; \n nextTickQueue.push(tock); \n if (nextTickQueue.length) { \n process._needTickCallback(); \n } \n}; \n```\n每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效\n- setImmediate()\nprocess.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。\n\nprocess.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。\n```javascript\n// 加入两个nextTick()的回调函数\nprocess.nextTick(function () { \n console.log('nextTick延迟执行1'); \n}); \nprocess.nextTick(function () { \n console.log('nextTick延迟执行2'); \n}); \n// 加入两个setImmediate()的回调函数\nsetImmediate(function () { \n console.log('setImmediate延迟执行1'); \n // 进入下次循环\n process.nextTick(function () { \n console.log('强势插入'); \n }); \n}); \nsetImmediate(function () { \n console.log('setImmediate延迟执行2'); \n}); \nconsole.log('正常执行'); \n// 其执行结果如下：\n// 正常执行\n// nextTick延迟执行1 \n// nextTick延迟执行2 \n// setImmediate延迟执行1 \n// 强势插入\n// setImmediate延迟执行2 \n```\n\n#### 异步编程\n\n- 高阶函数:高阶函数则是可以把函数作为参数，或是将函数作为返回值的函数\n- 偏函数用法: 偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。\n\n###### 异步编程的优势与难点\n- 优势\n非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。\n对于网络应用而言，并行带来的想象空间更大，延展而开的是分布式和云\n- 难点\n  - 异常处理\n  - 函数嵌套过深\n  - 阻塞代码\n  - 多线程编程\n  - 异步转同步\n\n###### 异步编程解决方案\n- 事件发布/订阅模式。\n  - Node自身提供的events模块（http://nodejs.org/docs/latest/api/events.html）是发布/订阅模式的一个简单实现，Node中部分模块都继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()、stopPropagation()和stopImmediatePropagation()等控制事件传递的方法。它具有 addListener/on() 、 once() 、 removeListener() 、removeAllListeners()和emit()等基本的事件监听模式的方法实现\n  - 如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0)；可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理\n  - 继承events模块\n  - 利用事件队列解决雪崩问题\n  - 多异步之间的协作方案\n```javascript\nvar count = 0; \nvar results = {}; \nvar done = function (key, value) { \n results[key] = value; \n count++; \n if (count === 3) { \n // 渲染页面\n render(results); \n } \n}; \nfs.readFile(template_path, \"utf8\", function (err, template) { \n done(\"template\", template); \n}); \ndb.query(sql, function (err, data) { \n done(\"data\", data); \n}); \nl10n.get(function (err, resources) { \n done(\"resources\", resources); \n});\n```\n   - EventProxy的原理\n```javascript\n// Trigger an event, firing all bound callbacks. Callbacks are passed the \n// same arguments as `trigger` is, apart from the event name. \n// Listening for `\"all\"` passes the true event name as the first argument \ntrigger : function(eventName) { \n var list, calls, ev, callback, args; \n var both = 2; \n if (!(calls = this._callbacks)) return this;\n while (both--) { \n ev = both ? eventName : 'all'; \n if (list = calls[ev]) { \n for (var i = 0, l = list.length; i < l; i++) { \n if (!(callback = list[i])) { \n list.splice(i, 1); i--; l--; \n } else { \n args = both ? Array.prototype.slice.call(arguments, 1) : arguments; \n callback[0].apply(callback[1] || this, args); \n } \n } \n } \n } \n return this; \n}\n```\n   - EventProxy的异常处理\n- Promise/Deferred模式。\n  -  Promises/A \n     -  Promise/Deferred模式其实包含两部分，即Promise和Deferred。这里暂且不提两者的区别是什么，先看看Promises/A的行为吧。Promises/A提议对单个异步操作做出了这样的抽象定义，具体如下所示。\n        - Promise操作只会处在3种状态的一种：未完成态、完成态和失败态。\n        - Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。\n        - Promise的状态一旦转化，将不能被更改\n      - 在API的定义上，Promises/A提议是比较简单的。一个Promise对象只要具备then()方法即可。但是对于then()方法，有以下简单的要求。\n        - 接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法\n        - 可选地支持progress事件回调作为第三个方法。\n        - then()方法只接受function对象，其余对象将被忽略。\n        - then()方法继续返回Promise对象，以实现链式调用\n        - ![defer和promise](./images/defer-promise.png)\n  - Promise中的多异步协作\n```javascript\nDeferred.prototype.all = function (promises) { \nvar count = promises.length; \n var that = this; \n var results = []; \n promises.forEach(function (promise, i) { \n promise.then(function (data) { \n count--; \n results[i] = data; \n if (count === 0) { \n that.resolve(results); \n } \n }, function (err) { \n that.reject(err); \n }); \n }); \n return this.promise; \n}; \n```\n        - 支持序列执行的Promise\n```javascript\npromise() \n .then(obj.api1) \n .then(obj.api2) \n .then(obj.api3) \n .then(obj.api4) \n .then(function (value4) { \n // Do something with value4 \n }, function (error) { \n // Handle any error from step1 through step4 \n }) \n .done(); \n尝试改造一下代码以实现链式调用，具体如下所示：\nvar Deferred = function () { \n this.promise = new Promise(); \n}; \n// 完成态\nDeferred.prototype.resolve = function (obj) { \n var promise = this.promise; \n var handler; \n while ((handler = promise.queue.shift())) { \n if (handler && handler.fulfilled) { \n var ret = handler.fulfilled(obj); \n if (ret && ret.isPromise) { \n ret.queue = promise.queue; \n this.promise = ret; \n return; \n } \n } \n } \n}; \n// 失败态\nDeferred.prototype.reject = function (err) { \n var promise = this.promise; \n var handler; \n while ((handler = promise.queue.shift())) { \n if (handler && handler.error) { \n var ret = handler.error(err); \n if (ret && ret.isPromise) { \n ret.queue = promise.queue; \n this.promise = ret;\n return; \n } \n } \n } \n}; \n// 生成回调函数\nDeferred.prototype.callback = function () { \n var that = this; \n return function (err, file) { \n if (err) { \n return that.reject(err); \n } \n that.resolve(file); \n }; \n}; \nvar Promise = function () { \n // 队列用于存储待执行的回调函数\n this.queue = []; \n this.isPromise = true; \n}; \nPromise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) { \n var handler = {}; \n if (typeof fulfilledHandler === 'function') { \n handler.fulfilled = fulfilledHandler; \n } \n if (typeof errorHandler === 'function') { \n handler.error = errorHandler; \n } \n this.queue.push(handler); \n return this; \n};\n```\n        - 将API Promise化\n- 流程控制库\n  - 尾触发与Next\n    - 需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。事实上，尾触发目前应用最多的地方是Connect的中间件\n    - ![中间件](./images/tail-trigger.png)\n    - 尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能够各自清晰\n  - async\n    - 异步的串行执行\n```javascript\nasync.series([ \n function (callback) { \n fs.readFile('file1.txt', 'utf-8', callback); \n }, \n function (callback) { \n fs.readFile('file2.txt', 'utf-8', callback); \n } \n], function (err, results) { \n // results => [file1.txt, file2.txt] \n}); \n这段代码等价于：\nfs.readFile('file1.txt', 'utf-8', function (err, content) { \n if (err) { \n return callback(err); \n } \n fs.readFile('file2.txt ', 'utf-8', function (err, data) { \n if (err) { \n return callback(err); \n } \n callback(null, [content, data]); \n }); \n}); \n\n```\n    - 异步的并行执行\n```javascript\nasync.parallel([ \n function (callback) { \n fs.readFile('file1.txt', 'utf-8', callback); \n }, \n function (callback) { \n fs.readFile('file2.txt', 'utf-8', callback); \n } \n], function (err, results) { \n // results => [file1.txt, file2.txt] \n}); \n```\n    - 异步调用的依赖处理\n      - series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。所幸，这种典型场景的需求，async提供了waterfall()方法来满足\n```javascript\nasync.waterfall([ \n function (callback) { \n fs.readFile('file1.txt', 'utf-8', function (err, content) { \n callback(err, content); \n }); \n }, \n function (arg1, callback) { \n // arg1 => file2.txt \n fs.readFile(arg1, 'utf-8', function (err, content) { \n callback(err, content); \n }); \n }, \n function(arg1, callback){ \n // arg1 => file3.txt \n fs.readFile(arg1, 'utf-8', function (err, content) { \n callback(err, content); \n }); \n } \n], function (err, result) { \n // result => file4.txt \n});\n```\n    - 自动依赖处理\n      - async提供了一个强大的方法auto()实现复杂业务处理。\n  - Step\n```javascript\nStep( \n function readFile1() { \n fs.readFile('file1.txt', 'utf-8', this); \n }, \n function readFile2(err, content) { \n fs.readFile('file2.txt', 'utf-8', this); \n }, \n function done(err, content) { \n console.log(content); \n } \n);\n```\n    - Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。\n    - 并行任务执行\n      - this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务\n      - 使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数\n    - 结果分组: group()\n  - wind\n    - 异步任务定义\n    - $await()与任务模型\n    - 异步方法转换辅助函数\n      - Wind.Async.Binding.fromCallback\n      - Wind.Async.Binding.fromStandard\n\n###### 异步并发控制\n- bagpipe的解决方案\n  - 通过一个队列来控制并发量。\n  - 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。\n  - 如果活跃调用达到限定值，调用暂时存放在队列中。\n  - 每个异步调用结束时，从队列中取出新的异步调用执行。\n```javascript\nvar Bagpipe = require('bagpipe'); \n// 设定最大并发数为10\nvar bagpipe = new Bagpipe(10); \nfor (var i = 0; i < 100; i++) { \n bagpipe.push(async, function () { \n // 异步回调执行\n }); \n} \nbagpipe.on('full', function (length) { \n console.warn('底层系统处理不能及时完成，队列拥堵，目前队列长度为:' + length); \n}); \n```\n      - 拒绝模式\n      - 超时控制\n\n   - async的解决方案：async也提供了一个方法用于处理异步调用的限制：parallelLimit()\n     - parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。\n     - parallelLimit()方法的缺陷在于无法动态地增加并行任务。为此，async提供了queue()方法来满足该需求，这对于遍历文件目录等操作十分有效","source":"nodejs/nodejs-note-2.md","raw":"---\ntitle: 深入浅出nodejs阅读笔记(2)\ndate: 2022-11-19 21:10:12\ntags: [node, docs]\n---\n\n#### 为什么要异步 I/O \n- 用户体验\n  - ![i/o花费](./images/async-experience.png)\n- 资源分配\n  - ![i/o花费](./images/how-to-call-async.png)\n\n*异步I/O与非阻塞I/O*\n操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果\n![调用阻塞i/o的过程](./images/jam.png)\n阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。\n\n阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回\n![调用非阻塞i/o的过程](./images/no-jam.png)\n\n*操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取*\n\n阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费\n现存的轮询技术主要有以下这些：\n- read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。\n![read轮询](./images/read-loop.png)\n- select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断\n![select轮询](./images/select-loop.png)\n*select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符*\n- poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。\n![poll轮询](./images/poll-loop.png)\n- epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高\n![epoll轮询](./images/epoll-loop.png)\n- kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在\n\n###### Node 的异步 I/O\n1. 事件循环\n   进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程\n2. 观察者\n   每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件\n3. 请求对象\n   请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理\n![异步i/o流程](./images/async-progress.png)\n\n*事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。*\nWindows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事\n件循环，以此完成异步I/O的过程。\nLinux下通过epoll实现这个过程\nFreeBSD下通过kqueue实现\nSolaris下通过Event ports实现\n\n不同的是线程池在Windows下由内核（IOCP）直接提供，*nix系列下由libuv自行实现\n\n###### 非 I/O 的异步 API \n- 定时器\n调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。\n\n定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒\n\n![定时器](./images/settimeout.png)\n- process.nextTick()\n```javascript\nprocess.nextTick = function(callback) { \n // on the way out, don't bother. \n // it won't get fired anyway \n if (process._exiting) return; \n if (tickDepth >= process.maxTickDepth) \n maxTickWarn(); \n var tock = { callback: callback }; \n if (process.domain) tock.domain = process.domain; \n nextTickQueue.push(tock); \n if (nextTickQueue.length) { \n process._needTickCallback(); \n } \n}; \n```\n每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效\n- setImmediate()\nprocess.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。\n\nprocess.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。\n```javascript\n// 加入两个nextTick()的回调函数\nprocess.nextTick(function () { \n console.log('nextTick延迟执行1'); \n}); \nprocess.nextTick(function () { \n console.log('nextTick延迟执行2'); \n}); \n// 加入两个setImmediate()的回调函数\nsetImmediate(function () { \n console.log('setImmediate延迟执行1'); \n // 进入下次循环\n process.nextTick(function () { \n console.log('强势插入'); \n }); \n}); \nsetImmediate(function () { \n console.log('setImmediate延迟执行2'); \n}); \nconsole.log('正常执行'); \n// 其执行结果如下：\n// 正常执行\n// nextTick延迟执行1 \n// nextTick延迟执行2 \n// setImmediate延迟执行1 \n// 强势插入\n// setImmediate延迟执行2 \n```\n\n#### 异步编程\n\n- 高阶函数:高阶函数则是可以把函数作为参数，或是将函数作为返回值的函数\n- 偏函数用法: 偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。\n\n###### 异步编程的优势与难点\n- 优势\n非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。\n对于网络应用而言，并行带来的想象空间更大，延展而开的是分布式和云\n- 难点\n  - 异常处理\n  - 函数嵌套过深\n  - 阻塞代码\n  - 多线程编程\n  - 异步转同步\n\n###### 异步编程解决方案\n- 事件发布/订阅模式。\n  - Node自身提供的events模块（http://nodejs.org/docs/latest/api/events.html）是发布/订阅模式的一个简单实现，Node中部分模块都继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()、stopPropagation()和stopImmediatePropagation()等控制事件传递的方法。它具有 addListener/on() 、 once() 、 removeListener() 、removeAllListeners()和emit()等基本的事件监听模式的方法实现\n  - 如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0)；可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理\n  - 继承events模块\n  - 利用事件队列解决雪崩问题\n  - 多异步之间的协作方案\n```javascript\nvar count = 0; \nvar results = {}; \nvar done = function (key, value) { \n results[key] = value; \n count++; \n if (count === 3) { \n // 渲染页面\n render(results); \n } \n}; \nfs.readFile(template_path, \"utf8\", function (err, template) { \n done(\"template\", template); \n}); \ndb.query(sql, function (err, data) { \n done(\"data\", data); \n}); \nl10n.get(function (err, resources) { \n done(\"resources\", resources); \n});\n```\n   - EventProxy的原理\n```javascript\n// Trigger an event, firing all bound callbacks. Callbacks are passed the \n// same arguments as `trigger` is, apart from the event name. \n// Listening for `\"all\"` passes the true event name as the first argument \ntrigger : function(eventName) { \n var list, calls, ev, callback, args; \n var both = 2; \n if (!(calls = this._callbacks)) return this;\n while (both--) { \n ev = both ? eventName : 'all'; \n if (list = calls[ev]) { \n for (var i = 0, l = list.length; i < l; i++) { \n if (!(callback = list[i])) { \n list.splice(i, 1); i--; l--; \n } else { \n args = both ? Array.prototype.slice.call(arguments, 1) : arguments; \n callback[0].apply(callback[1] || this, args); \n } \n } \n } \n } \n return this; \n}\n```\n   - EventProxy的异常处理\n- Promise/Deferred模式。\n  -  Promises/A \n     -  Promise/Deferred模式其实包含两部分，即Promise和Deferred。这里暂且不提两者的区别是什么，先看看Promises/A的行为吧。Promises/A提议对单个异步操作做出了这样的抽象定义，具体如下所示。\n        - Promise操作只会处在3种状态的一种：未完成态、完成态和失败态。\n        - Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。\n        - Promise的状态一旦转化，将不能被更改\n      - 在API的定义上，Promises/A提议是比较简单的。一个Promise对象只要具备then()方法即可。但是对于then()方法，有以下简单的要求。\n        - 接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法\n        - 可选地支持progress事件回调作为第三个方法。\n        - then()方法只接受function对象，其余对象将被忽略。\n        - then()方法继续返回Promise对象，以实现链式调用\n        - ![defer和promise](./images/defer-promise.png)\n  - Promise中的多异步协作\n```javascript\nDeferred.prototype.all = function (promises) { \nvar count = promises.length; \n var that = this; \n var results = []; \n promises.forEach(function (promise, i) { \n promise.then(function (data) { \n count--; \n results[i] = data; \n if (count === 0) { \n that.resolve(results); \n } \n }, function (err) { \n that.reject(err); \n }); \n }); \n return this.promise; \n}; \n```\n        - 支持序列执行的Promise\n```javascript\npromise() \n .then(obj.api1) \n .then(obj.api2) \n .then(obj.api3) \n .then(obj.api4) \n .then(function (value4) { \n // Do something with value4 \n }, function (error) { \n // Handle any error from step1 through step4 \n }) \n .done(); \n尝试改造一下代码以实现链式调用，具体如下所示：\nvar Deferred = function () { \n this.promise = new Promise(); \n}; \n// 完成态\nDeferred.prototype.resolve = function (obj) { \n var promise = this.promise; \n var handler; \n while ((handler = promise.queue.shift())) { \n if (handler && handler.fulfilled) { \n var ret = handler.fulfilled(obj); \n if (ret && ret.isPromise) { \n ret.queue = promise.queue; \n this.promise = ret; \n return; \n } \n } \n } \n}; \n// 失败态\nDeferred.prototype.reject = function (err) { \n var promise = this.promise; \n var handler; \n while ((handler = promise.queue.shift())) { \n if (handler && handler.error) { \n var ret = handler.error(err); \n if (ret && ret.isPromise) { \n ret.queue = promise.queue; \n this.promise = ret;\n return; \n } \n } \n } \n}; \n// 生成回调函数\nDeferred.prototype.callback = function () { \n var that = this; \n return function (err, file) { \n if (err) { \n return that.reject(err); \n } \n that.resolve(file); \n }; \n}; \nvar Promise = function () { \n // 队列用于存储待执行的回调函数\n this.queue = []; \n this.isPromise = true; \n}; \nPromise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) { \n var handler = {}; \n if (typeof fulfilledHandler === 'function') { \n handler.fulfilled = fulfilledHandler; \n } \n if (typeof errorHandler === 'function') { \n handler.error = errorHandler; \n } \n this.queue.push(handler); \n return this; \n};\n```\n        - 将API Promise化\n- 流程控制库\n  - 尾触发与Next\n    - 需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。事实上，尾触发目前应用最多的地方是Connect的中间件\n    - ![中间件](./images/tail-trigger.png)\n    - 尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能够各自清晰\n  - async\n    - 异步的串行执行\n```javascript\nasync.series([ \n function (callback) { \n fs.readFile('file1.txt', 'utf-8', callback); \n }, \n function (callback) { \n fs.readFile('file2.txt', 'utf-8', callback); \n } \n], function (err, results) { \n // results => [file1.txt, file2.txt] \n}); \n这段代码等价于：\nfs.readFile('file1.txt', 'utf-8', function (err, content) { \n if (err) { \n return callback(err); \n } \n fs.readFile('file2.txt ', 'utf-8', function (err, data) { \n if (err) { \n return callback(err); \n } \n callback(null, [content, data]); \n }); \n}); \n\n```\n    - 异步的并行执行\n```javascript\nasync.parallel([ \n function (callback) { \n fs.readFile('file1.txt', 'utf-8', callback); \n }, \n function (callback) { \n fs.readFile('file2.txt', 'utf-8', callback); \n } \n], function (err, results) { \n // results => [file1.txt, file2.txt] \n}); \n```\n    - 异步调用的依赖处理\n      - series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。所幸，这种典型场景的需求，async提供了waterfall()方法来满足\n```javascript\nasync.waterfall([ \n function (callback) { \n fs.readFile('file1.txt', 'utf-8', function (err, content) { \n callback(err, content); \n }); \n }, \n function (arg1, callback) { \n // arg1 => file2.txt \n fs.readFile(arg1, 'utf-8', function (err, content) { \n callback(err, content); \n }); \n }, \n function(arg1, callback){ \n // arg1 => file3.txt \n fs.readFile(arg1, 'utf-8', function (err, content) { \n callback(err, content); \n }); \n } \n], function (err, result) { \n // result => file4.txt \n});\n```\n    - 自动依赖处理\n      - async提供了一个强大的方法auto()实现复杂业务处理。\n  - Step\n```javascript\nStep( \n function readFile1() { \n fs.readFile('file1.txt', 'utf-8', this); \n }, \n function readFile2(err, content) { \n fs.readFile('file2.txt', 'utf-8', this); \n }, \n function done(err, content) { \n console.log(content); \n } \n);\n```\n    - Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。\n    - 并行任务执行\n      - this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务\n      - 使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数\n    - 结果分组: group()\n  - wind\n    - 异步任务定义\n    - $await()与任务模型\n    - 异步方法转换辅助函数\n      - Wind.Async.Binding.fromCallback\n      - Wind.Async.Binding.fromStandard\n\n###### 异步并发控制\n- bagpipe的解决方案\n  - 通过一个队列来控制并发量。\n  - 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。\n  - 如果活跃调用达到限定值，调用暂时存放在队列中。\n  - 每个异步调用结束时，从队列中取出新的异步调用执行。\n```javascript\nvar Bagpipe = require('bagpipe'); \n// 设定最大并发数为10\nvar bagpipe = new Bagpipe(10); \nfor (var i = 0; i < 100; i++) { \n bagpipe.push(async, function () { \n // 异步回调执行\n }); \n} \nbagpipe.on('full', function (length) { \n console.warn('底层系统处理不能及时完成，队列拥堵，目前队列长度为:' + length); \n}); \n```\n      - 拒绝模式\n      - 超时控制\n\n   - async的解决方案：async也提供了一个方法用于处理异步调用的限制：parallelLimit()\n     - parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。\n     - parallelLimit()方法的缺陷在于无法动态地增加并行任务。为此，async提供了queue()方法来满足该需求，这对于遍历文件目录等操作十分有效","updated":"2022-12-28T01:46:56.920Z","path":"nodejs/nodejs-note-2.html","comments":1,"layout":"page","_id":"clchh4gwt000scktt8ten6wa4","content":"<h4 id=\"为什么要异步-I-O\"><a href=\"#为什么要异步-I-O\" class=\"headerlink\" title=\"为什么要异步 I/O\"></a>为什么要异步 I/O</h4><ul>\n<li>用户体验<ul>\n<li><img src=\"/nodejs/images/async-experience.png\" alt=\"i/o花费\"></li>\n</ul>\n</li>\n<li>资源分配<ul>\n<li><img src=\"/nodejs/images/how-to-call-async.png\" alt=\"i/o花费\"></li>\n</ul>\n</li>\n</ul>\n<p><em>异步I/O与非阻塞I/O</em><br>操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果<br><img src=\"/nodejs/images/jam.png\" alt=\"调用阻塞i/o的过程\"><br>阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。</p>\n<p>阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回<br><img src=\"/nodejs/images/no-jam.png\" alt=\"调用非阻塞i/o的过程\"></p>\n<p><em>操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取</em></p>\n<p>阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费<br>现存的轮询技术主要有以下这些：</p>\n<ul>\n<li>read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。<br><img src=\"/nodejs/images/read-loop.png\" alt=\"read轮询\"></li>\n<li>select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断<br><img src=\"/nodejs/images/select-loop.png\" alt=\"select轮询\"></li>\n</ul>\n<p><em>select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符</em></p>\n<ul>\n<li>poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。<br><img src=\"/nodejs/images/poll-loop.png\" alt=\"poll轮询\"></li>\n<li>epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高<br><img src=\"/nodejs/images/epoll-loop.png\" alt=\"epoll轮询\"></li>\n<li>kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在</li>\n</ul>\n<h6 id=\"Node-的异步-I-O\"><a href=\"#Node-的异步-I-O\" class=\"headerlink\" title=\"Node 的异步 I/O\"></a>Node 的异步 I/O</h6><ol>\n<li>事件循环<br>进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程</li>\n<li>观察者<br>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</li>\n<li>请求对象<br>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理<br><img src=\"/nodejs/images/async-progress.png\" alt=\"异步i/o流程\"></li>\n</ol>\n<p><em>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</em><br>Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事<br>件循环，以此完成异步I/O的过程。<br>Linux下通过epoll实现这个过程<br>FreeBSD下通过kqueue实现<br>Solaris下通过Event ports实现</p>\n<p>不同的是线程池在Windows下由内核（IOCP）直接提供，*nix系列下由libuv自行实现</p>\n<h6 id=\"非-I-O-的异步-API\"><a href=\"#非-I-O-的异步-API\" class=\"headerlink\" title=\"非 I/O 的异步 API\"></a>非 I/O 的异步 API</h6><ul>\n<li>定时器<br>调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。</li>\n</ul>\n<p>定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒</p>\n<p><img src=\"/nodejs/images/settimeout.png\" alt=\"定时器\"></p>\n<ul>\n<li>process.nextTick()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// on the way out, don&#x27;t bother. </span></span><br><span class=\"line\"> <span class=\"comment\">// it won&#x27;t get fired anyway </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (process._exiting) <span class=\"keyword\">return</span>; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (tickDepth &gt;= process.maxTickDepth) </span><br><span class=\"line\"> maxTickWarn(); </span><br><span class=\"line\"> <span class=\"keyword\">var</span> tock = &#123; <span class=\"attr\">callback</span>: callback &#125;; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (process.domain) tock.domain = process.domain; </span><br><span class=\"line\"> nextTickQueue.push(tock); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (nextTickQueue.length) &#123; </span><br><span class=\"line\"> process._needTickCallback(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效</li>\n<li>setImmediate()<br>process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。</li>\n</ul>\n<p>process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加入两个nextTick()的回调函数</span></span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;nextTick延迟执行1&#x27;</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;nextTick延迟执行2&#x27;</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"comment\">// 加入两个setImmediate()的回调函数</span></span><br><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;setImmediate延迟执行1&#x27;</span>); </span><br><span class=\"line\"> <span class=\"comment\">// 进入下次循环</span></span><br><span class=\"line\"> process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;强势插入&#x27;</span>); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;setImmediate延迟执行2&#x27;</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;正常执行&#x27;</span>); </span><br><span class=\"line\"><span class=\"comment\">// 其执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 正常执行</span></span><br><span class=\"line\"><span class=\"comment\">// nextTick延迟执行1 </span></span><br><span class=\"line\"><span class=\"comment\">// nextTick延迟执行2 </span></span><br><span class=\"line\"><span class=\"comment\">// setImmediate延迟执行1 </span></span><br><span class=\"line\"><span class=\"comment\">// 强势插入</span></span><br><span class=\"line\"><span class=\"comment\">// setImmediate延迟执行2 </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h4><ul>\n<li>高阶函数:高阶函数则是可以把函数作为参数，或是将函数作为返回值的函数</li>\n<li>偏函数用法: 偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。</li>\n</ul>\n<h6 id=\"异步编程的优势与难点\"><a href=\"#异步编程的优势与难点\" class=\"headerlink\" title=\"异步编程的优势与难点\"></a>异步编程的优势与难点</h6><ul>\n<li>优势<br>非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。<br>对于网络应用而言，并行带来的想象空间更大，延展而开的是分布式和云</li>\n<li>难点<ul>\n<li>异常处理</li>\n<li>函数嵌套过深</li>\n<li>阻塞代码</li>\n<li>多线程编程</li>\n<li>异步转同步</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"异步编程解决方案\"><a href=\"#异步编程解决方案\" class=\"headerlink\" title=\"异步编程解决方案\"></a>异步编程解决方案</h6><ul>\n<li>事件发布/订阅模式。<ul>\n<li>Node自身提供的events模块（<a href=\"http://nodejs.org/docs/latest/api/events.html%EF%BC%89%E6%98%AF%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%8CNode%E4%B8%AD%E9%83%A8%E5%88%86%E6%A8%A1%E5%9D%97%E9%83%BD%E7%BB%A7%E6%89%BF%E8%87%AA%E5%AE%83%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%AF%94%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%A4%A7%E9%87%8FDOM%E4%BA%8B%E4%BB%B6%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%8C%E4%B9%9F%E4%B8%8D%E5%AD%98%E5%9C%A8preventDefault()%E3%80%81stopPropagation()%E5%92%8CstopImmediatePropagation()%E7%AD%89%E6%8E%A7%E5%88%B6%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%E5%AE%83%E5%85%B7%E6%9C%89\">http://nodejs.org/docs/latest/api/events.html）是发布/订阅模式的一个简单实现，Node中部分模块都继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()、stopPropagation()和stopImmediatePropagation()等控制事件传递的方法。它具有</a> addListener/on() 、 once() 、 removeListener() 、removeAllListeners()和emit()等基本的事件监听模式的方法实现</li>\n<li>如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0)；可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理</li>\n<li>继承events模块</li>\n<li>利用事件队列解决雪崩问题</li>\n<li>多异步之间的协作方案<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> results = &#123;&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123; </span><br><span class=\"line\"> results[key] = value; </span><br><span class=\"line\"> count++; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (count === <span class=\"number\">3</span>) &#123; </span><br><span class=\"line\"> <span class=\"comment\">// 渲染页面</span></span><br><span class=\"line\"> render(results); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">fs.readFile(template_path, <span class=\"string\">&quot;utf8&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, template</span>) </span>&#123; </span><br><span class=\"line\"> done(<span class=\"string\">&quot;template&quot;</span>, template); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">db.query(sql, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123; </span><br><span class=\"line\"> done(<span class=\"string\">&quot;data&quot;</span>, data); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">l10n.get(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, resources</span>) </span>&#123; </span><br><span class=\"line\"> done(<span class=\"string\">&quot;resources&quot;</span>, resources); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>EventProxy的原理<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trigger an event, firing all bound callbacks. Callbacks are passed the </span></span><br><span class=\"line\"><span class=\"comment\">// same arguments as `trigger` is, apart from the event name. </span></span><br><span class=\"line\"><span class=\"comment\">// Listening for `&quot;all&quot;` passes the true event name as the first argument </span></span><br><span class=\"line\"><span class=\"attr\">trigger</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> list, calls, ev, callback, args; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> both = <span class=\"number\">2</span>; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!(calls = <span class=\"built_in\">this</span>._callbacks)) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (both--) &#123; </span><br><span class=\"line\"> ev = both ? eventName : <span class=\"string\">&#x27;all&#x27;</span>; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (list = calls[ev]) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = list.length; i &lt; l; i++) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!(callback = list[i])) &#123; </span><br><span class=\"line\"> list.splice(i, <span class=\"number\">1</span>); i--; l--; </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\"> args = both ? <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>) : <span class=\"built_in\">arguments</span>; </span><br><span class=\"line\"> callback[<span class=\"number\">0</span>].apply(callback[<span class=\"number\">1</span>] || <span class=\"built_in\">this</span>, args); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>EventProxy的异常处理</li>\n</ul>\n</li>\n<li>Promise/Deferred模式。<ul>\n<li>Promises/A <ul>\n<li>Promise/Deferred模式其实包含两部分，即Promise和Deferred。这里暂且不提两者的区别是什么，先看看Promises/A的行为吧。Promises/A提议对单个异步操作做出了这样的抽象定义，具体如下所示。<ul>\n<li>Promise操作只会处在3种状态的一种：未完成态、完成态和失败态。</li>\n<li>Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。</li>\n<li>Promise的状态一旦转化，将不能被更改</li>\n</ul>\n</li>\n<li>在API的定义上，Promises/A提议是比较简单的。一个Promise对象只要具备then()方法即可。但是对于then()方法，有以下简单的要求。<ul>\n<li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法</li>\n<li>可选地支持progress事件回调作为第三个方法。</li>\n<li>then()方法只接受function对象，其余对象将被忽略。</li>\n<li>then()方法继续返回Promise对象，以实现链式调用</li>\n<li><img src=\"/nodejs/images/defer-promise.png\" alt=\"defer和promise\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Promise中的多异步协作<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deferred.prototype.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">var</span> count = promises.length; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> that = <span class=\"built_in\">this</span>; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> results = []; </span><br><span class=\"line\"> promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise, i</span>) </span>&#123; </span><br><span class=\"line\"> promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123; </span><br><span class=\"line\"> count--; </span><br><span class=\"line\"> results[i] = data; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (count === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\"> that.resolve(results); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123; </span><br><span class=\"line\"> that.reject(err); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.promise; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<pre><code>- 支持序列执行的Promise\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise() </span><br><span class=\"line\"> .then(obj.api1) </span><br><span class=\"line\"> .then(obj.api2) </span><br><span class=\"line\"> .then(obj.api3) </span><br><span class=\"line\"> .then(obj.api4) </span><br><span class=\"line\"> .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value4</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// Do something with value4 </span></span><br><span class=\"line\"> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// Handle any error from step1 through step4 </span></span><br><span class=\"line\"> &#125;) </span><br><span class=\"line\"> .done(); </span><br><span class=\"line\">尝试改造一下代码以实现链式调用，具体如下所示：</span><br><span class=\"line\"><span class=\"keyword\">var</span> Deferred = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// 完成态</span></span><br><span class=\"line\">Deferred.prototype.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> promise = <span class=\"built_in\">this</span>.promise; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> handler; </span><br><span class=\"line\"> <span class=\"keyword\">while</span> ((handler = promise.queue.shift())) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (handler &amp;&amp; handler.fulfilled) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> ret = handler.fulfilled(obj); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (ret &amp;&amp; ret.isPromise) &#123; </span><br><span class=\"line\"> ret.queue = promise.queue; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.promise = ret; </span><br><span class=\"line\"> <span class=\"keyword\">return</span>; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// 失败态</span></span><br><span class=\"line\">Deferred.prototype.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> promise = <span class=\"built_in\">this</span>.promise; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> handler; </span><br><span class=\"line\"> <span class=\"keyword\">while</span> ((handler = promise.queue.shift())) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (handler &amp;&amp; handler.error) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> ret = handler.error(err); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (ret &amp;&amp; ret.isPromise) &#123; </span><br><span class=\"line\"> ret.queue = promise.queue; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.promise = ret;</span><br><span class=\"line\"> <span class=\"keyword\">return</span>; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// 生成回调函数</span></span><br><span class=\"line\">Deferred.prototype.callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> that = <span class=\"built_in\">this</span>; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, file</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (err) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> that.reject(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> that.resolve(file); </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">Promise</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// 队列用于存储待执行的回调函数</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.queue = []; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.isPromise = <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> handler = &#123;&#125;; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fulfilledHandler === <span class=\"string\">&#x27;function&#x27;</span>) &#123; </span><br><span class=\"line\"> handler.fulfilled = fulfilledHandler; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> errorHandler === <span class=\"string\">&#x27;function&#x27;</span>) &#123; </span><br><span class=\"line\"> handler.error = errorHandler; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.queue.push(handler); </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<pre><code>- 将API Promise化\n</code></pre>\n</li>\n</ul>\n</li>\n<li>流程控制库<ul>\n<li>尾触发与Next<ul>\n<li>需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。事实上，尾触发目前应用最多的地方是Connect的中间件</li>\n<li><img src=\"/nodejs/images/tail-trigger.png\" alt=\"中间件\"></li>\n<li>尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能够各自清晰</li>\n</ul>\n</li>\n<li>async<ul>\n<li>异步的串行执行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.series([ </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, results</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">这段代码等价于：</span><br><span class=\"line\">fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (err) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> callback(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt &#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (err) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> callback(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> callback(<span class=\"literal\">null</span>, [content, data]); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>异步的并行执行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.parallel([ </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, results</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure></li>\n<li>异步调用的依赖处理<ul>\n<li>series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。所幸，这种典型场景的需求，async提供了waterfall()方法来满足<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.waterfall([ </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> callback(err, content); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, callback</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// arg1 =&gt; file2.txt </span></span><br><span class=\"line\"> fs.readFile(arg1, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> callback(err, content); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, callback</span>)</span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// arg1 =&gt; file3.txt </span></span><br><span class=\"line\"> fs.readFile(arg1, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> callback(err, content); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// result =&gt; file4.txt </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>自动依赖处理<ul>\n<li>async提供了一个强大的方法auto()实现复杂业务处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Step<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step( </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile1</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"built_in\">this</span>); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile2</span>(<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"built_in\">this</span>); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">done</span>(<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(content); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。</li>\n<li>并行任务执行<ul>\n<li>this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务</li>\n<li>使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数</li>\n</ul>\n</li>\n<li>结果分组: group()</li>\n</ul>\n</li>\n<li>wind<ul>\n<li>异步任务定义</li>\n<li>$await()与任务模型</li>\n<li>异步方法转换辅助函数<ul>\n<li>Wind.Async.Binding.fromCallback</li>\n<li>Wind.Async.Binding.fromStandard</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"异步并发控制\"><a href=\"#异步并发控制\" class=\"headerlink\" title=\"异步并发控制\"></a>异步并发控制</h6><ul>\n<li><p>bagpipe的解决方案</p>\n<ul>\n<li><p>通过一个队列来控制并发量。</p>\n</li>\n<li><p>如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。</p>\n</li>\n<li><p>如果活跃调用达到限定值，调用暂时存放在队列中。</p>\n</li>\n<li><p>每个异步调用结束时，从队列中取出新的异步调用执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Bagpipe = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;bagpipe&#x27;</span>); </span><br><span class=\"line\"><span class=\"comment\">// 设定最大并发数为10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bagpipe = <span class=\"keyword\">new</span> Bagpipe(<span class=\"number\">10</span>); </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123; </span><br><span class=\"line\"> bagpipe.push(<span class=\"keyword\">async</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// 异步回调执行</span></span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">bagpipe.on(<span class=\"string\">&#x27;full&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">length</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.warn(<span class=\"string\">&#x27;底层系统处理不能及时完成，队列拥堵，目前队列长度为:&#x27;</span> + length); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<ul>\n<li>拒绝模式</li>\n<li>超时控制</li>\n</ul>\n</li>\n<li><p>async的解决方案：async也提供了一个方法用于处理异步调用的限制：parallelLimit()</p>\n<ul>\n<li>parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。</li>\n<li>parallelLimit()方法的缺陷在于无法动态地增加并行任务。为此，async提供了queue()方法来满足该需求，这对于遍历文件目录等操作十分有效</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"为什么要异步-I-O\"><a href=\"#为什么要异步-I-O\" class=\"headerlink\" title=\"为什么要异步 I/O\"></a>为什么要异步 I/O</h4><ul>\n<li>用户体验<ul>\n<li><img src=\"/nodejs/images/async-experience.png\" alt=\"i/o花费\"></li>\n</ul>\n</li>\n<li>资源分配<ul>\n<li><img src=\"/nodejs/images/how-to-call-async.png\" alt=\"i/o花费\"></li>\n</ul>\n</li>\n</ul>\n<p><em>异步I/O与非阻塞I/O</em><br>操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果<br><img src=\"/nodejs/images/jam.png\" alt=\"调用阻塞i/o的过程\"><br>阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。</p>\n<p>阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回<br><img src=\"/nodejs/images/no-jam.png\" alt=\"调用非阻塞i/o的过程\"></p>\n<p><em>操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取</em></p>\n<p>阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费<br>现存的轮询技术主要有以下这些：</p>\n<ul>\n<li>read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。<br><img src=\"/nodejs/images/read-loop.png\" alt=\"read轮询\"></li>\n<li>select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断<br><img src=\"/nodejs/images/select-loop.png\" alt=\"select轮询\"></li>\n</ul>\n<p><em>select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符</em></p>\n<ul>\n<li>poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。<br><img src=\"/nodejs/images/poll-loop.png\" alt=\"poll轮询\"></li>\n<li>epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高<br><img src=\"/nodejs/images/epoll-loop.png\" alt=\"epoll轮询\"></li>\n<li>kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在</li>\n</ul>\n<h6 id=\"Node-的异步-I-O\"><a href=\"#Node-的异步-I-O\" class=\"headerlink\" title=\"Node 的异步 I/O\"></a>Node 的异步 I/O</h6><ol>\n<li>事件循环<br>进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程</li>\n<li>观察者<br>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</li>\n<li>请求对象<br>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理<br><img src=\"/nodejs/images/async-progress.png\" alt=\"异步i/o流程\"></li>\n</ol>\n<p><em>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</em><br>Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事<br>件循环，以此完成异步I/O的过程。<br>Linux下通过epoll实现这个过程<br>FreeBSD下通过kqueue实现<br>Solaris下通过Event ports实现</p>\n<p>不同的是线程池在Windows下由内核（IOCP）直接提供，*nix系列下由libuv自行实现</p>\n<h6 id=\"非-I-O-的异步-API\"><a href=\"#非-I-O-的异步-API\" class=\"headerlink\" title=\"非 I/O 的异步 API\"></a>非 I/O 的异步 API</h6><ul>\n<li>定时器<br>调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。</li>\n</ul>\n<p>定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒</p>\n<p><img src=\"/nodejs/images/settimeout.png\" alt=\"定时器\"></p>\n<ul>\n<li>process.nextTick()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// on the way out, don&#x27;t bother. </span></span><br><span class=\"line\"> <span class=\"comment\">// it won&#x27;t get fired anyway </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (process._exiting) <span class=\"keyword\">return</span>; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (tickDepth &gt;= process.maxTickDepth) </span><br><span class=\"line\"> maxTickWarn(); </span><br><span class=\"line\"> <span class=\"keyword\">var</span> tock = &#123; <span class=\"attr\">callback</span>: callback &#125;; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (process.domain) tock.domain = process.domain; </span><br><span class=\"line\"> nextTickQueue.push(tock); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (nextTickQueue.length) &#123; </span><br><span class=\"line\"> process._needTickCallback(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效</li>\n<li>setImmediate()<br>process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。</li>\n</ul>\n<p>process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加入两个nextTick()的回调函数</span></span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;nextTick延迟执行1&#x27;</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;nextTick延迟执行2&#x27;</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"comment\">// 加入两个setImmediate()的回调函数</span></span><br><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;setImmediate延迟执行1&#x27;</span>); </span><br><span class=\"line\"> <span class=\"comment\">// 进入下次循环</span></span><br><span class=\"line\"> process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;强势插入&#x27;</span>); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;setImmediate延迟执行2&#x27;</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;正常执行&#x27;</span>); </span><br><span class=\"line\"><span class=\"comment\">// 其执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 正常执行</span></span><br><span class=\"line\"><span class=\"comment\">// nextTick延迟执行1 </span></span><br><span class=\"line\"><span class=\"comment\">// nextTick延迟执行2 </span></span><br><span class=\"line\"><span class=\"comment\">// setImmediate延迟执行1 </span></span><br><span class=\"line\"><span class=\"comment\">// 强势插入</span></span><br><span class=\"line\"><span class=\"comment\">// setImmediate延迟执行2 </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h4><ul>\n<li>高阶函数:高阶函数则是可以把函数作为参数，或是将函数作为返回值的函数</li>\n<li>偏函数用法: 偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。</li>\n</ul>\n<h6 id=\"异步编程的优势与难点\"><a href=\"#异步编程的优势与难点\" class=\"headerlink\" title=\"异步编程的优势与难点\"></a>异步编程的优势与难点</h6><ul>\n<li>优势<br>非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。<br>对于网络应用而言，并行带来的想象空间更大，延展而开的是分布式和云</li>\n<li>难点<ul>\n<li>异常处理</li>\n<li>函数嵌套过深</li>\n<li>阻塞代码</li>\n<li>多线程编程</li>\n<li>异步转同步</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"异步编程解决方案\"><a href=\"#异步编程解决方案\" class=\"headerlink\" title=\"异步编程解决方案\"></a>异步编程解决方案</h6><ul>\n<li>事件发布/订阅模式。<ul>\n<li>Node自身提供的events模块（<a href=\"http://nodejs.org/docs/latest/api/events.html%EF%BC%89%E6%98%AF%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%8CNode%E4%B8%AD%E9%83%A8%E5%88%86%E6%A8%A1%E5%9D%97%E9%83%BD%E7%BB%A7%E6%89%BF%E8%87%AA%E5%AE%83%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%AF%94%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%A4%A7%E9%87%8FDOM%E4%BA%8B%E4%BB%B6%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%8C%E4%B9%9F%E4%B8%8D%E5%AD%98%E5%9C%A8preventDefault()%E3%80%81stopPropagation()%E5%92%8CstopImmediatePropagation()%E7%AD%89%E6%8E%A7%E5%88%B6%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%E5%AE%83%E5%85%B7%E6%9C%89\">http://nodejs.org/docs/latest/api/events.html）是发布/订阅模式的一个简单实现，Node中部分模块都继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()、stopPropagation()和stopImmediatePropagation()等控制事件传递的方法。它具有</a> addListener/on() 、 once() 、 removeListener() 、removeAllListeners()和emit()等基本的事件监听模式的方法实现</li>\n<li>如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0)；可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理</li>\n<li>继承events模块</li>\n<li>利用事件队列解决雪崩问题</li>\n<li>多异步之间的协作方案<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> results = &#123;&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> done = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123; </span><br><span class=\"line\"> results[key] = value; </span><br><span class=\"line\"> count++; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (count === <span class=\"number\">3</span>) &#123; </span><br><span class=\"line\"> <span class=\"comment\">// 渲染页面</span></span><br><span class=\"line\"> render(results); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">fs.readFile(template_path, <span class=\"string\">&quot;utf8&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, template</span>) </span>&#123; </span><br><span class=\"line\"> done(<span class=\"string\">&quot;template&quot;</span>, template); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">db.query(sql, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123; </span><br><span class=\"line\"> done(<span class=\"string\">&quot;data&quot;</span>, data); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">l10n.get(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, resources</span>) </span>&#123; </span><br><span class=\"line\"> done(<span class=\"string\">&quot;resources&quot;</span>, resources); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>EventProxy的原理<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trigger an event, firing all bound callbacks. Callbacks are passed the </span></span><br><span class=\"line\"><span class=\"comment\">// same arguments as `trigger` is, apart from the event name. </span></span><br><span class=\"line\"><span class=\"comment\">// Listening for `&quot;all&quot;` passes the true event name as the first argument </span></span><br><span class=\"line\"><span class=\"attr\">trigger</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> list, calls, ev, callback, args; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> both = <span class=\"number\">2</span>; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!(calls = <span class=\"built_in\">this</span>._callbacks)) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (both--) &#123; </span><br><span class=\"line\"> ev = both ? eventName : <span class=\"string\">&#x27;all&#x27;</span>; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (list = calls[ev]) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = list.length; i &lt; l; i++) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!(callback = list[i])) &#123; </span><br><span class=\"line\"> list.splice(i, <span class=\"number\">1</span>); i--; l--; </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\"> args = both ? <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>) : <span class=\"built_in\">arguments</span>; </span><br><span class=\"line\"> callback[<span class=\"number\">0</span>].apply(callback[<span class=\"number\">1</span>] || <span class=\"built_in\">this</span>, args); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>EventProxy的异常处理</li>\n</ul>\n</li>\n<li>Promise/Deferred模式。<ul>\n<li>Promises/A <ul>\n<li>Promise/Deferred模式其实包含两部分，即Promise和Deferred。这里暂且不提两者的区别是什么，先看看Promises/A的行为吧。Promises/A提议对单个异步操作做出了这样的抽象定义，具体如下所示。<ul>\n<li>Promise操作只会处在3种状态的一种：未完成态、完成态和失败态。</li>\n<li>Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。</li>\n<li>Promise的状态一旦转化，将不能被更改</li>\n</ul>\n</li>\n<li>在API的定义上，Promises/A提议是比较简单的。一个Promise对象只要具备then()方法即可。但是对于then()方法，有以下简单的要求。<ul>\n<li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法</li>\n<li>可选地支持progress事件回调作为第三个方法。</li>\n<li>then()方法只接受function对象，其余对象将被忽略。</li>\n<li>then()方法继续返回Promise对象，以实现链式调用</li>\n<li><img src=\"/nodejs/images/defer-promise.png\" alt=\"defer和promise\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Promise中的多异步协作<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deferred.prototype.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">var</span> count = promises.length; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> that = <span class=\"built_in\">this</span>; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> results = []; </span><br><span class=\"line\"> promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise, i</span>) </span>&#123; </span><br><span class=\"line\"> promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123; </span><br><span class=\"line\"> count--; </span><br><span class=\"line\"> results[i] = data; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (count === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\"> that.resolve(results); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123; </span><br><span class=\"line\"> that.reject(err); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.promise; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<pre><code>- 支持序列执行的Promise\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise() </span><br><span class=\"line\"> .then(obj.api1) </span><br><span class=\"line\"> .then(obj.api2) </span><br><span class=\"line\"> .then(obj.api3) </span><br><span class=\"line\"> .then(obj.api4) </span><br><span class=\"line\"> .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value4</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// Do something with value4 </span></span><br><span class=\"line\"> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// Handle any error from step1 through step4 </span></span><br><span class=\"line\"> &#125;) </span><br><span class=\"line\"> .done(); </span><br><span class=\"line\">尝试改造一下代码以实现链式调用，具体如下所示：</span><br><span class=\"line\"><span class=\"keyword\">var</span> Deferred = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// 完成态</span></span><br><span class=\"line\">Deferred.prototype.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> promise = <span class=\"built_in\">this</span>.promise; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> handler; </span><br><span class=\"line\"> <span class=\"keyword\">while</span> ((handler = promise.queue.shift())) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (handler &amp;&amp; handler.fulfilled) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> ret = handler.fulfilled(obj); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (ret &amp;&amp; ret.isPromise) &#123; </span><br><span class=\"line\"> ret.queue = promise.queue; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.promise = ret; </span><br><span class=\"line\"> <span class=\"keyword\">return</span>; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// 失败态</span></span><br><span class=\"line\">Deferred.prototype.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> promise = <span class=\"built_in\">this</span>.promise; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> handler; </span><br><span class=\"line\"> <span class=\"keyword\">while</span> ((handler = promise.queue.shift())) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (handler &amp;&amp; handler.error) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> ret = handler.error(err); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (ret &amp;&amp; ret.isPromise) &#123; </span><br><span class=\"line\"> ret.queue = promise.queue; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.promise = ret;</span><br><span class=\"line\"> <span class=\"keyword\">return</span>; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"comment\">// 生成回调函数</span></span><br><span class=\"line\">Deferred.prototype.callback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> that = <span class=\"built_in\">this</span>; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, file</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (err) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> that.reject(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> that.resolve(file); </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">Promise</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// 队列用于存储待执行的回调函数</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.queue = []; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.isPromise = <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> handler = &#123;&#125;; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fulfilledHandler === <span class=\"string\">&#x27;function&#x27;</span>) &#123; </span><br><span class=\"line\"> handler.fulfilled = fulfilledHandler; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> errorHandler === <span class=\"string\">&#x27;function&#x27;</span>) &#123; </span><br><span class=\"line\"> handler.error = errorHandler; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"built_in\">this</span>.queue.push(handler); </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<pre><code>- 将API Promise化\n</code></pre>\n</li>\n</ul>\n</li>\n<li>流程控制库<ul>\n<li>尾触发与Next<ul>\n<li>需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。事实上，尾触发目前应用最多的地方是Connect的中间件</li>\n<li><img src=\"/nodejs/images/tail-trigger.png\" alt=\"中间件\"></li>\n<li>尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能够各自清晰</li>\n</ul>\n</li>\n<li>async<ul>\n<li>异步的串行执行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.series([ </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, results</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">这段代码等价于：</span><br><span class=\"line\">fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (err) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> callback(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt &#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (err) &#123; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> callback(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> callback(<span class=\"literal\">null</span>, [content, data]); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>异步的并行执行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.parallel([ </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, callback); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, results</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure></li>\n<li>异步调用的依赖处理<ul>\n<li>series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。所幸，这种典型场景的需求，async提供了waterfall()方法来满足<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.waterfall([ </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> callback(err, content); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, callback</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// arg1 =&gt; file2.txt </span></span><br><span class=\"line\"> fs.readFile(arg1, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> callback(err, content); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1, callback</span>)</span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// arg1 =&gt; file3.txt </span></span><br><span class=\"line\"> fs.readFile(arg1, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> callback(err, content); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// result =&gt; file4.txt </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>自动依赖处理<ul>\n<li>async提供了一个强大的方法auto()实现复杂业务处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Step<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step( </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile1</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file1.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"built_in\">this</span>); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile2</span>(<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> fs.readFile(<span class=\"string\">&#x27;file2.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"built_in\">this</span>); </span><br><span class=\"line\"> &#125;, </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">done</span>(<span class=\"params\">err, content</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(content); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。</li>\n<li>并行任务执行<ul>\n<li>this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务</li>\n<li>使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数</li>\n</ul>\n</li>\n<li>结果分组: group()</li>\n</ul>\n</li>\n<li>wind<ul>\n<li>异步任务定义</li>\n<li>$await()与任务模型</li>\n<li>异步方法转换辅助函数<ul>\n<li>Wind.Async.Binding.fromCallback</li>\n<li>Wind.Async.Binding.fromStandard</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"异步并发控制\"><a href=\"#异步并发控制\" class=\"headerlink\" title=\"异步并发控制\"></a>异步并发控制</h6><ul>\n<li><p>bagpipe的解决方案</p>\n<ul>\n<li><p>通过一个队列来控制并发量。</p>\n</li>\n<li><p>如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。</p>\n</li>\n<li><p>如果活跃调用达到限定值，调用暂时存放在队列中。</p>\n</li>\n<li><p>每个异步调用结束时，从队列中取出新的异步调用执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Bagpipe = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;bagpipe&#x27;</span>); </span><br><span class=\"line\"><span class=\"comment\">// 设定最大并发数为10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bagpipe = <span class=\"keyword\">new</span> Bagpipe(<span class=\"number\">10</span>); </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123; </span><br><span class=\"line\"> bagpipe.push(<span class=\"keyword\">async</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// 异步回调执行</span></span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">bagpipe.on(<span class=\"string\">&#x27;full&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">length</span>) </span>&#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.warn(<span class=\"string\">&#x27;底层系统处理不能及时完成，队列拥堵，目前队列长度为:&#x27;</span> + length); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<ul>\n<li>拒绝模式</li>\n<li>超时控制</li>\n</ul>\n</li>\n<li><p>async的解决方案：async也提供了一个方法用于处理异步调用的限制：parallelLimit()</p>\n<ul>\n<li>parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。</li>\n<li>parallelLimit()方法的缺陷在于无法动态地增加并行任务。为此，async提供了queue()方法来满足该需求，这对于遍历文件目录等操作十分有效</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"深入浅出nodejs阅读笔记(5)","date":"2022-12-26T13:26:47.000Z","tags":["node","docs"],"_content":"\n#### 测试\n\n###### 单元测试\n*单元测试的意义*\n编写可测试代码有以下几个原则可以遵循：\n- 单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出\n- 接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。\n- 层次分离。层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证\n\n*单元测试介绍*\n单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分\n\n*断言*：断言就是单元测试中用来保证最小单元是否正常的检测方法\n断言用于检查程序在运行时是否满足期望。JavaScript的断言规范最早来自于CommonJS的单元测试规范（详见http://wiki.commonjs.org/wiki/Unit_Testing/1.0），Node实现了规范中的断言部分。\n```\nvar assert = require('assert'); \nassert.equal(Math.max(1, 100), 100); \n```\n在断言规范中，定义了以下几种检测方法:\n- ok()：判断结果是否为真。\n- equal()：判断实际值与期望值是否相等。\n- notEqual()：判断实际值与期望值是否不相等。\n- deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。\n- notDeepEqual()：判断实际值与期望值是否不深度相等。\n- strictEqual()：判断实际值与期望值是否严格相等（相当于===）。\n- notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==）。\n- throws()：判断代码块是否抛出异常。\n除此之外，Node的assert模块还扩充了如下两个断言方法。\n- doesNotThrow()：判断代码块是否没有抛出异常。\n- ifError()：判断实际值是否为一个假值（null、undefined、0、''、false），如果实际值为真值，将会抛出异常。\n\n*测试框架*\n测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告，提升测试用例的开发速度，提高测试用例的可维护性和可读性，以及一些周边性的工作\n\n测试风格\n测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，它们的差别如下所示:\n- 关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。\n- 表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯\n\nmocha的BDD风格示例\n```\ndescribe('Array', function(){ \n before(function(){ \n // ... \n }); \n describe('#indexOf()', function(){ \n it('should return -1 when not present', function(){ \n [1,2,3].indexOf(4).should.equal(-1); \n }); \n }); \n}); \n```\nBDD对测试用例的组织主要采用describe和it进行组织。describe可以描述多层级的结构，具体到测试用例时，用it。另外，它还提供before、after、beforeEach和afterEach这4个钩子方法，用于协助describe中测试用例的准备、安装、卸载和回收等工作。before和after分别在进入和退出describe时触发执行，beforeEach和afterEach则分别在describe中每一个测试用例（it）执行前和执行后触发执行\n![单测](./images/test.png)\nmocha的TDD风格示例\n```\nsuite('Array', function(){ \n setup(function(){ \n // ... \n }); \n suite('#indexOf()', function(){ \n test('should return -1 when not present', function(){ \n assert.equal(-1, [1,2,3].indexOf(4)); \n }); \n }); \n});\n```\nTDD对测试用例的组织主要采用suite和test完成。suite也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含setup和teardown，对应BDD中的before和after。\n![单测](./images/test-1.png)\n\n测试报告\nmocha提供了相当丰富的报告格式，调用mocha --reporters即可查看所有的报告格式\n默认的报告格式为dot，其他比较常用的格式有spec、json、html-cov等。执行mocha -R <reporter>命令即可采用这些报告。json报告因为其格式非常通用，多用于将结果传递给其他程序进行处理，而html-cov则用于可视化地观察代码覆盖率\n\n测试用例\n测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注\n- 异步测试\n```\nit('fs.readFile should be ok', function (done) { \n fs.readFile('file_path', 'utf-8', function (err, data) { \n should.not.exist(err); \n done(); \n }); \n}); \n```\n测试用例方法it()接受两个参数；用例标题（title）和回调函数（fn）。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行\n- 超时设置\nmocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例\n```\nit('async test', function (done) { \n // 模拟一个要执行很久的异步方法\n setTimeout(done, 10000); \n}); \n```\nmocha的默认超时时间为2000毫秒。一般情况下，通过mocha -t <ms>设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置\n```\nit('should take less than 500ms', function (done) { \n this.timeout(500); \n setTimeout(done, 300); \n}); \n```\n也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例\n```\ndescribe('a suite of tests', function(){ \n this.timeout(500); \n it('should take less than 500ms', function (done) { \n setTimeout(done, 300); \n }); \n it('should take less than 500ms as well', function (done) { \n setTimeout(done, 200); \n }); \n}); \n```\n\n*测试覆盖率*\n测试覆盖率是单元测试中的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况\n\n若要探知这个测试用例对源代码的覆盖率，需要一种工具来统计每一行代码是否执行，这里要介绍的相关工具是jscover模块。通过npm install jscover -g的方式可以安装该模块\n\njscover模块虽然已经够用，但是还有两个问题:\n- 它的编译部分是通过Java实现的，这样环境依赖上就多出了Java。\n- 它需要编译代码到一个额外的新目录，这个过程相对麻烦。\nblanket模块解决了这两个问题，它由纯JavaScript实现，编译代码的过程也是隐式的，无须配置额外的目录，对于原模块项目没有额外的侵入\n\nblanket与jscover的原理基本一致，在实现过程上有所不同，其差别在于blanket将编译的步骤注入在require中，而不是去额外编译成文件，执行测试时再去引用编译后的文件，它的技巧在require中\n\n它的配置比jscover要简单，只需要在所有测试用例运行之前通过--require选项引入它即可：\nmocha --require blanket -R html-cov > coverage.html \n\n另一个需要注意的是，在包描述文件中配置scripts节点。在scripts节点中，pattern属性用以匹配需要编译的文件：\n```\n\"scripts\": { \n \"blanket\": { \n \"pattern\": \"eventproxy/lib\" \n } \n}, \n```\n当在测试文件中通过require引入一个文件模块时，它将判断这个文件的实际路径，如果符合这个匹配规则，就对它进行编译\n\n使用blanket之后，就无须配置环境变量了，也无须根据环境去判断引入哪种代码\n\n*mock*\n在测试领域里，模拟异常其实是一个不小的科目，它有着一个特殊的名词：mock。我们通过伪造被调用方来测试上层代码的健壮性等\n\n由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk\n```\nvar fs = require('fs'); \nvar muk = require('muk'); \nbefore(function () { \n muk(fs, 'readFileSync', function(path, encoding) { \n throw new Error(\"mock readFileSync error\"); \n }); \n}); \n// it(); \nafter(function () { \n muk.restore(); \n}); \n\nvar fs = require('fs'); \nvar muk = require('muk'); \nbeforeEach(function () { \n muk(fs, 'readFileSync', function(path, encoding) { \n throw new Error(\"mock readFileSync error\"); \n }); \n}); \n// it(); \n// it(); \nafterEach(function () { \n muk.restore(); \n}); \n```\n模拟时无须临时缓存正确引用，用例执行结束后调用muk.restore()恢复即可\n\n值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步\n```\nfs.readFile = function (filename, encoding, callback) { \n process.nextTick(function () { \n callback(new Error(\"mock readFile error\")); \n }); \n};\n```\n\n*私有方法的测试*\n除了将这些私有方法通过exports导出外。rewire模块提供了一种巧妙的方式实现对私有方法的访问。\nrewire的调用方式与require十分类似。对于如下的私有方法，我们获取它并为其执行测试用例非常简单：\n```\nvar limit = function (num) { \n return num < 0 ? 0 : num; \n}; \n\nit('limit should return success', function () { \n var lib = rewire('../lib/index.js'); \n var litmit = lib.__get__('limit'); \n litmit(10).should.be.equal(10); \n}); \n```\n每一个被rewire引入的模块都有__set__()和__get__()方法。它巧妙地利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行\n\n###### 工程化与自动化\n*工程化*\nNode在*nix系统下可以很好地利用一些成熟工具，其中Makefile比较小巧灵活，适合用来构建工程\n\n*持续集成*\ntravis-ci\n\n###### 性能测试\n单元测试主要用于检测代码的行为是否符合预期。在完成代码的行为检测后，还需要对已有代码的性能作出评估，检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力。换句话说，性能也是功能。性能测试的范畴比较广泛，包括负载测试、压力测试和基准测试等\n\n*基准测试*\n基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距\n\n为了得到更规范和更好的输出结果，这里介绍benchmark这个模块是如何组织基准测试的\n```\nvar Benchmark = require('benchmark'); \nvar suite = new Benchmark.Suite(); \nvar arr = [0, 1, 2, 3, 5, 6]; \nsuite.add('nativeMap', function () { \n return arr.map(callback); \n}).add('customMap', function () { \n var ret = []; \n for (var i = 0; i < arr.length; i++) { \n ret.push(callback(arr[i])); \n } \n return ret; \n}).on('cycle', function (event) { \n console.log(String(event.target)); \n}).on('complete', function() { \n console.log('Fastest is ' + this.filter('fastest').pluck('name')); \n}).run(); \n```\n\n###### 压力测试\n对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力\n\n最常用的工具是ab、siege、http_load等，下面我们通过ab工具来构造压力测试\n```\n$ ab -c 10 -t 3 http://localhost:8001/ \nThis is ApacheBench, Version 2.3 <$Revision: 655654 $> \nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ \nLicensed to The Apache Software Foundation, http://www.apache.org/ \nBenchmarking localhost (be patient) \nCompleted 5000 requests \nCompleted 10000 requests \nFinished 11573 requests \nServer Software: \nServer Hostname: localhost \nServer Port: 8001 \nDocument Path: / \nDocument Length: 10240 bytes \nConcurrency Level: 10 \nTime taken for tests: 3.000 seconds \nComplete requests: 11573 \nFailed requests: 0 \nWrite errors: 0 \nTotal transferred: 119375495 bytes \nHTML transferred: 118507520 bytes \nRequests per second: 3857.60 [#/sec] (mean) \nTime per request: 2.592 [ms] (mean) \nTime per request: 0.259 [ms] (mean, across all concurrent requests) \nTransfer rate: 38858.59 [Kbytes/sec] received \nConnection Times (ms) \n min mean[+/-sd] median max \nConnect: 0 0 0.3 0 31 \nProcessing: 1 2 1.9 2 35 \nWaiting: 0 2 1.9 2 35 \nTotal: 1 3 2.0 2 35 \nPercentage of the requests served within a certain time (ms) \n 50% 2\n 66% 3 \n 75% 3 \n 80% 3 \n 90% 3\n 95% 3 \n 98% 5 \n 99% 6 \n 100% 35 (longes % t request)\n```\n\n各个参数的含义:\n- Document Path：表示文档的路径，此处为/。\n- Document Length：表示文档的长度，就是报文的大小，这里有10KB。\n- Concurrency Level：并发级别，就是我们在命令中传入的c，此处为10，即10个并发。\n- Time taken for tests：表示完成所有测试所花费的时间，它与命令行中传入的t选项有细微出入。\n- Complete requests：表示在这次测试中一共完成多少次请求。\n- Failed requests：表示其中产生失败的请求数，这次测试中没有失败的请求。\n- Write errors：表示在写入过程中出现的错误次数（连接断开导致的）。\n- Total transferred：表示所有的报文大小。\n- HTML transferred：表示仅HTTP报文的正文大小，它比上一个值小。\n- Requests per second：这是我们重点关注的一个值，它表示服务器每秒能处理多少请求，是重点反映服务器并发能力的指标。这个值又称RPS或QPS。\n- 两个Time per request值：第一个代表的是用户平均等待时间，第二个代表的是服务器平均请求处理事件，前者除以并发数得到后者。\n- Transfer rate：表示传输率，等于传输的大小除以传输时间，这个值受网卡的带宽限制。\n- Connection Times：连接时间，它包括客户端向服务器端建立连接、服务器端处理请求、等待报文响应的过程。\n\n###### 基准测试驱动开发\n简称也是BDD，全称为Benchmark Driven Development，即基准测试驱动开发，其中主要分为如下几步:\n(1) 写基准测试。\n(2) 写/改代码。\n(3) 收集数据。\n(4) 找出问题。\n(5)回到第(2)步\n![单测](./images/test-2.png)\n\n#### 产 品 化\n###### 项目工程化\n所谓的工程化，可以理解为项目的组织能力。体现在文件上，就是文件的组织能力\n- 目录结构\n  - 主要的两类项目为Web应用和模块应用。普通的模块应用遵循CommonJS的模块和包规范即可\n- 构建工具\n在Node的应用中，主流的构建工具还是老牌的make，但它的缺点是只在*nix操作系统下有效。为了实现跨平台，Grunt应运而生。Grunt通过Node写成，借助Node的跨平台能力，实现了很好的平台兼容性。\nMakefile\n  - Makefile文件是*nix系统下经典的构建工具。除了Windows系统外，其他系统几乎都能使用它。受Makefile影响的还有Ruby的Rakefile和Gemfile等。Makefile文件通常用来管理一些编译相关\nGrunt\n  - Makefile唯一的缺陷也许就是跨平台问题了，为此才有ant、rake等工具的出现。在Node生态系统中，也有一款构建工具解决了Makefile无法跨平台的问题——Grunt。\n  - Grunt用Node写成，能够同时在Windows和*nix平台下运行。\n  - Grunt结合NPM的包依赖管理，完全可以媲美Java世界的Maven工具，同时它又如Makefile一样，能够用来构建完善的自动化任务工具。\n  - 它的设计理念与Makefile并不相同：Makefile依托强大的bash编程，Grunt则依托它丰富的插件，它自身提供通用接口用于插件的接入，具体的任务则由插件完成。\n  - Grunt的核心插件以grunt-contrib-开头，在NPM包管理平台上可以找到和查看。Grunt提供了3个模块分别用于运行时、初始化和命令行：grunt、grunt-init、grunt-cli。后面两个模块都可以作为命令行工具使用，安装时带-g即可\n\n- 编码规范\n编码规范的统一一般有几种实现方式，一种是文档式的约定，一种是代码提交时的强制检查。前者靠自觉，后者靠工具\n\n- 代码审查\n代码审查主要在请求合并的过程中完成，需要审查的点有功能是否正确完成、编码风格是否符合规范、单元测试是否有同步添加等\n\n###### 部署流程\n*部署环境*\n普通测试环境称为stage环境，预发布环境称为pre-release环境，实际的生产环境称为product环境\n\n*部署操作*\n为了能让进程持续执行，我们可能会用到nohup和&以不挂断进程的方式执行：nohup node app.js &\n\n###### 性能\n对于Web应用而言，最直接有效的莫过于动静分离、多进程架构、分布式，其中涉及的几个拆分原则如下所示。\n- 做专一的事。\n- 让擅长的工具做擅长的事情。\n- 将模型简化。\n- 将风险分离\n\n*动静分离*\n将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让Node只处理动态请求即可。这个过程可以用Nginx或者专业的CDN来处理\n![动静分离](./images/product.png)\n\n*启用缓存*\n提升性能其实差不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不必要的计算，应用场景最多的就是缓存\n\n*多进程架构*\n*读写分离*\n\n###### 日志\n*访问日志*\n访问日志一般用来记录每个客户端对应用的访问。在Web应用中，主要记录HTTP请求中的关键数据。\n中间件框架Connect在其众多中间件中提供了一个日志中间件，通过它可以将关键数据按一定格式输出到日志文件中。\n```\nvar app = connect(); \n// 记录访问日志\nconnect.logger.format('home', ':remote-addr :response-time - [:date] \":method :url \nHTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\" :res[content-length]'); \napp.use(connect.logger({ \n format: 'home', \n stream: fs.createWriteStream(__dirname + '/logs/access.log') \n}));\n```\n\n*异常日志*\n异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信息去定位bug出现的具体位置，以快速修复问题。\n异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分，具体如下所示:\n- console.log：普通日志。\n- console.info：普通信息。\n- console.warn：警告信息。\n- console.error：错误信息。\nconsole模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。\n\nconsole对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象\n```\nvar info = fs.createWriteStream(logdir + '/info.log', {flags: 'a', mode: '0666'}); \nvar error = fs.createWriteStream(logdir + '/error.log', {flags: 'a', mode: '0666'}); \nvar logger = new console.Console(info, error); \nlogger.log('Hello world!'); \nlogger.error('segment fault');\n```\n对于未捕获的异常，Node提供了机制以免进程直接退出，但是发生未捕获异常的进程也不能继续在线上进行服务了，因为可能有内存泄漏的风险产生\n\n###### 日志与数据库\n将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来\n\n分割日志\n日志的写入一般都是依托在可写流上的。对于Console对象，它的内部属性_stdout和_stderr就是指向我们传入的两个输入流对象的\n\n###### 监控报警\n\n*监控*\n监控的主要目的是为了将一些重要指标采样记录下来，一旦这些指标发生较大变化，可以配合报警系统将问题反馈到负责人那\n- 日志监控\n业务逻辑型的监控主要体现在日志上,除了异常日志的监控外，对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布\n- 响应时间\n响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长\n健康的系统响应时间应该是波动较小的、持续均衡的\n- 进程监控\n监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。\n- 磁盘监控\n磁盘监控主要是监控磁盘的用量。\n给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了\n- 内存监控\n如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落\n如果进程中存在内存泄漏，又一时没有排查解决，有一种方案可以解决这种状况。这种方案应用于多进程架构的服务集群，让每个工作进程指定服务多少次请求，达到请求数之后进程就不再服务新的连接，主进程启动新的工作进程来服务客户，旧的进程等所有连接断开后就退出。这样即使存在内存泄漏的风险，也能有效地规避内存泄漏带来的影响\n- CPU占用监控\n服务器的CPU占用监控也是必不可少的项，CPU的使用分为用户态、内核态、IOWait等\nCPU的使用率中，用户态小于70%、内核态小于35%且整体小于70%时，处于健康状态\n- CPU load监控\nCPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载\n- I/O负载\nI/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库\n- 网络监控\n网络流量监控的两个主要指标是流入流量和流出流量\n- 应用状态监控\n除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用的反馈接口来检查它的健康状态\n- DNS监控\nDNS是网络应用的基础，在实际的对外服务产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控\n\n*报警的实现*\n搭配监控系统的则是报警系统，空有监控而没有通知功能，故障也是无法及时反馈给开发者的。如今的报警已经能够多样化，- 邮件报警、IM报警适合在线工作状态\n- 短信或电话报警适合非在线状态\n\n邮件报警: 如果报警系统由Node编写，可以调用nodemailer模块来实现邮件的发送\n```\nvar nodemailer = require(\"nodemailer\"); \n// 建立一个SMTP传输连接\nvar smtpTransport = nodemailer.createTransport(\"SMTP\", { \n service: \"Gmail\", \n auth: { \n user: \"gmail.user@gmail.com\", \n pass: \"userpass\" \n } \n}); \n// 邮件选项\nvar mailOptions = { \n from: \"Fred Foo ✔ <foo@bar.com>\", // 发件人邮件地址\n to: \"bar@bar.com, baz@bar.com\", // 收件人邮件地址列表\n subject: \"Hello ✔\", // 标题\n text: \"Hello world ✔\", // 纯文本内容\n html: \"<b>Hello world ✔</b>\" // HTML内容\n} \n// 发送邮件\nsmtpTransport.sendMail(mailOptions, function (err, response) { \n if (err) { \n console.log(err); \n } else { \n console.log(\"Message sent: \" + response.message); \n } \n});\n```\n\n短信或电话报警。一些短信服务平台提供短信接入服务，可以在监控系统中接入此类服务时，一旦线上出现到达阈值的异常时，就将信息发送给应用相关的责任人。\n\n###### 稳定性\n- 多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性等问题。\n![负载均衡](./images/product-1.png)\n- 多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟等问题。在容灾方面，机房与机房之间可以互为备份\n- 容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务","source":"nodejs/nodejs-note-5.md","raw":"---\ntitle: 深入浅出nodejs阅读笔记(5)\ndate: 2022-12-26 21:26:47\ntags: [node, docs]\n---\n\n#### 测试\n\n###### 单元测试\n*单元测试的意义*\n编写可测试代码有以下几个原则可以遵循：\n- 单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出\n- 接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。\n- 层次分离。层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证\n\n*单元测试介绍*\n单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分\n\n*断言*：断言就是单元测试中用来保证最小单元是否正常的检测方法\n断言用于检查程序在运行时是否满足期望。JavaScript的断言规范最早来自于CommonJS的单元测试规范（详见http://wiki.commonjs.org/wiki/Unit_Testing/1.0），Node实现了规范中的断言部分。\n```\nvar assert = require('assert'); \nassert.equal(Math.max(1, 100), 100); \n```\n在断言规范中，定义了以下几种检测方法:\n- ok()：判断结果是否为真。\n- equal()：判断实际值与期望值是否相等。\n- notEqual()：判断实际值与期望值是否不相等。\n- deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。\n- notDeepEqual()：判断实际值与期望值是否不深度相等。\n- strictEqual()：判断实际值与期望值是否严格相等（相当于===）。\n- notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==）。\n- throws()：判断代码块是否抛出异常。\n除此之外，Node的assert模块还扩充了如下两个断言方法。\n- doesNotThrow()：判断代码块是否没有抛出异常。\n- ifError()：判断实际值是否为一个假值（null、undefined、0、''、false），如果实际值为真值，将会抛出异常。\n\n*测试框架*\n测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告，提升测试用例的开发速度，提高测试用例的可维护性和可读性，以及一些周边性的工作\n\n测试风格\n测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，它们的差别如下所示:\n- 关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。\n- 表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯\n\nmocha的BDD风格示例\n```\ndescribe('Array', function(){ \n before(function(){ \n // ... \n }); \n describe('#indexOf()', function(){ \n it('should return -1 when not present', function(){ \n [1,2,3].indexOf(4).should.equal(-1); \n }); \n }); \n}); \n```\nBDD对测试用例的组织主要采用describe和it进行组织。describe可以描述多层级的结构，具体到测试用例时，用it。另外，它还提供before、after、beforeEach和afterEach这4个钩子方法，用于协助describe中测试用例的准备、安装、卸载和回收等工作。before和after分别在进入和退出describe时触发执行，beforeEach和afterEach则分别在describe中每一个测试用例（it）执行前和执行后触发执行\n![单测](./images/test.png)\nmocha的TDD风格示例\n```\nsuite('Array', function(){ \n setup(function(){ \n // ... \n }); \n suite('#indexOf()', function(){ \n test('should return -1 when not present', function(){ \n assert.equal(-1, [1,2,3].indexOf(4)); \n }); \n }); \n});\n```\nTDD对测试用例的组织主要采用suite和test完成。suite也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含setup和teardown，对应BDD中的before和after。\n![单测](./images/test-1.png)\n\n测试报告\nmocha提供了相当丰富的报告格式，调用mocha --reporters即可查看所有的报告格式\n默认的报告格式为dot，其他比较常用的格式有spec、json、html-cov等。执行mocha -R <reporter>命令即可采用这些报告。json报告因为其格式非常通用，多用于将结果传递给其他程序进行处理，而html-cov则用于可视化地观察代码覆盖率\n\n测试用例\n测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注\n- 异步测试\n```\nit('fs.readFile should be ok', function (done) { \n fs.readFile('file_path', 'utf-8', function (err, data) { \n should.not.exist(err); \n done(); \n }); \n}); \n```\n测试用例方法it()接受两个参数；用例标题（title）和回调函数（fn）。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行\n- 超时设置\nmocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例\n```\nit('async test', function (done) { \n // 模拟一个要执行很久的异步方法\n setTimeout(done, 10000); \n}); \n```\nmocha的默认超时时间为2000毫秒。一般情况下，通过mocha -t <ms>设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置\n```\nit('should take less than 500ms', function (done) { \n this.timeout(500); \n setTimeout(done, 300); \n}); \n```\n也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例\n```\ndescribe('a suite of tests', function(){ \n this.timeout(500); \n it('should take less than 500ms', function (done) { \n setTimeout(done, 300); \n }); \n it('should take less than 500ms as well', function (done) { \n setTimeout(done, 200); \n }); \n}); \n```\n\n*测试覆盖率*\n测试覆盖率是单元测试中的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况\n\n若要探知这个测试用例对源代码的覆盖率，需要一种工具来统计每一行代码是否执行，这里要介绍的相关工具是jscover模块。通过npm install jscover -g的方式可以安装该模块\n\njscover模块虽然已经够用，但是还有两个问题:\n- 它的编译部分是通过Java实现的，这样环境依赖上就多出了Java。\n- 它需要编译代码到一个额外的新目录，这个过程相对麻烦。\nblanket模块解决了这两个问题，它由纯JavaScript实现，编译代码的过程也是隐式的，无须配置额外的目录，对于原模块项目没有额外的侵入\n\nblanket与jscover的原理基本一致，在实现过程上有所不同，其差别在于blanket将编译的步骤注入在require中，而不是去额外编译成文件，执行测试时再去引用编译后的文件，它的技巧在require中\n\n它的配置比jscover要简单，只需要在所有测试用例运行之前通过--require选项引入它即可：\nmocha --require blanket -R html-cov > coverage.html \n\n另一个需要注意的是，在包描述文件中配置scripts节点。在scripts节点中，pattern属性用以匹配需要编译的文件：\n```\n\"scripts\": { \n \"blanket\": { \n \"pattern\": \"eventproxy/lib\" \n } \n}, \n```\n当在测试文件中通过require引入一个文件模块时，它将判断这个文件的实际路径，如果符合这个匹配规则，就对它进行编译\n\n使用blanket之后，就无须配置环境变量了，也无须根据环境去判断引入哪种代码\n\n*mock*\n在测试领域里，模拟异常其实是一个不小的科目，它有着一个特殊的名词：mock。我们通过伪造被调用方来测试上层代码的健壮性等\n\n由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk\n```\nvar fs = require('fs'); \nvar muk = require('muk'); \nbefore(function () { \n muk(fs, 'readFileSync', function(path, encoding) { \n throw new Error(\"mock readFileSync error\"); \n }); \n}); \n// it(); \nafter(function () { \n muk.restore(); \n}); \n\nvar fs = require('fs'); \nvar muk = require('muk'); \nbeforeEach(function () { \n muk(fs, 'readFileSync', function(path, encoding) { \n throw new Error(\"mock readFileSync error\"); \n }); \n}); \n// it(); \n// it(); \nafterEach(function () { \n muk.restore(); \n}); \n```\n模拟时无须临时缓存正确引用，用例执行结束后调用muk.restore()恢复即可\n\n值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步\n```\nfs.readFile = function (filename, encoding, callback) { \n process.nextTick(function () { \n callback(new Error(\"mock readFile error\")); \n }); \n};\n```\n\n*私有方法的测试*\n除了将这些私有方法通过exports导出外。rewire模块提供了一种巧妙的方式实现对私有方法的访问。\nrewire的调用方式与require十分类似。对于如下的私有方法，我们获取它并为其执行测试用例非常简单：\n```\nvar limit = function (num) { \n return num < 0 ? 0 : num; \n}; \n\nit('limit should return success', function () { \n var lib = rewire('../lib/index.js'); \n var litmit = lib.__get__('limit'); \n litmit(10).should.be.equal(10); \n}); \n```\n每一个被rewire引入的模块都有__set__()和__get__()方法。它巧妙地利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行\n\n###### 工程化与自动化\n*工程化*\nNode在*nix系统下可以很好地利用一些成熟工具，其中Makefile比较小巧灵活，适合用来构建工程\n\n*持续集成*\ntravis-ci\n\n###### 性能测试\n单元测试主要用于检测代码的行为是否符合预期。在完成代码的行为检测后，还需要对已有代码的性能作出评估，检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力。换句话说，性能也是功能。性能测试的范畴比较广泛，包括负载测试、压力测试和基准测试等\n\n*基准测试*\n基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距\n\n为了得到更规范和更好的输出结果，这里介绍benchmark这个模块是如何组织基准测试的\n```\nvar Benchmark = require('benchmark'); \nvar suite = new Benchmark.Suite(); \nvar arr = [0, 1, 2, 3, 5, 6]; \nsuite.add('nativeMap', function () { \n return arr.map(callback); \n}).add('customMap', function () { \n var ret = []; \n for (var i = 0; i < arr.length; i++) { \n ret.push(callback(arr[i])); \n } \n return ret; \n}).on('cycle', function (event) { \n console.log(String(event.target)); \n}).on('complete', function() { \n console.log('Fastest is ' + this.filter('fastest').pluck('name')); \n}).run(); \n```\n\n###### 压力测试\n对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力\n\n最常用的工具是ab、siege、http_load等，下面我们通过ab工具来构造压力测试\n```\n$ ab -c 10 -t 3 http://localhost:8001/ \nThis is ApacheBench, Version 2.3 <$Revision: 655654 $> \nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ \nLicensed to The Apache Software Foundation, http://www.apache.org/ \nBenchmarking localhost (be patient) \nCompleted 5000 requests \nCompleted 10000 requests \nFinished 11573 requests \nServer Software: \nServer Hostname: localhost \nServer Port: 8001 \nDocument Path: / \nDocument Length: 10240 bytes \nConcurrency Level: 10 \nTime taken for tests: 3.000 seconds \nComplete requests: 11573 \nFailed requests: 0 \nWrite errors: 0 \nTotal transferred: 119375495 bytes \nHTML transferred: 118507520 bytes \nRequests per second: 3857.60 [#/sec] (mean) \nTime per request: 2.592 [ms] (mean) \nTime per request: 0.259 [ms] (mean, across all concurrent requests) \nTransfer rate: 38858.59 [Kbytes/sec] received \nConnection Times (ms) \n min mean[+/-sd] median max \nConnect: 0 0 0.3 0 31 \nProcessing: 1 2 1.9 2 35 \nWaiting: 0 2 1.9 2 35 \nTotal: 1 3 2.0 2 35 \nPercentage of the requests served within a certain time (ms) \n 50% 2\n 66% 3 \n 75% 3 \n 80% 3 \n 90% 3\n 95% 3 \n 98% 5 \n 99% 6 \n 100% 35 (longes % t request)\n```\n\n各个参数的含义:\n- Document Path：表示文档的路径，此处为/。\n- Document Length：表示文档的长度，就是报文的大小，这里有10KB。\n- Concurrency Level：并发级别，就是我们在命令中传入的c，此处为10，即10个并发。\n- Time taken for tests：表示完成所有测试所花费的时间，它与命令行中传入的t选项有细微出入。\n- Complete requests：表示在这次测试中一共完成多少次请求。\n- Failed requests：表示其中产生失败的请求数，这次测试中没有失败的请求。\n- Write errors：表示在写入过程中出现的错误次数（连接断开导致的）。\n- Total transferred：表示所有的报文大小。\n- HTML transferred：表示仅HTTP报文的正文大小，它比上一个值小。\n- Requests per second：这是我们重点关注的一个值，它表示服务器每秒能处理多少请求，是重点反映服务器并发能力的指标。这个值又称RPS或QPS。\n- 两个Time per request值：第一个代表的是用户平均等待时间，第二个代表的是服务器平均请求处理事件，前者除以并发数得到后者。\n- Transfer rate：表示传输率，等于传输的大小除以传输时间，这个值受网卡的带宽限制。\n- Connection Times：连接时间，它包括客户端向服务器端建立连接、服务器端处理请求、等待报文响应的过程。\n\n###### 基准测试驱动开发\n简称也是BDD，全称为Benchmark Driven Development，即基准测试驱动开发，其中主要分为如下几步:\n(1) 写基准测试。\n(2) 写/改代码。\n(3) 收集数据。\n(4) 找出问题。\n(5)回到第(2)步\n![单测](./images/test-2.png)\n\n#### 产 品 化\n###### 项目工程化\n所谓的工程化，可以理解为项目的组织能力。体现在文件上，就是文件的组织能力\n- 目录结构\n  - 主要的两类项目为Web应用和模块应用。普通的模块应用遵循CommonJS的模块和包规范即可\n- 构建工具\n在Node的应用中，主流的构建工具还是老牌的make，但它的缺点是只在*nix操作系统下有效。为了实现跨平台，Grunt应运而生。Grunt通过Node写成，借助Node的跨平台能力，实现了很好的平台兼容性。\nMakefile\n  - Makefile文件是*nix系统下经典的构建工具。除了Windows系统外，其他系统几乎都能使用它。受Makefile影响的还有Ruby的Rakefile和Gemfile等。Makefile文件通常用来管理一些编译相关\nGrunt\n  - Makefile唯一的缺陷也许就是跨平台问题了，为此才有ant、rake等工具的出现。在Node生态系统中，也有一款构建工具解决了Makefile无法跨平台的问题——Grunt。\n  - Grunt用Node写成，能够同时在Windows和*nix平台下运行。\n  - Grunt结合NPM的包依赖管理，完全可以媲美Java世界的Maven工具，同时它又如Makefile一样，能够用来构建完善的自动化任务工具。\n  - 它的设计理念与Makefile并不相同：Makefile依托强大的bash编程，Grunt则依托它丰富的插件，它自身提供通用接口用于插件的接入，具体的任务则由插件完成。\n  - Grunt的核心插件以grunt-contrib-开头，在NPM包管理平台上可以找到和查看。Grunt提供了3个模块分别用于运行时、初始化和命令行：grunt、grunt-init、grunt-cli。后面两个模块都可以作为命令行工具使用，安装时带-g即可\n\n- 编码规范\n编码规范的统一一般有几种实现方式，一种是文档式的约定，一种是代码提交时的强制检查。前者靠自觉，后者靠工具\n\n- 代码审查\n代码审查主要在请求合并的过程中完成，需要审查的点有功能是否正确完成、编码风格是否符合规范、单元测试是否有同步添加等\n\n###### 部署流程\n*部署环境*\n普通测试环境称为stage环境，预发布环境称为pre-release环境，实际的生产环境称为product环境\n\n*部署操作*\n为了能让进程持续执行，我们可能会用到nohup和&以不挂断进程的方式执行：nohup node app.js &\n\n###### 性能\n对于Web应用而言，最直接有效的莫过于动静分离、多进程架构、分布式，其中涉及的几个拆分原则如下所示。\n- 做专一的事。\n- 让擅长的工具做擅长的事情。\n- 将模型简化。\n- 将风险分离\n\n*动静分离*\n将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让Node只处理动态请求即可。这个过程可以用Nginx或者专业的CDN来处理\n![动静分离](./images/product.png)\n\n*启用缓存*\n提升性能其实差不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不必要的计算，应用场景最多的就是缓存\n\n*多进程架构*\n*读写分离*\n\n###### 日志\n*访问日志*\n访问日志一般用来记录每个客户端对应用的访问。在Web应用中，主要记录HTTP请求中的关键数据。\n中间件框架Connect在其众多中间件中提供了一个日志中间件，通过它可以将关键数据按一定格式输出到日志文件中。\n```\nvar app = connect(); \n// 记录访问日志\nconnect.logger.format('home', ':remote-addr :response-time - [:date] \":method :url \nHTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\" :res[content-length]'); \napp.use(connect.logger({ \n format: 'home', \n stream: fs.createWriteStream(__dirname + '/logs/access.log') \n}));\n```\n\n*异常日志*\n异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信息去定位bug出现的具体位置，以快速修复问题。\n异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分，具体如下所示:\n- console.log：普通日志。\n- console.info：普通信息。\n- console.warn：警告信息。\n- console.error：错误信息。\nconsole模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。\n\nconsole对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象\n```\nvar info = fs.createWriteStream(logdir + '/info.log', {flags: 'a', mode: '0666'}); \nvar error = fs.createWriteStream(logdir + '/error.log', {flags: 'a', mode: '0666'}); \nvar logger = new console.Console(info, error); \nlogger.log('Hello world!'); \nlogger.error('segment fault');\n```\n对于未捕获的异常，Node提供了机制以免进程直接退出，但是发生未捕获异常的进程也不能继续在线上进行服务了，因为可能有内存泄漏的风险产生\n\n###### 日志与数据库\n将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来\n\n分割日志\n日志的写入一般都是依托在可写流上的。对于Console对象，它的内部属性_stdout和_stderr就是指向我们传入的两个输入流对象的\n\n###### 监控报警\n\n*监控*\n监控的主要目的是为了将一些重要指标采样记录下来，一旦这些指标发生较大变化，可以配合报警系统将问题反馈到负责人那\n- 日志监控\n业务逻辑型的监控主要体现在日志上,除了异常日志的监控外，对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布\n- 响应时间\n响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长\n健康的系统响应时间应该是波动较小的、持续均衡的\n- 进程监控\n监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。\n- 磁盘监控\n磁盘监控主要是监控磁盘的用量。\n给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了\n- 内存监控\n如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落\n如果进程中存在内存泄漏，又一时没有排查解决，有一种方案可以解决这种状况。这种方案应用于多进程架构的服务集群，让每个工作进程指定服务多少次请求，达到请求数之后进程就不再服务新的连接，主进程启动新的工作进程来服务客户，旧的进程等所有连接断开后就退出。这样即使存在内存泄漏的风险，也能有效地规避内存泄漏带来的影响\n- CPU占用监控\n服务器的CPU占用监控也是必不可少的项，CPU的使用分为用户态、内核态、IOWait等\nCPU的使用率中，用户态小于70%、内核态小于35%且整体小于70%时，处于健康状态\n- CPU load监控\nCPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载\n- I/O负载\nI/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库\n- 网络监控\n网络流量监控的两个主要指标是流入流量和流出流量\n- 应用状态监控\n除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用的反馈接口来检查它的健康状态\n- DNS监控\nDNS是网络应用的基础，在实际的对外服务产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控\n\n*报警的实现*\n搭配监控系统的则是报警系统，空有监控而没有通知功能，故障也是无法及时反馈给开发者的。如今的报警已经能够多样化，- 邮件报警、IM报警适合在线工作状态\n- 短信或电话报警适合非在线状态\n\n邮件报警: 如果报警系统由Node编写，可以调用nodemailer模块来实现邮件的发送\n```\nvar nodemailer = require(\"nodemailer\"); \n// 建立一个SMTP传输连接\nvar smtpTransport = nodemailer.createTransport(\"SMTP\", { \n service: \"Gmail\", \n auth: { \n user: \"gmail.user@gmail.com\", \n pass: \"userpass\" \n } \n}); \n// 邮件选项\nvar mailOptions = { \n from: \"Fred Foo ✔ <foo@bar.com>\", // 发件人邮件地址\n to: \"bar@bar.com, baz@bar.com\", // 收件人邮件地址列表\n subject: \"Hello ✔\", // 标题\n text: \"Hello world ✔\", // 纯文本内容\n html: \"<b>Hello world ✔</b>\" // HTML内容\n} \n// 发送邮件\nsmtpTransport.sendMail(mailOptions, function (err, response) { \n if (err) { \n console.log(err); \n } else { \n console.log(\"Message sent: \" + response.message); \n } \n});\n```\n\n短信或电话报警。一些短信服务平台提供短信接入服务，可以在监控系统中接入此类服务时，一旦线上出现到达阈值的异常时，就将信息发送给应用相关的责任人。\n\n###### 稳定性\n- 多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性等问题。\n![负载均衡](./images/product-1.png)\n- 多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟等问题。在容灾方面，机房与机房之间可以互为备份\n- 容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务","updated":"2023-01-04T08:09:32.366Z","path":"nodejs/nodejs-note-5.html","comments":1,"layout":"page","_id":"clchh4gwu000ucktt1ojz2lbi","content":"<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><h6 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h6><p><em>单元测试的意义</em><br>编写可测试代码有以下几个原则可以遵循：</p>\n<ul>\n<li>单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出</li>\n<li>接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。</li>\n<li>层次分离。层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证</li>\n</ul>\n<p><em>单元测试介绍</em><br>单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分</p>\n<p><em>断言</em>：断言就是单元测试中用来保证最小单元是否正常的检测方法<br>断言用于检查程序在运行时是否满足期望。JavaScript的断言规范最早来自于CommonJS的单元测试规范（详见<a href=\"http://wiki.commonjs.org/wiki/Unit_Testing/1.0%EF%BC%89%EF%BC%8CNode%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%84%E8%8C%83%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80%E9%83%A8%E5%88%86%E3%80%82\">http://wiki.commonjs.org/wiki/Unit_Testing/1.0），Node实现了规范中的断言部分。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var assert = require(&#x27;assert&#x27;); </span><br><span class=\"line\">assert.equal(Math.max(1, 100), 100); </span><br></pre></td></tr></table></figure>\n<p>在断言规范中，定义了以下几种检测方法:</p>\n<ul>\n<li>ok()：判断结果是否为真。</li>\n<li>equal()：判断实际值与期望值是否相等。</li>\n<li>notEqual()：判断实际值与期望值是否不相等。</li>\n<li>deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。</li>\n<li>notDeepEqual()：判断实际值与期望值是否不深度相等。</li>\n<li>strictEqual()：判断实际值与期望值是否严格相等（相当于===）。</li>\n<li>notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==）。</li>\n<li>throws()：判断代码块是否抛出异常。<br>除此之外，Node的assert模块还扩充了如下两个断言方法。</li>\n<li>doesNotThrow()：判断代码块是否没有抛出异常。</li>\n<li>ifError()：判断实际值是否为一个假值（null、undefined、0、’’、false），如果实际值为真值，将会抛出异常。</li>\n</ul>\n<p><em>测试框架</em><br>测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告，提升测试用例的开发速度，提高测试用例的可维护性和可读性，以及一些周边性的工作</p>\n<p>测试风格<br>测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，它们的差别如下所示:</p>\n<ul>\n<li>关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。</li>\n<li>表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯</li>\n</ul>\n<p>mocha的BDD风格示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&#x27;Array&#x27;, function()&#123; </span><br><span class=\"line\"> before(function()&#123; </span><br><span class=\"line\"> // ... </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> describe(&#x27;#indexOf()&#x27;, function()&#123; </span><br><span class=\"line\"> it(&#x27;should return -1 when not present&#x27;, function()&#123; </span><br><span class=\"line\"> [1,2,3].indexOf(4).should.equal(-1); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p>BDD对测试用例的组织主要采用describe和it进行组织。describe可以描述多层级的结构，具体到测试用例时，用it。另外，它还提供before、after、beforeEach和afterEach这4个钩子方法，用于协助describe中测试用例的准备、安装、卸载和回收等工作。before和after分别在进入和退出describe时触发执行，beforeEach和afterEach则分别在describe中每一个测试用例（it）执行前和执行后触发执行<br><img src=\"/nodejs/images/test.png\" alt=\"单测\"><br>mocha的TDD风格示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suite(&#x27;Array&#x27;, function()&#123; </span><br><span class=\"line\"> setup(function()&#123; </span><br><span class=\"line\"> // ... </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> suite(&#x27;#indexOf()&#x27;, function()&#123; </span><br><span class=\"line\"> test(&#x27;should return -1 when not present&#x27;, function()&#123; </span><br><span class=\"line\"> assert.equal(-1, [1,2,3].indexOf(4)); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>TDD对测试用例的组织主要采用suite和test完成。suite也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含setup和teardown，对应BDD中的before和after。<br><img src=\"/nodejs/images/test-1.png\" alt=\"单测\"></p>\n<p>测试报告<br>mocha提供了相当丰富的报告格式，调用mocha –reporters即可查看所有的报告格式<br>默认的报告格式为dot，其他比较常用的格式有spec、json、html-cov等。执行mocha -R <reporter>命令即可采用这些报告。json报告因为其格式非常通用，多用于将结果传递给其他程序进行处理，而html-cov则用于可视化地观察代码覆盖率</reporter></p>\n<p>测试用例<br>测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注</p>\n<ul>\n<li>异步测试<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&#x27;fs.readFile should be ok&#x27;, function (done) &#123; </span><br><span class=\"line\"> fs.readFile(&#x27;file_path&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; </span><br><span class=\"line\"> should.not.exist(err); </span><br><span class=\"line\"> done(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n测试用例方法it()接受两个参数；用例标题（title）和回调函数（fn）。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行</li>\n<li>超时设置<br>mocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&#x27;async test&#x27;, function (done) &#123; </span><br><span class=\"line\"> // 模拟一个要执行很久的异步方法</span><br><span class=\"line\"> setTimeout(done, 10000); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\nmocha的默认超时时间为2000毫秒。一般情况下，通过mocha -t <ms>设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&#x27;should take less than 500ms&#x27;, function (done) &#123; </span><br><span class=\"line\"> this.timeout(500); </span><br><span class=\"line\"> setTimeout(done, 300); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&#x27;a suite of tests&#x27;, function()&#123; </span><br><span class=\"line\"> this.timeout(500); </span><br><span class=\"line\"> it(&#x27;should take less than 500ms&#x27;, function (done) &#123; </span><br><span class=\"line\"> setTimeout(done, 300); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> it(&#x27;should take less than 500ms as well&#x27;, function (done) &#123; </span><br><span class=\"line\"> setTimeout(done, 200); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure></ms></li>\n</ul>\n<p><em>测试覆盖率</em><br>测试覆盖率是单元测试中的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况</p>\n<p>若要探知这个测试用例对源代码的覆盖率，需要一种工具来统计每一行代码是否执行，这里要介绍的相关工具是jscover模块。通过npm install jscover -g的方式可以安装该模块</p>\n<p>jscover模块虽然已经够用，但是还有两个问题:</p>\n<ul>\n<li>它的编译部分是通过Java实现的，这样环境依赖上就多出了Java。</li>\n<li>它需要编译代码到一个额外的新目录，这个过程相对麻烦。<br>blanket模块解决了这两个问题，它由纯JavaScript实现，编译代码的过程也是隐式的，无须配置额外的目录，对于原模块项目没有额外的侵入</li>\n</ul>\n<p>blanket与jscover的原理基本一致，在实现过程上有所不同，其差别在于blanket将编译的步骤注入在require中，而不是去额外编译成文件，执行测试时再去引用编译后的文件，它的技巧在require中</p>\n<p>它的配置比jscover要简单，只需要在所有测试用例运行之前通过–require选项引入它即可：<br>mocha –require blanket -R html-cov &gt; coverage.html </p>\n<p>另一个需要注意的是，在包描述文件中配置scripts节点。在scripts节点中，pattern属性用以匹配需要编译的文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123; </span><br><span class=\"line\"> &quot;blanket&quot;: &#123; </span><br><span class=\"line\"> &quot;pattern&quot;: &quot;eventproxy/lib&quot; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;, </span><br></pre></td></tr></table></figure>\n<p>当在测试文件中通过require引入一个文件模块时，它将判断这个文件的实际路径，如果符合这个匹配规则，就对它进行编译</p>\n<p>使用blanket之后，就无须配置环境变量了，也无须根据环境去判断引入哪种代码</p>\n<p><em>mock</em><br>在测试领域里，模拟异常其实是一个不小的科目，它有着一个特殊的名词：mock。我们通过伪造被调用方来测试上层代码的健壮性等</p>\n<p>由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var muk = require(&#x27;muk&#x27;); </span><br><span class=\"line\">before(function () &#123; </span><br><span class=\"line\"> muk(fs, &#x27;readFileSync&#x27;, function(path, encoding) &#123; </span><br><span class=\"line\"> throw new Error(&quot;mock readFileSync error&quot;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">// it(); </span><br><span class=\"line\">after(function () &#123; </span><br><span class=\"line\"> muk.restore(); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var muk = require(&#x27;muk&#x27;); </span><br><span class=\"line\">beforeEach(function () &#123; </span><br><span class=\"line\"> muk(fs, &#x27;readFileSync&#x27;, function(path, encoding) &#123; </span><br><span class=\"line\"> throw new Error(&quot;mock readFileSync error&quot;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">// it(); </span><br><span class=\"line\">// it(); </span><br><span class=\"line\">afterEach(function () &#123; </span><br><span class=\"line\"> muk.restore(); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p>模拟时无须临时缓存正确引用，用例执行结束后调用muk.restore()恢复即可</p>\n<p>值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readFile = function (filename, encoding, callback) &#123; </span><br><span class=\"line\"> process.nextTick(function () &#123; </span><br><span class=\"line\"> callback(new Error(&quot;mock readFile error&quot;)); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><em>私有方法的测试</em><br>除了将这些私有方法通过exports导出外。rewire模块提供了一种巧妙的方式实现对私有方法的访问。<br>rewire的调用方式与require十分类似。对于如下的私有方法，我们获取它并为其执行测试用例非常简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var limit = function (num) &#123; </span><br><span class=\"line\"> return num &lt; 0 ? 0 : num; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">it(&#x27;limit should return success&#x27;, function () &#123; </span><br><span class=\"line\"> var lib = rewire(&#x27;../lib/index.js&#x27;); </span><br><span class=\"line\"> var litmit = lib.__get__(&#x27;limit&#x27;); </span><br><span class=\"line\"> litmit(10).should.be.equal(10); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p>每一个被rewire引入的模块都有__set__()和__get__()方法。它巧妙地利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行</p>\n<h6 id=\"工程化与自动化\"><a href=\"#工程化与自动化\" class=\"headerlink\" title=\"工程化与自动化\"></a>工程化与自动化</h6><p><em>工程化</em><br>Node在*nix系统下可以很好地利用一些成熟工具，其中Makefile比较小巧灵活，适合用来构建工程</p>\n<p><em>持续集成</em><br>travis-ci</p>\n<h6 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h6><p>单元测试主要用于检测代码的行为是否符合预期。在完成代码的行为检测后，还需要对已有代码的性能作出评估，检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力。换句话说，性能也是功能。性能测试的范畴比较广泛，包括负载测试、压力测试和基准测试等</p>\n<p><em>基准测试</em><br>基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距</p>\n<p>为了得到更规范和更好的输出结果，这里介绍benchmark这个模块是如何组织基准测试的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Benchmark = require(&#x27;benchmark&#x27;); </span><br><span class=\"line\">var suite = new Benchmark.Suite(); </span><br><span class=\"line\">var arr = [0, 1, 2, 3, 5, 6]; </span><br><span class=\"line\">suite.add(&#x27;nativeMap&#x27;, function () &#123; </span><br><span class=\"line\"> return arr.map(callback); </span><br><span class=\"line\">&#125;).add(&#x27;customMap&#x27;, function () &#123; </span><br><span class=\"line\"> var ret = []; </span><br><span class=\"line\"> for (var i = 0; i &lt; arr.length; i++) &#123; </span><br><span class=\"line\"> ret.push(callback(arr[i])); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> return ret; </span><br><span class=\"line\">&#125;).on(&#x27;cycle&#x27;, function (event) &#123; </span><br><span class=\"line\"> console.log(String(event.target)); </span><br><span class=\"line\">&#125;).on(&#x27;complete&#x27;, function() &#123; </span><br><span class=\"line\"> console.log(&#x27;Fastest is &#x27; + this.filter(&#x27;fastest&#x27;).pluck(&#x27;name&#x27;)); </span><br><span class=\"line\">&#125;).run(); </span><br></pre></td></tr></table></figure>\n\n<h6 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h6><p>对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力</p>\n<p>最常用的工具是ab、siege、http_load等，下面我们通过ab工具来构造压力测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ab -c 10 -t 3 http://localhost:8001/ </span><br><span class=\"line\">This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; </span><br><span class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ </span><br><span class=\"line\">Licensed to The Apache Software Foundation, http://www.apache.org/ </span><br><span class=\"line\">Benchmarking localhost (be patient) </span><br><span class=\"line\">Completed 5000 requests </span><br><span class=\"line\">Completed 10000 requests </span><br><span class=\"line\">Finished 11573 requests </span><br><span class=\"line\">Server Software: </span><br><span class=\"line\">Server Hostname: localhost </span><br><span class=\"line\">Server Port: 8001 </span><br><span class=\"line\">Document Path: / </span><br><span class=\"line\">Document Length: 10240 bytes </span><br><span class=\"line\">Concurrency Level: 10 </span><br><span class=\"line\">Time taken for tests: 3.000 seconds </span><br><span class=\"line\">Complete requests: 11573 </span><br><span class=\"line\">Failed requests: 0 </span><br><span class=\"line\">Write errors: 0 </span><br><span class=\"line\">Total transferred: 119375495 bytes </span><br><span class=\"line\">HTML transferred: 118507520 bytes </span><br><span class=\"line\">Requests per second: 3857.60 [#/sec] (mean) </span><br><span class=\"line\">Time per request: 2.592 [ms] (mean) </span><br><span class=\"line\">Time per request: 0.259 [ms] (mean, across all concurrent requests) </span><br><span class=\"line\">Transfer rate: 38858.59 [Kbytes/sec] received </span><br><span class=\"line\">Connection Times (ms) </span><br><span class=\"line\"> min mean[+/-sd] median max </span><br><span class=\"line\">Connect: 0 0 0.3 0 31 </span><br><span class=\"line\">Processing: 1 2 1.9 2 35 </span><br><span class=\"line\">Waiting: 0 2 1.9 2 35 </span><br><span class=\"line\">Total: 1 3 2.0 2 35 </span><br><span class=\"line\">Percentage of the requests served within a certain time (ms) </span><br><span class=\"line\"> 50% 2</span><br><span class=\"line\"> 66% 3 </span><br><span class=\"line\"> 75% 3 </span><br><span class=\"line\"> 80% 3 </span><br><span class=\"line\"> 90% 3</span><br><span class=\"line\"> 95% 3 </span><br><span class=\"line\"> 98% 5 </span><br><span class=\"line\"> 99% 6 </span><br><span class=\"line\"> 100% 35 (longes % t request)</span><br></pre></td></tr></table></figure>\n\n<p>各个参数的含义:</p>\n<ul>\n<li>Document Path：表示文档的路径，此处为/。</li>\n<li>Document Length：表示文档的长度，就是报文的大小，这里有10KB。</li>\n<li>Concurrency Level：并发级别，就是我们在命令中传入的c，此处为10，即10个并发。</li>\n<li>Time taken for tests：表示完成所有测试所花费的时间，它与命令行中传入的t选项有细微出入。</li>\n<li>Complete requests：表示在这次测试中一共完成多少次请求。</li>\n<li>Failed requests：表示其中产生失败的请求数，这次测试中没有失败的请求。</li>\n<li>Write errors：表示在写入过程中出现的错误次数（连接断开导致的）。</li>\n<li>Total transferred：表示所有的报文大小。</li>\n<li>HTML transferred：表示仅HTTP报文的正文大小，它比上一个值小。</li>\n<li>Requests per second：这是我们重点关注的一个值，它表示服务器每秒能处理多少请求，是重点反映服务器并发能力的指标。这个值又称RPS或QPS。</li>\n<li>两个Time per request值：第一个代表的是用户平均等待时间，第二个代表的是服务器平均请求处理事件，前者除以并发数得到后者。</li>\n<li>Transfer rate：表示传输率，等于传输的大小除以传输时间，这个值受网卡的带宽限制。</li>\n<li>Connection Times：连接时间，它包括客户端向服务器端建立连接、服务器端处理请求、等待报文响应的过程。</li>\n</ul>\n<h6 id=\"基准测试驱动开发\"><a href=\"#基准测试驱动开发\" class=\"headerlink\" title=\"基准测试驱动开发\"></a>基准测试驱动开发</h6><p>简称也是BDD，全称为Benchmark Driven Development，即基准测试驱动开发，其中主要分为如下几步:<br>(1) 写基准测试。<br>(2) 写/改代码。<br>(3) 收集数据。<br>(4) 找出问题。<br>(5)回到第(2)步<br><img src=\"/nodejs/images/test-2.png\" alt=\"单测\"></p>\n<h4 id=\"产-品-化\"><a href=\"#产-品-化\" class=\"headerlink\" title=\"产 品 化\"></a>产 品 化</h4><h6 id=\"项目工程化\"><a href=\"#项目工程化\" class=\"headerlink\" title=\"项目工程化\"></a>项目工程化</h6><p>所谓的工程化，可以理解为项目的组织能力。体现在文件上，就是文件的组织能力</p>\n<ul>\n<li><p>目录结构</p>\n<ul>\n<li>主要的两类项目为Web应用和模块应用。普通的模块应用遵循CommonJS的模块和包规范即可</li>\n</ul>\n</li>\n<li><p>构建工具<br>在Node的应用中，主流的构建工具还是老牌的make，但它的缺点是只在*nix操作系统下有效。为了实现跨平台，Grunt应运而生。Grunt通过Node写成，借助Node的跨平台能力，实现了很好的平台兼容性。<br>Makefile</p>\n<ul>\n<li>Makefile文件是*nix系统下经典的构建工具。除了Windows系统外，其他系统几乎都能使用它。受Makefile影响的还有Ruby的Rakefile和Gemfile等。Makefile文件通常用来管理一些编译相关<br>Grunt</li>\n<li>Makefile唯一的缺陷也许就是跨平台问题了，为此才有ant、rake等工具的出现。在Node生态系统中，也有一款构建工具解决了Makefile无法跨平台的问题——Grunt。</li>\n<li>Grunt用Node写成，能够同时在Windows和*nix平台下运行。</li>\n<li>Grunt结合NPM的包依赖管理，完全可以媲美Java世界的Maven工具，同时它又如Makefile一样，能够用来构建完善的自动化任务工具。</li>\n<li>它的设计理念与Makefile并不相同：Makefile依托强大的bash编程，Grunt则依托它丰富的插件，它自身提供通用接口用于插件的接入，具体的任务则由插件完成。</li>\n<li>Grunt的核心插件以grunt-contrib-开头，在NPM包管理平台上可以找到和查看。Grunt提供了3个模块分别用于运行时、初始化和命令行：grunt、grunt-init、grunt-cli。后面两个模块都可以作为命令行工具使用，安装时带-g即可</li>\n</ul>\n</li>\n<li><p>编码规范<br>编码规范的统一一般有几种实现方式，一种是文档式的约定，一种是代码提交时的强制检查。前者靠自觉，后者靠工具</p>\n</li>\n<li><p>代码审查<br>代码审查主要在请求合并的过程中完成，需要审查的点有功能是否正确完成、编码风格是否符合规范、单元测试是否有同步添加等</p>\n</li>\n</ul>\n<h6 id=\"部署流程\"><a href=\"#部署流程\" class=\"headerlink\" title=\"部署流程\"></a>部署流程</h6><p><em>部署环境</em><br>普通测试环境称为stage环境，预发布环境称为pre-release环境，实际的生产环境称为product环境</p>\n<p><em>部署操作</em><br>为了能让进程持续执行，我们可能会用到nohup和&amp;以不挂断进程的方式执行：nohup node app.js &amp;</p>\n<h6 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h6><p>对于Web应用而言，最直接有效的莫过于动静分离、多进程架构、分布式，其中涉及的几个拆分原则如下所示。</p>\n<ul>\n<li>做专一的事。</li>\n<li>让擅长的工具做擅长的事情。</li>\n<li>将模型简化。</li>\n<li>将风险分离</li>\n</ul>\n<p><em>动静分离</em><br>将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让Node只处理动态请求即可。这个过程可以用Nginx或者专业的CDN来处理<br><img src=\"/nodejs/images/product.png\" alt=\"动静分离\"></p>\n<p><em>启用缓存</em><br>提升性能其实差不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不必要的计算，应用场景最多的就是缓存</p>\n<p><em>多进程架构</em><br><em>读写分离</em></p>\n<h6 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h6><p><em>访问日志</em><br>访问日志一般用来记录每个客户端对应用的访问。在Web应用中，主要记录HTTP请求中的关键数据。<br>中间件框架Connect在其众多中间件中提供了一个日志中间件，通过它可以将关键数据按一定格式输出到日志文件中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = connect(); </span><br><span class=\"line\">// 记录访问日志</span><br><span class=\"line\">connect.logger.format(&#x27;home&#x27;, &#x27;:remote-addr :response-time - [:date] &quot;:method :url </span><br><span class=\"line\">HTTP/:http-version&quot; :status :res[content-length] &quot;:referrer&quot; &quot;:user-agent&quot; :res[content-length]&#x27;); </span><br><span class=\"line\">app.use(connect.logger(&#123; </span><br><span class=\"line\"> format: &#x27;home&#x27;, </span><br><span class=\"line\"> stream: fs.createWriteStream(__dirname + &#x27;/logs/access.log&#x27;) </span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p><em>异常日志</em><br>异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信息去定位bug出现的具体位置，以快速修复问题。<br>异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分，具体如下所示:</p>\n<ul>\n<li>console.log：普通日志。</li>\n<li>console.info：普通信息。</li>\n<li>console.warn：警告信息。</li>\n<li>console.error：错误信息。<br>console模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。</li>\n</ul>\n<p>console对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var info = fs.createWriteStream(logdir + &#x27;/info.log&#x27;, &#123;flags: &#x27;a&#x27;, mode: &#x27;0666&#x27;&#125;); </span><br><span class=\"line\">var error = fs.createWriteStream(logdir + &#x27;/error.log&#x27;, &#123;flags: &#x27;a&#x27;, mode: &#x27;0666&#x27;&#125;); </span><br><span class=\"line\">var logger = new console.Console(info, error); </span><br><span class=\"line\">logger.log(&#x27;Hello world!&#x27;); </span><br><span class=\"line\">logger.error(&#x27;segment fault&#x27;);</span><br></pre></td></tr></table></figure>\n<p>对于未捕获的异常，Node提供了机制以免进程直接退出，但是发生未捕获异常的进程也不能继续在线上进行服务了，因为可能有内存泄漏的风险产生</p>\n<h6 id=\"日志与数据库\"><a href=\"#日志与数据库\" class=\"headerlink\" title=\"日志与数据库\"></a>日志与数据库</h6><p>将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来</p>\n<p>分割日志<br>日志的写入一般都是依托在可写流上的。对于Console对象，它的内部属性_stdout和_stderr就是指向我们传入的两个输入流对象的</p>\n<h6 id=\"监控报警\"><a href=\"#监控报警\" class=\"headerlink\" title=\"监控报警\"></a>监控报警</h6><p><em>监控</em><br>监控的主要目的是为了将一些重要指标采样记录下来，一旦这些指标发生较大变化，可以配合报警系统将问题反馈到负责人那</p>\n<ul>\n<li>日志监控<br>业务逻辑型的监控主要体现在日志上,除了异常日志的监控外，对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布</li>\n<li>响应时间<br>响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长<br>健康的系统响应时间应该是波动较小的、持续均衡的</li>\n<li>进程监控<br>监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。</li>\n<li>磁盘监控<br>磁盘监控主要是监控磁盘的用量。<br>给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了</li>\n<li>内存监控<br>如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落<br>如果进程中存在内存泄漏，又一时没有排查解决，有一种方案可以解决这种状况。这种方案应用于多进程架构的服务集群，让每个工作进程指定服务多少次请求，达到请求数之后进程就不再服务新的连接，主进程启动新的工作进程来服务客户，旧的进程等所有连接断开后就退出。这样即使存在内存泄漏的风险，也能有效地规避内存泄漏带来的影响</li>\n<li>CPU占用监控<br>服务器的CPU占用监控也是必不可少的项，CPU的使用分为用户态、内核态、IOWait等<br>CPU的使用率中，用户态小于70%、内核态小于35%且整体小于70%时，处于健康状态</li>\n<li>CPU load监控<br>CPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载</li>\n<li>I/O负载<br>I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库</li>\n<li>网络监控<br>网络流量监控的两个主要指标是流入流量和流出流量</li>\n<li>应用状态监控<br>除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用的反馈接口来检查它的健康状态</li>\n<li>DNS监控<br>DNS是网络应用的基础，在实际的对外服务产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控</li>\n</ul>\n<p><em>报警的实现</em><br>搭配监控系统的则是报警系统，空有监控而没有通知功能，故障也是无法及时反馈给开发者的。如今的报警已经能够多样化，- 邮件报警、IM报警适合在线工作状态</p>\n<ul>\n<li>短信或电话报警适合非在线状态</li>\n</ul>\n<p>邮件报警: 如果报警系统由Node编写，可以调用nodemailer模块来实现邮件的发送</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nodemailer = require(&quot;nodemailer&quot;); </span><br><span class=\"line\">// 建立一个SMTP传输连接</span><br><span class=\"line\">var smtpTransport = nodemailer.createTransport(&quot;SMTP&quot;, &#123; </span><br><span class=\"line\"> service: &quot;Gmail&quot;, </span><br><span class=\"line\"> auth: &#123; </span><br><span class=\"line\"> user: &quot;gmail.user@gmail.com&quot;, </span><br><span class=\"line\"> pass: &quot;userpass&quot; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">// 邮件选项</span><br><span class=\"line\">var mailOptions = &#123; </span><br><span class=\"line\"> from: &quot;Fred Foo ✔ &lt;foo@bar.com&gt;&quot;, // 发件人邮件地址</span><br><span class=\"line\"> to: &quot;bar@bar.com, baz@bar.com&quot;, // 收件人邮件地址列表</span><br><span class=\"line\"> subject: &quot;Hello ✔&quot;, // 标题</span><br><span class=\"line\"> text: &quot;Hello world ✔&quot;, // 纯文本内容</span><br><span class=\"line\"> html: &quot;&lt;b&gt;Hello world ✔&lt;/b&gt;&quot; // HTML内容</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// 发送邮件</span><br><span class=\"line\">smtpTransport.sendMail(mailOptions, function (err, response) &#123; </span><br><span class=\"line\"> if (err) &#123; </span><br><span class=\"line\"> console.log(err); </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> console.log(&quot;Message sent: &quot; + response.message); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>短信或电话报警。一些短信服务平台提供短信接入服务，可以在监控系统中接入此类服务时，一旦线上出现到达阈值的异常时，就将信息发送给应用相关的责任人。</p>\n<h6 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h6><ul>\n<li>多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性等问题。<br><img src=\"/nodejs/images/product-1.png\" alt=\"负载均衡\"></li>\n<li>多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟等问题。在容灾方面，机房与机房之间可以互为备份</li>\n<li>容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><h6 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h6><p><em>单元测试的意义</em><br>编写可测试代码有以下几个原则可以遵循：</p>\n<ul>\n<li>单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出</li>\n<li>接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。</li>\n<li>层次分离。层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证</li>\n</ul>\n<p><em>单元测试介绍</em><br>单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分</p>\n<p><em>断言</em>：断言就是单元测试中用来保证最小单元是否正常的检测方法<br>断言用于检查程序在运行时是否满足期望。JavaScript的断言规范最早来自于CommonJS的单元测试规范（详见<a href=\"http://wiki.commonjs.org/wiki/Unit_Testing/1.0%EF%BC%89%EF%BC%8CNode%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%84%E8%8C%83%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80%E9%83%A8%E5%88%86%E3%80%82\">http://wiki.commonjs.org/wiki/Unit_Testing/1.0），Node实现了规范中的断言部分。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var assert = require(&#x27;assert&#x27;); </span><br><span class=\"line\">assert.equal(Math.max(1, 100), 100); </span><br></pre></td></tr></table></figure>\n<p>在断言规范中，定义了以下几种检测方法:</p>\n<ul>\n<li>ok()：判断结果是否为真。</li>\n<li>equal()：判断实际值与期望值是否相等。</li>\n<li>notEqual()：判断实际值与期望值是否不相等。</li>\n<li>deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。</li>\n<li>notDeepEqual()：判断实际值与期望值是否不深度相等。</li>\n<li>strictEqual()：判断实际值与期望值是否严格相等（相当于===）。</li>\n<li>notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==）。</li>\n<li>throws()：判断代码块是否抛出异常。<br>除此之外，Node的assert模块还扩充了如下两个断言方法。</li>\n<li>doesNotThrow()：判断代码块是否没有抛出异常。</li>\n<li>ifError()：判断实际值是否为一个假值（null、undefined、0、’’、false），如果实际值为真值，将会抛出异常。</li>\n</ul>\n<p><em>测试框架</em><br>测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告，提升测试用例的开发速度，提高测试用例的可维护性和可读性，以及一些周边性的工作</p>\n<p>测试风格<br>测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，它们的差别如下所示:</p>\n<ul>\n<li>关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。</li>\n<li>表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯</li>\n</ul>\n<p>mocha的BDD风格示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&#x27;Array&#x27;, function()&#123; </span><br><span class=\"line\"> before(function()&#123; </span><br><span class=\"line\"> // ... </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> describe(&#x27;#indexOf()&#x27;, function()&#123; </span><br><span class=\"line\"> it(&#x27;should return -1 when not present&#x27;, function()&#123; </span><br><span class=\"line\"> [1,2,3].indexOf(4).should.equal(-1); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p>BDD对测试用例的组织主要采用describe和it进行组织。describe可以描述多层级的结构，具体到测试用例时，用it。另外，它还提供before、after、beforeEach和afterEach这4个钩子方法，用于协助describe中测试用例的准备、安装、卸载和回收等工作。before和after分别在进入和退出describe时触发执行，beforeEach和afterEach则分别在describe中每一个测试用例（it）执行前和执行后触发执行<br><img src=\"/nodejs/images/test.png\" alt=\"单测\"><br>mocha的TDD风格示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suite(&#x27;Array&#x27;, function()&#123; </span><br><span class=\"line\"> setup(function()&#123; </span><br><span class=\"line\"> // ... </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> suite(&#x27;#indexOf()&#x27;, function()&#123; </span><br><span class=\"line\"> test(&#x27;should return -1 when not present&#x27;, function()&#123; </span><br><span class=\"line\"> assert.equal(-1, [1,2,3].indexOf(4)); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>TDD对测试用例的组织主要采用suite和test完成。suite也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含setup和teardown，对应BDD中的before和after。<br><img src=\"/nodejs/images/test-1.png\" alt=\"单测\"></p>\n<p>测试报告<br>mocha提供了相当丰富的报告格式，调用mocha –reporters即可查看所有的报告格式<br>默认的报告格式为dot，其他比较常用的格式有spec、json、html-cov等。执行mocha -R <reporter>命令即可采用这些报告。json报告因为其格式非常通用，多用于将结果传递给其他程序进行处理，而html-cov则用于可视化地观察代码覆盖率</reporter></p>\n<p>测试用例<br>测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注</p>\n<ul>\n<li>异步测试<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&#x27;fs.readFile should be ok&#x27;, function (done) &#123; </span><br><span class=\"line\"> fs.readFile(&#x27;file_path&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; </span><br><span class=\"line\"> should.not.exist(err); </span><br><span class=\"line\"> done(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n测试用例方法it()接受两个参数；用例标题（title）和回调函数（fn）。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行</li>\n<li>超时设置<br>mocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&#x27;async test&#x27;, function (done) &#123; </span><br><span class=\"line\"> // 模拟一个要执行很久的异步方法</span><br><span class=\"line\"> setTimeout(done, 10000); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\nmocha的默认超时时间为2000毫秒。一般情况下，通过mocha -t <ms>设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&#x27;should take less than 500ms&#x27;, function (done) &#123; </span><br><span class=\"line\"> this.timeout(500); </span><br><span class=\"line\"> setTimeout(done, 300); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&#x27;a suite of tests&#x27;, function()&#123; </span><br><span class=\"line\"> this.timeout(500); </span><br><span class=\"line\"> it(&#x27;should take less than 500ms&#x27;, function (done) &#123; </span><br><span class=\"line\"> setTimeout(done, 300); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> it(&#x27;should take less than 500ms as well&#x27;, function (done) &#123; </span><br><span class=\"line\"> setTimeout(done, 200); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure></ms></li>\n</ul>\n<p><em>测试覆盖率</em><br>测试覆盖率是单元测试中的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况</p>\n<p>若要探知这个测试用例对源代码的覆盖率，需要一种工具来统计每一行代码是否执行，这里要介绍的相关工具是jscover模块。通过npm install jscover -g的方式可以安装该模块</p>\n<p>jscover模块虽然已经够用，但是还有两个问题:</p>\n<ul>\n<li>它的编译部分是通过Java实现的，这样环境依赖上就多出了Java。</li>\n<li>它需要编译代码到一个额外的新目录，这个过程相对麻烦。<br>blanket模块解决了这两个问题，它由纯JavaScript实现，编译代码的过程也是隐式的，无须配置额外的目录，对于原模块项目没有额外的侵入</li>\n</ul>\n<p>blanket与jscover的原理基本一致，在实现过程上有所不同，其差别在于blanket将编译的步骤注入在require中，而不是去额外编译成文件，执行测试时再去引用编译后的文件，它的技巧在require中</p>\n<p>它的配置比jscover要简单，只需要在所有测试用例运行之前通过–require选项引入它即可：<br>mocha –require blanket -R html-cov &gt; coverage.html </p>\n<p>另一个需要注意的是，在包描述文件中配置scripts节点。在scripts节点中，pattern属性用以匹配需要编译的文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123; </span><br><span class=\"line\"> &quot;blanket&quot;: &#123; </span><br><span class=\"line\"> &quot;pattern&quot;: &quot;eventproxy/lib&quot; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;, </span><br></pre></td></tr></table></figure>\n<p>当在测试文件中通过require引入一个文件模块时，它将判断这个文件的实际路径，如果符合这个匹配规则，就对它进行编译</p>\n<p>使用blanket之后，就无须配置环境变量了，也无须根据环境去判断引入哪种代码</p>\n<p><em>mock</em><br>在测试领域里，模拟异常其实是一个不小的科目，它有着一个特殊的名词：mock。我们通过伪造被调用方来测试上层代码的健壮性等</p>\n<p>由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var muk = require(&#x27;muk&#x27;); </span><br><span class=\"line\">before(function () &#123; </span><br><span class=\"line\"> muk(fs, &#x27;readFileSync&#x27;, function(path, encoding) &#123; </span><br><span class=\"line\"> throw new Error(&quot;mock readFileSync error&quot;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">// it(); </span><br><span class=\"line\">after(function () &#123; </span><br><span class=\"line\"> muk.restore(); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var muk = require(&#x27;muk&#x27;); </span><br><span class=\"line\">beforeEach(function () &#123; </span><br><span class=\"line\"> muk(fs, &#x27;readFileSync&#x27;, function(path, encoding) &#123; </span><br><span class=\"line\"> throw new Error(&quot;mock readFileSync error&quot;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">// it(); </span><br><span class=\"line\">// it(); </span><br><span class=\"line\">afterEach(function () &#123; </span><br><span class=\"line\"> muk.restore(); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p>模拟时无须临时缓存正确引用，用例执行结束后调用muk.restore()恢复即可</p>\n<p>值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readFile = function (filename, encoding, callback) &#123; </span><br><span class=\"line\"> process.nextTick(function () &#123; </span><br><span class=\"line\"> callback(new Error(&quot;mock readFile error&quot;)); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><em>私有方法的测试</em><br>除了将这些私有方法通过exports导出外。rewire模块提供了一种巧妙的方式实现对私有方法的访问。<br>rewire的调用方式与require十分类似。对于如下的私有方法，我们获取它并为其执行测试用例非常简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var limit = function (num) &#123; </span><br><span class=\"line\"> return num &lt; 0 ? 0 : num; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">it(&#x27;limit should return success&#x27;, function () &#123; </span><br><span class=\"line\"> var lib = rewire(&#x27;../lib/index.js&#x27;); </span><br><span class=\"line\"> var litmit = lib.__get__(&#x27;limit&#x27;); </span><br><span class=\"line\"> litmit(10).should.be.equal(10); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p>每一个被rewire引入的模块都有__set__()和__get__()方法。它巧妙地利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行</p>\n<h6 id=\"工程化与自动化\"><a href=\"#工程化与自动化\" class=\"headerlink\" title=\"工程化与自动化\"></a>工程化与自动化</h6><p><em>工程化</em><br>Node在*nix系统下可以很好地利用一些成熟工具，其中Makefile比较小巧灵活，适合用来构建工程</p>\n<p><em>持续集成</em><br>travis-ci</p>\n<h6 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h6><p>单元测试主要用于检测代码的行为是否符合预期。在完成代码的行为检测后，还需要对已有代码的性能作出评估，检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力。换句话说，性能也是功能。性能测试的范畴比较广泛，包括负载测试、压力测试和基准测试等</p>\n<p><em>基准测试</em><br>基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距</p>\n<p>为了得到更规范和更好的输出结果，这里介绍benchmark这个模块是如何组织基准测试的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Benchmark = require(&#x27;benchmark&#x27;); </span><br><span class=\"line\">var suite = new Benchmark.Suite(); </span><br><span class=\"line\">var arr = [0, 1, 2, 3, 5, 6]; </span><br><span class=\"line\">suite.add(&#x27;nativeMap&#x27;, function () &#123; </span><br><span class=\"line\"> return arr.map(callback); </span><br><span class=\"line\">&#125;).add(&#x27;customMap&#x27;, function () &#123; </span><br><span class=\"line\"> var ret = []; </span><br><span class=\"line\"> for (var i = 0; i &lt; arr.length; i++) &#123; </span><br><span class=\"line\"> ret.push(callback(arr[i])); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> return ret; </span><br><span class=\"line\">&#125;).on(&#x27;cycle&#x27;, function (event) &#123; </span><br><span class=\"line\"> console.log(String(event.target)); </span><br><span class=\"line\">&#125;).on(&#x27;complete&#x27;, function() &#123; </span><br><span class=\"line\"> console.log(&#x27;Fastest is &#x27; + this.filter(&#x27;fastest&#x27;).pluck(&#x27;name&#x27;)); </span><br><span class=\"line\">&#125;).run(); </span><br></pre></td></tr></table></figure>\n\n<h6 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h6><p>对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力</p>\n<p>最常用的工具是ab、siege、http_load等，下面我们通过ab工具来构造压力测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ab -c 10 -t 3 http://localhost:8001/ </span><br><span class=\"line\">This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; </span><br><span class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ </span><br><span class=\"line\">Licensed to The Apache Software Foundation, http://www.apache.org/ </span><br><span class=\"line\">Benchmarking localhost (be patient) </span><br><span class=\"line\">Completed 5000 requests </span><br><span class=\"line\">Completed 10000 requests </span><br><span class=\"line\">Finished 11573 requests </span><br><span class=\"line\">Server Software: </span><br><span class=\"line\">Server Hostname: localhost </span><br><span class=\"line\">Server Port: 8001 </span><br><span class=\"line\">Document Path: / </span><br><span class=\"line\">Document Length: 10240 bytes </span><br><span class=\"line\">Concurrency Level: 10 </span><br><span class=\"line\">Time taken for tests: 3.000 seconds </span><br><span class=\"line\">Complete requests: 11573 </span><br><span class=\"line\">Failed requests: 0 </span><br><span class=\"line\">Write errors: 0 </span><br><span class=\"line\">Total transferred: 119375495 bytes </span><br><span class=\"line\">HTML transferred: 118507520 bytes </span><br><span class=\"line\">Requests per second: 3857.60 [#/sec] (mean) </span><br><span class=\"line\">Time per request: 2.592 [ms] (mean) </span><br><span class=\"line\">Time per request: 0.259 [ms] (mean, across all concurrent requests) </span><br><span class=\"line\">Transfer rate: 38858.59 [Kbytes/sec] received </span><br><span class=\"line\">Connection Times (ms) </span><br><span class=\"line\"> min mean[+/-sd] median max </span><br><span class=\"line\">Connect: 0 0 0.3 0 31 </span><br><span class=\"line\">Processing: 1 2 1.9 2 35 </span><br><span class=\"line\">Waiting: 0 2 1.9 2 35 </span><br><span class=\"line\">Total: 1 3 2.0 2 35 </span><br><span class=\"line\">Percentage of the requests served within a certain time (ms) </span><br><span class=\"line\"> 50% 2</span><br><span class=\"line\"> 66% 3 </span><br><span class=\"line\"> 75% 3 </span><br><span class=\"line\"> 80% 3 </span><br><span class=\"line\"> 90% 3</span><br><span class=\"line\"> 95% 3 </span><br><span class=\"line\"> 98% 5 </span><br><span class=\"line\"> 99% 6 </span><br><span class=\"line\"> 100% 35 (longes % t request)</span><br></pre></td></tr></table></figure>\n\n<p>各个参数的含义:</p>\n<ul>\n<li>Document Path：表示文档的路径，此处为/。</li>\n<li>Document Length：表示文档的长度，就是报文的大小，这里有10KB。</li>\n<li>Concurrency Level：并发级别，就是我们在命令中传入的c，此处为10，即10个并发。</li>\n<li>Time taken for tests：表示完成所有测试所花费的时间，它与命令行中传入的t选项有细微出入。</li>\n<li>Complete requests：表示在这次测试中一共完成多少次请求。</li>\n<li>Failed requests：表示其中产生失败的请求数，这次测试中没有失败的请求。</li>\n<li>Write errors：表示在写入过程中出现的错误次数（连接断开导致的）。</li>\n<li>Total transferred：表示所有的报文大小。</li>\n<li>HTML transferred：表示仅HTTP报文的正文大小，它比上一个值小。</li>\n<li>Requests per second：这是我们重点关注的一个值，它表示服务器每秒能处理多少请求，是重点反映服务器并发能力的指标。这个值又称RPS或QPS。</li>\n<li>两个Time per request值：第一个代表的是用户平均等待时间，第二个代表的是服务器平均请求处理事件，前者除以并发数得到后者。</li>\n<li>Transfer rate：表示传输率，等于传输的大小除以传输时间，这个值受网卡的带宽限制。</li>\n<li>Connection Times：连接时间，它包括客户端向服务器端建立连接、服务器端处理请求、等待报文响应的过程。</li>\n</ul>\n<h6 id=\"基准测试驱动开发\"><a href=\"#基准测试驱动开发\" class=\"headerlink\" title=\"基准测试驱动开发\"></a>基准测试驱动开发</h6><p>简称也是BDD，全称为Benchmark Driven Development，即基准测试驱动开发，其中主要分为如下几步:<br>(1) 写基准测试。<br>(2) 写/改代码。<br>(3) 收集数据。<br>(4) 找出问题。<br>(5)回到第(2)步<br><img src=\"/nodejs/images/test-2.png\" alt=\"单测\"></p>\n<h4 id=\"产-品-化\"><a href=\"#产-品-化\" class=\"headerlink\" title=\"产 品 化\"></a>产 品 化</h4><h6 id=\"项目工程化\"><a href=\"#项目工程化\" class=\"headerlink\" title=\"项目工程化\"></a>项目工程化</h6><p>所谓的工程化，可以理解为项目的组织能力。体现在文件上，就是文件的组织能力</p>\n<ul>\n<li><p>目录结构</p>\n<ul>\n<li>主要的两类项目为Web应用和模块应用。普通的模块应用遵循CommonJS的模块和包规范即可</li>\n</ul>\n</li>\n<li><p>构建工具<br>在Node的应用中，主流的构建工具还是老牌的make，但它的缺点是只在*nix操作系统下有效。为了实现跨平台，Grunt应运而生。Grunt通过Node写成，借助Node的跨平台能力，实现了很好的平台兼容性。<br>Makefile</p>\n<ul>\n<li>Makefile文件是*nix系统下经典的构建工具。除了Windows系统外，其他系统几乎都能使用它。受Makefile影响的还有Ruby的Rakefile和Gemfile等。Makefile文件通常用来管理一些编译相关<br>Grunt</li>\n<li>Makefile唯一的缺陷也许就是跨平台问题了，为此才有ant、rake等工具的出现。在Node生态系统中，也有一款构建工具解决了Makefile无法跨平台的问题——Grunt。</li>\n<li>Grunt用Node写成，能够同时在Windows和*nix平台下运行。</li>\n<li>Grunt结合NPM的包依赖管理，完全可以媲美Java世界的Maven工具，同时它又如Makefile一样，能够用来构建完善的自动化任务工具。</li>\n<li>它的设计理念与Makefile并不相同：Makefile依托强大的bash编程，Grunt则依托它丰富的插件，它自身提供通用接口用于插件的接入，具体的任务则由插件完成。</li>\n<li>Grunt的核心插件以grunt-contrib-开头，在NPM包管理平台上可以找到和查看。Grunt提供了3个模块分别用于运行时、初始化和命令行：grunt、grunt-init、grunt-cli。后面两个模块都可以作为命令行工具使用，安装时带-g即可</li>\n</ul>\n</li>\n<li><p>编码规范<br>编码规范的统一一般有几种实现方式，一种是文档式的约定，一种是代码提交时的强制检查。前者靠自觉，后者靠工具</p>\n</li>\n<li><p>代码审查<br>代码审查主要在请求合并的过程中完成，需要审查的点有功能是否正确完成、编码风格是否符合规范、单元测试是否有同步添加等</p>\n</li>\n</ul>\n<h6 id=\"部署流程\"><a href=\"#部署流程\" class=\"headerlink\" title=\"部署流程\"></a>部署流程</h6><p><em>部署环境</em><br>普通测试环境称为stage环境，预发布环境称为pre-release环境，实际的生产环境称为product环境</p>\n<p><em>部署操作</em><br>为了能让进程持续执行，我们可能会用到nohup和&amp;以不挂断进程的方式执行：nohup node app.js &amp;</p>\n<h6 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h6><p>对于Web应用而言，最直接有效的莫过于动静分离、多进程架构、分布式，其中涉及的几个拆分原则如下所示。</p>\n<ul>\n<li>做专一的事。</li>\n<li>让擅长的工具做擅长的事情。</li>\n<li>将模型简化。</li>\n<li>将风险分离</li>\n</ul>\n<p><em>动静分离</em><br>将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让Node只处理动态请求即可。这个过程可以用Nginx或者专业的CDN来处理<br><img src=\"/nodejs/images/product.png\" alt=\"动静分离\"></p>\n<p><em>启用缓存</em><br>提升性能其实差不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不必要的计算，应用场景最多的就是缓存</p>\n<p><em>多进程架构</em><br><em>读写分离</em></p>\n<h6 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h6><p><em>访问日志</em><br>访问日志一般用来记录每个客户端对应用的访问。在Web应用中，主要记录HTTP请求中的关键数据。<br>中间件框架Connect在其众多中间件中提供了一个日志中间件，通过它可以将关键数据按一定格式输出到日志文件中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = connect(); </span><br><span class=\"line\">// 记录访问日志</span><br><span class=\"line\">connect.logger.format(&#x27;home&#x27;, &#x27;:remote-addr :response-time - [:date] &quot;:method :url </span><br><span class=\"line\">HTTP/:http-version&quot; :status :res[content-length] &quot;:referrer&quot; &quot;:user-agent&quot; :res[content-length]&#x27;); </span><br><span class=\"line\">app.use(connect.logger(&#123; </span><br><span class=\"line\"> format: &#x27;home&#x27;, </span><br><span class=\"line\"> stream: fs.createWriteStream(__dirname + &#x27;/logs/access.log&#x27;) </span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p><em>异常日志</em><br>异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信息去定位bug出现的具体位置，以快速修复问题。<br>异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分，具体如下所示:</p>\n<ul>\n<li>console.log：普通日志。</li>\n<li>console.info：普通信息。</li>\n<li>console.warn：警告信息。</li>\n<li>console.error：错误信息。<br>console模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。</li>\n</ul>\n<p>console对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var info = fs.createWriteStream(logdir + &#x27;/info.log&#x27;, &#123;flags: &#x27;a&#x27;, mode: &#x27;0666&#x27;&#125;); </span><br><span class=\"line\">var error = fs.createWriteStream(logdir + &#x27;/error.log&#x27;, &#123;flags: &#x27;a&#x27;, mode: &#x27;0666&#x27;&#125;); </span><br><span class=\"line\">var logger = new console.Console(info, error); </span><br><span class=\"line\">logger.log(&#x27;Hello world!&#x27;); </span><br><span class=\"line\">logger.error(&#x27;segment fault&#x27;);</span><br></pre></td></tr></table></figure>\n<p>对于未捕获的异常，Node提供了机制以免进程直接退出，但是发生未捕获异常的进程也不能继续在线上进行服务了，因为可能有内存泄漏的风险产生</p>\n<h6 id=\"日志与数据库\"><a href=\"#日志与数据库\" class=\"headerlink\" title=\"日志与数据库\"></a>日志与数据库</h6><p>将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来</p>\n<p>分割日志<br>日志的写入一般都是依托在可写流上的。对于Console对象，它的内部属性_stdout和_stderr就是指向我们传入的两个输入流对象的</p>\n<h6 id=\"监控报警\"><a href=\"#监控报警\" class=\"headerlink\" title=\"监控报警\"></a>监控报警</h6><p><em>监控</em><br>监控的主要目的是为了将一些重要指标采样记录下来，一旦这些指标发生较大变化，可以配合报警系统将问题反馈到负责人那</p>\n<ul>\n<li>日志监控<br>业务逻辑型的监控主要体现在日志上,除了异常日志的监控外，对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布</li>\n<li>响应时间<br>响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长<br>健康的系统响应时间应该是波动较小的、持续均衡的</li>\n<li>进程监控<br>监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。</li>\n<li>磁盘监控<br>磁盘监控主要是监控磁盘的用量。<br>给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了</li>\n<li>内存监控<br>如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落<br>如果进程中存在内存泄漏，又一时没有排查解决，有一种方案可以解决这种状况。这种方案应用于多进程架构的服务集群，让每个工作进程指定服务多少次请求，达到请求数之后进程就不再服务新的连接，主进程启动新的工作进程来服务客户，旧的进程等所有连接断开后就退出。这样即使存在内存泄漏的风险，也能有效地规避内存泄漏带来的影响</li>\n<li>CPU占用监控<br>服务器的CPU占用监控也是必不可少的项，CPU的使用分为用户态、内核态、IOWait等<br>CPU的使用率中，用户态小于70%、内核态小于35%且整体小于70%时，处于健康状态</li>\n<li>CPU load监控<br>CPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载</li>\n<li>I/O负载<br>I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库</li>\n<li>网络监控<br>网络流量监控的两个主要指标是流入流量和流出流量</li>\n<li>应用状态监控<br>除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用的反馈接口来检查它的健康状态</li>\n<li>DNS监控<br>DNS是网络应用的基础，在实际的对外服务产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控</li>\n</ul>\n<p><em>报警的实现</em><br>搭配监控系统的则是报警系统，空有监控而没有通知功能，故障也是无法及时反馈给开发者的。如今的报警已经能够多样化，- 邮件报警、IM报警适合在线工作状态</p>\n<ul>\n<li>短信或电话报警适合非在线状态</li>\n</ul>\n<p>邮件报警: 如果报警系统由Node编写，可以调用nodemailer模块来实现邮件的发送</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nodemailer = require(&quot;nodemailer&quot;); </span><br><span class=\"line\">// 建立一个SMTP传输连接</span><br><span class=\"line\">var smtpTransport = nodemailer.createTransport(&quot;SMTP&quot;, &#123; </span><br><span class=\"line\"> service: &quot;Gmail&quot;, </span><br><span class=\"line\"> auth: &#123; </span><br><span class=\"line\"> user: &quot;gmail.user@gmail.com&quot;, </span><br><span class=\"line\"> pass: &quot;userpass&quot; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">// 邮件选项</span><br><span class=\"line\">var mailOptions = &#123; </span><br><span class=\"line\"> from: &quot;Fred Foo ✔ &lt;foo@bar.com&gt;&quot;, // 发件人邮件地址</span><br><span class=\"line\"> to: &quot;bar@bar.com, baz@bar.com&quot;, // 收件人邮件地址列表</span><br><span class=\"line\"> subject: &quot;Hello ✔&quot;, // 标题</span><br><span class=\"line\"> text: &quot;Hello world ✔&quot;, // 纯文本内容</span><br><span class=\"line\"> html: &quot;&lt;b&gt;Hello world ✔&lt;/b&gt;&quot; // HTML内容</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// 发送邮件</span><br><span class=\"line\">smtpTransport.sendMail(mailOptions, function (err, response) &#123; </span><br><span class=\"line\"> if (err) &#123; </span><br><span class=\"line\"> console.log(err); </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> console.log(&quot;Message sent: &quot; + response.message); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>短信或电话报警。一些短信服务平台提供短信接入服务，可以在监控系统中接入此类服务时，一旦线上出现到达阈值的异常时，就将信息发送给应用相关的责任人。</p>\n<h6 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h6><ul>\n<li>多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性等问题。<br><img src=\"/nodejs/images/product-1.png\" alt=\"负载均衡\"></li>\n<li>多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟等问题。在容灾方面，机房与机房之间可以互为备份</li>\n<li>容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务</li>\n</ul>\n"},{"title":"深入浅出nodejs阅读笔记(4)","date":"2022-12-25T11:56:24.000Z","tags":["node","docs"],"_content":"\n#### 构建Web应用\n\n###### cookie\n告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：\nSet-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; \n其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项:\n- path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。\n- Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。\n- HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。\n- Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到\n\n在YSlow的性能优化规则:\n- 减小Cookie的大小\n- 为静态组件使用不同的域名\n- 减少DNS查询\n\n###### Session\nSession的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递\n\n常见的两种实现方式:\n- 基于Cookie来实现用户和数据的映射\n一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间\n```\nvar sessions = {}; \nvar key = 'session_id'; \nvar EXPIRES = 20 * 60 * 1000; \nvar generate = function () { \n var session = {}; \n session.id = (new Date()).getTime() + Math.random(); \n session.cookie = { \n expire: (new Date()).getTime() + EXPIRES \n }; \n sessions[session.id] = session; \n return session; \n}; \n```\n- 通过查询字符串来实现浏览器端和服务器端数据的对应\n\n采用高速缓存的理由有以下几条:\n- Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。\n- 高速缓存直接在内存中进行数据存储和访问。\n- 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。\n\n###### 缓存\n关于缓存的规则：\n- 添加Expires 或Cache-Control 到报文头中。\n- 配置 ETags。\n- 让Ajax 可缓存\n\n![缓存](./images/cache.png)\n\n时间戳有一些缺陷存在:\n- 文件的时间戳改动但内容并不一定改动。\n- 时间戳只能精确到秒级别，更新频繁的内容将无法生效\n\nETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。\nETag的请求和响应是If-None-Match/ETag\n```\nvar handle = function (req, res) { \n fs.readFile(filename, function(err, file) { \n var hash = getHash(file); \n var noneMatch = req.headers['if-none-match']; \n if (hash === noneMatch) { \n res.writeHead(304, \"Not Modified\"); \n res.end(); \n } else { \n res.setHeader(\"ETag\", hash); \n res.writeHead(200, \"Ok\"); \n res.end(file); \n } \n }); \n}; \n```\n\nHTTP1.0时，在服务器端设置Expires可以告知浏览器要缓存文件内容，如下代码所示:\n```\nvar handle = function (req, res) { \n fs.readFile(filename, function(err, file) { \n var expires = new Date(); \n expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000); \n res.setHeader(\"Expires\", expires.toUTCString()); \n res.writeHead(200, \"Ok\"); \n res.end(file); \n }); \n}; \n```\nExpires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求\n\nExpires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。在这种情况下，Cache-Control以更丰富的形式，实现相同的功能，如下所示：\n```\nvar handle = function (req, res) { \n fs.readFile(filename, function(err, file) { \n res.setHeader(\"Cache-Control\", \"max-age=\" + 10 * 365 * 24 * 60 * 60 * 1000); \n res.writeHead(200, \"Ok\"); \n res.end(file); \n }); \n};\n```\nCache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项\n\n由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。\n\n一般的更新机制有如下两种:\n- 每次发布，路径中跟随Web应用的版本号：http://url.com/?v=20130501。\n- 每次发布，路径中跟随该文件内容的hash值：http://url.com/?hash=afadfadwe\n\n###### Basic认证\n一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它\n\n###### 数据上传\n如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。\n通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示：\n```\nvar hasBody = function(req) { \n return 'transfer-encoding' in req.headers || 'content-length' in req.headers; \n}; \n```\n在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示：\n```\nfunction (req, res) { \n if (hasBody(req)) { \n var buffers = []; \n req.on('data', function (chunk) { \n buffers.push(chunk); \n }); \n req.on('end', function () { \n req.rawBody = Buffer.concat(buffers).toString(); \n handle(req, res); \n }); \n } else { \n handle(req, res); \n } \n} \n```\n将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处\n\n获取数据\n```\nvar handle = function (req, res) { \n if (req.headers['content-type'] === 'application/x-www-form-urlencoded') { \n req.body = querystring.parse(req.rawBody); \n } \n todo(req, res); \n}; \n\n\nvar mime = function (req) { \n var str = req.headers['content-type'] || ''; \n return str.split(';')[0]; \n};\n\nvar handle = function (req, res) { \n if (mime(req) === 'application/json') { \n try { \n req.body = JSON.parse(req.rawBody); \n } catch (e) { \n // 异常内容，响应Bad request \n res.writeHead(400); \n res.end('Invalid JSON'); \n return; \n } \n } \n todo(req, res); \n}; \n```\n\n解析XML文件稍微复杂一点，建议使用支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示：\n```\nvar xml2js = require('xml2js'); \nvar handle = function (req, res) { \n if (mime(req) === 'application/xml') { \n xml2js.parseString(req.rawBody, function (err, xml) { \n if (err) { \n // 异常内容，响应Bad request \n res.writeHead(400); \n res.end('Invalid XML'); \n return; \n } \n req.body = xml; \n todo(req, res); \n }); \n } \n};\n```\n\n*附件上传*\n\n```\nfunction (req, res) { \n if (hasBody(req)) { \n var done = function () { \n handle(req, res); \n }; \n if (mime(req) === 'application/json') { \n parseJSON(req, done); \n } else if (mime(req) === 'application/xml') { \n parseXML(req, done); \n } else if (mime(req) === 'multipart/form-data') { \n parseMultipart(req, done); \n } \n } else { \n handle(req, res); \n } \n} \n```\n\nformidable基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示：\n```\nvar formidable = require('formidable'); \nfunction (req, res) { \n if (hasBody(req)) { \n if (mime(req) === 'multipart/form-data') { \n var form = new formidable.IncomingForm(); \n form.parse(req, function(err, fields, files) { \n req.body = fields; \n req.files = files; \n handle(req, res); \n }); \n } \n } else { \n handle(req, res); \n } \n} \n```\n\n###### 数据上传与安全\n内存限制\n主要有两个方案。\n- 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。\n- 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据\n\n```\nvar bytes = 1024; \nfunction (req, res) { \n var received = 0, \n var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null; \n // 如果内容超过长度限制，返回请求实体过长的状态码\n if (len && len > bytes) { \n res.writeHead(413); \n res.end(); \n return; \n }\n  // limit \n req.on('data', function (chunk) { \n received += chunk.length; \n if (received > bytes) { \n // 停止接收数据，触发end() \n req.destroy(); \n } \n }); \n handle(req, res); \n}; \n```\n\nCSRF \nCSRF的全称是Cross-Site Request Forgery，中文意思为跨站请求伪造。\n\n解决CSRF攻击的方案有添加随机值的方式，如下所示：\n```\nvar generateRandom = function(len) { \n return crypto.randomBytes(Math.ceil(len * 3 / 4)) \n .toString('base64') \n .slice(0, len); \n};\n```\n\n###### 路由解析\n文件路径型\n- 静态文件\n- 动态文件\n\nMVC\nMVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。\n- 控制器（Controller），一组行为的集合。\n- 模型（Model），数据相关的操作和封装。\n- 视图（View），视图的渲染。\n\n![MVC](./images/mvc.png)\n这是目前最为经典的分层模式，大致而言，它的工作模式如下说明。\n- 路由解析，根据URL寻找到对应的控制器和行为。\n- 行为调用相关的模型，进行数据操作。\n- 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。\n\n如何根据URL做路由映射，这里有两个分支实现。\n一种方式是通过手工关联映射\n一种是自然关联映射\n前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件\n\n手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。\n- 正则匹配\n- 参数解析\n\n自然映射这种路由方式在PHP的MVC框架CodeIgniter中应用十分广泛，设计十分简洁，在Node中实现它也十分容易。与手工映射相比，如果URL变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。\n\n*RESTful*\nREST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上\n\nRESTful与MVC设计并不冲突，而且是更好的改进。相比MVC，RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化\n\n###### 中间件\n![中间件](./images/middle.png)\n\n*异常处理*\n```\nvar handle = function (req, res, stack) { \n var next = function (err) { \n if (err) { \n return handle500(err, req, res, stack); \n } \n // 从stack数组中取出中间件并执行\n var middleware = stack.shift(); \n if (middleware) { \n // 传入next()函数自身，使中间件能够执行结束后递归\n try { \n middleware(req, res, next); \n } catch (ex) { \n next(err); \n } \n } \n }; \n // 启动执行\n next(); \n}; \n```\n\n*中间件与性能*\n编写高效的中间件\n- 使用高效的方法。必要时通过jsperf.com测试基准性能。\n- 缓存需要重复计算的结果（需要控制缓存用量）。\n- 避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。\n\n合理使用路由\n\n###### 页面渲染\n*内容响应*\n- MIME: 浏览器正是通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值\nMIME的全称是Multipurpose Internet Mail Extensions，从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的MIME值，如JSON文件的值为application/json、XML文件的值为application/xml、PDF文件的值为application/pdf。\n为了方便获知文件的MIME值，社区有专有的mime模块可以用判段文件类型。它的调用十分简单，如下所示：\n```\nvar mime = require('mime'); \nmime.lookup('/path/to/file.txt'); // => 'text/plain' \nmime.lookup('file.txt'); // => 'text/plain' \nmime.lookup('.TXT'); // => 'text/plain' \nmime.lookup('htm'); // => 'text/html' \n```\n除了MIME值外，Content-Type的值中还可以包含一些参数，如字符集。示例如下：\nContent-Type: text/javascript; charset=utf-8 \n- 附件下载\nContent-Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名\n- 响应JSON\n- 响应跳转\n\n*视图渲染*\n集成文件系统\n```\nvar cache = {}; \nvar VIEW_FOLDER = '/path/to/wwwroot/views'; \nres.render = function (viewname, data) { \n if (!cache[viewname]) { \n var text; \n try { \n text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), 'utf8'); \n } catch (e) { \n  res.writeHead(500, {'Content-Type': 'text/html'}); \n res.end('模板文件错误'); \n return; \n } \n cache[viewname] = complie(text); \n } \n var complied = cache[viewname]; \n res.writeHead(200, {'Content-Type': 'text/html'}); \n var html = complied(data); \n res.end(html); \n};\n```\n\n**Bigpipe**\nBigpipe的解决思路则是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。\n\nBigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。\n- 页面布局框架（无数据的）。\n- 后端持续性的数据输出。\n- 前端渲染\n![bigpipe](./images/bigpipe.png)\n```\nvar cache = {}; \nvar layout = 'layout.html'; \napp.get('/profile', function (req, res) { \n if (!cache[layout]) { \n cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); \n } \n res.writeHead(200, {'Content-Type': 'text/html'}); \n res.write(render(complie(cache[layout]))); \n // TODO \n}); \n\n\napp.get('/profile', function (req, res) { \n if (!cache[layout]) { \n cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); \n } \n res.writeHead(200, {'Content-Type': 'text/html'}); \n res.write(render(complie(cache[layout]))); \n ep.all('users', 'articles', function () { \n res.end(); \n }); \n ep.fail(function (err) { \n res.end(); \n }); \n db.getData('sql1', function (err, data) { \n data = err ? {} : data; \n res.write('<script>bigpipe.set(\"articles\", ' + JSON.stringify(data) + ');</script>'; \n }); \n db.getData('sql2', function (err, data) { \n data = err ? {} : data; \n res.write('<script>bigpipe.set(\"copyright\", ' + JSON.stringify(data) + ');</script>'; \n }); \n});\n\n\nvar Bigpipe = function () { \n this.callbacks = {}; \n}; \nBigpipe.prototype.ready = function (key, callback) { \n if (!this.callbacks[key]) { \n this.callbacks[key] = []; \n } \n this.callbacks[key].push(callback); \n}; \nBigpipe.prototype.set = function (key, data) { \n var callbacks = this.callbacks[key] || []; \n for (var i = 0; i < callbacks.length; i++) { \n callbacks[i].call(this, data); \n } \n};\n```\nBigpipe将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好了，其随着数据输出的过程逐步渲染页面，使得用户能够感知到页面是活的。这远比一开始给出空白页面，然后在某个时候突然渲染好带给用户的体验更好\n\n#### 玩转进程\n\n###### 服务模型的变迁\n*石器时代：同步*\n最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。\n它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N\n\n*青铜时代：复制进程*\n为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。\n为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽\n假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N\n\n*白银时代：多线程*\n为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。\n如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。\n\n*黄金时代：事件驱动*\n基于事件的服务模型存在的两个问题：CPU的利用率和进程的健壮性\n\n###### 多进程架构\n面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。\n```\n// worker.js\nvar http = require('http'); \nhttp.createServer(function (req, res) { \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('Hello World\\n'); \n}).listen(Math.round((1 + Math.random()) * 1000), '127.0.0.1'); \n\nvar fork = require('child_process').fork; \nvar cpus = require('os').cpus(); \nfor (var i = 0; i < cpus.length; i++) { \n fork('./worker.js'); \n} \n```\n![主从模式](./images/master-slave.png)\nMaster-Worker模式，又称主从模式。进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。\n\n*通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10 MB的内存。尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然要切记fork()进程是昂贵的*\n\n*创建子进程*\nchild_process模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。\n- spawn()：启动一个子进程来执行命令。\n- exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函\n数获知子进程的状况。\n- execFile()：启动一个子进程来执行可执行文件。\n- fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文\n件模块即可。\nspawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。\nexec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件\n\n```\nvar cp = require('child_process'); \ncp.spawn('node', ['worker.js']); \ncp.exec('node worker.js', function (err, stdout, stderr) { \n // some code \n}); \ncp.execFile('worker.js', function (err, stdout, stderr) { \n // some code \n}); \ncp.fork('./worker.js');\n```\n![fork](./images/fork.png)\n\n*进程间通信*\n通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息\n- 进程间通信原理\nIPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术\n![pipe](./images/pipe.png)\n父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接\n![pipe](./images/pipe-1.png)\n\n*句柄传递*\n通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。\n\nchild.send(message, [sendHandle]) \n句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等\n```\nvar child = require('child_process').fork('child.js'); \n// Open up the server object and send the handle \nvar server = require('net').createServer(); \nserver.on('connection', function (socket) { \n socket.end('handled by parent\\n'); \n}); \nserver.listen(1337, function () { \n child.send('server', server); \n}); \n\nprocess.on('message', function (m, server) { \n if (m === 'server') { \n server.on('connection', function (socket) { \n socket.end('handled by child\\n'); \n }); \n } \n});\n```\n![pipe](./images/pipe-2.png)\n主进程发送完句柄并关闭监听之后\n![pipe](./images/pipe-3.png)\n\n句柄发送与还原\n目前子进程对象send()方法可以发送的句柄类型包括如下几种。\n- net.Socket。TCP套接字。\n- net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。\n- net.Native。C++层面的TCP套接字或IPC管道。\n- dgram.Socket。UDP套接字。\n- dgram.Native。C++层面的UDP套接字。\nsend()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示：\n{ \n cmd: 'NODE_HANDLE', \n type: 'net.Server', \n msg: message \n} \n\n连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。\n![pipe](./images/pipe-4.png)\n\nNode进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果\n\n端口共同监听\n多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的\n\n###### 集群稳定之路\n\n*进程事件*\n除了message事件外，Node还有如下这些事件。\n- error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。\n- exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。\n- close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。\n- disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。\n\n在命令行中执行kill -l可以看到详细的信号列表\n\n*自动重启*\n```\n// master.js \nvar fork = require('child_process').fork; \nvar cpus = require('os').cpus(); \nvar server = require('net').createServer(); \nserver.listen(1337); \nvar workers = {}; \nvar createWorker = function () { \n var worker = fork(__dirname + '/worker.js'); \n // 退出时重新启动新的进程\n worker.on('exit', function () { \n console.log('Worker ' + worker.pid + ' exited.'); \n delete workers[worker.pid]; \n createWorker(); \n }); \n // 句柄转发\n worker.send('server', server); \n workers[worker.pid] = worker; \n console.log('Create worker. pid: ' + worker.pid); \n}; \nfor (var i = 0; i < cpus.length; i++) { \n createWorker(); \n} \n// 进程自己退出时，让所有工作进程退出\nprocess.on('exit', function () { \n for (var pid in workers) { \n workers[pid].kill(); \n } \n});\n\n// worker.js \nvar http = require('http'); \nvar server = http.createServer(function (req, res) { \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('handled by child, pid is ' + process.pid + '\\n'); \n}); \nvar worker; \nprocess.on('message', function (m, tcp) { \n if (m === 'server') { \n worker = tcp; \n worker.on('connection', function (socket) { \n  server.emit('connection', socket); \n }); \n } \n}); \nprocess.on('uncaughtException', function () { \n // 停止接收新的连接\n worker.close(function () { \n // 所有已有连接断开后，退出进程\n process.exit(1); \n }); \n}); \n```\n*限量重启*\n```\n// 重启次数\nvar limit = 10; \n// 时间单位\nvar during = 60000; \nvar restart = []; \nvar isTooFrequently = function () { \n // 记录重启时间\n var time = Date.now(); \n var length = restart.push(time); \n if (length > limit) { \n // 取出最后10个记录\n restart = restart.slice(limit * -1); \n } \n // 最后一次重启到前10次重启之间的时间间隔\n return restart.length >= limit && restart[restart.length - 1] - restart[0] < during; \n}; \nvar workers = {}; \nvar createWorker = function () { \n // 检查是否太过频繁\n if (isTooFrequently()) { \n // 触发giveup事件后，不再重启\n process.emit('giveup', length, during); \n return; \n } \n var worker = fork(__dirname + '/worker.js'); \n worker.on('exit', function () { \n console.log('Worker ' + worker.pid + ' exited.'); \n delete workers[worker.pid]; \n }); \n // 重新启动新的进程\n worker.on('message', function (message) { \n if (message.act === 'suicide') { \n createWorker(); \n } \n }); \n // 句柄转发\n worker.send('server', server); \n workers[worker.pid] = worker; \n console.log('Create worker. pid: ' + worker.pid); \n}; \n```\n\n*负载均衡*\n在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来,这种保证多个处理单元工作量公平的策略叫负载均衡\n\nNode默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务\n\n对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况\n\n为 此 Node在 v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接\n\n*状态共享*\n- 第三方数据存储\n这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。\n实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询\n定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟\n![轮询](./images/loop.png)\n- 主动通知\n一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。\n![轮询](./images/loop-1.png)\n这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程\n\n###### Cluster 模块\n```\n// cluster.js \nvar cluster = require('cluster'); \ncluster.setupMaster({ \n exec: \"worker.js\" \n}); \nvar cpus = require('os').cpus(); \nfor (var i = 0; i < cpus.length; i++) { \n cluster.fork(); \n} \n\nvar cluster = require('cluster'); \nvar http = require('http'); \nvar numCPUs = require('os').cpus().length; \nif (cluster.isMaster) { \n // Fork workers \n for (var i = 0; i < numCPUs; i++) { \n cluster.fork(); \n } \n cluster.on('exit', function(worker, code, signal) { \n console.log('worker ' + worker.process.pid + ' died'); \n }); \n} else { \n // Workers can share any TCP connection \n // In this case its a HTTP server \n http.createServer(function(req, res) { \n res.writeHead(200); \n res.end(\"hello world\\n\"); \n }).listen(8000); \n}\n```\n\n在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID\n```\ncluster.isWorker = ('NODE_UNIQUE_ID' in process.env); \ncluster.isMaster = (cluster.isWorker === false); \n```\n官方示例中忽而判断cluster.isMaster、忽而判断cluster.isWorker，对于代码的可读性十分差。建议用cluster.setupMaster()这个API，将主进程和工作进程从代码上完全剥离\n\n通过cluster.setupMaster()创建子进程而不是使用cluster.fork()\n\n*Cluster 工作原理*\n事实上cluster模块就是child_process和net模块的组合应用\n\n*Cluster 事件*\n- fork：复制一个工作进程后触发该事件。\n- online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。\n- listening：工作进程中调用listen()（共享了服务器端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件。\n- disconnect：主进程和工作进程之间IPC通道断开后会触发该事件。\n- exit：有工作进程退出时触发该事件。\n- setup：cluster.setupMaster()执行后触发该事件","source":"nodejs/nodejs-note-4.md","raw":"---\ntitle: 深入浅出nodejs阅读笔记(4)\ndate: 2022-12-25 19:56:24\ntags: [node, docs]\n---\n\n#### 构建Web应用\n\n###### cookie\n告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：\nSet-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; \n其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项:\n- path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。\n- Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。\n- HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。\n- Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到\n\n在YSlow的性能优化规则:\n- 减小Cookie的大小\n- 为静态组件使用不同的域名\n- 减少DNS查询\n\n###### Session\nSession的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递\n\n常见的两种实现方式:\n- 基于Cookie来实现用户和数据的映射\n一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间\n```\nvar sessions = {}; \nvar key = 'session_id'; \nvar EXPIRES = 20 * 60 * 1000; \nvar generate = function () { \n var session = {}; \n session.id = (new Date()).getTime() + Math.random(); \n session.cookie = { \n expire: (new Date()).getTime() + EXPIRES \n }; \n sessions[session.id] = session; \n return session; \n}; \n```\n- 通过查询字符串来实现浏览器端和服务器端数据的对应\n\n采用高速缓存的理由有以下几条:\n- Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。\n- 高速缓存直接在内存中进行数据存储和访问。\n- 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。\n\n###### 缓存\n关于缓存的规则：\n- 添加Expires 或Cache-Control 到报文头中。\n- 配置 ETags。\n- 让Ajax 可缓存\n\n![缓存](./images/cache.png)\n\n时间戳有一些缺陷存在:\n- 文件的时间戳改动但内容并不一定改动。\n- 时间戳只能精确到秒级别，更新频繁的内容将无法生效\n\nETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。\nETag的请求和响应是If-None-Match/ETag\n```\nvar handle = function (req, res) { \n fs.readFile(filename, function(err, file) { \n var hash = getHash(file); \n var noneMatch = req.headers['if-none-match']; \n if (hash === noneMatch) { \n res.writeHead(304, \"Not Modified\"); \n res.end(); \n } else { \n res.setHeader(\"ETag\", hash); \n res.writeHead(200, \"Ok\"); \n res.end(file); \n } \n }); \n}; \n```\n\nHTTP1.0时，在服务器端设置Expires可以告知浏览器要缓存文件内容，如下代码所示:\n```\nvar handle = function (req, res) { \n fs.readFile(filename, function(err, file) { \n var expires = new Date(); \n expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000); \n res.setHeader(\"Expires\", expires.toUTCString()); \n res.writeHead(200, \"Ok\"); \n res.end(file); \n }); \n}; \n```\nExpires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求\n\nExpires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。在这种情况下，Cache-Control以更丰富的形式，实现相同的功能，如下所示：\n```\nvar handle = function (req, res) { \n fs.readFile(filename, function(err, file) { \n res.setHeader(\"Cache-Control\", \"max-age=\" + 10 * 365 * 24 * 60 * 60 * 1000); \n res.writeHead(200, \"Ok\"); \n res.end(file); \n }); \n};\n```\nCache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项\n\n由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。\n\n一般的更新机制有如下两种:\n- 每次发布，路径中跟随Web应用的版本号：http://url.com/?v=20130501。\n- 每次发布，路径中跟随该文件内容的hash值：http://url.com/?hash=afadfadwe\n\n###### Basic认证\n一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它\n\n###### 数据上传\n如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。\n通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示：\n```\nvar hasBody = function(req) { \n return 'transfer-encoding' in req.headers || 'content-length' in req.headers; \n}; \n```\n在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示：\n```\nfunction (req, res) { \n if (hasBody(req)) { \n var buffers = []; \n req.on('data', function (chunk) { \n buffers.push(chunk); \n }); \n req.on('end', function () { \n req.rawBody = Buffer.concat(buffers).toString(); \n handle(req, res); \n }); \n } else { \n handle(req, res); \n } \n} \n```\n将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处\n\n获取数据\n```\nvar handle = function (req, res) { \n if (req.headers['content-type'] === 'application/x-www-form-urlencoded') { \n req.body = querystring.parse(req.rawBody); \n } \n todo(req, res); \n}; \n\n\nvar mime = function (req) { \n var str = req.headers['content-type'] || ''; \n return str.split(';')[0]; \n};\n\nvar handle = function (req, res) { \n if (mime(req) === 'application/json') { \n try { \n req.body = JSON.parse(req.rawBody); \n } catch (e) { \n // 异常内容，响应Bad request \n res.writeHead(400); \n res.end('Invalid JSON'); \n return; \n } \n } \n todo(req, res); \n}; \n```\n\n解析XML文件稍微复杂一点，建议使用支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示：\n```\nvar xml2js = require('xml2js'); \nvar handle = function (req, res) { \n if (mime(req) === 'application/xml') { \n xml2js.parseString(req.rawBody, function (err, xml) { \n if (err) { \n // 异常内容，响应Bad request \n res.writeHead(400); \n res.end('Invalid XML'); \n return; \n } \n req.body = xml; \n todo(req, res); \n }); \n } \n};\n```\n\n*附件上传*\n\n```\nfunction (req, res) { \n if (hasBody(req)) { \n var done = function () { \n handle(req, res); \n }; \n if (mime(req) === 'application/json') { \n parseJSON(req, done); \n } else if (mime(req) === 'application/xml') { \n parseXML(req, done); \n } else if (mime(req) === 'multipart/form-data') { \n parseMultipart(req, done); \n } \n } else { \n handle(req, res); \n } \n} \n```\n\nformidable基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示：\n```\nvar formidable = require('formidable'); \nfunction (req, res) { \n if (hasBody(req)) { \n if (mime(req) === 'multipart/form-data') { \n var form = new formidable.IncomingForm(); \n form.parse(req, function(err, fields, files) { \n req.body = fields; \n req.files = files; \n handle(req, res); \n }); \n } \n } else { \n handle(req, res); \n } \n} \n```\n\n###### 数据上传与安全\n内存限制\n主要有两个方案。\n- 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。\n- 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据\n\n```\nvar bytes = 1024; \nfunction (req, res) { \n var received = 0, \n var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null; \n // 如果内容超过长度限制，返回请求实体过长的状态码\n if (len && len > bytes) { \n res.writeHead(413); \n res.end(); \n return; \n }\n  // limit \n req.on('data', function (chunk) { \n received += chunk.length; \n if (received > bytes) { \n // 停止接收数据，触发end() \n req.destroy(); \n } \n }); \n handle(req, res); \n}; \n```\n\nCSRF \nCSRF的全称是Cross-Site Request Forgery，中文意思为跨站请求伪造。\n\n解决CSRF攻击的方案有添加随机值的方式，如下所示：\n```\nvar generateRandom = function(len) { \n return crypto.randomBytes(Math.ceil(len * 3 / 4)) \n .toString('base64') \n .slice(0, len); \n};\n```\n\n###### 路由解析\n文件路径型\n- 静态文件\n- 动态文件\n\nMVC\nMVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。\n- 控制器（Controller），一组行为的集合。\n- 模型（Model），数据相关的操作和封装。\n- 视图（View），视图的渲染。\n\n![MVC](./images/mvc.png)\n这是目前最为经典的分层模式，大致而言，它的工作模式如下说明。\n- 路由解析，根据URL寻找到对应的控制器和行为。\n- 行为调用相关的模型，进行数据操作。\n- 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。\n\n如何根据URL做路由映射，这里有两个分支实现。\n一种方式是通过手工关联映射\n一种是自然关联映射\n前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件\n\n手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。\n- 正则匹配\n- 参数解析\n\n自然映射这种路由方式在PHP的MVC框架CodeIgniter中应用十分广泛，设计十分简洁，在Node中实现它也十分容易。与手工映射相比，如果URL变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。\n\n*RESTful*\nREST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上\n\nRESTful与MVC设计并不冲突，而且是更好的改进。相比MVC，RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化\n\n###### 中间件\n![中间件](./images/middle.png)\n\n*异常处理*\n```\nvar handle = function (req, res, stack) { \n var next = function (err) { \n if (err) { \n return handle500(err, req, res, stack); \n } \n // 从stack数组中取出中间件并执行\n var middleware = stack.shift(); \n if (middleware) { \n // 传入next()函数自身，使中间件能够执行结束后递归\n try { \n middleware(req, res, next); \n } catch (ex) { \n next(err); \n } \n } \n }; \n // 启动执行\n next(); \n}; \n```\n\n*中间件与性能*\n编写高效的中间件\n- 使用高效的方法。必要时通过jsperf.com测试基准性能。\n- 缓存需要重复计算的结果（需要控制缓存用量）。\n- 避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。\n\n合理使用路由\n\n###### 页面渲染\n*内容响应*\n- MIME: 浏览器正是通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值\nMIME的全称是Multipurpose Internet Mail Extensions，从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的MIME值，如JSON文件的值为application/json、XML文件的值为application/xml、PDF文件的值为application/pdf。\n为了方便获知文件的MIME值，社区有专有的mime模块可以用判段文件类型。它的调用十分简单，如下所示：\n```\nvar mime = require('mime'); \nmime.lookup('/path/to/file.txt'); // => 'text/plain' \nmime.lookup('file.txt'); // => 'text/plain' \nmime.lookup('.TXT'); // => 'text/plain' \nmime.lookup('htm'); // => 'text/html' \n```\n除了MIME值外，Content-Type的值中还可以包含一些参数，如字符集。示例如下：\nContent-Type: text/javascript; charset=utf-8 \n- 附件下载\nContent-Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名\n- 响应JSON\n- 响应跳转\n\n*视图渲染*\n集成文件系统\n```\nvar cache = {}; \nvar VIEW_FOLDER = '/path/to/wwwroot/views'; \nres.render = function (viewname, data) { \n if (!cache[viewname]) { \n var text; \n try { \n text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), 'utf8'); \n } catch (e) { \n  res.writeHead(500, {'Content-Type': 'text/html'}); \n res.end('模板文件错误'); \n return; \n } \n cache[viewname] = complie(text); \n } \n var complied = cache[viewname]; \n res.writeHead(200, {'Content-Type': 'text/html'}); \n var html = complied(data); \n res.end(html); \n};\n```\n\n**Bigpipe**\nBigpipe的解决思路则是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。\n\nBigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。\n- 页面布局框架（无数据的）。\n- 后端持续性的数据输出。\n- 前端渲染\n![bigpipe](./images/bigpipe.png)\n```\nvar cache = {}; \nvar layout = 'layout.html'; \napp.get('/profile', function (req, res) { \n if (!cache[layout]) { \n cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); \n } \n res.writeHead(200, {'Content-Type': 'text/html'}); \n res.write(render(complie(cache[layout]))); \n // TODO \n}); \n\n\napp.get('/profile', function (req, res) { \n if (!cache[layout]) { \n cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); \n } \n res.writeHead(200, {'Content-Type': 'text/html'}); \n res.write(render(complie(cache[layout]))); \n ep.all('users', 'articles', function () { \n res.end(); \n }); \n ep.fail(function (err) { \n res.end(); \n }); \n db.getData('sql1', function (err, data) { \n data = err ? {} : data; \n res.write('<script>bigpipe.set(\"articles\", ' + JSON.stringify(data) + ');</script>'; \n }); \n db.getData('sql2', function (err, data) { \n data = err ? {} : data; \n res.write('<script>bigpipe.set(\"copyright\", ' + JSON.stringify(data) + ');</script>'; \n }); \n});\n\n\nvar Bigpipe = function () { \n this.callbacks = {}; \n}; \nBigpipe.prototype.ready = function (key, callback) { \n if (!this.callbacks[key]) { \n this.callbacks[key] = []; \n } \n this.callbacks[key].push(callback); \n}; \nBigpipe.prototype.set = function (key, data) { \n var callbacks = this.callbacks[key] || []; \n for (var i = 0; i < callbacks.length; i++) { \n callbacks[i].call(this, data); \n } \n};\n```\nBigpipe将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好了，其随着数据输出的过程逐步渲染页面，使得用户能够感知到页面是活的。这远比一开始给出空白页面，然后在某个时候突然渲染好带给用户的体验更好\n\n#### 玩转进程\n\n###### 服务模型的变迁\n*石器时代：同步*\n最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。\n它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N\n\n*青铜时代：复制进程*\n为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。\n为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽\n假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N\n\n*白银时代：多线程*\n为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。\n如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。\n\n*黄金时代：事件驱动*\n基于事件的服务模型存在的两个问题：CPU的利用率和进程的健壮性\n\n###### 多进程架构\n面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。\n```\n// worker.js\nvar http = require('http'); \nhttp.createServer(function (req, res) { \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('Hello World\\n'); \n}).listen(Math.round((1 + Math.random()) * 1000), '127.0.0.1'); \n\nvar fork = require('child_process').fork; \nvar cpus = require('os').cpus(); \nfor (var i = 0; i < cpus.length; i++) { \n fork('./worker.js'); \n} \n```\n![主从模式](./images/master-slave.png)\nMaster-Worker模式，又称主从模式。进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。\n\n*通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10 MB的内存。尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然要切记fork()进程是昂贵的*\n\n*创建子进程*\nchild_process模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。\n- spawn()：启动一个子进程来执行命令。\n- exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函\n数获知子进程的状况。\n- execFile()：启动一个子进程来执行可执行文件。\n- fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文\n件模块即可。\nspawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。\nexec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件\n\n```\nvar cp = require('child_process'); \ncp.spawn('node', ['worker.js']); \ncp.exec('node worker.js', function (err, stdout, stderr) { \n // some code \n}); \ncp.execFile('worker.js', function (err, stdout, stderr) { \n // some code \n}); \ncp.fork('./worker.js');\n```\n![fork](./images/fork.png)\n\n*进程间通信*\n通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息\n- 进程间通信原理\nIPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术\n![pipe](./images/pipe.png)\n父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接\n![pipe](./images/pipe-1.png)\n\n*句柄传递*\n通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。\n\nchild.send(message, [sendHandle]) \n句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等\n```\nvar child = require('child_process').fork('child.js'); \n// Open up the server object and send the handle \nvar server = require('net').createServer(); \nserver.on('connection', function (socket) { \n socket.end('handled by parent\\n'); \n}); \nserver.listen(1337, function () { \n child.send('server', server); \n}); \n\nprocess.on('message', function (m, server) { \n if (m === 'server') { \n server.on('connection', function (socket) { \n socket.end('handled by child\\n'); \n }); \n } \n});\n```\n![pipe](./images/pipe-2.png)\n主进程发送完句柄并关闭监听之后\n![pipe](./images/pipe-3.png)\n\n句柄发送与还原\n目前子进程对象send()方法可以发送的句柄类型包括如下几种。\n- net.Socket。TCP套接字。\n- net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。\n- net.Native。C++层面的TCP套接字或IPC管道。\n- dgram.Socket。UDP套接字。\n- dgram.Native。C++层面的UDP套接字。\nsend()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示：\n{ \n cmd: 'NODE_HANDLE', \n type: 'net.Server', \n msg: message \n} \n\n连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。\n![pipe](./images/pipe-4.png)\n\nNode进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果\n\n端口共同监听\n多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的\n\n###### 集群稳定之路\n\n*进程事件*\n除了message事件外，Node还有如下这些事件。\n- error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。\n- exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。\n- close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。\n- disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。\n\n在命令行中执行kill -l可以看到详细的信号列表\n\n*自动重启*\n```\n// master.js \nvar fork = require('child_process').fork; \nvar cpus = require('os').cpus(); \nvar server = require('net').createServer(); \nserver.listen(1337); \nvar workers = {}; \nvar createWorker = function () { \n var worker = fork(__dirname + '/worker.js'); \n // 退出时重新启动新的进程\n worker.on('exit', function () { \n console.log('Worker ' + worker.pid + ' exited.'); \n delete workers[worker.pid]; \n createWorker(); \n }); \n // 句柄转发\n worker.send('server', server); \n workers[worker.pid] = worker; \n console.log('Create worker. pid: ' + worker.pid); \n}; \nfor (var i = 0; i < cpus.length; i++) { \n createWorker(); \n} \n// 进程自己退出时，让所有工作进程退出\nprocess.on('exit', function () { \n for (var pid in workers) { \n workers[pid].kill(); \n } \n});\n\n// worker.js \nvar http = require('http'); \nvar server = http.createServer(function (req, res) { \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('handled by child, pid is ' + process.pid + '\\n'); \n}); \nvar worker; \nprocess.on('message', function (m, tcp) { \n if (m === 'server') { \n worker = tcp; \n worker.on('connection', function (socket) { \n  server.emit('connection', socket); \n }); \n } \n}); \nprocess.on('uncaughtException', function () { \n // 停止接收新的连接\n worker.close(function () { \n // 所有已有连接断开后，退出进程\n process.exit(1); \n }); \n}); \n```\n*限量重启*\n```\n// 重启次数\nvar limit = 10; \n// 时间单位\nvar during = 60000; \nvar restart = []; \nvar isTooFrequently = function () { \n // 记录重启时间\n var time = Date.now(); \n var length = restart.push(time); \n if (length > limit) { \n // 取出最后10个记录\n restart = restart.slice(limit * -1); \n } \n // 最后一次重启到前10次重启之间的时间间隔\n return restart.length >= limit && restart[restart.length - 1] - restart[0] < during; \n}; \nvar workers = {}; \nvar createWorker = function () { \n // 检查是否太过频繁\n if (isTooFrequently()) { \n // 触发giveup事件后，不再重启\n process.emit('giveup', length, during); \n return; \n } \n var worker = fork(__dirname + '/worker.js'); \n worker.on('exit', function () { \n console.log('Worker ' + worker.pid + ' exited.'); \n delete workers[worker.pid]; \n }); \n // 重新启动新的进程\n worker.on('message', function (message) { \n if (message.act === 'suicide') { \n createWorker(); \n } \n }); \n // 句柄转发\n worker.send('server', server); \n workers[worker.pid] = worker; \n console.log('Create worker. pid: ' + worker.pid); \n}; \n```\n\n*负载均衡*\n在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来,这种保证多个处理单元工作量公平的策略叫负载均衡\n\nNode默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务\n\n对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况\n\n为 此 Node在 v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接\n\n*状态共享*\n- 第三方数据存储\n这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。\n实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询\n定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟\n![轮询](./images/loop.png)\n- 主动通知\n一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。\n![轮询](./images/loop-1.png)\n这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程\n\n###### Cluster 模块\n```\n// cluster.js \nvar cluster = require('cluster'); \ncluster.setupMaster({ \n exec: \"worker.js\" \n}); \nvar cpus = require('os').cpus(); \nfor (var i = 0; i < cpus.length; i++) { \n cluster.fork(); \n} \n\nvar cluster = require('cluster'); \nvar http = require('http'); \nvar numCPUs = require('os').cpus().length; \nif (cluster.isMaster) { \n // Fork workers \n for (var i = 0; i < numCPUs; i++) { \n cluster.fork(); \n } \n cluster.on('exit', function(worker, code, signal) { \n console.log('worker ' + worker.process.pid + ' died'); \n }); \n} else { \n // Workers can share any TCP connection \n // In this case its a HTTP server \n http.createServer(function(req, res) { \n res.writeHead(200); \n res.end(\"hello world\\n\"); \n }).listen(8000); \n}\n```\n\n在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID\n```\ncluster.isWorker = ('NODE_UNIQUE_ID' in process.env); \ncluster.isMaster = (cluster.isWorker === false); \n```\n官方示例中忽而判断cluster.isMaster、忽而判断cluster.isWorker，对于代码的可读性十分差。建议用cluster.setupMaster()这个API，将主进程和工作进程从代码上完全剥离\n\n通过cluster.setupMaster()创建子进程而不是使用cluster.fork()\n\n*Cluster 工作原理*\n事实上cluster模块就是child_process和net模块的组合应用\n\n*Cluster 事件*\n- fork：复制一个工作进程后触发该事件。\n- online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。\n- listening：工作进程中调用listen()（共享了服务器端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件。\n- disconnect：主进程和工作进程之间IPC通道断开后会触发该事件。\n- exit：有工作进程退出时触发该事件。\n- setup：cluster.setupMaster()执行后触发该事件","updated":"2022-12-28T01:46:56.926Z","path":"nodejs/nodejs-note-4.html","comments":1,"layout":"page","_id":"clchh4gwu000wckttdfkmh585","content":"<h4 id=\"构建Web应用\"><a href=\"#构建Web应用\" class=\"headerlink\" title=\"构建Web应用\"></a>构建Web应用</h4><h6 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h6><p>告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：<br>Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;<br>其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项:</p>\n<ul>\n<li>path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。</li>\n<li>Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。</li>\n<li>HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。</li>\n<li>Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到</li>\n</ul>\n<p>在YSlow的性能优化规则:</p>\n<ul>\n<li>减小Cookie的大小</li>\n<li>为静态组件使用不同的域名</li>\n<li>减少DNS查询</li>\n</ul>\n<h6 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h6><p>Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递</p>\n<p>常见的两种实现方式:</p>\n<ul>\n<li>基于Cookie来实现用户和数据的映射<br>一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sessions = &#123;&#125;; </span><br><span class=\"line\">var key = &#x27;session_id&#x27;; </span><br><span class=\"line\">var EXPIRES = 20 * 60 * 1000; </span><br><span class=\"line\">var generate = function () &#123; </span><br><span class=\"line\"> var session = &#123;&#125;; </span><br><span class=\"line\"> session.id = (new Date()).getTime() + Math.random(); </span><br><span class=\"line\"> session.cookie = &#123; </span><br><span class=\"line\"> expire: (new Date()).getTime() + EXPIRES </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> sessions[session.id] = session; </span><br><span class=\"line\"> return session; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure></li>\n<li>通过查询字符串来实现浏览器端和服务器端数据的对应</li>\n</ul>\n<p>采用高速缓存的理由有以下几条:</p>\n<ul>\n<li>Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。</li>\n<li>高速缓存直接在内存中进行数据存储和访问。</li>\n<li>缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。</li>\n</ul>\n<h6 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h6><p>关于缓存的规则：</p>\n<ul>\n<li>添加Expires 或Cache-Control 到报文头中。</li>\n<li>配置 ETags。</li>\n<li>让Ajax 可缓存</li>\n</ul>\n<p><img src=\"/nodejs/images/cache.png\" alt=\"缓存\"></p>\n<p>时间戳有一些缺陷存在:</p>\n<ul>\n<li>文件的时间戳改动但内容并不一定改动。</li>\n<li>时间戳只能精确到秒级别，更新频繁的内容将无法生效</li>\n</ul>\n<p>ETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。<br>ETag的请求和响应是If-None-Match/ETag</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> fs.readFile(filename, function(err, file) &#123; </span><br><span class=\"line\"> var hash = getHash(file); </span><br><span class=\"line\"> var noneMatch = req.headers[&#x27;if-none-match&#x27;]; </span><br><span class=\"line\"> if (hash === noneMatch) &#123; </span><br><span class=\"line\"> res.writeHead(304, &quot;Not Modified&quot;); </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> res.setHeader(&quot;ETag&quot;, hash); </span><br><span class=\"line\"> res.writeHead(200, &quot;Ok&quot;); </span><br><span class=\"line\"> res.end(file); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>HTTP1.0时，在服务器端设置Expires可以告知浏览器要缓存文件内容，如下代码所示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> fs.readFile(filename, function(err, file) &#123; </span><br><span class=\"line\"> var expires = new Date(); </span><br><span class=\"line\"> expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000); </span><br><span class=\"line\"> res.setHeader(&quot;Expires&quot;, expires.toUTCString()); </span><br><span class=\"line\"> res.writeHead(200, &quot;Ok&quot;); </span><br><span class=\"line\"> res.end(file); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>Expires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求</p>\n<p>Expires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。在这种情况下，Cache-Control以更丰富的形式，实现相同的功能，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> fs.readFile(filename, function(err, file) &#123; </span><br><span class=\"line\"> res.setHeader(&quot;Cache-Control&quot;, &quot;max-age=&quot; + 10 * 365 * 24 * 60 * 60 * 1000); </span><br><span class=\"line\"> res.writeHead(200, &quot;Ok&quot;); </span><br><span class=\"line\"> res.end(file); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项</p>\n<p>由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。</p>\n<p>一般的更新机制有如下两种:</p>\n<ul>\n<li>每次发布，路径中跟随Web应用的版本号：<a href=\"http://url.com/?v=20130501%E3%80%82\">http://url.com/?v=20130501。</a></li>\n<li>每次发布，路径中跟随该文件内容的hash值：<a href=\"http://url.com/?hash=afadfadwe\">http://url.com/?hash=afadfadwe</a></li>\n</ul>\n<h6 id=\"Basic认证\"><a href=\"#Basic认证\" class=\"headerlink\" title=\"Basic认证\"></a>Basic认证</h6><p>一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它</p>\n<h6 id=\"数据上传\"><a href=\"#数据上传\" class=\"headerlink\" title=\"数据上传\"></a>数据上传</h6><p>如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。<br>通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hasBody = function(req) &#123; </span><br><span class=\"line\"> return &#x27;transfer-encoding&#x27; in req.headers || &#x27;content-length&#x27; in req.headers; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> if (hasBody(req)) &#123; </span><br><span class=\"line\"> var buffers = []; </span><br><span class=\"line\"> req.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> buffers.push(chunk); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> req.on(&#x27;end&#x27;, function () &#123; </span><br><span class=\"line\"> req.rawBody = Buffer.concat(buffers).toString(); </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处</p>\n<p>获取数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> if (req.headers[&#x27;content-type&#x27;] === &#x27;application/x-www-form-urlencoded&#x27;) &#123; </span><br><span class=\"line\"> req.body = querystring.parse(req.rawBody); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> todo(req, res); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var mime = function (req) &#123; </span><br><span class=\"line\"> var str = req.headers[&#x27;content-type&#x27;] || &#x27;&#x27;; </span><br><span class=\"line\"> return str.split(&#x27;;&#x27;)[0]; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> if (mime(req) === &#x27;application/json&#x27;) &#123; </span><br><span class=\"line\"> try &#123; </span><br><span class=\"line\"> req.body = JSON.parse(req.rawBody); </span><br><span class=\"line\"> &#125; catch (e) &#123; </span><br><span class=\"line\"> // 异常内容，响应Bad request </span><br><span class=\"line\"> res.writeHead(400); </span><br><span class=\"line\"> res.end(&#x27;Invalid JSON&#x27;); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> todo(req, res); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>解析XML文件稍微复杂一点，建议使用支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xml2js = require(&#x27;xml2js&#x27;); </span><br><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> if (mime(req) === &#x27;application/xml&#x27;) &#123; </span><br><span class=\"line\"> xml2js.parseString(req.rawBody, function (err, xml) &#123; </span><br><span class=\"line\"> if (err) &#123; </span><br><span class=\"line\"> // 异常内容，响应Bad request </span><br><span class=\"line\"> res.writeHead(400); </span><br><span class=\"line\"> res.end(&#x27;Invalid XML&#x27;); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> req.body = xml; </span><br><span class=\"line\"> todo(req, res); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><em>附件上传</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> if (hasBody(req)) &#123; </span><br><span class=\"line\"> var done = function () &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> if (mime(req) === &#x27;application/json&#x27;) &#123; </span><br><span class=\"line\"> parseJSON(req, done); </span><br><span class=\"line\"> &#125; else if (mime(req) === &#x27;application/xml&#x27;) &#123; </span><br><span class=\"line\"> parseXML(req, done); </span><br><span class=\"line\"> &#125; else if (mime(req) === &#x27;multipart/form-data&#x27;) &#123; </span><br><span class=\"line\"> parseMultipart(req, done); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>formidable基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var formidable = require(&#x27;formidable&#x27;); </span><br><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> if (hasBody(req)) &#123; </span><br><span class=\"line\"> if (mime(req) === &#x27;multipart/form-data&#x27;) &#123; </span><br><span class=\"line\"> var form = new formidable.IncomingForm(); </span><br><span class=\"line\"> form.parse(req, function(err, fields, files) &#123; </span><br><span class=\"line\"> req.body = fields; </span><br><span class=\"line\"> req.files = files; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h6 id=\"数据上传与安全\"><a href=\"#数据上传与安全\" class=\"headerlink\" title=\"数据上传与安全\"></a>数据上传与安全</h6><p>内存限制<br>主要有两个方案。</p>\n<ul>\n<li>限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。</li>\n<li>通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bytes = 1024; </span><br><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> var received = 0, </span><br><span class=\"line\"> var len = req.headers[&#x27;content-length&#x27;] ? parseInt(req.headers[&#x27;content-length&#x27;], 10) : null; </span><br><span class=\"line\"> // 如果内容超过长度限制，返回请求实体过长的状态码</span><br><span class=\"line\"> if (len &amp;&amp; len &gt; bytes) &#123; </span><br><span class=\"line\"> res.writeHead(413); </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  // limit </span><br><span class=\"line\"> req.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> received += chunk.length; </span><br><span class=\"line\"> if (received &gt; bytes) &#123; </span><br><span class=\"line\"> // 停止接收数据，触发end() </span><br><span class=\"line\"> req.destroy(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>CSRF<br>CSRF的全称是Cross-Site Request Forgery，中文意思为跨站请求伪造。</p>\n<p>解决CSRF攻击的方案有添加随机值的方式，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var generateRandom = function(len) &#123; </span><br><span class=\"line\"> return crypto.randomBytes(Math.ceil(len * 3 / 4)) </span><br><span class=\"line\"> .toString(&#x27;base64&#x27;) </span><br><span class=\"line\"> .slice(0, len); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"路由解析\"><a href=\"#路由解析\" class=\"headerlink\" title=\"路由解析\"></a>路由解析</h6><p>文件路径型</p>\n<ul>\n<li>静态文件</li>\n<li>动态文件</li>\n</ul>\n<p>MVC<br>MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。</p>\n<ul>\n<li>控制器（Controller），一组行为的集合。</li>\n<li>模型（Model），数据相关的操作和封装。</li>\n<li>视图（View），视图的渲染。</li>\n</ul>\n<p><img src=\"/nodejs/images/mvc.png\" alt=\"MVC\"><br>这是目前最为经典的分层模式，大致而言，它的工作模式如下说明。</p>\n<ul>\n<li>路由解析，根据URL寻找到对应的控制器和行为。</li>\n<li>行为调用相关的模型，进行数据操作。</li>\n<li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</li>\n</ul>\n<p>如何根据URL做路由映射，这里有两个分支实现。<br>一种方式是通过手工关联映射<br>一种是自然关联映射<br>前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件</p>\n<p>手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。</p>\n<ul>\n<li>正则匹配</li>\n<li>参数解析</li>\n</ul>\n<p>自然映射这种路由方式在PHP的MVC框架CodeIgniter中应用十分广泛，设计十分简洁，在Node中实现它也十分容易。与手工映射相比，如果URL变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。</p>\n<p><em>RESTful</em><br>REST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上</p>\n<p>RESTful与MVC设计并不冲突，而且是更好的改进。相比MVC，RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化</p>\n<h6 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h6><p><img src=\"/nodejs/images/middle.png\" alt=\"中间件\"></p>\n<p><em>异常处理</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res, stack) &#123; </span><br><span class=\"line\"> var next = function (err) &#123; </span><br><span class=\"line\"> if (err) &#123; </span><br><span class=\"line\"> return handle500(err, req, res, stack); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> // 从stack数组中取出中间件并执行</span><br><span class=\"line\"> var middleware = stack.shift(); </span><br><span class=\"line\"> if (middleware) &#123; </span><br><span class=\"line\"> // 传入next()函数自身，使中间件能够执行结束后递归</span><br><span class=\"line\"> try &#123; </span><br><span class=\"line\"> middleware(req, res, next); </span><br><span class=\"line\"> &#125; catch (ex) &#123; </span><br><span class=\"line\"> next(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> // 启动执行</span><br><span class=\"line\"> next(); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p><em>中间件与性能</em><br>编写高效的中间件</p>\n<ul>\n<li>使用高效的方法。必要时通过jsperf.com测试基准性能。</li>\n<li>缓存需要重复计算的结果（需要控制缓存用量）。</li>\n<li>避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。</li>\n</ul>\n<p>合理使用路由</p>\n<h6 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h6><p><em>内容响应</em></p>\n<ul>\n<li>MIME: 浏览器正是通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值<br>MIME的全称是Multipurpose Internet Mail Extensions，从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的MIME值，如JSON文件的值为application/json、XML文件的值为application/xml、PDF文件的值为application/pdf。<br>为了方便获知文件的MIME值，社区有专有的mime模块可以用判段文件类型。它的调用十分简单，如下所示：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mime = require(&#x27;mime&#x27;); </span><br><span class=\"line\">mime.lookup(&#x27;/path/to/file.txt&#x27;); // =&gt; &#x27;text/plain&#x27; </span><br><span class=\"line\">mime.lookup(&#x27;file.txt&#x27;); // =&gt; &#x27;text/plain&#x27; </span><br><span class=\"line\">mime.lookup(&#x27;.TXT&#x27;); // =&gt; &#x27;text/plain&#x27; </span><br><span class=\"line\">mime.lookup(&#x27;htm&#x27;); // =&gt; &#x27;text/html&#x27; </span><br></pre></td></tr></table></figure>\n除了MIME值外，Content-Type的值中还可以包含一些参数，如字符集。示例如下：<br>Content-Type: text/javascript; charset=utf-8 </li>\n<li>附件下载<br>Content-Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名</li>\n<li>响应JSON</li>\n<li>响应跳转</li>\n</ul>\n<p><em>视图渲染</em><br>集成文件系统</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123;&#125;; </span><br><span class=\"line\">var VIEW_FOLDER = &#x27;/path/to/wwwroot/views&#x27;; </span><br><span class=\"line\">res.render = function (viewname, data) &#123; </span><br><span class=\"line\"> if (!cache[viewname]) &#123; </span><br><span class=\"line\"> var text; </span><br><span class=\"line\"> try &#123; </span><br><span class=\"line\"> text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), &#x27;utf8&#x27;); </span><br><span class=\"line\"> &#125; catch (e) &#123; </span><br><span class=\"line\">  res.writeHead(500, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;模板文件错误&#x27;); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> cache[viewname] = complie(text); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> var complied = cache[viewname]; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> var html = complied(data); </span><br><span class=\"line\"> res.end(html); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Bigpipe</strong><br>Bigpipe的解决思路则是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。</p>\n<p>Bigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。</p>\n<ul>\n<li>页面布局框架（无数据的）。</li>\n<li>后端持续性的数据输出。</li>\n<li>前端渲染<br><img src=\"/nodejs/images/bigpipe.png\" alt=\"bigpipe\"><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123;&#125;; </span><br><span class=\"line\">var layout = &#x27;layout.html&#x27;; </span><br><span class=\"line\">app.get(&#x27;/profile&#x27;, function (req, res) &#123; </span><br><span class=\"line\"> if (!cache[layout]) &#123; </span><br><span class=\"line\"> cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#x27;utf8&#x27;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> res.write(render(complie(cache[layout]))); </span><br><span class=\"line\"> // TODO </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#x27;/profile&#x27;, function (req, res) &#123; </span><br><span class=\"line\"> if (!cache[layout]) &#123; </span><br><span class=\"line\"> cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#x27;utf8&#x27;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> res.write(render(complie(cache[layout]))); </span><br><span class=\"line\"> ep.all(&#x27;users&#x27;, &#x27;articles&#x27;, function () &#123; </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> ep.fail(function (err) &#123; </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> db.getData(&#x27;sql1&#x27;, function (err, data) &#123; </span><br><span class=\"line\"> data = err ? &#123;&#125; : data; </span><br><span class=\"line\"> res.write(&#x27;&lt;script&gt;bigpipe.set(&quot;articles&quot;, &#x27; + JSON.stringify(data) + &#x27;);&lt;/script&gt;&#x27;; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> db.getData(&#x27;sql2&#x27;, function (err, data) &#123; </span><br><span class=\"line\"> data = err ? &#123;&#125; : data; </span><br><span class=\"line\"> res.write(&#x27;&lt;script&gt;bigpipe.set(&quot;copyright&quot;, &#x27; + JSON.stringify(data) + &#x27;);&lt;/script&gt;&#x27;; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var Bigpipe = function () &#123; </span><br><span class=\"line\"> this.callbacks = &#123;&#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">Bigpipe.prototype.ready = function (key, callback) &#123; </span><br><span class=\"line\"> if (!this.callbacks[key]) &#123; </span><br><span class=\"line\"> this.callbacks[key] = []; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> this.callbacks[key].push(callback); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">Bigpipe.prototype.set = function (key, data) &#123; </span><br><span class=\"line\"> var callbacks = this.callbacks[key] || []; </span><br><span class=\"line\"> for (var i = 0; i &lt; callbacks.length; i++) &#123; </span><br><span class=\"line\"> callbacks[i].call(this, data); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\nBigpipe将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好了，其随着数据输出的过程逐步渲染页面，使得用户能够感知到页面是活的。这远比一开始给出空白页面，然后在某个时候突然渲染好带给用户的体验更好</li>\n</ul>\n<h4 id=\"玩转进程\"><a href=\"#玩转进程\" class=\"headerlink\" title=\"玩转进程\"></a>玩转进程</h4><h6 id=\"服务模型的变迁\"><a href=\"#服务模型的变迁\" class=\"headerlink\" title=\"服务模型的变迁\"></a>服务模型的变迁</h6><p><em>石器时代：同步</em><br>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。<br>它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N</p>\n<p><em>青铜时代：复制进程</em><br>为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。<br>为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽<br>假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N</p>\n<p><em>白银时代：多线程</em><br>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。<br>如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。</p>\n<p><em>黄金时代：事件驱动</em><br>基于事件的服务模型存在的两个问题：CPU的利用率和进程的健壮性</p>\n<h6 id=\"多进程架构\"><a href=\"#多进程架构\" class=\"headerlink\" title=\"多进程架构\"></a>多进程架构</h6><p>面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// worker.js</span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;Hello World\\n&#x27;); </span><br><span class=\"line\">&#125;).listen(Math.round((1 + Math.random()) * 1000), &#x27;127.0.0.1&#x27;); </span><br><span class=\"line\"></span><br><span class=\"line\">var fork = require(&#x27;child_process&#x27;).fork; </span><br><span class=\"line\">var cpus = require(&#x27;os&#x27;).cpus(); </span><br><span class=\"line\">for (var i = 0; i &lt; cpus.length; i++) &#123; </span><br><span class=\"line\"> fork(&#x27;./worker.js&#x27;); </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/master-slave.png\" alt=\"主从模式\"><br>Master-Worker模式，又称主从模式。进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。</p>\n<p><em>通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10 MB的内存。尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然要切记fork()进程是昂贵的</em></p>\n<p><em>创建子进程</em><br>child_process模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。</p>\n<ul>\n<li>spawn()：启动一个子进程来执行命令。</li>\n<li>exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函<br>数获知子进程的状况。</li>\n<li>execFile()：启动一个子进程来执行可执行文件。</li>\n<li>fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文<br>件模块即可。<br>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。<br>exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cp = require(&#x27;child_process&#x27;); </span><br><span class=\"line\">cp.spawn(&#x27;node&#x27;, [&#x27;worker.js&#x27;]); </span><br><span class=\"line\">cp.exec(&#x27;node worker.js&#x27;, function (err, stdout, stderr) &#123; </span><br><span class=\"line\"> // some code </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">cp.execFile(&#x27;worker.js&#x27;, function (err, stdout, stderr) &#123; </span><br><span class=\"line\"> // some code </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">cp.fork(&#x27;./worker.js&#x27;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/fork.png\" alt=\"fork\"></p>\n<p><em>进程间通信</em><br>通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息</p>\n<ul>\n<li>进程间通信原理<br>IPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术<br><img src=\"/nodejs/images/pipe.png\" alt=\"pipe\"><br>父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接<br><img src=\"/nodejs/images/pipe-1.png\" alt=\"pipe\"></li>\n</ul>\n<p><em>句柄传递</em><br>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。</p>\n<p>child.send(message, [sendHandle])<br>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child = require(&#x27;child_process&#x27;).fork(&#x27;child.js&#x27;); </span><br><span class=\"line\">// Open up the server object and send the handle </span><br><span class=\"line\">var server = require(&#x27;net&#x27;).createServer(); </span><br><span class=\"line\">server.on(&#x27;connection&#x27;, function (socket) &#123; </span><br><span class=\"line\"> socket.end(&#x27;handled by parent\\n&#x27;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.listen(1337, function () &#123; </span><br><span class=\"line\"> child.send(&#x27;server&#x27;, server); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">process.on(&#x27;message&#x27;, function (m, server) &#123; </span><br><span class=\"line\"> if (m === &#x27;server&#x27;) &#123; </span><br><span class=\"line\"> server.on(&#x27;connection&#x27;, function (socket) &#123; </span><br><span class=\"line\"> socket.end(&#x27;handled by child\\n&#x27;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/pipe-2.png\" alt=\"pipe\"><br>主进程发送完句柄并关闭监听之后<br><img src=\"/nodejs/images/pipe-3.png\" alt=\"pipe\"></p>\n<p>句柄发送与还原<br>目前子进程对象send()方法可以发送的句柄类型包括如下几种。</p>\n<ul>\n<li>net.Socket。TCP套接字。</li>\n<li>net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。</li>\n<li>net.Native。C++层面的TCP套接字或IPC管道。</li>\n<li>dgram.Socket。UDP套接字。</li>\n<li>dgram.Native。C++层面的UDP套接字。<br>send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示：<br>{<br>cmd: ‘NODE_HANDLE’,<br>type: ‘net.Server’,<br>msg: message<br>} </li>\n</ul>\n<p>连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。<br><img src=\"/nodejs/images/pipe-4.png\" alt=\"pipe\"></p>\n<p>Node进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果</p>\n<p>端口共同监听<br>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的</p>\n<h6 id=\"集群稳定之路\"><a href=\"#集群稳定之路\" class=\"headerlink\" title=\"集群稳定之路\"></a>集群稳定之路</h6><p><em>进程事件</em><br>除了message事件外，Node还有如下这些事件。</p>\n<ul>\n<li>error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。</li>\n<li>exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。</li>\n<li>close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。</li>\n<li>disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li>\n</ul>\n<p>在命令行中执行kill -l可以看到详细的信号列表</p>\n<p><em>自动重启</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// master.js </span><br><span class=\"line\">var fork = require(&#x27;child_process&#x27;).fork; </span><br><span class=\"line\">var cpus = require(&#x27;os&#x27;).cpus(); </span><br><span class=\"line\">var server = require(&#x27;net&#x27;).createServer(); </span><br><span class=\"line\">server.listen(1337); </span><br><span class=\"line\">var workers = &#123;&#125;; </span><br><span class=\"line\">var createWorker = function () &#123; </span><br><span class=\"line\"> var worker = fork(__dirname + &#x27;/worker.js&#x27;); </span><br><span class=\"line\"> // 退出时重新启动新的进程</span><br><span class=\"line\"> worker.on(&#x27;exit&#x27;, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;Worker &#x27; + worker.pid + &#x27; exited.&#x27;); </span><br><span class=\"line\"> delete workers[worker.pid]; </span><br><span class=\"line\"> createWorker(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> // 句柄转发</span><br><span class=\"line\"> worker.send(&#x27;server&#x27;, server); </span><br><span class=\"line\"> workers[worker.pid] = worker; </span><br><span class=\"line\"> console.log(&#x27;Create worker. pid: &#x27; + worker.pid); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">for (var i = 0; i &lt; cpus.length; i++) &#123; </span><br><span class=\"line\"> createWorker(); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// 进程自己退出时，让所有工作进程退出</span><br><span class=\"line\">process.on(&#x27;exit&#x27;, function () &#123; </span><br><span class=\"line\"> for (var pid in workers) &#123; </span><br><span class=\"line\"> workers[pid].kill(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// worker.js </span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">var server = http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;handled by child, pid is &#x27; + process.pid + &#x27;\\n&#x27;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var worker; </span><br><span class=\"line\">process.on(&#x27;message&#x27;, function (m, tcp) &#123; </span><br><span class=\"line\"> if (m === &#x27;server&#x27;) &#123; </span><br><span class=\"line\"> worker = tcp; </span><br><span class=\"line\"> worker.on(&#x27;connection&#x27;, function (socket) &#123; </span><br><span class=\"line\">  server.emit(&#x27;connection&#x27;, socket); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">process.on(&#x27;uncaughtException&#x27;, function () &#123; </span><br><span class=\"line\"> // 停止接收新的连接</span><br><span class=\"line\"> worker.close(function () &#123; </span><br><span class=\"line\"> // 所有已有连接断开后，退出进程</span><br><span class=\"line\"> process.exit(1); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p><em>限量重启</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 重启次数</span><br><span class=\"line\">var limit = 10; </span><br><span class=\"line\">// 时间单位</span><br><span class=\"line\">var during = 60000; </span><br><span class=\"line\">var restart = []; </span><br><span class=\"line\">var isTooFrequently = function () &#123; </span><br><span class=\"line\"> // 记录重启时间</span><br><span class=\"line\"> var time = Date.now(); </span><br><span class=\"line\"> var length = restart.push(time); </span><br><span class=\"line\"> if (length &gt; limit) &#123; </span><br><span class=\"line\"> // 取出最后10个记录</span><br><span class=\"line\"> restart = restart.slice(limit * -1); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> // 最后一次重启到前10次重启之间的时间间隔</span><br><span class=\"line\"> return restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var workers = &#123;&#125;; </span><br><span class=\"line\">var createWorker = function () &#123; </span><br><span class=\"line\"> // 检查是否太过频繁</span><br><span class=\"line\"> if (isTooFrequently()) &#123; </span><br><span class=\"line\"> // 触发giveup事件后，不再重启</span><br><span class=\"line\"> process.emit(&#x27;giveup&#x27;, length, during); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> var worker = fork(__dirname + &#x27;/worker.js&#x27;); </span><br><span class=\"line\"> worker.on(&#x27;exit&#x27;, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;Worker &#x27; + worker.pid + &#x27; exited.&#x27;); </span><br><span class=\"line\"> delete workers[worker.pid]; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> // 重新启动新的进程</span><br><span class=\"line\"> worker.on(&#x27;message&#x27;, function (message) &#123; </span><br><span class=\"line\"> if (message.act === &#x27;suicide&#x27;) &#123; </span><br><span class=\"line\"> createWorker(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> // 句柄转发</span><br><span class=\"line\"> worker.send(&#x27;server&#x27;, server); </span><br><span class=\"line\"> workers[worker.pid] = worker; </span><br><span class=\"line\"> console.log(&#x27;Create worker. pid: &#x27; + worker.pid); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p><em>负载均衡</em><br>在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来,这种保证多个处理单元工作量公平的策略叫负载均衡</p>\n<p>Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务</p>\n<p>对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况</p>\n<p>为 此 Node在 v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接</p>\n<p><em>状态共享</em></p>\n<ul>\n<li>第三方数据存储<br>这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。<br>实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询<br>定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟<br><img src=\"/nodejs/images/loop.png\" alt=\"轮询\"></li>\n<li>主动通知<br>一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。<br><img src=\"/nodejs/images/loop-1.png\" alt=\"轮询\"><br>这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程</li>\n</ul>\n<h6 id=\"Cluster-模块\"><a href=\"#Cluster-模块\" class=\"headerlink\" title=\"Cluster 模块\"></a>Cluster 模块</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// cluster.js </span><br><span class=\"line\">var cluster = require(&#x27;cluster&#x27;); </span><br><span class=\"line\">cluster.setupMaster(&#123; </span><br><span class=\"line\"> exec: &quot;worker.js&quot; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var cpus = require(&#x27;os&#x27;).cpus(); </span><br><span class=\"line\">for (var i = 0; i &lt; cpus.length; i++) &#123; </span><br><span class=\"line\"> cluster.fork(); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">var cluster = require(&#x27;cluster&#x27;); </span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">var numCPUs = require(&#x27;os&#x27;).cpus().length; </span><br><span class=\"line\">if (cluster.isMaster) &#123; </span><br><span class=\"line\"> // Fork workers </span><br><span class=\"line\"> for (var i = 0; i &lt; numCPUs; i++) &#123; </span><br><span class=\"line\"> cluster.fork(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> cluster.on(&#x27;exit&#x27;, function(worker, code, signal) &#123; </span><br><span class=\"line\"> console.log(&#x27;worker &#x27; + worker.process.pid + &#x27; died&#x27;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125; else &#123; </span><br><span class=\"line\"> // Workers can share any TCP connection </span><br><span class=\"line\"> // In this case its a HTTP server </span><br><span class=\"line\"> http.createServer(function(req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200); </span><br><span class=\"line\"> res.end(&quot;hello world\\n&quot;); </span><br><span class=\"line\"> &#125;).listen(8000); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.isWorker = (&#x27;NODE_UNIQUE_ID&#x27; in process.env); </span><br><span class=\"line\">cluster.isMaster = (cluster.isWorker === false); </span><br></pre></td></tr></table></figure>\n<p>官方示例中忽而判断cluster.isMaster、忽而判断cluster.isWorker，对于代码的可读性十分差。建议用cluster.setupMaster()这个API，将主进程和工作进程从代码上完全剥离</p>\n<p>通过cluster.setupMaster()创建子进程而不是使用cluster.fork()</p>\n<p><em>Cluster 工作原理</em><br>事实上cluster模块就是child_process和net模块的组合应用</p>\n<p><em>Cluster 事件</em></p>\n<ul>\n<li>fork：复制一个工作进程后触发该事件。</li>\n<li>online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。</li>\n<li>listening：工作进程中调用listen()（共享了服务器端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件。</li>\n<li>disconnect：主进程和工作进程之间IPC通道断开后会触发该事件。</li>\n<li>exit：有工作进程退出时触发该事件。</li>\n<li>setup：cluster.setupMaster()执行后触发该事件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"构建Web应用\"><a href=\"#构建Web应用\" class=\"headerlink\" title=\"构建Web应用\"></a>构建Web应用</h4><h6 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h6><p>告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：<br>Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;<br>其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项:</p>\n<ul>\n<li>path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。</li>\n<li>Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。</li>\n<li>HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。</li>\n<li>Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到</li>\n</ul>\n<p>在YSlow的性能优化规则:</p>\n<ul>\n<li>减小Cookie的大小</li>\n<li>为静态组件使用不同的域名</li>\n<li>减少DNS查询</li>\n</ul>\n<h6 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h6><p>Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递</p>\n<p>常见的两种实现方式:</p>\n<ul>\n<li>基于Cookie来实现用户和数据的映射<br>一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sessions = &#123;&#125;; </span><br><span class=\"line\">var key = &#x27;session_id&#x27;; </span><br><span class=\"line\">var EXPIRES = 20 * 60 * 1000; </span><br><span class=\"line\">var generate = function () &#123; </span><br><span class=\"line\"> var session = &#123;&#125;; </span><br><span class=\"line\"> session.id = (new Date()).getTime() + Math.random(); </span><br><span class=\"line\"> session.cookie = &#123; </span><br><span class=\"line\"> expire: (new Date()).getTime() + EXPIRES </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> sessions[session.id] = session; </span><br><span class=\"line\"> return session; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure></li>\n<li>通过查询字符串来实现浏览器端和服务器端数据的对应</li>\n</ul>\n<p>采用高速缓存的理由有以下几条:</p>\n<ul>\n<li>Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。</li>\n<li>高速缓存直接在内存中进行数据存储和访问。</li>\n<li>缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。</li>\n</ul>\n<h6 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h6><p>关于缓存的规则：</p>\n<ul>\n<li>添加Expires 或Cache-Control 到报文头中。</li>\n<li>配置 ETags。</li>\n<li>让Ajax 可缓存</li>\n</ul>\n<p><img src=\"/nodejs/images/cache.png\" alt=\"缓存\"></p>\n<p>时间戳有一些缺陷存在:</p>\n<ul>\n<li>文件的时间戳改动但内容并不一定改动。</li>\n<li>时间戳只能精确到秒级别，更新频繁的内容将无法生效</li>\n</ul>\n<p>ETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。<br>ETag的请求和响应是If-None-Match/ETag</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> fs.readFile(filename, function(err, file) &#123; </span><br><span class=\"line\"> var hash = getHash(file); </span><br><span class=\"line\"> var noneMatch = req.headers[&#x27;if-none-match&#x27;]; </span><br><span class=\"line\"> if (hash === noneMatch) &#123; </span><br><span class=\"line\"> res.writeHead(304, &quot;Not Modified&quot;); </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> res.setHeader(&quot;ETag&quot;, hash); </span><br><span class=\"line\"> res.writeHead(200, &quot;Ok&quot;); </span><br><span class=\"line\"> res.end(file); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>HTTP1.0时，在服务器端设置Expires可以告知浏览器要缓存文件内容，如下代码所示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> fs.readFile(filename, function(err, file) &#123; </span><br><span class=\"line\"> var expires = new Date(); </span><br><span class=\"line\"> expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000); </span><br><span class=\"line\"> res.setHeader(&quot;Expires&quot;, expires.toUTCString()); </span><br><span class=\"line\"> res.writeHead(200, &quot;Ok&quot;); </span><br><span class=\"line\"> res.end(file); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>Expires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求</p>\n<p>Expires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。在这种情况下，Cache-Control以更丰富的形式，实现相同的功能，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> fs.readFile(filename, function(err, file) &#123; </span><br><span class=\"line\"> res.setHeader(&quot;Cache-Control&quot;, &quot;max-age=&quot; + 10 * 365 * 24 * 60 * 60 * 1000); </span><br><span class=\"line\"> res.writeHead(200, &quot;Ok&quot;); </span><br><span class=\"line\"> res.end(file); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项</p>\n<p>由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。</p>\n<p>一般的更新机制有如下两种:</p>\n<ul>\n<li>每次发布，路径中跟随Web应用的版本号：<a href=\"http://url.com/?v=20130501%E3%80%82\">http://url.com/?v=20130501。</a></li>\n<li>每次发布，路径中跟随该文件内容的hash值：<a href=\"http://url.com/?hash=afadfadwe\">http://url.com/?hash=afadfadwe</a></li>\n</ul>\n<h6 id=\"Basic认证\"><a href=\"#Basic认证\" class=\"headerlink\" title=\"Basic认证\"></a>Basic认证</h6><p>一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它</p>\n<h6 id=\"数据上传\"><a href=\"#数据上传\" class=\"headerlink\" title=\"数据上传\"></a>数据上传</h6><p>如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。<br>通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hasBody = function(req) &#123; </span><br><span class=\"line\"> return &#x27;transfer-encoding&#x27; in req.headers || &#x27;content-length&#x27; in req.headers; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> if (hasBody(req)) &#123; </span><br><span class=\"line\"> var buffers = []; </span><br><span class=\"line\"> req.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> buffers.push(chunk); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> req.on(&#x27;end&#x27;, function () &#123; </span><br><span class=\"line\"> req.rawBody = Buffer.concat(buffers).toString(); </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处</p>\n<p>获取数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> if (req.headers[&#x27;content-type&#x27;] === &#x27;application/x-www-form-urlencoded&#x27;) &#123; </span><br><span class=\"line\"> req.body = querystring.parse(req.rawBody); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> todo(req, res); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var mime = function (req) &#123; </span><br><span class=\"line\"> var str = req.headers[&#x27;content-type&#x27;] || &#x27;&#x27;; </span><br><span class=\"line\"> return str.split(&#x27;;&#x27;)[0]; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> if (mime(req) === &#x27;application/json&#x27;) &#123; </span><br><span class=\"line\"> try &#123; </span><br><span class=\"line\"> req.body = JSON.parse(req.rawBody); </span><br><span class=\"line\"> &#125; catch (e) &#123; </span><br><span class=\"line\"> // 异常内容，响应Bad request </span><br><span class=\"line\"> res.writeHead(400); </span><br><span class=\"line\"> res.end(&#x27;Invalid JSON&#x27;); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> todo(req, res); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>解析XML文件稍微复杂一点，建议使用支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xml2js = require(&#x27;xml2js&#x27;); </span><br><span class=\"line\">var handle = function (req, res) &#123; </span><br><span class=\"line\"> if (mime(req) === &#x27;application/xml&#x27;) &#123; </span><br><span class=\"line\"> xml2js.parseString(req.rawBody, function (err, xml) &#123; </span><br><span class=\"line\"> if (err) &#123; </span><br><span class=\"line\"> // 异常内容，响应Bad request </span><br><span class=\"line\"> res.writeHead(400); </span><br><span class=\"line\"> res.end(&#x27;Invalid XML&#x27;); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> req.body = xml; </span><br><span class=\"line\"> todo(req, res); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><em>附件上传</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> if (hasBody(req)) &#123; </span><br><span class=\"line\"> var done = function () &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> if (mime(req) === &#x27;application/json&#x27;) &#123; </span><br><span class=\"line\"> parseJSON(req, done); </span><br><span class=\"line\"> &#125; else if (mime(req) === &#x27;application/xml&#x27;) &#123; </span><br><span class=\"line\"> parseXML(req, done); </span><br><span class=\"line\"> &#125; else if (mime(req) === &#x27;multipart/form-data&#x27;) &#123; </span><br><span class=\"line\"> parseMultipart(req, done); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>formidable基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var formidable = require(&#x27;formidable&#x27;); </span><br><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> if (hasBody(req)) &#123; </span><br><span class=\"line\"> if (mime(req) === &#x27;multipart/form-data&#x27;) &#123; </span><br><span class=\"line\"> var form = new formidable.IncomingForm(); </span><br><span class=\"line\"> form.parse(req, function(err, fields, files) &#123; </span><br><span class=\"line\"> req.body = fields; </span><br><span class=\"line\"> req.files = files; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; else &#123; </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h6 id=\"数据上传与安全\"><a href=\"#数据上传与安全\" class=\"headerlink\" title=\"数据上传与安全\"></a>数据上传与安全</h6><p>内存限制<br>主要有两个方案。</p>\n<ul>\n<li>限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。</li>\n<li>通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bytes = 1024; </span><br><span class=\"line\">function (req, res) &#123; </span><br><span class=\"line\"> var received = 0, </span><br><span class=\"line\"> var len = req.headers[&#x27;content-length&#x27;] ? parseInt(req.headers[&#x27;content-length&#x27;], 10) : null; </span><br><span class=\"line\"> // 如果内容超过长度限制，返回请求实体过长的状态码</span><br><span class=\"line\"> if (len &amp;&amp; len &gt; bytes) &#123; </span><br><span class=\"line\"> res.writeHead(413); </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  // limit </span><br><span class=\"line\"> req.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> received += chunk.length; </span><br><span class=\"line\"> if (received &gt; bytes) &#123; </span><br><span class=\"line\"> // 停止接收数据，触发end() </span><br><span class=\"line\"> req.destroy(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> handle(req, res); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>CSRF<br>CSRF的全称是Cross-Site Request Forgery，中文意思为跨站请求伪造。</p>\n<p>解决CSRF攻击的方案有添加随机值的方式，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var generateRandom = function(len) &#123; </span><br><span class=\"line\"> return crypto.randomBytes(Math.ceil(len * 3 / 4)) </span><br><span class=\"line\"> .toString(&#x27;base64&#x27;) </span><br><span class=\"line\"> .slice(0, len); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"路由解析\"><a href=\"#路由解析\" class=\"headerlink\" title=\"路由解析\"></a>路由解析</h6><p>文件路径型</p>\n<ul>\n<li>静态文件</li>\n<li>动态文件</li>\n</ul>\n<p>MVC<br>MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。</p>\n<ul>\n<li>控制器（Controller），一组行为的集合。</li>\n<li>模型（Model），数据相关的操作和封装。</li>\n<li>视图（View），视图的渲染。</li>\n</ul>\n<p><img src=\"/nodejs/images/mvc.png\" alt=\"MVC\"><br>这是目前最为经典的分层模式，大致而言，它的工作模式如下说明。</p>\n<ul>\n<li>路由解析，根据URL寻找到对应的控制器和行为。</li>\n<li>行为调用相关的模型，进行数据操作。</li>\n<li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</li>\n</ul>\n<p>如何根据URL做路由映射，这里有两个分支实现。<br>一种方式是通过手工关联映射<br>一种是自然关联映射<br>前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件</p>\n<p>手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。</p>\n<ul>\n<li>正则匹配</li>\n<li>参数解析</li>\n</ul>\n<p>自然映射这种路由方式在PHP的MVC框架CodeIgniter中应用十分广泛，设计十分简洁，在Node中实现它也十分容易。与手工映射相比，如果URL变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。</p>\n<p><em>RESTful</em><br>REST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上</p>\n<p>RESTful与MVC设计并不冲突，而且是更好的改进。相比MVC，RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化</p>\n<h6 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h6><p><img src=\"/nodejs/images/middle.png\" alt=\"中间件\"></p>\n<p><em>异常处理</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handle = function (req, res, stack) &#123; </span><br><span class=\"line\"> var next = function (err) &#123; </span><br><span class=\"line\"> if (err) &#123; </span><br><span class=\"line\"> return handle500(err, req, res, stack); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> // 从stack数组中取出中间件并执行</span><br><span class=\"line\"> var middleware = stack.shift(); </span><br><span class=\"line\"> if (middleware) &#123; </span><br><span class=\"line\"> // 传入next()函数自身，使中间件能够执行结束后递归</span><br><span class=\"line\"> try &#123; </span><br><span class=\"line\"> middleware(req, res, next); </span><br><span class=\"line\"> &#125; catch (ex) &#123; </span><br><span class=\"line\"> next(err); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> // 启动执行</span><br><span class=\"line\"> next(); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p><em>中间件与性能</em><br>编写高效的中间件</p>\n<ul>\n<li>使用高效的方法。必要时通过jsperf.com测试基准性能。</li>\n<li>缓存需要重复计算的结果（需要控制缓存用量）。</li>\n<li>避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。</li>\n</ul>\n<p>合理使用路由</p>\n<h6 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h6><p><em>内容响应</em></p>\n<ul>\n<li>MIME: 浏览器正是通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值<br>MIME的全称是Multipurpose Internet Mail Extensions，从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的MIME值，如JSON文件的值为application/json、XML文件的值为application/xml、PDF文件的值为application/pdf。<br>为了方便获知文件的MIME值，社区有专有的mime模块可以用判段文件类型。它的调用十分简单，如下所示：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mime = require(&#x27;mime&#x27;); </span><br><span class=\"line\">mime.lookup(&#x27;/path/to/file.txt&#x27;); // =&gt; &#x27;text/plain&#x27; </span><br><span class=\"line\">mime.lookup(&#x27;file.txt&#x27;); // =&gt; &#x27;text/plain&#x27; </span><br><span class=\"line\">mime.lookup(&#x27;.TXT&#x27;); // =&gt; &#x27;text/plain&#x27; </span><br><span class=\"line\">mime.lookup(&#x27;htm&#x27;); // =&gt; &#x27;text/html&#x27; </span><br></pre></td></tr></table></figure>\n除了MIME值外，Content-Type的值中还可以包含一些参数，如字符集。示例如下：<br>Content-Type: text/javascript; charset=utf-8 </li>\n<li>附件下载<br>Content-Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名</li>\n<li>响应JSON</li>\n<li>响应跳转</li>\n</ul>\n<p><em>视图渲染</em><br>集成文件系统</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123;&#125;; </span><br><span class=\"line\">var VIEW_FOLDER = &#x27;/path/to/wwwroot/views&#x27;; </span><br><span class=\"line\">res.render = function (viewname, data) &#123; </span><br><span class=\"line\"> if (!cache[viewname]) &#123; </span><br><span class=\"line\"> var text; </span><br><span class=\"line\"> try &#123; </span><br><span class=\"line\"> text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), &#x27;utf8&#x27;); </span><br><span class=\"line\"> &#125; catch (e) &#123; </span><br><span class=\"line\">  res.writeHead(500, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;模板文件错误&#x27;); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> cache[viewname] = complie(text); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> var complied = cache[viewname]; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> var html = complied(data); </span><br><span class=\"line\"> res.end(html); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Bigpipe</strong><br>Bigpipe的解决思路则是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。</p>\n<p>Bigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。</p>\n<ul>\n<li>页面布局框架（无数据的）。</li>\n<li>后端持续性的数据输出。</li>\n<li>前端渲染<br><img src=\"/nodejs/images/bigpipe.png\" alt=\"bigpipe\"><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache = &#123;&#125;; </span><br><span class=\"line\">var layout = &#x27;layout.html&#x27;; </span><br><span class=\"line\">app.get(&#x27;/profile&#x27;, function (req, res) &#123; </span><br><span class=\"line\"> if (!cache[layout]) &#123; </span><br><span class=\"line\"> cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#x27;utf8&#x27;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> res.write(render(complie(cache[layout]))); </span><br><span class=\"line\"> // TODO </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#x27;/profile&#x27;, function (req, res) &#123; </span><br><span class=\"line\"> if (!cache[layout]) &#123; </span><br><span class=\"line\"> cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#x27;utf8&#x27;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); </span><br><span class=\"line\"> res.write(render(complie(cache[layout]))); </span><br><span class=\"line\"> ep.all(&#x27;users&#x27;, &#x27;articles&#x27;, function () &#123; </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> ep.fail(function (err) &#123; </span><br><span class=\"line\"> res.end(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> db.getData(&#x27;sql1&#x27;, function (err, data) &#123; </span><br><span class=\"line\"> data = err ? &#123;&#125; : data; </span><br><span class=\"line\"> res.write(&#x27;&lt;script&gt;bigpipe.set(&quot;articles&quot;, &#x27; + JSON.stringify(data) + &#x27;);&lt;/script&gt;&#x27;; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> db.getData(&#x27;sql2&#x27;, function (err, data) &#123; </span><br><span class=\"line\"> data = err ? &#123;&#125; : data; </span><br><span class=\"line\"> res.write(&#x27;&lt;script&gt;bigpipe.set(&quot;copyright&quot;, &#x27; + JSON.stringify(data) + &#x27;);&lt;/script&gt;&#x27;; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var Bigpipe = function () &#123; </span><br><span class=\"line\"> this.callbacks = &#123;&#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">Bigpipe.prototype.ready = function (key, callback) &#123; </span><br><span class=\"line\"> if (!this.callbacks[key]) &#123; </span><br><span class=\"line\"> this.callbacks[key] = []; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> this.callbacks[key].push(callback); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">Bigpipe.prototype.set = function (key, data) &#123; </span><br><span class=\"line\"> var callbacks = this.callbacks[key] || []; </span><br><span class=\"line\"> for (var i = 0; i &lt; callbacks.length; i++) &#123; </span><br><span class=\"line\"> callbacks[i].call(this, data); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\nBigpipe将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好了，其随着数据输出的过程逐步渲染页面，使得用户能够感知到页面是活的。这远比一开始给出空白页面，然后在某个时候突然渲染好带给用户的体验更好</li>\n</ul>\n<h4 id=\"玩转进程\"><a href=\"#玩转进程\" class=\"headerlink\" title=\"玩转进程\"></a>玩转进程</h4><h6 id=\"服务模型的变迁\"><a href=\"#服务模型的变迁\" class=\"headerlink\" title=\"服务模型的变迁\"></a>服务模型的变迁</h6><p><em>石器时代：同步</em><br>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。<br>它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N</p>\n<p><em>青铜时代：复制进程</em><br>为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。<br>为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽<br>假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N</p>\n<p><em>白银时代：多线程</em><br>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。<br>如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。</p>\n<p><em>黄金时代：事件驱动</em><br>基于事件的服务模型存在的两个问题：CPU的利用率和进程的健壮性</p>\n<h6 id=\"多进程架构\"><a href=\"#多进程架构\" class=\"headerlink\" title=\"多进程架构\"></a>多进程架构</h6><p>面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// worker.js</span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;Hello World\\n&#x27;); </span><br><span class=\"line\">&#125;).listen(Math.round((1 + Math.random()) * 1000), &#x27;127.0.0.1&#x27;); </span><br><span class=\"line\"></span><br><span class=\"line\">var fork = require(&#x27;child_process&#x27;).fork; </span><br><span class=\"line\">var cpus = require(&#x27;os&#x27;).cpus(); </span><br><span class=\"line\">for (var i = 0; i &lt; cpus.length; i++) &#123; </span><br><span class=\"line\"> fork(&#x27;./worker.js&#x27;); </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/master-slave.png\" alt=\"主从模式\"><br>Master-Worker模式，又称主从模式。进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。</p>\n<p><em>通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10 MB的内存。尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然要切记fork()进程是昂贵的</em></p>\n<p><em>创建子进程</em><br>child_process模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。</p>\n<ul>\n<li>spawn()：启动一个子进程来执行命令。</li>\n<li>exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函<br>数获知子进程的状况。</li>\n<li>execFile()：启动一个子进程来执行可执行文件。</li>\n<li>fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文<br>件模块即可。<br>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。<br>exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cp = require(&#x27;child_process&#x27;); </span><br><span class=\"line\">cp.spawn(&#x27;node&#x27;, [&#x27;worker.js&#x27;]); </span><br><span class=\"line\">cp.exec(&#x27;node worker.js&#x27;, function (err, stdout, stderr) &#123; </span><br><span class=\"line\"> // some code </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">cp.execFile(&#x27;worker.js&#x27;, function (err, stdout, stderr) &#123; </span><br><span class=\"line\"> // some code </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">cp.fork(&#x27;./worker.js&#x27;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/fork.png\" alt=\"fork\"></p>\n<p><em>进程间通信</em><br>通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息</p>\n<ul>\n<li>进程间通信原理<br>IPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术<br><img src=\"/nodejs/images/pipe.png\" alt=\"pipe\"><br>父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接<br><img src=\"/nodejs/images/pipe-1.png\" alt=\"pipe\"></li>\n</ul>\n<p><em>句柄传递</em><br>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。</p>\n<p>child.send(message, [sendHandle])<br>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child = require(&#x27;child_process&#x27;).fork(&#x27;child.js&#x27;); </span><br><span class=\"line\">// Open up the server object and send the handle </span><br><span class=\"line\">var server = require(&#x27;net&#x27;).createServer(); </span><br><span class=\"line\">server.on(&#x27;connection&#x27;, function (socket) &#123; </span><br><span class=\"line\"> socket.end(&#x27;handled by parent\\n&#x27;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.listen(1337, function () &#123; </span><br><span class=\"line\"> child.send(&#x27;server&#x27;, server); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">process.on(&#x27;message&#x27;, function (m, server) &#123; </span><br><span class=\"line\"> if (m === &#x27;server&#x27;) &#123; </span><br><span class=\"line\"> server.on(&#x27;connection&#x27;, function (socket) &#123; </span><br><span class=\"line\"> socket.end(&#x27;handled by child\\n&#x27;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/nodejs/images/pipe-2.png\" alt=\"pipe\"><br>主进程发送完句柄并关闭监听之后<br><img src=\"/nodejs/images/pipe-3.png\" alt=\"pipe\"></p>\n<p>句柄发送与还原<br>目前子进程对象send()方法可以发送的句柄类型包括如下几种。</p>\n<ul>\n<li>net.Socket。TCP套接字。</li>\n<li>net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。</li>\n<li>net.Native。C++层面的TCP套接字或IPC管道。</li>\n<li>dgram.Socket。UDP套接字。</li>\n<li>dgram.Native。C++层面的UDP套接字。<br>send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示：<br>{<br>cmd: ‘NODE_HANDLE’,<br>type: ‘net.Server’,<br>msg: message<br>} </li>\n</ul>\n<p>连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。<br><img src=\"/nodejs/images/pipe-4.png\" alt=\"pipe\"></p>\n<p>Node进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果</p>\n<p>端口共同监听<br>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的</p>\n<h6 id=\"集群稳定之路\"><a href=\"#集群稳定之路\" class=\"headerlink\" title=\"集群稳定之路\"></a>集群稳定之路</h6><p><em>进程事件</em><br>除了message事件外，Node还有如下这些事件。</p>\n<ul>\n<li>error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。</li>\n<li>exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。</li>\n<li>close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。</li>\n<li>disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li>\n</ul>\n<p>在命令行中执行kill -l可以看到详细的信号列表</p>\n<p><em>自动重启</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// master.js </span><br><span class=\"line\">var fork = require(&#x27;child_process&#x27;).fork; </span><br><span class=\"line\">var cpus = require(&#x27;os&#x27;).cpus(); </span><br><span class=\"line\">var server = require(&#x27;net&#x27;).createServer(); </span><br><span class=\"line\">server.listen(1337); </span><br><span class=\"line\">var workers = &#123;&#125;; </span><br><span class=\"line\">var createWorker = function () &#123; </span><br><span class=\"line\"> var worker = fork(__dirname + &#x27;/worker.js&#x27;); </span><br><span class=\"line\"> // 退出时重新启动新的进程</span><br><span class=\"line\"> worker.on(&#x27;exit&#x27;, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;Worker &#x27; + worker.pid + &#x27; exited.&#x27;); </span><br><span class=\"line\"> delete workers[worker.pid]; </span><br><span class=\"line\"> createWorker(); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> // 句柄转发</span><br><span class=\"line\"> worker.send(&#x27;server&#x27;, server); </span><br><span class=\"line\"> workers[worker.pid] = worker; </span><br><span class=\"line\"> console.log(&#x27;Create worker. pid: &#x27; + worker.pid); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">for (var i = 0; i &lt; cpus.length; i++) &#123; </span><br><span class=\"line\"> createWorker(); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// 进程自己退出时，让所有工作进程退出</span><br><span class=\"line\">process.on(&#x27;exit&#x27;, function () &#123; </span><br><span class=\"line\"> for (var pid in workers) &#123; </span><br><span class=\"line\"> workers[pid].kill(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// worker.js </span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">var server = http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;handled by child, pid is &#x27; + process.pid + &#x27;\\n&#x27;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var worker; </span><br><span class=\"line\">process.on(&#x27;message&#x27;, function (m, tcp) &#123; </span><br><span class=\"line\"> if (m === &#x27;server&#x27;) &#123; </span><br><span class=\"line\"> worker = tcp; </span><br><span class=\"line\"> worker.on(&#x27;connection&#x27;, function (socket) &#123; </span><br><span class=\"line\">  server.emit(&#x27;connection&#x27;, socket); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">process.on(&#x27;uncaughtException&#x27;, function () &#123; </span><br><span class=\"line\"> // 停止接收新的连接</span><br><span class=\"line\"> worker.close(function () &#123; </span><br><span class=\"line\"> // 所有已有连接断开后，退出进程</span><br><span class=\"line\"> process.exit(1); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<p><em>限量重启</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 重启次数</span><br><span class=\"line\">var limit = 10; </span><br><span class=\"line\">// 时间单位</span><br><span class=\"line\">var during = 60000; </span><br><span class=\"line\">var restart = []; </span><br><span class=\"line\">var isTooFrequently = function () &#123; </span><br><span class=\"line\"> // 记录重启时间</span><br><span class=\"line\"> var time = Date.now(); </span><br><span class=\"line\"> var length = restart.push(time); </span><br><span class=\"line\"> if (length &gt; limit) &#123; </span><br><span class=\"line\"> // 取出最后10个记录</span><br><span class=\"line\"> restart = restart.slice(limit * -1); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> // 最后一次重启到前10次重启之间的时间间隔</span><br><span class=\"line\"> return restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var workers = &#123;&#125;; </span><br><span class=\"line\">var createWorker = function () &#123; </span><br><span class=\"line\"> // 检查是否太过频繁</span><br><span class=\"line\"> if (isTooFrequently()) &#123; </span><br><span class=\"line\"> // 触发giveup事件后，不再重启</span><br><span class=\"line\"> process.emit(&#x27;giveup&#x27;, length, during); </span><br><span class=\"line\"> return; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> var worker = fork(__dirname + &#x27;/worker.js&#x27;); </span><br><span class=\"line\"> worker.on(&#x27;exit&#x27;, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;Worker &#x27; + worker.pid + &#x27; exited.&#x27;); </span><br><span class=\"line\"> delete workers[worker.pid]; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> // 重新启动新的进程</span><br><span class=\"line\"> worker.on(&#x27;message&#x27;, function (message) &#123; </span><br><span class=\"line\"> if (message.act === &#x27;suicide&#x27;) &#123; </span><br><span class=\"line\"> createWorker(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> // 句柄转发</span><br><span class=\"line\"> worker.send(&#x27;server&#x27;, server); </span><br><span class=\"line\"> workers[worker.pid] = worker; </span><br><span class=\"line\"> console.log(&#x27;Create worker. pid: &#x27; + worker.pid); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p><em>负载均衡</em><br>在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来,这种保证多个处理单元工作量公平的策略叫负载均衡</p>\n<p>Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务</p>\n<p>对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况</p>\n<p>为 此 Node在 v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接</p>\n<p><em>状态共享</em></p>\n<ul>\n<li>第三方数据存储<br>这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。<br>实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询<br>定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟<br><img src=\"/nodejs/images/loop.png\" alt=\"轮询\"></li>\n<li>主动通知<br>一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。<br><img src=\"/nodejs/images/loop-1.png\" alt=\"轮询\"><br>这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程</li>\n</ul>\n<h6 id=\"Cluster-模块\"><a href=\"#Cluster-模块\" class=\"headerlink\" title=\"Cluster 模块\"></a>Cluster 模块</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// cluster.js </span><br><span class=\"line\">var cluster = require(&#x27;cluster&#x27;); </span><br><span class=\"line\">cluster.setupMaster(&#123; </span><br><span class=\"line\"> exec: &quot;worker.js&quot; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var cpus = require(&#x27;os&#x27;).cpus(); </span><br><span class=\"line\">for (var i = 0; i &lt; cpus.length; i++) &#123; </span><br><span class=\"line\"> cluster.fork(); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">var cluster = require(&#x27;cluster&#x27;); </span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">var numCPUs = require(&#x27;os&#x27;).cpus().length; </span><br><span class=\"line\">if (cluster.isMaster) &#123; </span><br><span class=\"line\"> // Fork workers </span><br><span class=\"line\"> for (var i = 0; i &lt; numCPUs; i++) &#123; </span><br><span class=\"line\"> cluster.fork(); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> cluster.on(&#x27;exit&#x27;, function(worker, code, signal) &#123; </span><br><span class=\"line\"> console.log(&#x27;worker &#x27; + worker.process.pid + &#x27; died&#x27;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125; else &#123; </span><br><span class=\"line\"> // Workers can share any TCP connection </span><br><span class=\"line\"> // In this case its a HTTP server </span><br><span class=\"line\"> http.createServer(function(req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200); </span><br><span class=\"line\"> res.end(&quot;hello world\\n&quot;); </span><br><span class=\"line\"> &#125;).listen(8000); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.isWorker = (&#x27;NODE_UNIQUE_ID&#x27; in process.env); </span><br><span class=\"line\">cluster.isMaster = (cluster.isWorker === false); </span><br></pre></td></tr></table></figure>\n<p>官方示例中忽而判断cluster.isMaster、忽而判断cluster.isWorker，对于代码的可读性十分差。建议用cluster.setupMaster()这个API，将主进程和工作进程从代码上完全剥离</p>\n<p>通过cluster.setupMaster()创建子进程而不是使用cluster.fork()</p>\n<p><em>Cluster 工作原理</em><br>事实上cluster模块就是child_process和net模块的组合应用</p>\n<p><em>Cluster 事件</em></p>\n<ul>\n<li>fork：复制一个工作进程后触发该事件。</li>\n<li>online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。</li>\n<li>listening：工作进程中调用listen()（共享了服务器端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件。</li>\n<li>disconnect：主进程和工作进程之间IPC通道断开后会触发该事件。</li>\n<li>exit：有工作进程退出时触发该事件。</li>\n<li>setup：cluster.setupMaster()执行后触发该事件</li>\n</ul>\n"},{"title":"nodejs基础知识(2)","date":"2022-10-19T11:12:12.000Z","tags":["node","assert","asyncHooks"],"_content":"\n#### nodejs文档知识点\n\n###### assert-断言\n*作用：*用于测试不变式\n\n*assert.deepEqual(a, b[, message])*\n只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等\n注意：子对象中可枚举的属性也会被测试\n\n*assert.deepStrictEqual(a, b[, message])*\n与assert.deepEqual作用类似，使用全等 === 进行比较\n\n*assert.doesNotThrow(block[, error][, message])*\n调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误\n\n*assert.equal(actual, expected[, message])*\n使用相等运算符 == 测试actual与expected是否相等\n\n*assert.fail(message)*\n*assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])*\n抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 '!='。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除\n\n*assert.ifError(value)*\n如果value为真，则抛出value，即value为错误信息\n\n*assert.notDeepEqual(actual, expected[, message])*\n测试不深度相等，与assert.deepEqual()相反\n\n*assert.notDeepStrictEqual(actual, expected[, message])*\n测试是否不深度全等，与assert.deepStrictEqual()相反\n\n*assert.notEqual(actual, expected[, message])*\n使用 != 不等运算符测试参数是否不相等\n\n*assert.notStrictEqual(actual, expected[, message])*\n使用不全等运算符（!==）测试参数是否不全等\n\n*assert.ok(value[, message])*\n测试 value 是否为真值。 相当于 assert.equal(!!value, true, message)\n\n\n###### 异步钩子(Async Hooks)\nError handling(错误处理)\n应用程序运行时带有--abort on uncaught可以实现退出后，打印堆栈跟踪，留下一个核心文件\n**If any AsyncHook callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all 'uncaughtException' listeners are removed, thus forcing the process to exit. The 'exit' callbacks will still be called unless the application is run with --abort-on-uncaught-exception, in which case a stack trace will be printed and the application exits, leaving a core file.**\n\nPrinting in AsyncHook callbacks(异步钩子打印信息)\n在异步钩子函数中，打印信息查看数据不能使用 console.log等异步操作，会导致无限递归。\n推荐使用 fs.writeSync(1, msg).\n```javascript\nconst fs = require('fs');\nconst util = require('util');\n\nfunction debug(...args) {\n  // use a function like this one when debugging inside an AsyncHooks callback\n  fs.writeSync(1, `${util.format(...args)}\\n`);\n}\n```\n**Because printing to the console is an asynchronous operation, console.log() will cause AsyncHook callbacks to be called. Using console.log() or similar asynchronous operations inside an AsyncHook callback function will cause an infinite recursion. An easy solution to this when debugging is to use a synchronous logging operation such as fs.writeFileSync(file, msg, flag). This will print to the file and will not invoke AsyncHook recursively because it is synchronous.**\n\n*asyncHook.enable()*\n启用异步钩子\n\n*asyncHook.disable()*\n禁用异步钩子\n\n*init(asyncId, type, triggerAsyncId, resource)*\nasyncId: number类型，唯一标识符\ntype: string类型，异步类型\ntriggerAsyncId: number类型，在其执行上下文中创建此异步资源的异步资源的唯一ID\nresource: object类型，异步操作的资源的引用，需要在销毁期间释放\n应用场景：用于资源开启，被调用之前\n\n```javascript\nrequire('net').createServer().listen(function() { this.close(); });\n// OR\nclearTimeout(setTimeout(() => {}, 10));\n```\n注意：每个资源的ID在当前进程作用域中唯一\n\n*type*命名一般符合资源结构，比如：\n```\nFSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,\nJSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,\nSIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, TIMERWRAP, TTYWRAP,\nUDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,\nRANDOMBYTESREQUEST, TLSWRAP, Timeout, Immediate, TickObject, PROMISE\n```\n备注：type类型可能存在冲突，推荐给type添加前缀，比如 package name\n\n*triggerAsyncId*\n引起新资源初始化，调用init函数的资源的唯一标识符，triggerAsyncId展示资源为什么被创建\n```javascript\nasync_hooks.createHook({\n  init(asyncId, type, triggerAsyncId) {\n    const eid = async_hooks.executionAsyncId();\n    fs.writeSync(\n      1, `${type}(${asyncId}): trigger: ${triggerAsyncId} execution: ${eid}\\n`);\n  }\n}).enable();\n\nrequire('net').createServer((conn) => {}).listen(8080);\n```\n\n*resource*\n实际初始化的异步资源\n\n```javascript\nlet indent = 0;\nasync_hooks.createHook({\n  init(asyncId, type, triggerAsyncId) {\n    const eid = async_hooks.executionAsyncId();\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(\n      1,\n      `${indentStr}${type}(${asyncId}):` +\n      ` trigger: ${triggerAsyncId} execution: ${eid}\\n`);\n  },\n  before(asyncId) {\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(1, `${indentStr}before:  ${asyncId}\\n`);\n    indent += 2;\n  },\n  after(asyncId) {\n    indent -= 2;\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(1, `${indentStr}after:   ${asyncId}\\n`);\n  },\n  destroy(asyncId) {\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(1, `${indentStr}destroy: ${asyncId}\\n`);\n  },\n}).enable();\n\nrequire('net').createServer(() => {}).listen(8080, () => {\n  // Let's wait 10ms before logging the server started.\n  setTimeout(() => {\n    console.log('>>>', async_hooks.executionAsyncId());\n  }, 10);\n});\n\n\n// 打印\nTCPSERVERWRAP(2): trigger: 1 execution: 1\nTickObject(3): trigger: 2 execution: 1\nbefore:  3\n  Timeout(4): trigger: 3 execution: 3\n  TIMERWRAP(5): trigger: 3 execution: 3\nafter:   3\ndestroy: 3\nbefore:  5\n  before:  4\n    TTYWRAP(6): trigger: 4 execution: 4\n    SIGNALWRAP(7): trigger: 4 execution: 4\n    TTYWRAP(8): trigger: 4 execution: 4\n>>> 4\n    TickObject(9): trigger: 4 execution: 4\n  after:   4\nafter:   5\nbefore:  9\nafter:   9\ndestroy: 4\ndestroy: 9\ndestroy: 5\n```\n\n*before(asyncId)*\n当异步操作启动（如 TCP 服务器接收新连接）或完成（如将数据写入磁盘）时，会调用回调通知用户。 before 回调在所述回调执行之前被调用。 asyncId 是分配给即将执行回调的资源的唯一标识符。\n\n*after(asyncId)*\n在 before 中指定的回调完成后立即调用。\n注意：callback执行中产生异常，after在'uncaughtException' 事件或域的处理程序运行后运行\n\n*destroy(asyncId)*\nasyncId 对应的资源销毁后调用。 它也从嵌入器 API emitDestroy() 异步调用。\n注意：如果资源的回收依赖于垃圾回收机制，由于内存泄露，通过resource对象传给init的引用，destroy不会被调用。???如果不依赖垃圾回收机制，则没有上述问题。\n\n*promiseResolve(asyncId)*\n当调用传给 Promise 构造函数的 resolve 函数时调用（直接或通过其他解决 promise 的方法）。\n注意：这并不一定意味着promise在此时被resolve或reject，promise可能是通过假设另一个Promise的状态来解决的\n\n*async_hooks.executionAsyncResource()*\nexecutionAsyncResource() 返回的资源对象通常是带有未记录 API 的内部 Node.js 句柄对象。 在对象上使用任何函数或属性都可能使您的应用程序崩溃，应该避免。\n\n*async_hooks.executionAsyncId()*\n当前执行上下文的asyncId，可用于跟踪某些函数被调用的情况\n```javascript\nconst async_hooks = require('async_hooks');\n\nconsole.log(async_hooks.executionAsyncId());  // 1 - bootstrap\nfs.open(path, 'r', (err, fd) => {\n  console.log(async_hooks.executionAsyncId());  // 6 - open()\n});\n```\nexecutionAsyncId() 返回的 ID 与执行时机有关，与因果无关（被 triggerAsyncId() 涵盖）\n```javascript\nconst server = net.createServer(function onConnection(conn) {\n  // Returns the ID of the server, not of the new connection, because the\n  // onConnection callback runs in the execution scope of the server's\n  // MakeCallback().\n  async_hooks.executionAsyncId();\n\n}).listen(port, function onListening() {\n  // Returns the ID of a TickObject (i.e. process.nextTick()) because all\n  // callbacks passed to .listen() are wrapped in a nextTick().\n  async_hooks.executionAsyncId();\n});\n```\n\n*async_hooks.triggerAsyncId()*\n返回正在执行资源的Id\n默认情况下，promise 上下文可能无法获得有效的 triggerAsyncId。\n```javascript\nconst server = net.createServer((conn) => {\n  // The resource that caused (or triggered) this callback to be called\n  // was that of the new connection. Thus the return value of triggerAsyncId()\n  // is the asyncId of \"conn\".\n  async_hooks.triggerAsyncId();\n\n}).listen(port, () => {\n  // Even though all callbacks passed to .listen() are wrapped in a nextTick()\n  // the callback itself exists because the call to the server's .listen()\n  // was made. So the return value would be the ID of the server.\n  async_hooks.triggerAsyncId();\n});\n```\n\n*async_hooks.asyncWrapProviders*\n返回：提供程序类型到相应数字id的map映射。此映射包含可能由async_hooks.init发出的所有事件类型\n此特性禁止使用 process.binding('async_wrap').Providers\n\n*Promise 执行跟踪*\n默认情况下，由于 V8 提供的 promise 自省 API 相对昂贵，因此不会为 promise 执行分配 asyncId。 这意味着默认情况下，使用 promise 或 async/await 的程序将无法正确执行并触发 promise 回调上下文的 id。\n```javascript\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\nPromise.resolve(1729).then(() => {\n  console.log(`eid ${executionAsyncId()} tid ${triggerAsyncId()}`);\n});\n// produces:\n// eid 1 tid 0\n```\n```javascript\nimport { createHook, executionAsyncId, triggerAsyncId } from 'node:async_hooks';\ncreateHook({ init() {} }).enable(); // forces PromiseHooks to be enabled.\nPromise.resolve(1729).then(() => {\n  console.log(`eid ${executionAsyncId()} tid ${triggerAsyncId()}`);\n});\n// produces:\n// eid 7 tid 6\n```\n\n###### AsyncResource类\nAsyncResource类被设计为由嵌入程序的异步资源扩展。使用它，用户可以轻松地触发自己资源的生命周期事件。\n```javascript\nimport { AsyncResource, executionAsyncId } from 'node:async_hooks';\n\n// AsyncResource() is meant to be extended. Instantiating a\n// new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n// async_hook.executionAsyncId() is used.\nconst asyncResource = new AsyncResource(\n  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false }\n);\n\n// Run a function in the execution context of the resource. This will\n// * establish the context of the resource\n// * trigger the AsyncHooks before callbacks\n// * call the provided function `fn` with the supplied arguments\n// * trigger the AsyncHooks after callbacks\n// * restore the original execution context\nasyncResource.runInAsyncScope(fn, thisArg, ...args);\n\n// Call AsyncHooks destroy callbacks.\nasyncResource.emitDestroy();\n\n// Return the unique ID assigned to the AsyncResource instance.\nasyncResource.asyncId();\n\n// Return the trigger ID for the AsyncResource instance.\nasyncResource.triggerAsyncId();\n```\n\n###### AsyncLocalStorage 类\n\n\n###### 参考\nhttps://www.jianshu.com/p/4a568dac41ed","source":"nodejs/nodejs-note-6.md","raw":"---\ntitle: nodejs基础知识(2)\ndate: 2022-10-19 19:12:12\ntags: [node, assert, asyncHooks]\n---\n\n#### nodejs文档知识点\n\n###### assert-断言\n*作用：*用于测试不变式\n\n*assert.deepEqual(a, b[, message])*\n只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等\n注意：子对象中可枚举的属性也会被测试\n\n*assert.deepStrictEqual(a, b[, message])*\n与assert.deepEqual作用类似，使用全等 === 进行比较\n\n*assert.doesNotThrow(block[, error][, message])*\n调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误\n\n*assert.equal(actual, expected[, message])*\n使用相等运算符 == 测试actual与expected是否相等\n\n*assert.fail(message)*\n*assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])*\n抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 '!='。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除\n\n*assert.ifError(value)*\n如果value为真，则抛出value，即value为错误信息\n\n*assert.notDeepEqual(actual, expected[, message])*\n测试不深度相等，与assert.deepEqual()相反\n\n*assert.notDeepStrictEqual(actual, expected[, message])*\n测试是否不深度全等，与assert.deepStrictEqual()相反\n\n*assert.notEqual(actual, expected[, message])*\n使用 != 不等运算符测试参数是否不相等\n\n*assert.notStrictEqual(actual, expected[, message])*\n使用不全等运算符（!==）测试参数是否不全等\n\n*assert.ok(value[, message])*\n测试 value 是否为真值。 相当于 assert.equal(!!value, true, message)\n\n\n###### 异步钩子(Async Hooks)\nError handling(错误处理)\n应用程序运行时带有--abort on uncaught可以实现退出后，打印堆栈跟踪，留下一个核心文件\n**If any AsyncHook callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all 'uncaughtException' listeners are removed, thus forcing the process to exit. The 'exit' callbacks will still be called unless the application is run with --abort-on-uncaught-exception, in which case a stack trace will be printed and the application exits, leaving a core file.**\n\nPrinting in AsyncHook callbacks(异步钩子打印信息)\n在异步钩子函数中，打印信息查看数据不能使用 console.log等异步操作，会导致无限递归。\n推荐使用 fs.writeSync(1, msg).\n```javascript\nconst fs = require('fs');\nconst util = require('util');\n\nfunction debug(...args) {\n  // use a function like this one when debugging inside an AsyncHooks callback\n  fs.writeSync(1, `${util.format(...args)}\\n`);\n}\n```\n**Because printing to the console is an asynchronous operation, console.log() will cause AsyncHook callbacks to be called. Using console.log() or similar asynchronous operations inside an AsyncHook callback function will cause an infinite recursion. An easy solution to this when debugging is to use a synchronous logging operation such as fs.writeFileSync(file, msg, flag). This will print to the file and will not invoke AsyncHook recursively because it is synchronous.**\n\n*asyncHook.enable()*\n启用异步钩子\n\n*asyncHook.disable()*\n禁用异步钩子\n\n*init(asyncId, type, triggerAsyncId, resource)*\nasyncId: number类型，唯一标识符\ntype: string类型，异步类型\ntriggerAsyncId: number类型，在其执行上下文中创建此异步资源的异步资源的唯一ID\nresource: object类型，异步操作的资源的引用，需要在销毁期间释放\n应用场景：用于资源开启，被调用之前\n\n```javascript\nrequire('net').createServer().listen(function() { this.close(); });\n// OR\nclearTimeout(setTimeout(() => {}, 10));\n```\n注意：每个资源的ID在当前进程作用域中唯一\n\n*type*命名一般符合资源结构，比如：\n```\nFSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,\nJSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,\nSIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, TIMERWRAP, TTYWRAP,\nUDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,\nRANDOMBYTESREQUEST, TLSWRAP, Timeout, Immediate, TickObject, PROMISE\n```\n备注：type类型可能存在冲突，推荐给type添加前缀，比如 package name\n\n*triggerAsyncId*\n引起新资源初始化，调用init函数的资源的唯一标识符，triggerAsyncId展示资源为什么被创建\n```javascript\nasync_hooks.createHook({\n  init(asyncId, type, triggerAsyncId) {\n    const eid = async_hooks.executionAsyncId();\n    fs.writeSync(\n      1, `${type}(${asyncId}): trigger: ${triggerAsyncId} execution: ${eid}\\n`);\n  }\n}).enable();\n\nrequire('net').createServer((conn) => {}).listen(8080);\n```\n\n*resource*\n实际初始化的异步资源\n\n```javascript\nlet indent = 0;\nasync_hooks.createHook({\n  init(asyncId, type, triggerAsyncId) {\n    const eid = async_hooks.executionAsyncId();\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(\n      1,\n      `${indentStr}${type}(${asyncId}):` +\n      ` trigger: ${triggerAsyncId} execution: ${eid}\\n`);\n  },\n  before(asyncId) {\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(1, `${indentStr}before:  ${asyncId}\\n`);\n    indent += 2;\n  },\n  after(asyncId) {\n    indent -= 2;\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(1, `${indentStr}after:   ${asyncId}\\n`);\n  },\n  destroy(asyncId) {\n    const indentStr = ' '.repeat(indent);\n    fs.writeSync(1, `${indentStr}destroy: ${asyncId}\\n`);\n  },\n}).enable();\n\nrequire('net').createServer(() => {}).listen(8080, () => {\n  // Let's wait 10ms before logging the server started.\n  setTimeout(() => {\n    console.log('>>>', async_hooks.executionAsyncId());\n  }, 10);\n});\n\n\n// 打印\nTCPSERVERWRAP(2): trigger: 1 execution: 1\nTickObject(3): trigger: 2 execution: 1\nbefore:  3\n  Timeout(4): trigger: 3 execution: 3\n  TIMERWRAP(5): trigger: 3 execution: 3\nafter:   3\ndestroy: 3\nbefore:  5\n  before:  4\n    TTYWRAP(6): trigger: 4 execution: 4\n    SIGNALWRAP(7): trigger: 4 execution: 4\n    TTYWRAP(8): trigger: 4 execution: 4\n>>> 4\n    TickObject(9): trigger: 4 execution: 4\n  after:   4\nafter:   5\nbefore:  9\nafter:   9\ndestroy: 4\ndestroy: 9\ndestroy: 5\n```\n\n*before(asyncId)*\n当异步操作启动（如 TCP 服务器接收新连接）或完成（如将数据写入磁盘）时，会调用回调通知用户。 before 回调在所述回调执行之前被调用。 asyncId 是分配给即将执行回调的资源的唯一标识符。\n\n*after(asyncId)*\n在 before 中指定的回调完成后立即调用。\n注意：callback执行中产生异常，after在'uncaughtException' 事件或域的处理程序运行后运行\n\n*destroy(asyncId)*\nasyncId 对应的资源销毁后调用。 它也从嵌入器 API emitDestroy() 异步调用。\n注意：如果资源的回收依赖于垃圾回收机制，由于内存泄露，通过resource对象传给init的引用，destroy不会被调用。???如果不依赖垃圾回收机制，则没有上述问题。\n\n*promiseResolve(asyncId)*\n当调用传给 Promise 构造函数的 resolve 函数时调用（直接或通过其他解决 promise 的方法）。\n注意：这并不一定意味着promise在此时被resolve或reject，promise可能是通过假设另一个Promise的状态来解决的\n\n*async_hooks.executionAsyncResource()*\nexecutionAsyncResource() 返回的资源对象通常是带有未记录 API 的内部 Node.js 句柄对象。 在对象上使用任何函数或属性都可能使您的应用程序崩溃，应该避免。\n\n*async_hooks.executionAsyncId()*\n当前执行上下文的asyncId，可用于跟踪某些函数被调用的情况\n```javascript\nconst async_hooks = require('async_hooks');\n\nconsole.log(async_hooks.executionAsyncId());  // 1 - bootstrap\nfs.open(path, 'r', (err, fd) => {\n  console.log(async_hooks.executionAsyncId());  // 6 - open()\n});\n```\nexecutionAsyncId() 返回的 ID 与执行时机有关，与因果无关（被 triggerAsyncId() 涵盖）\n```javascript\nconst server = net.createServer(function onConnection(conn) {\n  // Returns the ID of the server, not of the new connection, because the\n  // onConnection callback runs in the execution scope of the server's\n  // MakeCallback().\n  async_hooks.executionAsyncId();\n\n}).listen(port, function onListening() {\n  // Returns the ID of a TickObject (i.e. process.nextTick()) because all\n  // callbacks passed to .listen() are wrapped in a nextTick().\n  async_hooks.executionAsyncId();\n});\n```\n\n*async_hooks.triggerAsyncId()*\n返回正在执行资源的Id\n默认情况下，promise 上下文可能无法获得有效的 triggerAsyncId。\n```javascript\nconst server = net.createServer((conn) => {\n  // The resource that caused (or triggered) this callback to be called\n  // was that of the new connection. Thus the return value of triggerAsyncId()\n  // is the asyncId of \"conn\".\n  async_hooks.triggerAsyncId();\n\n}).listen(port, () => {\n  // Even though all callbacks passed to .listen() are wrapped in a nextTick()\n  // the callback itself exists because the call to the server's .listen()\n  // was made. So the return value would be the ID of the server.\n  async_hooks.triggerAsyncId();\n});\n```\n\n*async_hooks.asyncWrapProviders*\n返回：提供程序类型到相应数字id的map映射。此映射包含可能由async_hooks.init发出的所有事件类型\n此特性禁止使用 process.binding('async_wrap').Providers\n\n*Promise 执行跟踪*\n默认情况下，由于 V8 提供的 promise 自省 API 相对昂贵，因此不会为 promise 执行分配 asyncId。 这意味着默认情况下，使用 promise 或 async/await 的程序将无法正确执行并触发 promise 回调上下文的 id。\n```javascript\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\nPromise.resolve(1729).then(() => {\n  console.log(`eid ${executionAsyncId()} tid ${triggerAsyncId()}`);\n});\n// produces:\n// eid 1 tid 0\n```\n```javascript\nimport { createHook, executionAsyncId, triggerAsyncId } from 'node:async_hooks';\ncreateHook({ init() {} }).enable(); // forces PromiseHooks to be enabled.\nPromise.resolve(1729).then(() => {\n  console.log(`eid ${executionAsyncId()} tid ${triggerAsyncId()}`);\n});\n// produces:\n// eid 7 tid 6\n```\n\n###### AsyncResource类\nAsyncResource类被设计为由嵌入程序的异步资源扩展。使用它，用户可以轻松地触发自己资源的生命周期事件。\n```javascript\nimport { AsyncResource, executionAsyncId } from 'node:async_hooks';\n\n// AsyncResource() is meant to be extended. Instantiating a\n// new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n// async_hook.executionAsyncId() is used.\nconst asyncResource = new AsyncResource(\n  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false }\n);\n\n// Run a function in the execution context of the resource. This will\n// * establish the context of the resource\n// * trigger the AsyncHooks before callbacks\n// * call the provided function `fn` with the supplied arguments\n// * trigger the AsyncHooks after callbacks\n// * restore the original execution context\nasyncResource.runInAsyncScope(fn, thisArg, ...args);\n\n// Call AsyncHooks destroy callbacks.\nasyncResource.emitDestroy();\n\n// Return the unique ID assigned to the AsyncResource instance.\nasyncResource.asyncId();\n\n// Return the trigger ID for the AsyncResource instance.\nasyncResource.triggerAsyncId();\n```\n\n###### AsyncLocalStorage 类\n\n\n###### 参考\nhttps://www.jianshu.com/p/4a568dac41ed","updated":"2022-11-01T03:28:15.463Z","path":"nodejs/nodejs-note-6.html","comments":1,"layout":"page","_id":"clchh4gwv000ycktt2z1l1pot","content":"<h4 id=\"nodejs文档知识点\"><a href=\"#nodejs文档知识点\" class=\"headerlink\" title=\"nodejs文档知识点\"></a>nodejs文档知识点</h4><h6 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert-断言\"></a>assert-断言</h6><p><em>作用：</em>用于测试不变式</p>\n<p><em>assert.deepEqual(a, b[, message])</em><br>只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等<br>注意：子对象中可枚举的属性也会被测试</p>\n<p><em>assert.deepStrictEqual(a, b[, message])</em><br>与assert.deepEqual作用类似，使用全等 === 进行比较</p>\n<p><em>assert.doesNotThrow(block[, error][, message])</em><br>调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误</p>\n<p><em>assert.equal(actual, expected[, message])</em><br>使用相等运算符 == 测试actual与expected是否相等</p>\n<p><em>assert.fail(message)</em><br><em>assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])</em><br>抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 ‘!=’。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除</p>\n<p><em>assert.ifError(value)</em><br>如果value为真，则抛出value，即value为错误信息</p>\n<p><em>assert.notDeepEqual(actual, expected[, message])</em><br>测试不深度相等，与assert.deepEqual()相反</p>\n<p><em>assert.notDeepStrictEqual(actual, expected[, message])</em><br>测试是否不深度全等，与assert.deepStrictEqual()相反</p>\n<p><em>assert.notEqual(actual, expected[, message])</em><br>使用 != 不等运算符测试参数是否不相等</p>\n<p><em>assert.notStrictEqual(actual, expected[, message])</em><br>使用不全等运算符（!==）测试参数是否不全等</p>\n<p><em>assert.ok(value[, message])</em><br>测试 value 是否为真值。 相当于 assert.equal(!!value, true, message)</p>\n<h6 id=\"异步钩子-Async-Hooks\"><a href=\"#异步钩子-Async-Hooks\" class=\"headerlink\" title=\"异步钩子(Async Hooks)\"></a>异步钩子(Async Hooks)</h6><p>Error handling(错误处理)<br>应用程序运行时带有–abort on uncaught可以实现退出后，打印堆栈跟踪，留下一个核心文件<br><strong>If any AsyncHook callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all ‘uncaughtException’ listeners are removed, thus forcing the process to exit. The ‘exit’ callbacks will still be called unless the application is run with –abort-on-uncaught-exception, in which case a stack trace will be printed and the application exits, leaving a core file.</strong></p>\n<p>Printing in AsyncHook callbacks(异步钩子打印信息)<br>在异步钩子函数中，打印信息查看数据不能使用 console.log等异步操作，会导致无限递归。<br>推荐使用 fs.writeSync(1, msg).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debug</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// use a function like this one when debugging inside an AsyncHooks callback</span></span><br><span class=\"line\">  fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;util.format(...args)&#125;</span>\\n`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Because printing to the console is an asynchronous operation, console.log() will cause AsyncHook callbacks to be called. Using console.log() or similar asynchronous operations inside an AsyncHook callback function will cause an infinite recursion. An easy solution to this when debugging is to use a synchronous logging operation such as fs.writeFileSync(file, msg, flag). This will print to the file and will not invoke AsyncHook recursively because it is synchronous.</strong></p>\n<p><em>asyncHook.enable()</em><br>启用异步钩子</p>\n<p><em>asyncHook.disable()</em><br>禁用异步钩子</p>\n<p><em>init(asyncId, type, triggerAsyncId, resource)</em><br>asyncId: number类型，唯一标识符<br>type: string类型，异步类型<br>triggerAsyncId: number类型，在其执行上下文中创建此异步资源的异步资源的唯一ID<br>resource: object类型，异步操作的资源的引用，需要在销毁期间释放<br>应用场景：用于资源开启，被调用之前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).createServer().listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">this</span>.close(); &#125;);</span><br><span class=\"line\"><span class=\"comment\">// OR</span></span><br><span class=\"line\"><span class=\"built_in\">clearTimeout</span>(<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;, <span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n<p>注意：每个资源的ID在当前进程作用域中唯一</p>\n<p><em>type</em>命名一般符合资源结构，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,</span><br><span class=\"line\">JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,</span><br><span class=\"line\">SIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, TIMERWRAP, TTYWRAP,</span><br><span class=\"line\">UDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,</span><br><span class=\"line\">RANDOMBYTESREQUEST, TLSWRAP, Timeout, Immediate, TickObject, PROMISE</span><br></pre></td></tr></table></figure>\n<p>备注：type类型可能存在冲突，推荐给type添加前缀，比如 package name</p>\n<p><em>triggerAsyncId</em><br>引起新资源初始化，调用init函数的资源的唯一标识符，triggerAsyncId展示资源为什么被创建</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async_hooks.createHook(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\">asyncId, type, triggerAsyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> eid = async_hooks.executionAsyncId();</span><br><span class=\"line\">    fs.writeSync(</span><br><span class=\"line\">      <span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>(<span class=\"subst\">$&#123;asyncId&#125;</span>): trigger: <span class=\"subst\">$&#123;triggerAsyncId&#125;</span> execution: <span class=\"subst\">$&#123;eid&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).enable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).createServer(<span class=\"function\">(<span class=\"params\">conn</span>) =&gt;</span> &#123;&#125;).listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>resource</em><br>实际初始化的异步资源</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indent = <span class=\"number\">0</span>;</span><br><span class=\"line\">async_hooks.createHook(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\">asyncId, type, triggerAsyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> eid = async_hooks.executionAsyncId();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(</span><br><span class=\"line\">      <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span><span class=\"subst\">$&#123;type&#125;</span>(<span class=\"subst\">$&#123;asyncId&#125;</span>):`</span> +</span><br><span class=\"line\">      <span class=\"string\">` trigger: <span class=\"subst\">$&#123;triggerAsyncId&#125;</span> execution: <span class=\"subst\">$&#123;eid&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">before</span>(<span class=\"params\">asyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>before:  <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>);</span><br><span class=\"line\">    indent += <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">after</span>(<span class=\"params\">asyncId</span>)</span> &#123;</span><br><span class=\"line\">    indent -= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>after:   <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">destroy</span>(<span class=\"params\">asyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>destroy: <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;).enable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).createServer(<span class=\"function\">() =&gt;</span> &#123;&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Let&#x27;s wait 10ms before logging the server started.</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;&gt;&gt;&gt;&#x27;</span>, async_hooks.executionAsyncId());</span><br><span class=\"line\">  &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印</span></span><br><span class=\"line\">TCPSERVERWRAP(<span class=\"number\">2</span>): trigger: <span class=\"number\">1</span> execution: <span class=\"number\">1</span></span><br><span class=\"line\">TickObject(<span class=\"number\">3</span>): trigger: <span class=\"number\">2</span> execution: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">before</span>:  <span class=\"number\">3</span></span><br><span class=\"line\">  Timeout(<span class=\"number\">4</span>): trigger: <span class=\"number\">3</span> execution: <span class=\"number\">3</span></span><br><span class=\"line\">  TIMERWRAP(<span class=\"number\">5</span>): trigger: <span class=\"number\">3</span> execution: <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">after</span>:   <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">before</span>:  <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"attr\">before</span>:  <span class=\"number\">4</span></span><br><span class=\"line\">    TTYWRAP(<span class=\"number\">6</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">    SIGNALWRAP(<span class=\"number\">7</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">    TTYWRAP(<span class=\"number\">8</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"number\">4</span></span><br><span class=\"line\">    TickObject(<span class=\"number\">9</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"attr\">after</span>:   <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">after</span>:   <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">before</span>:  <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"attr\">after</span>:   <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p><em>before(asyncId)</em><br>当异步操作启动（如 TCP 服务器接收新连接）或完成（如将数据写入磁盘）时，会调用回调通知用户。 before 回调在所述回调执行之前被调用。 asyncId 是分配给即将执行回调的资源的唯一标识符。</p>\n<p><em>after(asyncId)</em><br>在 before 中指定的回调完成后立即调用。<br>注意：callback执行中产生异常，after在’uncaughtException’ 事件或域的处理程序运行后运行</p>\n<p><em>destroy(asyncId)</em><br>asyncId 对应的资源销毁后调用。 它也从嵌入器 API emitDestroy() 异步调用。<br>注意：如果资源的回收依赖于垃圾回收机制，由于内存泄露，通过resource对象传给init的引用，destroy不会被调用。???如果不依赖垃圾回收机制，则没有上述问题。</p>\n<p><em>promiseResolve(asyncId)</em><br>当调用传给 Promise 构造函数的 resolve 函数时调用（直接或通过其他解决 promise 的方法）。<br>注意：这并不一定意味着promise在此时被resolve或reject，promise可能是通过假设另一个Promise的状态来解决的</p>\n<p><em>async_hooks.executionAsyncResource()</em><br>executionAsyncResource() 返回的资源对象通常是带有未记录 API 的内部 Node.js 句柄对象。 在对象上使用任何函数或属性都可能使您的应用程序崩溃，应该避免。</p>\n<p><em>async_hooks.executionAsyncId()</em><br>当前执行上下文的asyncId，可用于跟踪某些函数被调用的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> async_hooks = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;async_hooks&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(async_hooks.executionAsyncId());  <span class=\"comment\">// 1 - bootstrap</span></span><br><span class=\"line\">fs.open(path, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, fd</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(async_hooks.executionAsyncId());  <span class=\"comment\">// 6 - open()</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>executionAsyncId() 返回的 ID 与执行时机有关，与因果无关（被 triggerAsyncId() 涵盖）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onConnection</span>(<span class=\"params\">conn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Returns the ID of the server, not of the new connection, because the</span></span><br><span class=\"line\">  <span class=\"comment\">// onConnection callback runs in the execution scope of the server&#x27;s</span></span><br><span class=\"line\">  <span class=\"comment\">// MakeCallback().</span></span><br><span class=\"line\">  async_hooks.executionAsyncId();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).listen(port, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onListening</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Returns the ID of a TickObject (i.e. process.nextTick()) because all</span></span><br><span class=\"line\">  <span class=\"comment\">// callbacks passed to .listen() are wrapped in a nextTick().</span></span><br><span class=\"line\">  async_hooks.executionAsyncId();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><em>async_hooks.triggerAsyncId()</em><br>返回正在执行资源的Id<br>默认情况下，promise 上下文可能无法获得有效的 triggerAsyncId。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">conn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// The resource that caused (or triggered) this callback to be called</span></span><br><span class=\"line\">  <span class=\"comment\">// was that of the new connection. Thus the return value of triggerAsyncId()</span></span><br><span class=\"line\">  <span class=\"comment\">// is the asyncId of &quot;conn&quot;.</span></span><br><span class=\"line\">  async_hooks.triggerAsyncId();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).listen(port, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Even though all callbacks passed to .listen() are wrapped in a nextTick()</span></span><br><span class=\"line\">  <span class=\"comment\">// the callback itself exists because the call to the server&#x27;s .listen()</span></span><br><span class=\"line\">  <span class=\"comment\">// was made. So the return value would be the ID of the server.</span></span><br><span class=\"line\">  async_hooks.triggerAsyncId();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><em>async_hooks.asyncWrapProviders</em><br>返回：提供程序类型到相应数字id的map映射。此映射包含可能由async_hooks.init发出的所有事件类型<br>此特性禁止使用 process.binding(‘async_wrap’).Providers</p>\n<p><em>Promise 执行跟踪</em><br>默认情况下，由于 V8 提供的 promise 自省 API 相对昂贵，因此不会为 promise 执行分配 asyncId。 这意味着默认情况下，使用 promise 或 async/await 的程序将无法正确执行并触发 promise 回调上下文的 id。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; executionAsyncId, triggerAsyncId &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node:async_hooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1729</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`eid <span class=\"subst\">$&#123;executionAsyncId()&#125;</span> tid <span class=\"subst\">$&#123;triggerAsyncId()&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// produces:</span></span><br><span class=\"line\"><span class=\"comment\">// eid 1 tid 0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createHook, executionAsyncId, triggerAsyncId &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node:async_hooks&#x27;</span>;</span><br><span class=\"line\">createHook(&#123; <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\"></span>)</span> &#123;&#125; &#125;).enable(); <span class=\"comment\">// forces PromiseHooks to be enabled.</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1729</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`eid <span class=\"subst\">$&#123;executionAsyncId()&#125;</span> tid <span class=\"subst\">$&#123;triggerAsyncId()&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// produces:</span></span><br><span class=\"line\"><span class=\"comment\">// eid 7 tid 6</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"AsyncResource类\"><a href=\"#AsyncResource类\" class=\"headerlink\" title=\"AsyncResource类\"></a>AsyncResource类</h6><p>AsyncResource类被设计为由嵌入程序的异步资源扩展。使用它，用户可以轻松地触发自己资源的生命周期事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; AsyncResource, executionAsyncId &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node:async_hooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AsyncResource() is meant to be extended. Instantiating a</span></span><br><span class=\"line\"><span class=\"comment\">// new AsyncResource() also triggers init. If triggerAsyncId is omitted then</span></span><br><span class=\"line\"><span class=\"comment\">// async_hook.executionAsyncId() is used.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncResource = <span class=\"keyword\">new</span> AsyncResource(</span><br><span class=\"line\">  type, &#123; <span class=\"attr\">triggerAsyncId</span>: executionAsyncId(), <span class=\"attr\">requireManualDestroy</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Run a function in the execution context of the resource. This will</span></span><br><span class=\"line\"><span class=\"comment\">// * establish the context of the resource</span></span><br><span class=\"line\"><span class=\"comment\">// * trigger the AsyncHooks before callbacks</span></span><br><span class=\"line\"><span class=\"comment\">// * call the provided function `fn` with the supplied arguments</span></span><br><span class=\"line\"><span class=\"comment\">// * trigger the AsyncHooks after callbacks</span></span><br><span class=\"line\"><span class=\"comment\">// * restore the original execution context</span></span><br><span class=\"line\">asyncResource.runInAsyncScope(fn, thisArg, ...args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Call AsyncHooks destroy callbacks.</span></span><br><span class=\"line\">asyncResource.emitDestroy();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Return the unique ID assigned to the AsyncResource instance.</span></span><br><span class=\"line\">asyncResource.asyncId();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Return the trigger ID for the AsyncResource instance.</span></span><br><span class=\"line\">asyncResource.triggerAsyncId();</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"AsyncLocalStorage-类\"><a href=\"#AsyncLocalStorage-类\" class=\"headerlink\" title=\"AsyncLocalStorage 类\"></a>AsyncLocalStorage 类</h6><h6 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h6><p><a href=\"https://www.jianshu.com/p/4a568dac41ed\">https://www.jianshu.com/p/4a568dac41ed</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"nodejs文档知识点\"><a href=\"#nodejs文档知识点\" class=\"headerlink\" title=\"nodejs文档知识点\"></a>nodejs文档知识点</h4><h6 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert-断言\"></a>assert-断言</h6><p><em>作用：</em>用于测试不变式</p>\n<p><em>assert.deepEqual(a, b[, message])</em><br>只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等<br>注意：子对象中可枚举的属性也会被测试</p>\n<p><em>assert.deepStrictEqual(a, b[, message])</em><br>与assert.deepEqual作用类似，使用全等 === 进行比较</p>\n<p><em>assert.doesNotThrow(block[, error][, message])</em><br>调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误</p>\n<p><em>assert.equal(actual, expected[, message])</em><br>使用相等运算符 == 测试actual与expected是否相等</p>\n<p><em>assert.fail(message)</em><br><em>assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])</em><br>抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 ‘!=’。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除</p>\n<p><em>assert.ifError(value)</em><br>如果value为真，则抛出value，即value为错误信息</p>\n<p><em>assert.notDeepEqual(actual, expected[, message])</em><br>测试不深度相等，与assert.deepEqual()相反</p>\n<p><em>assert.notDeepStrictEqual(actual, expected[, message])</em><br>测试是否不深度全等，与assert.deepStrictEqual()相反</p>\n<p><em>assert.notEqual(actual, expected[, message])</em><br>使用 != 不等运算符测试参数是否不相等</p>\n<p><em>assert.notStrictEqual(actual, expected[, message])</em><br>使用不全等运算符（!==）测试参数是否不全等</p>\n<p><em>assert.ok(value[, message])</em><br>测试 value 是否为真值。 相当于 assert.equal(!!value, true, message)</p>\n<h6 id=\"异步钩子-Async-Hooks\"><a href=\"#异步钩子-Async-Hooks\" class=\"headerlink\" title=\"异步钩子(Async Hooks)\"></a>异步钩子(Async Hooks)</h6><p>Error handling(错误处理)<br>应用程序运行时带有–abort on uncaught可以实现退出后，打印堆栈跟踪，留下一个核心文件<br><strong>If any AsyncHook callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all ‘uncaughtException’ listeners are removed, thus forcing the process to exit. The ‘exit’ callbacks will still be called unless the application is run with –abort-on-uncaught-exception, in which case a stack trace will be printed and the application exits, leaving a core file.</strong></p>\n<p>Printing in AsyncHook callbacks(异步钩子打印信息)<br>在异步钩子函数中，打印信息查看数据不能使用 console.log等异步操作，会导致无限递归。<br>推荐使用 fs.writeSync(1, msg).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debug</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// use a function like this one when debugging inside an AsyncHooks callback</span></span><br><span class=\"line\">  fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;util.format(...args)&#125;</span>\\n`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Because printing to the console is an asynchronous operation, console.log() will cause AsyncHook callbacks to be called. Using console.log() or similar asynchronous operations inside an AsyncHook callback function will cause an infinite recursion. An easy solution to this when debugging is to use a synchronous logging operation such as fs.writeFileSync(file, msg, flag). This will print to the file and will not invoke AsyncHook recursively because it is synchronous.</strong></p>\n<p><em>asyncHook.enable()</em><br>启用异步钩子</p>\n<p><em>asyncHook.disable()</em><br>禁用异步钩子</p>\n<p><em>init(asyncId, type, triggerAsyncId, resource)</em><br>asyncId: number类型，唯一标识符<br>type: string类型，异步类型<br>triggerAsyncId: number类型，在其执行上下文中创建此异步资源的异步资源的唯一ID<br>resource: object类型，异步操作的资源的引用，需要在销毁期间释放<br>应用场景：用于资源开启，被调用之前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).createServer().listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">this</span>.close(); &#125;);</span><br><span class=\"line\"><span class=\"comment\">// OR</span></span><br><span class=\"line\"><span class=\"built_in\">clearTimeout</span>(<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;, <span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n<p>注意：每个资源的ID在当前进程作用域中唯一</p>\n<p><em>type</em>命名一般符合资源结构，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,</span><br><span class=\"line\">JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,</span><br><span class=\"line\">SIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, TIMERWRAP, TTYWRAP,</span><br><span class=\"line\">UDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,</span><br><span class=\"line\">RANDOMBYTESREQUEST, TLSWRAP, Timeout, Immediate, TickObject, PROMISE</span><br></pre></td></tr></table></figure>\n<p>备注：type类型可能存在冲突，推荐给type添加前缀，比如 package name</p>\n<p><em>triggerAsyncId</em><br>引起新资源初始化，调用init函数的资源的唯一标识符，triggerAsyncId展示资源为什么被创建</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async_hooks.createHook(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\">asyncId, type, triggerAsyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> eid = async_hooks.executionAsyncId();</span><br><span class=\"line\">    fs.writeSync(</span><br><span class=\"line\">      <span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>(<span class=\"subst\">$&#123;asyncId&#125;</span>): trigger: <span class=\"subst\">$&#123;triggerAsyncId&#125;</span> execution: <span class=\"subst\">$&#123;eid&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).enable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).createServer(<span class=\"function\">(<span class=\"params\">conn</span>) =&gt;</span> &#123;&#125;).listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>resource</em><br>实际初始化的异步资源</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indent = <span class=\"number\">0</span>;</span><br><span class=\"line\">async_hooks.createHook(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\">asyncId, type, triggerAsyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> eid = async_hooks.executionAsyncId();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(</span><br><span class=\"line\">      <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span><span class=\"subst\">$&#123;type&#125;</span>(<span class=\"subst\">$&#123;asyncId&#125;</span>):`</span> +</span><br><span class=\"line\">      <span class=\"string\">` trigger: <span class=\"subst\">$&#123;triggerAsyncId&#125;</span> execution: <span class=\"subst\">$&#123;eid&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">before</span>(<span class=\"params\">asyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>before:  <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>);</span><br><span class=\"line\">    indent += <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">after</span>(<span class=\"params\">asyncId</span>)</span> &#123;</span><br><span class=\"line\">    indent -= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>after:   <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">destroy</span>(<span class=\"params\">asyncId</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> indentStr = <span class=\"string\">&#x27; &#x27;</span>.repeat(indent);</span><br><span class=\"line\">    fs.writeSync(<span class=\"number\">1</span>, <span class=\"string\">`<span class=\"subst\">$&#123;indentStr&#125;</span>destroy: <span class=\"subst\">$&#123;asyncId&#125;</span>\\n`</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;).enable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>).createServer(<span class=\"function\">() =&gt;</span> &#123;&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Let&#x27;s wait 10ms before logging the server started.</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;&gt;&gt;&gt;&#x27;</span>, async_hooks.executionAsyncId());</span><br><span class=\"line\">  &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印</span></span><br><span class=\"line\">TCPSERVERWRAP(<span class=\"number\">2</span>): trigger: <span class=\"number\">1</span> execution: <span class=\"number\">1</span></span><br><span class=\"line\">TickObject(<span class=\"number\">3</span>): trigger: <span class=\"number\">2</span> execution: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">before</span>:  <span class=\"number\">3</span></span><br><span class=\"line\">  Timeout(<span class=\"number\">4</span>): trigger: <span class=\"number\">3</span> execution: <span class=\"number\">3</span></span><br><span class=\"line\">  TIMERWRAP(<span class=\"number\">5</span>): trigger: <span class=\"number\">3</span> execution: <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">after</span>:   <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">before</span>:  <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"attr\">before</span>:  <span class=\"number\">4</span></span><br><span class=\"line\">    TTYWRAP(<span class=\"number\">6</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">    SIGNALWRAP(<span class=\"number\">7</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">    TTYWRAP(<span class=\"number\">8</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"number\">4</span></span><br><span class=\"line\">    TickObject(<span class=\"number\">9</span>): trigger: <span class=\"number\">4</span> execution: <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"attr\">after</span>:   <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">after</span>:   <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">before</span>:  <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"attr\">after</span>:   <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"attr\">destroy</span>: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p><em>before(asyncId)</em><br>当异步操作启动（如 TCP 服务器接收新连接）或完成（如将数据写入磁盘）时，会调用回调通知用户。 before 回调在所述回调执行之前被调用。 asyncId 是分配给即将执行回调的资源的唯一标识符。</p>\n<p><em>after(asyncId)</em><br>在 before 中指定的回调完成后立即调用。<br>注意：callback执行中产生异常，after在’uncaughtException’ 事件或域的处理程序运行后运行</p>\n<p><em>destroy(asyncId)</em><br>asyncId 对应的资源销毁后调用。 它也从嵌入器 API emitDestroy() 异步调用。<br>注意：如果资源的回收依赖于垃圾回收机制，由于内存泄露，通过resource对象传给init的引用，destroy不会被调用。???如果不依赖垃圾回收机制，则没有上述问题。</p>\n<p><em>promiseResolve(asyncId)</em><br>当调用传给 Promise 构造函数的 resolve 函数时调用（直接或通过其他解决 promise 的方法）。<br>注意：这并不一定意味着promise在此时被resolve或reject，promise可能是通过假设另一个Promise的状态来解决的</p>\n<p><em>async_hooks.executionAsyncResource()</em><br>executionAsyncResource() 返回的资源对象通常是带有未记录 API 的内部 Node.js 句柄对象。 在对象上使用任何函数或属性都可能使您的应用程序崩溃，应该避免。</p>\n<p><em>async_hooks.executionAsyncId()</em><br>当前执行上下文的asyncId，可用于跟踪某些函数被调用的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> async_hooks = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;async_hooks&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(async_hooks.executionAsyncId());  <span class=\"comment\">// 1 - bootstrap</span></span><br><span class=\"line\">fs.open(path, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, fd</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(async_hooks.executionAsyncId());  <span class=\"comment\">// 6 - open()</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>executionAsyncId() 返回的 ID 与执行时机有关，与因果无关（被 triggerAsyncId() 涵盖）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onConnection</span>(<span class=\"params\">conn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Returns the ID of the server, not of the new connection, because the</span></span><br><span class=\"line\">  <span class=\"comment\">// onConnection callback runs in the execution scope of the server&#x27;s</span></span><br><span class=\"line\">  <span class=\"comment\">// MakeCallback().</span></span><br><span class=\"line\">  async_hooks.executionAsyncId();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).listen(port, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onListening</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Returns the ID of a TickObject (i.e. process.nextTick()) because all</span></span><br><span class=\"line\">  <span class=\"comment\">// callbacks passed to .listen() are wrapped in a nextTick().</span></span><br><span class=\"line\">  async_hooks.executionAsyncId();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><em>async_hooks.triggerAsyncId()</em><br>返回正在执行资源的Id<br>默认情况下，promise 上下文可能无法获得有效的 triggerAsyncId。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer(<span class=\"function\">(<span class=\"params\">conn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// The resource that caused (or triggered) this callback to be called</span></span><br><span class=\"line\">  <span class=\"comment\">// was that of the new connection. Thus the return value of triggerAsyncId()</span></span><br><span class=\"line\">  <span class=\"comment\">// is the asyncId of &quot;conn&quot;.</span></span><br><span class=\"line\">  async_hooks.triggerAsyncId();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).listen(port, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Even though all callbacks passed to .listen() are wrapped in a nextTick()</span></span><br><span class=\"line\">  <span class=\"comment\">// the callback itself exists because the call to the server&#x27;s .listen()</span></span><br><span class=\"line\">  <span class=\"comment\">// was made. So the return value would be the ID of the server.</span></span><br><span class=\"line\">  async_hooks.triggerAsyncId();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><em>async_hooks.asyncWrapProviders</em><br>返回：提供程序类型到相应数字id的map映射。此映射包含可能由async_hooks.init发出的所有事件类型<br>此特性禁止使用 process.binding(‘async_wrap’).Providers</p>\n<p><em>Promise 执行跟踪</em><br>默认情况下，由于 V8 提供的 promise 自省 API 相对昂贵，因此不会为 promise 执行分配 asyncId。 这意味着默认情况下，使用 promise 或 async/await 的程序将无法正确执行并触发 promise 回调上下文的 id。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; executionAsyncId, triggerAsyncId &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node:async_hooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1729</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`eid <span class=\"subst\">$&#123;executionAsyncId()&#125;</span> tid <span class=\"subst\">$&#123;triggerAsyncId()&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// produces:</span></span><br><span class=\"line\"><span class=\"comment\">// eid 1 tid 0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createHook, executionAsyncId, triggerAsyncId &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node:async_hooks&#x27;</span>;</span><br><span class=\"line\">createHook(&#123; <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\"></span>)</span> &#123;&#125; &#125;).enable(); <span class=\"comment\">// forces PromiseHooks to be enabled.</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1729</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`eid <span class=\"subst\">$&#123;executionAsyncId()&#125;</span> tid <span class=\"subst\">$&#123;triggerAsyncId()&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// produces:</span></span><br><span class=\"line\"><span class=\"comment\">// eid 7 tid 6</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"AsyncResource类\"><a href=\"#AsyncResource类\" class=\"headerlink\" title=\"AsyncResource类\"></a>AsyncResource类</h6><p>AsyncResource类被设计为由嵌入程序的异步资源扩展。使用它，用户可以轻松地触发自己资源的生命周期事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; AsyncResource, executionAsyncId &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node:async_hooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AsyncResource() is meant to be extended. Instantiating a</span></span><br><span class=\"line\"><span class=\"comment\">// new AsyncResource() also triggers init. If triggerAsyncId is omitted then</span></span><br><span class=\"line\"><span class=\"comment\">// async_hook.executionAsyncId() is used.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncResource = <span class=\"keyword\">new</span> AsyncResource(</span><br><span class=\"line\">  type, &#123; <span class=\"attr\">triggerAsyncId</span>: executionAsyncId(), <span class=\"attr\">requireManualDestroy</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Run a function in the execution context of the resource. This will</span></span><br><span class=\"line\"><span class=\"comment\">// * establish the context of the resource</span></span><br><span class=\"line\"><span class=\"comment\">// * trigger the AsyncHooks before callbacks</span></span><br><span class=\"line\"><span class=\"comment\">// * call the provided function `fn` with the supplied arguments</span></span><br><span class=\"line\"><span class=\"comment\">// * trigger the AsyncHooks after callbacks</span></span><br><span class=\"line\"><span class=\"comment\">// * restore the original execution context</span></span><br><span class=\"line\">asyncResource.runInAsyncScope(fn, thisArg, ...args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Call AsyncHooks destroy callbacks.</span></span><br><span class=\"line\">asyncResource.emitDestroy();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Return the unique ID assigned to the AsyncResource instance.</span></span><br><span class=\"line\">asyncResource.asyncId();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Return the trigger ID for the AsyncResource instance.</span></span><br><span class=\"line\">asyncResource.triggerAsyncId();</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"AsyncLocalStorage-类\"><a href=\"#AsyncLocalStorage-类\" class=\"headerlink\" title=\"AsyncLocalStorage 类\"></a>AsyncLocalStorage 类</h6><h6 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h6><p><a href=\"https://www.jianshu.com/p/4a568dac41ed\">https://www.jianshu.com/p/4a568dac41ed</a></p>\n"},{"title":"深入浅出nodejs阅读笔记(3)","date":"2022-11-26T12:36:45.000Z","tags":["node","docs"],"_content":"\n#### 内存控制\n- V8 的对象分配\n  - 在V8中，所有的JavaScript对象都是通过堆来进行分配的。\n  - V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制\n  - Node在启动时可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小\n\n- V8 的垃圾回收机制\n  - V8主要的垃圾回收算法\n    - V8的垃圾回收策略主要基于分代式垃圾回收机制。\n    - V8的内存分代在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象\n    - V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提及的--max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，-max-new-space-size命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错\n    - 在默认设置下，如果一直分配内存，在64位系统和32位系统下会分别只能使用约1.4 GB和约0.7 GB的大小\n    - 新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB\n  - Scavenge算法\n    - 在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法\n    - Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。\n    - 在单纯的Scavenge过程中，From空间中的存活对象会被复制到To空间中去，然后对From空间和To空间进行角色对换（又称翻转）。但在分代式垃圾回收的前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。\n    - ![晋升流程](./images/v8-promot.png)\n    - ![晋升流程](./images/v8-promot2.png)\n  - Mark-Sweep & Mark-Compact\n    - V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象\n    - Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态\n    - Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存\n    - ![标记移动](./images/sweep-compact.png)\n    - ![算法对比](./images/collect-diff.png)\n    - V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact\n  - Incremental Marking\n    - 垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。\n    - 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成\n    - ![增量标记](./images/increase-target.png)\n  - 查看垃圾回收日志\n    - 查看垃圾回收日志的方式主要是在启动时添加--trace_gc参数\n    - 通过在Node启动时使用--prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间\n###### 高效使用内存\n- 作用域\n  - 标识符查找\n  - 作用域链\n  - 变量的主动释放\n- 闭包\n  - 实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）\n- 内存指标: process.memoryUsage()可以查看内存使用情况。除此之外，os模块中的totalmem()和freemem()方法也可以查看内存使用情况\n  - 查看内存使用情况\n    - 查看进程的内存占用\n```javascript\n$ node \n> process.memoryUsage() \n{ rss: 13852672, \n heapTotal: 6131200, \n heapUsed: 2757120 } \n```\n    - rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节\n  - 2. 查看系统的内存占用\n    - 与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位\n\n- 堆外内存: 将那些不是通过V8分配的内存称为堆外内存\n  - Buffer对象并非通过V8分配\n```\nvar useMem = function () { \n var size = 200 * 1024 * 1024; \n var buffer = new Buffer(size); \n for (var i = 0; i < size; i++) { \n buffer[i] = 0; \n } \n return buffer; \n}; \n```\n###### 内存泄漏\nNode对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃\n\n造成内存泄漏的原因\n  - 缓存。\n    - 在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功\n    - 用对象的键值对来缓存东西，与严格意义上的缓存有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有\n  - 解决手段：限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长\n    - 缓存限制策略\n      - 记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰\n      - LRU算法的缓存，地址为https://github.com/isaacs/node-lru-cache\n    - 缓存的解决方案\n      - 采用进程外的缓存，进程自身不存储状态\n        - (1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。\n        - (2) 进程之间可以共享缓存\n        - Redis：https://github.com/mranney/node_redis。\n        - Memcached：https://github.com/3rd-Eden/node-memcached。\n  - 队列消费不及时。\n    - 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。\n    - 任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值\n  - 作用域未释放\n\n###### 内存泄漏排查\n常见工具：\n- v8-profiler\n- node-heapdump\n```\nvar leakArray = []; \nvar leak = function () { \n leakArray.push(\"leak\" + Math.random()); \n}; \nhttp.createServer(function (req, res) { \n leak(); \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('Hello World\\n'); \n}).listen(1337); \nconsole.log('Server running at http://127.0.0.1:1337/'); \n```\n- node-mtrace\n- dtrace\n- node-memwatch\n```\nvar memwatch = require('memwatch'); \nmemwatch.on('leak', function (info) { \n console.log('leak:'); \n console.log(info); \n}); \nmemwatch.on('stats', function (stats) { \n console.log('stats:') \n console.log(stats); \n}); \nvar http = require('http'); \nvar leakArray = []; \nvar leak = function () { \n leakArray.push(\"leak\" + Math.random()); \n}; \nhttp.createServer(function (req, res) { \n leak(); \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('Hello World\\n'); \n}).listen(1337); \nconsole.log('Server running at http://127.0.0.1:1337/'); \n```\n  - stats事件\n    - 每次进行全堆垃圾回收时，将会触发一次stats事件\n```\nstats: \n{ num_full_gc: 4, // 第几次全堆垃圾回收\n num_inc_gc: 23, // 第几次增量垃圾回收\n heap_compactions: 4, // 第几次对老生代进行整理\n usage_trend: 0, // 使用趋势\n estimated_base: 7152944, // 预估基数\n current_base: 7152944, // 当前基数\n min: 6720776, // 最小\n max: 7152944 } // 最大\n在这些数据中，num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况\n```\n  - leak事件\n    - 如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件\n  - 堆内存比较\n```\nvar memwatch = require('memwatch'); \nvar leakArray = []; \nvar leak = function () { \n leakArray.push(\"leak\" + Math.random()); \n}; \n// Take first snapshot \nvar hd = new memwatch.HeapDiff(); \nfor (var i = 0; i < 10000; i++) { \n leak(); \n} \n// Take the second snapshot and compute the diff \nvar diff = hd.end(); \nconsole.log(JSON.stringify(diff, null, 2));\n```\n\n###### 大内存应用\nstream模块用于处理大文件。stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种\n\n由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作\n```\nvar reader = fs.createReadStream('in.txt'); \nvar writer = fs.createWriteStream('out.txt'); \nreader.pipe(writer); \n```\n\n#### 理解Buffer\nBuffer是一个像Array的对象，但它主要用于操作字节\n\n- 模块结构\n  - Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现\n  - ![buffer](./images/buffer.png)\n  - 由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用\n- Buffer对象\n  - Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值\n  - 给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只保留整数部分\n```\nbuf[20] = -100; \nconsole.log(buf[20]); // 156 \nbuf[21] = 300; \nconsole.log(buf[21]); // 44 \nbuf[22] = 3.1415; \nconsole.log(buf[22]); // 3 \n```\n- Buffer内存分配\n  - Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的\n  - 此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略\n  - 为了高效地使用申请来的内存，Node采用了slab分配机制,一种动态内存管理机制\n    - full：完全分配状态。\n    - partial：部分分配状态。\n    - empty：没有被分配状态。\n  - Node以8 KB为界限来区分Buffer是大对象还是小对象,这个8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配\n    - 分配小Buffer对象\n      - 如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它\n      - ![buffer](./images/buffer-1.png)\n      - 当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态\n      - ![buffer](./images/buffer-2.png)\n      - 如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费\n      - ![buffer](./images/buffer-3.png)\n      - 注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放\n    - 分配大Buffer对象\n      - 如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占\n\n###### Buffer 的转换\nBuffer对象可以与字符串之间相互转换,目前支持的字符串编码类型有如下这几种:\n- ASCII\n- UTF-8\n- UTF-16LE/UCS-2\n- Base64\n- Binary\n- Hex\n\n- 字符串转Buffer\n  - 字符串转Buffer对象主要是通过构造函数完成的：new Buffer(str, [encoding]);\n  - 通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储\n  - 需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理\n- Buffer转字符串\n  - 实现Buffer向字符串的转换也十分简单，Buffer对象的toString()可以将Buffer对象转换为字符串，代码如下：buf.toString([encoding], [start], [end]) \n  - 可以设置encoding（默认为UTF-8）、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。\n- Buffer不支持的编码类型\n  - Buffer提供了一个isEncoding()函数来判断编码是否支持转换：Buffer.isEncoding(encoding)\n  - 在中国常用的GBK、GB2312和BIG-5编码都不在支持的行列中\n  - 对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。iconv和iconv-lite两个模块可以支持更多的编码类型转换，包括Windows 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KOI8系列，以及Latin1、US-ASCII，也支持宽字节编码GBK和GB2312\n\n###### Buffer 的拼接\n```\nvar fs = require('fs'); \nvar rs = fs.createReadStream('test.md'); \nvar data = ''; \nrs.on(\"data\", function (chunk){ \n data += chunk; \n}); \nrs.on(\"end\", function () { \n console.log(data); \n}); \n```\n- 原因在于文件可读流在读取时会逐个读取Buffer\n- setEncoding()与string_decoder()\n  - setEncoding该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串\n  - string_decoder目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题。\n- 正确拼接Buffer\n```\nvar chunks = []; \nvar size = 0; \nres.on('data', function (chunk) { \n chunks.push(chunk); \n size += chunk.length; \n}); \nres.on('end', function () { \n   var buf = Buffer.concat(chunks, size); \n var str = iconv.decode(buf, 'utf8'); \n console.log(str); \n});\n```\n  - 正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个合并的Buffer对象\n  - Buffer.concat()方法封装的从小Buffer对象向大Buffer对象的复制过程：\n```\nBuffer.concat = function(list, length) { \n if (!Array.isArray(list)) { \n throw new Error('Usage: Buffer.concat(list, [length])'); \n } \n if (list.length === 0) { \n return new Buffer(0); \n } else if (list.length === 1) { \n return list[0]; \n } \n if (typeof length !== 'number') { \n length = 0; \n for (var i = 0; i < list.length; i++) { \n var buf = list[i]; \n length += buf.length; \n } \n } \n var buffer = new Buffer(length); \n var pos = 0; \n for (var i = 0; i < list.length; i++) { \n var buf = list[i]; \n buf.copy(buffer, pos); \n pos += buf.length; \n } \n return buffer; \n}; \n```\n###### Buffer 与性能\n通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗\n- 文件读取\n  - 在文件的读取时，有一个highWaterMark设置对性能的影响至关重要\n    - highWaterMark的大小对性能有两个影响的点\n      - highWaterMark设置对Buffer内存的分配和使用有一定影响。\n      - highWaterMark设置过小，可能导致系统调用次数过多。\n    - highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快。\n\n#### 网络编程\nNode提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端\n\n- 构建 TCP 服务\n  - TCP\n    - TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议\n    - ![七层协议](./images/net-1.png)\n    - TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话\n    - ![七层协议](./images/net-2.png)\n  - 创建TCP服务器端\n```\nvar net = require('net'); \nvar server = net.createServer(function (socket) { \n // 新的连接\n socket.on('data', function (data) { \n socket.write(\"你好\"); \n }); \n socket.on('end', function () { \n console.log('连接断开'); \n }); \n socket.write(\"欢迎光临《深入浅出Node.js》示例：\\n\"); \n}); \nserver.listen(8124, function () { \n console.log('server bound'); \n});\n```\n  - TCP服务的事件\n    - 服务器事件\n      - listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。\n      - connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过net.create\u0002Server()，最后一个参数传递。\n      - close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。\n      - error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常\n    - 连接事件\n      - data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。\n      - end：当连接中的任意一端发送了FIN数据时，将会触发该事件。\n      - connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。\n      - drain：当任意一端调用write()发送数据时，当前这端会触发该事件。\n      - error：当异常发生时，触发该事件。\n      - close：当套接字完全关闭时，触发该事件。\n      - timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了\n    - TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。\n    - 在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中\n    - 另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件\n###### 构建 UDP 服务\nUDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。\n- 创建UDP套接字\n  - 创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。\n  - var dgram = require('dgram'); var socket = dgram.createSocket(\"udp4\");\n- 创建UDP服务器端\n  - 若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可\n```\nvar dgram = require(\"dgram\"); \nvar server = dgram.createSocket(\"udp4\"); \nserver.on(\"message\", function (msg, rinfo) { \n console.log(\"server got: \" + msg + \" from \" + \n rinfo.address + \":\" + rinfo.port); \n}); \nserver.on(\"listening\", function () { \n var address = server.address();\n console.log(\"server listening \" + \n address.address + \":\" + address.port); \n}); \nserver.bind(41234);\n```\n- 创建UDP客户端\n```\nvar dgram = require('dgram'); \nvar message = new Buffer(\"深入浅出Node.js\"); \nvar client = dgram.createSocket(\"udp4\"); \nclient.send(message, 0, message.length, 41234, \"localhost\", function(err, bytes) { \n client.close(); \n}); \n\nsocket.send(buf, offset, length, port, address, [callback])\n// 参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调\n```\n- UDP套接字事件\n  - UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。它具备如下自定义事件\n    - message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。\n    - listening：当UDP套接字开始侦听时触发该事件。\n    - close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。\n    - error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。\n\n###### 构建 HTTP 服务\n- HTTP\n  - 初识HTTP\n    - HTTP的全称是超文本传输协议，英文写作HyperText Transfer Protocol\n    - HTTP构建在TCP之上，属于应用层协议。在HTTP的两端是服务器和浏览器，即著名的B/S模式，如今精彩纷呈的Web即是HTTP的应用。\n    - HTTP得以发展是W3C和IETF两个组织合作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。\n  -  HTTP报文\n```\n$ curl -v http://127.0.0.1:1337 \n* About to connect() to 127.0.0.1 port 1337 (#0) \n* Trying 127.0.0.1... \n* connected \n* Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) \n> GET / HTTP/1.1 \n> User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 \n> Host: 127.0.0.1:1337 \n> Accept: */* \n> \n< HTTP/1.1 200 OK \n< Content-Type: text/plain \n< Date: Sat, 06 Apr 2013 08:01:44 GMT \n< Connection: keep-alive \n< Transfer-Encoding: chunked \n< \nHello World\n* Connection #0 to host 127.0.0.1 left intact \n* Closing connection #0\n```\n    - HTTP服务只做两件事情：处理HTTP请求和发送HTTP响应\n  - http模块\n    - 在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。\n    - ![http](./images/net-3.png)\n    - http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑\n    - ![http](./images/net-4.png)\n      - HTTP服务的事件\n        - connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。\n        - request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。\n        - close事件：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。\n        - checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。\n        - connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭\n        - upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。\n        - clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件\n###### HTTP客户端\nhttp模块提供了一个底层API：http.request(options, connect)，用于构造HTTP客户端\n```\nvar options = { \n hostname: '127.0.0.1', \n port: 1334, \n path: '/', \n method: 'GET' \n}; \nvar req = http.request(options, function(res) { \n console.log('STATUS: ' + res.statusCode); \n console.log('HEADERS: ' + JSON.stringify(res.headers)); \n res.setEncoding('utf8'); \n res.on('data', function (chunk) { \n console.log(chunk); \n }); \n}); \nreq.end();\n```\nHTTP请求头中的选项有:\n- host：服务器的域名或IP地址，默认为localhost。\n- hostname：服务器名称。\n- port：服务器端口，默认为80。\n- localAddress：建立网络连接的本地网卡。\n- socketPath：Domain套接字路径。\n- method：HTTP请求方法，默认为GET。\n- path：请求路径，默认为/。\n- headers：请求头对象。\n- auth：Basic认证，这个值将被计算成请求头中的Authorization部分。\n\n\n- HTTP响应\n  - HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。\n```\nfunction(res) { \n console.log('STATUS: ' + res.statusCode); \n console.log('HEADERS: ' + JSON.stringify(res.headers)); \n res.setEncoding('utf8'); \n res.on('data', function (chunk) { \n console.log(chunk); \n }); \n}\n```\n- HTTP 代理\n  - http提供的ClientRequest对象也是基于TCP层实现的，在keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5个连接\n  - ![http](./images/http.png)\n  - 调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接数的限制是相同的行为\n  - 如果你在服务器端通过ClientRequest调用网络中的其他HTTP服务，记得关注代理对象对网络请求的限制。一旦请求量过大，连接限制将会限制服务性能。如需要改变，可以在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5\n```\nvar agent = new http.Agent({ \n maxSockets: 10 \n}); \nvar options = { \n hostname: '127.0.0.1', \n port: 1334, \n path: '/', \n method: 'GET', \n agent: agent \n}; \n```\n  - 可以设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制\n- HTTP客户端事件\n  - response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。\n  - socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件。\n  - connect：当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。\n  - upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。\n  - continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件\n\n###### 构建 WebSocket 服务\n- WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。\n- WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。\n\nwebsocket与http相比的优点：\n- 客户端与服务器端只建立一个TCP连接，可以使用更少的连接。\n- WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。\n- 有更轻量级的协议头，减少数据传送量。\n\n```\nvar socket = new WebSocket('ws://127.0.0.1:12010/updates'); \nsocket.onopen = function () { \n setInterval(function() { \n if (socket.bufferedAmount == 0) \n socket.send(getUpdateData()); \n }, 50); \n}; \nsocket.onmessage = function (event) { \n // TODO：event.data \n};\n```\n\n在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用Comet（彗星）来命名它\n\n- WebSocket握手\n```\nGET /chat HTTP/1.1 \nHost: server.example.com \nUpgrade: websocket \nConnection: Upgrade \nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== \nSec-WebSocket-Protocol: chat, superchat \nSec-WebSocket-Version: 13 \n```\n  - Upgrade/Connection两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验\n  - Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端\n  - 服务器端在处理完请求后，响应如下报文：\n```\nHTTP/1.1 101 Switching Protocols \nUpgrade: websocket \nConnection: Upgrade \nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= \nSec-WebSocket-Protocol: chat\n```\n\n###### WebSocket数据传输\n![websocket](./images/websocket.png)\n```\nWebSocket.prototype.setSocket = function (socket) { \n this.socket = socket; \n this.socket.on('data', this.receiver); \n}; \n\nWebSocket.prototype.send = function (data) { \n this._send(data); \n}; \n```\n  - 为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭\n  - ![websocket](./images/websocket-1.png)\n  - fin：如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为多帧时，它既是第一帧也是最后一帧。\n  - rsv1、rsv2、rsv3：各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为1，其余情况为0。\n  - opcode：长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示ping数据帧，10表示pong数据帧，其余值暂时没有定义。ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。\n  - masked：表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。\n  - payload length：一个7、7+16或7+64位长的数据位，标识数据的长度，如果值在0~125之间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，则后面64位的值是数据的真实长度。\n  - masking key：当masked为1时存在，是一个32位长的数据位，用于解密数据。\n  - payload data：我们的目标数据，位数为8的倍数。\n\nnode与websocket共性\n- 基于事件的编程接口。\n- 基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。\n\n###### 网络服务与安全\nNode在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上\n  - TLS/SSL\n    - 密钥\n      - TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥\n      - ![TLS/SSL](./images/tls-ssl.png)\n      - Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。\n```\n# 私钥\n// 生成服务器端私钥\n$ openssl genrsa -out server.key 1024 \n// 生成客户端私钥\n$ openssl genrsa -out client.key 1024\n\n#公钥\n$ openssl rsa -in server.key -pubout -out server.pem \n$ openssl rsa -in client.key -pubout -out client.pem \n```\n      - 传递公私钥中可能存在中间人攻击，为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名\n    - 数字证书\n      - CA（Certificate Authority，数字证书认证中心）。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名\n      - 通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书\n```\n$ openssl genrsa -out ca.key 1024 \n$ openssl req -new -key ca.key -out ca.csr \n$ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt\n```\n      - ![CA](./images/ca.png)\n      - ![CA](./images/ca-1.png)\n\n###### TLS服务\n- 创建服务器端\n```\nvar tls = require('tls'); \nvar fs = require('fs'); \nvar options = { \n key: fs.readFileSync('./keys/server.key'), \n cert: fs.readFileSync('./keys/server.crt'), \n requestCert: true, \n ca: [ fs.readFileSync('./keys/ca.crt') ] \n}; \nvar server = tls.createServer(options, function (stream) { \n console.log('server connected', stream.authorized ? 'authorized' : 'unauthorized'); \n stream.write(\"welcome!\\n\"); \n stream.setEncoding('utf8'); \n stream.pipe(stream); \n}); \nserver.listen(8000, function() {\n  console.log('server bound'); \n}); \n\n# 通过下面的命令可以测试证书是否正常\n$ openssl s_client -connect 127.0.0.1:8000\n```\n- TLS客户端\n```\n// 创建私钥\n$ openssl genrsa -out client.key 1024 \n// 生成CSR \n$ openssl req -new -key client.key -out client.csr \n// 生成签名证书\n$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt\n\nvar tls = require('tls'); \nvar fs = require('fs'); \nvar options = { \n key: fs.readFileSync('./keys/client.key'), \n cert: fs.readFileSync('./keys/client.crt'), \n ca: [ fs.readFileSync('./keys/ca.crt') ] \n}; \nvar stream = tls.connect(8000, options, function () { \n console.log('client connected', stream.authorized ? 'authorized' : 'unauthorized'); \n process.stdin.pipe(stream); \n}); \nstream.setEncoding('utf8'); \nstream.on('data', function(data) { \n console.log(data); \n}); \nstream.on('end', function() { \n server.close(); \n}); \n```\n\n###### HTTPS服务\n- 创建HTTPS服务\n```\nvar https = require('https'); \nvar fs = require('fs'); \nvar options = { \n key: fs.readFileSync('./keys/server.key'), \n cert: fs.readFileSync('./keys/server.crt') \n}; \nhttps.createServer(options, function (req, res) { \n res.writeHead(200); \n res.end(\"hello world\\n\"); \n}).listen(8000);\n\n$ curl https://localhost:8000/ \ncurl: (60) SSL certificate problem, verify that the CA cert is OK. Details: \nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed \nMore details here: http://curl.haxx.se/docs/sslcerts.html \ncurl performs SSL certificate verification by default, using a \"bundle\" \n of Certificate Authority (CA) public keys (CA certs). If the default \n bundle file isn't adequate, you can specify an alternate file \n using the --cacert option. \nIf this HTTPS server uses a certificate signed by a CA represented in \n the bundle, the certificate verification probably failed due to a \n problem with the certificate (it might be expired, or the name might \n not match the domain name in the URL). \nIf you'd like to turn off curl's verification of the certificate, use \n the -k (or --insecure) option.\n```\n由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，解决方案：\n  - 一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险\n  - 一种解决的方式是给curl设置--cacert选项，告知CA证书使之完成对服务器证书的验证\n```\n$ curl -k https://localhost:8000/ \nhello world\n\n$ curl --cacert keys/ca.crt https://localhost:8000/ \nhello world \n```\n- HTTPS客户端\n```\nvar https = require('https'); \nvar fs = require('fs'); \nvar options = { \n hostname: 'localhost', \n port: 8000, \n path: '/', \n method: 'GET', \n key: fs.readFileSync('./keys/client.key'), \n cert: fs.readFileSync('./keys/client.crt'), \n ca: [fs.readFileSync('./keys/ca.crt')] \n}; \noptions.agent = new https.Agent(options); \nvar req = https.request(options, function(res) { \n res.setEncoding('utf-8'); \n res.on('data', function(d) { \n console.log(d); \n }); \n}); \nreq.end(); \nreq.on('error', function(e) { \n console.log(e); \n}); \n```\n如果不设置ca选项，将会得到如下异常: [Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE] \n解决该异常的方案是添加选项属性rejectUnauthorized为false，它的效果与curl工具加-k一样，都会在数据传输过程中会加密，但是无法保证服务器端的证书不是伪造的\n\n\n\n??? 当客户端调用send()发送数据时，服务器端触发onmessage()；当服务器端调用send()发送数\n据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装\n为一帧或多帧数据，然后逐帧发送","source":"nodejs/nodejs-note-3.md","raw":"---\ntitle: 深入浅出nodejs阅读笔记(3)\ndate: 2022-11-26 20:36:45\ntags: [node, docs]\n---\n\n#### 内存控制\n- V8 的对象分配\n  - 在V8中，所有的JavaScript对象都是通过堆来进行分配的。\n  - V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制\n  - Node在启动时可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小\n\n- V8 的垃圾回收机制\n  - V8主要的垃圾回收算法\n    - V8的垃圾回收策略主要基于分代式垃圾回收机制。\n    - V8的内存分代在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象\n    - V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提及的--max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，-max-new-space-size命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错\n    - 在默认设置下，如果一直分配内存，在64位系统和32位系统下会分别只能使用约1.4 GB和约0.7 GB的大小\n    - 新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB\n  - Scavenge算法\n    - 在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法\n    - Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。\n    - 在单纯的Scavenge过程中，From空间中的存活对象会被复制到To空间中去，然后对From空间和To空间进行角色对换（又称翻转）。但在分代式垃圾回收的前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。\n    - ![晋升流程](./images/v8-promot.png)\n    - ![晋升流程](./images/v8-promot2.png)\n  - Mark-Sweep & Mark-Compact\n    - V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象\n    - Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态\n    - Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存\n    - ![标记移动](./images/sweep-compact.png)\n    - ![算法对比](./images/collect-diff.png)\n    - V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact\n  - Incremental Marking\n    - 垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。\n    - 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成\n    - ![增量标记](./images/increase-target.png)\n  - 查看垃圾回收日志\n    - 查看垃圾回收日志的方式主要是在启动时添加--trace_gc参数\n    - 通过在Node启动时使用--prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间\n###### 高效使用内存\n- 作用域\n  - 标识符查找\n  - 作用域链\n  - 变量的主动释放\n- 闭包\n  - 实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）\n- 内存指标: process.memoryUsage()可以查看内存使用情况。除此之外，os模块中的totalmem()和freemem()方法也可以查看内存使用情况\n  - 查看内存使用情况\n    - 查看进程的内存占用\n```javascript\n$ node \n> process.memoryUsage() \n{ rss: 13852672, \n heapTotal: 6131200, \n heapUsed: 2757120 } \n```\n    - rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节\n  - 2. 查看系统的内存占用\n    - 与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位\n\n- 堆外内存: 将那些不是通过V8分配的内存称为堆外内存\n  - Buffer对象并非通过V8分配\n```\nvar useMem = function () { \n var size = 200 * 1024 * 1024; \n var buffer = new Buffer(size); \n for (var i = 0; i < size; i++) { \n buffer[i] = 0; \n } \n return buffer; \n}; \n```\n###### 内存泄漏\nNode对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃\n\n造成内存泄漏的原因\n  - 缓存。\n    - 在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功\n    - 用对象的键值对来缓存东西，与严格意义上的缓存有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有\n  - 解决手段：限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长\n    - 缓存限制策略\n      - 记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰\n      - LRU算法的缓存，地址为https://github.com/isaacs/node-lru-cache\n    - 缓存的解决方案\n      - 采用进程外的缓存，进程自身不存储状态\n        - (1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。\n        - (2) 进程之间可以共享缓存\n        - Redis：https://github.com/mranney/node_redis。\n        - Memcached：https://github.com/3rd-Eden/node-memcached。\n  - 队列消费不及时。\n    - 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。\n    - 任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值\n  - 作用域未释放\n\n###### 内存泄漏排查\n常见工具：\n- v8-profiler\n- node-heapdump\n```\nvar leakArray = []; \nvar leak = function () { \n leakArray.push(\"leak\" + Math.random()); \n}; \nhttp.createServer(function (req, res) { \n leak(); \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('Hello World\\n'); \n}).listen(1337); \nconsole.log('Server running at http://127.0.0.1:1337/'); \n```\n- node-mtrace\n- dtrace\n- node-memwatch\n```\nvar memwatch = require('memwatch'); \nmemwatch.on('leak', function (info) { \n console.log('leak:'); \n console.log(info); \n}); \nmemwatch.on('stats', function (stats) { \n console.log('stats:') \n console.log(stats); \n}); \nvar http = require('http'); \nvar leakArray = []; \nvar leak = function () { \n leakArray.push(\"leak\" + Math.random()); \n}; \nhttp.createServer(function (req, res) { \n leak(); \n res.writeHead(200, {'Content-Type': 'text/plain'}); \n res.end('Hello World\\n'); \n}).listen(1337); \nconsole.log('Server running at http://127.0.0.1:1337/'); \n```\n  - stats事件\n    - 每次进行全堆垃圾回收时，将会触发一次stats事件\n```\nstats: \n{ num_full_gc: 4, // 第几次全堆垃圾回收\n num_inc_gc: 23, // 第几次增量垃圾回收\n heap_compactions: 4, // 第几次对老生代进行整理\n usage_trend: 0, // 使用趋势\n estimated_base: 7152944, // 预估基数\n current_base: 7152944, // 当前基数\n min: 6720776, // 最小\n max: 7152944 } // 最大\n在这些数据中，num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况\n```\n  - leak事件\n    - 如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件\n  - 堆内存比较\n```\nvar memwatch = require('memwatch'); \nvar leakArray = []; \nvar leak = function () { \n leakArray.push(\"leak\" + Math.random()); \n}; \n// Take first snapshot \nvar hd = new memwatch.HeapDiff(); \nfor (var i = 0; i < 10000; i++) { \n leak(); \n} \n// Take the second snapshot and compute the diff \nvar diff = hd.end(); \nconsole.log(JSON.stringify(diff, null, 2));\n```\n\n###### 大内存应用\nstream模块用于处理大文件。stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种\n\n由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作\n```\nvar reader = fs.createReadStream('in.txt'); \nvar writer = fs.createWriteStream('out.txt'); \nreader.pipe(writer); \n```\n\n#### 理解Buffer\nBuffer是一个像Array的对象，但它主要用于操作字节\n\n- 模块结构\n  - Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现\n  - ![buffer](./images/buffer.png)\n  - 由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用\n- Buffer对象\n  - Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值\n  - 给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只保留整数部分\n```\nbuf[20] = -100; \nconsole.log(buf[20]); // 156 \nbuf[21] = 300; \nconsole.log(buf[21]); // 44 \nbuf[22] = 3.1415; \nconsole.log(buf[22]); // 3 \n```\n- Buffer内存分配\n  - Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的\n  - 此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略\n  - 为了高效地使用申请来的内存，Node采用了slab分配机制,一种动态内存管理机制\n    - full：完全分配状态。\n    - partial：部分分配状态。\n    - empty：没有被分配状态。\n  - Node以8 KB为界限来区分Buffer是大对象还是小对象,这个8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配\n    - 分配小Buffer对象\n      - 如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它\n      - ![buffer](./images/buffer-1.png)\n      - 当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态\n      - ![buffer](./images/buffer-2.png)\n      - 如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费\n      - ![buffer](./images/buffer-3.png)\n      - 注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放\n    - 分配大Buffer对象\n      - 如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占\n\n###### Buffer 的转换\nBuffer对象可以与字符串之间相互转换,目前支持的字符串编码类型有如下这几种:\n- ASCII\n- UTF-8\n- UTF-16LE/UCS-2\n- Base64\n- Binary\n- Hex\n\n- 字符串转Buffer\n  - 字符串转Buffer对象主要是通过构造函数完成的：new Buffer(str, [encoding]);\n  - 通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储\n  - 需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理\n- Buffer转字符串\n  - 实现Buffer向字符串的转换也十分简单，Buffer对象的toString()可以将Buffer对象转换为字符串，代码如下：buf.toString([encoding], [start], [end]) \n  - 可以设置encoding（默认为UTF-8）、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。\n- Buffer不支持的编码类型\n  - Buffer提供了一个isEncoding()函数来判断编码是否支持转换：Buffer.isEncoding(encoding)\n  - 在中国常用的GBK、GB2312和BIG-5编码都不在支持的行列中\n  - 对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。iconv和iconv-lite两个模块可以支持更多的编码类型转换，包括Windows 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KOI8系列，以及Latin1、US-ASCII，也支持宽字节编码GBK和GB2312\n\n###### Buffer 的拼接\n```\nvar fs = require('fs'); \nvar rs = fs.createReadStream('test.md'); \nvar data = ''; \nrs.on(\"data\", function (chunk){ \n data += chunk; \n}); \nrs.on(\"end\", function () { \n console.log(data); \n}); \n```\n- 原因在于文件可读流在读取时会逐个读取Buffer\n- setEncoding()与string_decoder()\n  - setEncoding该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串\n  - string_decoder目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题。\n- 正确拼接Buffer\n```\nvar chunks = []; \nvar size = 0; \nres.on('data', function (chunk) { \n chunks.push(chunk); \n size += chunk.length; \n}); \nres.on('end', function () { \n   var buf = Buffer.concat(chunks, size); \n var str = iconv.decode(buf, 'utf8'); \n console.log(str); \n});\n```\n  - 正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个合并的Buffer对象\n  - Buffer.concat()方法封装的从小Buffer对象向大Buffer对象的复制过程：\n```\nBuffer.concat = function(list, length) { \n if (!Array.isArray(list)) { \n throw new Error('Usage: Buffer.concat(list, [length])'); \n } \n if (list.length === 0) { \n return new Buffer(0); \n } else if (list.length === 1) { \n return list[0]; \n } \n if (typeof length !== 'number') { \n length = 0; \n for (var i = 0; i < list.length; i++) { \n var buf = list[i]; \n length += buf.length; \n } \n } \n var buffer = new Buffer(length); \n var pos = 0; \n for (var i = 0; i < list.length; i++) { \n var buf = list[i]; \n buf.copy(buffer, pos); \n pos += buf.length; \n } \n return buffer; \n}; \n```\n###### Buffer 与性能\n通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗\n- 文件读取\n  - 在文件的读取时，有一个highWaterMark设置对性能的影响至关重要\n    - highWaterMark的大小对性能有两个影响的点\n      - highWaterMark设置对Buffer内存的分配和使用有一定影响。\n      - highWaterMark设置过小，可能导致系统调用次数过多。\n    - highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快。\n\n#### 网络编程\nNode提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端\n\n- 构建 TCP 服务\n  - TCP\n    - TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议\n    - ![七层协议](./images/net-1.png)\n    - TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话\n    - ![七层协议](./images/net-2.png)\n  - 创建TCP服务器端\n```\nvar net = require('net'); \nvar server = net.createServer(function (socket) { \n // 新的连接\n socket.on('data', function (data) { \n socket.write(\"你好\"); \n }); \n socket.on('end', function () { \n console.log('连接断开'); \n }); \n socket.write(\"欢迎光临《深入浅出Node.js》示例：\\n\"); \n}); \nserver.listen(8124, function () { \n console.log('server bound'); \n});\n```\n  - TCP服务的事件\n    - 服务器事件\n      - listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。\n      - connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过net.create\u0002Server()，最后一个参数传递。\n      - close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。\n      - error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常\n    - 连接事件\n      - data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。\n      - end：当连接中的任意一端发送了FIN数据时，将会触发该事件。\n      - connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。\n      - drain：当任意一端调用write()发送数据时，当前这端会触发该事件。\n      - error：当异常发生时，触发该事件。\n      - close：当套接字完全关闭时，触发该事件。\n      - timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了\n    - TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。\n    - 在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中\n    - 另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件\n###### 构建 UDP 服务\nUDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。\n- 创建UDP套接字\n  - 创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。\n  - var dgram = require('dgram'); var socket = dgram.createSocket(\"udp4\");\n- 创建UDP服务器端\n  - 若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可\n```\nvar dgram = require(\"dgram\"); \nvar server = dgram.createSocket(\"udp4\"); \nserver.on(\"message\", function (msg, rinfo) { \n console.log(\"server got: \" + msg + \" from \" + \n rinfo.address + \":\" + rinfo.port); \n}); \nserver.on(\"listening\", function () { \n var address = server.address();\n console.log(\"server listening \" + \n address.address + \":\" + address.port); \n}); \nserver.bind(41234);\n```\n- 创建UDP客户端\n```\nvar dgram = require('dgram'); \nvar message = new Buffer(\"深入浅出Node.js\"); \nvar client = dgram.createSocket(\"udp4\"); \nclient.send(message, 0, message.length, 41234, \"localhost\", function(err, bytes) { \n client.close(); \n}); \n\nsocket.send(buf, offset, length, port, address, [callback])\n// 参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调\n```\n- UDP套接字事件\n  - UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。它具备如下自定义事件\n    - message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。\n    - listening：当UDP套接字开始侦听时触发该事件。\n    - close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。\n    - error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。\n\n###### 构建 HTTP 服务\n- HTTP\n  - 初识HTTP\n    - HTTP的全称是超文本传输协议，英文写作HyperText Transfer Protocol\n    - HTTP构建在TCP之上，属于应用层协议。在HTTP的两端是服务器和浏览器，即著名的B/S模式，如今精彩纷呈的Web即是HTTP的应用。\n    - HTTP得以发展是W3C和IETF两个组织合作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。\n  -  HTTP报文\n```\n$ curl -v http://127.0.0.1:1337 \n* About to connect() to 127.0.0.1 port 1337 (#0) \n* Trying 127.0.0.1... \n* connected \n* Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) \n> GET / HTTP/1.1 \n> User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 \n> Host: 127.0.0.1:1337 \n> Accept: */* \n> \n< HTTP/1.1 200 OK \n< Content-Type: text/plain \n< Date: Sat, 06 Apr 2013 08:01:44 GMT \n< Connection: keep-alive \n< Transfer-Encoding: chunked \n< \nHello World\n* Connection #0 to host 127.0.0.1 left intact \n* Closing connection #0\n```\n    - HTTP服务只做两件事情：处理HTTP请求和发送HTTP响应\n  - http模块\n    - 在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。\n    - ![http](./images/net-3.png)\n    - http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑\n    - ![http](./images/net-4.png)\n      - HTTP服务的事件\n        - connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。\n        - request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。\n        - close事件：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。\n        - checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。\n        - connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭\n        - upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。\n        - clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件\n###### HTTP客户端\nhttp模块提供了一个底层API：http.request(options, connect)，用于构造HTTP客户端\n```\nvar options = { \n hostname: '127.0.0.1', \n port: 1334, \n path: '/', \n method: 'GET' \n}; \nvar req = http.request(options, function(res) { \n console.log('STATUS: ' + res.statusCode); \n console.log('HEADERS: ' + JSON.stringify(res.headers)); \n res.setEncoding('utf8'); \n res.on('data', function (chunk) { \n console.log(chunk); \n }); \n}); \nreq.end();\n```\nHTTP请求头中的选项有:\n- host：服务器的域名或IP地址，默认为localhost。\n- hostname：服务器名称。\n- port：服务器端口，默认为80。\n- localAddress：建立网络连接的本地网卡。\n- socketPath：Domain套接字路径。\n- method：HTTP请求方法，默认为GET。\n- path：请求路径，默认为/。\n- headers：请求头对象。\n- auth：Basic认证，这个值将被计算成请求头中的Authorization部分。\n\n\n- HTTP响应\n  - HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。\n```\nfunction(res) { \n console.log('STATUS: ' + res.statusCode); \n console.log('HEADERS: ' + JSON.stringify(res.headers)); \n res.setEncoding('utf8'); \n res.on('data', function (chunk) { \n console.log(chunk); \n }); \n}\n```\n- HTTP 代理\n  - http提供的ClientRequest对象也是基于TCP层实现的，在keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5个连接\n  - ![http](./images/http.png)\n  - 调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接数的限制是相同的行为\n  - 如果你在服务器端通过ClientRequest调用网络中的其他HTTP服务，记得关注代理对象对网络请求的限制。一旦请求量过大，连接限制将会限制服务性能。如需要改变，可以在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5\n```\nvar agent = new http.Agent({ \n maxSockets: 10 \n}); \nvar options = { \n hostname: '127.0.0.1', \n port: 1334, \n path: '/', \n method: 'GET', \n agent: agent \n}; \n```\n  - 可以设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制\n- HTTP客户端事件\n  - response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。\n  - socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件。\n  - connect：当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。\n  - upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。\n  - continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件\n\n###### 构建 WebSocket 服务\n- WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。\n- WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。\n\nwebsocket与http相比的优点：\n- 客户端与服务器端只建立一个TCP连接，可以使用更少的连接。\n- WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。\n- 有更轻量级的协议头，减少数据传送量。\n\n```\nvar socket = new WebSocket('ws://127.0.0.1:12010/updates'); \nsocket.onopen = function () { \n setInterval(function() { \n if (socket.bufferedAmount == 0) \n socket.send(getUpdateData()); \n }, 50); \n}; \nsocket.onmessage = function (event) { \n // TODO：event.data \n};\n```\n\n在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用Comet（彗星）来命名它\n\n- WebSocket握手\n```\nGET /chat HTTP/1.1 \nHost: server.example.com \nUpgrade: websocket \nConnection: Upgrade \nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== \nSec-WebSocket-Protocol: chat, superchat \nSec-WebSocket-Version: 13 \n```\n  - Upgrade/Connection两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验\n  - Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端\n  - 服务器端在处理完请求后，响应如下报文：\n```\nHTTP/1.1 101 Switching Protocols \nUpgrade: websocket \nConnection: Upgrade \nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= \nSec-WebSocket-Protocol: chat\n```\n\n###### WebSocket数据传输\n![websocket](./images/websocket.png)\n```\nWebSocket.prototype.setSocket = function (socket) { \n this.socket = socket; \n this.socket.on('data', this.receiver); \n}; \n\nWebSocket.prototype.send = function (data) { \n this._send(data); \n}; \n```\n  - 为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭\n  - ![websocket](./images/websocket-1.png)\n  - fin：如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为多帧时，它既是第一帧也是最后一帧。\n  - rsv1、rsv2、rsv3：各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为1，其余情况为0。\n  - opcode：长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示ping数据帧，10表示pong数据帧，其余值暂时没有定义。ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。\n  - masked：表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。\n  - payload length：一个7、7+16或7+64位长的数据位，标识数据的长度，如果值在0~125之间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，则后面64位的值是数据的真实长度。\n  - masking key：当masked为1时存在，是一个32位长的数据位，用于解密数据。\n  - payload data：我们的目标数据，位数为8的倍数。\n\nnode与websocket共性\n- 基于事件的编程接口。\n- 基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。\n\n###### 网络服务与安全\nNode在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上\n  - TLS/SSL\n    - 密钥\n      - TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥\n      - ![TLS/SSL](./images/tls-ssl.png)\n      - Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。\n```\n# 私钥\n// 生成服务器端私钥\n$ openssl genrsa -out server.key 1024 \n// 生成客户端私钥\n$ openssl genrsa -out client.key 1024\n\n#公钥\n$ openssl rsa -in server.key -pubout -out server.pem \n$ openssl rsa -in client.key -pubout -out client.pem \n```\n      - 传递公私钥中可能存在中间人攻击，为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名\n    - 数字证书\n      - CA（Certificate Authority，数字证书认证中心）。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名\n      - 通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书\n```\n$ openssl genrsa -out ca.key 1024 \n$ openssl req -new -key ca.key -out ca.csr \n$ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt\n```\n      - ![CA](./images/ca.png)\n      - ![CA](./images/ca-1.png)\n\n###### TLS服务\n- 创建服务器端\n```\nvar tls = require('tls'); \nvar fs = require('fs'); \nvar options = { \n key: fs.readFileSync('./keys/server.key'), \n cert: fs.readFileSync('./keys/server.crt'), \n requestCert: true, \n ca: [ fs.readFileSync('./keys/ca.crt') ] \n}; \nvar server = tls.createServer(options, function (stream) { \n console.log('server connected', stream.authorized ? 'authorized' : 'unauthorized'); \n stream.write(\"welcome!\\n\"); \n stream.setEncoding('utf8'); \n stream.pipe(stream); \n}); \nserver.listen(8000, function() {\n  console.log('server bound'); \n}); \n\n# 通过下面的命令可以测试证书是否正常\n$ openssl s_client -connect 127.0.0.1:8000\n```\n- TLS客户端\n```\n// 创建私钥\n$ openssl genrsa -out client.key 1024 \n// 生成CSR \n$ openssl req -new -key client.key -out client.csr \n// 生成签名证书\n$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt\n\nvar tls = require('tls'); \nvar fs = require('fs'); \nvar options = { \n key: fs.readFileSync('./keys/client.key'), \n cert: fs.readFileSync('./keys/client.crt'), \n ca: [ fs.readFileSync('./keys/ca.crt') ] \n}; \nvar stream = tls.connect(8000, options, function () { \n console.log('client connected', stream.authorized ? 'authorized' : 'unauthorized'); \n process.stdin.pipe(stream); \n}); \nstream.setEncoding('utf8'); \nstream.on('data', function(data) { \n console.log(data); \n}); \nstream.on('end', function() { \n server.close(); \n}); \n```\n\n###### HTTPS服务\n- 创建HTTPS服务\n```\nvar https = require('https'); \nvar fs = require('fs'); \nvar options = { \n key: fs.readFileSync('./keys/server.key'), \n cert: fs.readFileSync('./keys/server.crt') \n}; \nhttps.createServer(options, function (req, res) { \n res.writeHead(200); \n res.end(\"hello world\\n\"); \n}).listen(8000);\n\n$ curl https://localhost:8000/ \ncurl: (60) SSL certificate problem, verify that the CA cert is OK. Details: \nerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed \nMore details here: http://curl.haxx.se/docs/sslcerts.html \ncurl performs SSL certificate verification by default, using a \"bundle\" \n of Certificate Authority (CA) public keys (CA certs). If the default \n bundle file isn't adequate, you can specify an alternate file \n using the --cacert option. \nIf this HTTPS server uses a certificate signed by a CA represented in \n the bundle, the certificate verification probably failed due to a \n problem with the certificate (it might be expired, or the name might \n not match the domain name in the URL). \nIf you'd like to turn off curl's verification of the certificate, use \n the -k (or --insecure) option.\n```\n由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，解决方案：\n  - 一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险\n  - 一种解决的方式是给curl设置--cacert选项，告知CA证书使之完成对服务器证书的验证\n```\n$ curl -k https://localhost:8000/ \nhello world\n\n$ curl --cacert keys/ca.crt https://localhost:8000/ \nhello world \n```\n- HTTPS客户端\n```\nvar https = require('https'); \nvar fs = require('fs'); \nvar options = { \n hostname: 'localhost', \n port: 8000, \n path: '/', \n method: 'GET', \n key: fs.readFileSync('./keys/client.key'), \n cert: fs.readFileSync('./keys/client.crt'), \n ca: [fs.readFileSync('./keys/ca.crt')] \n}; \noptions.agent = new https.Agent(options); \nvar req = https.request(options, function(res) { \n res.setEncoding('utf-8'); \n res.on('data', function(d) { \n console.log(d); \n }); \n}); \nreq.end(); \nreq.on('error', function(e) { \n console.log(e); \n}); \n```\n如果不设置ca选项，将会得到如下异常: [Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE] \n解决该异常的方案是添加选项属性rejectUnauthorized为false，它的效果与curl工具加-k一样，都会在数据传输过程中会加密，但是无法保证服务器端的证书不是伪造的\n\n\n\n??? 当客户端调用send()发送数据时，服务器端触发onmessage()；当服务器端调用send()发送数\n据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装\n为一帧或多帧数据，然后逐帧发送","updated":"2022-12-28T01:46:56.923Z","path":"nodejs/nodejs-note-3.html","comments":1,"layout":"page","_id":"clchh4gww0010cktt1zc5c3b2","content":"<h4 id=\"内存控制\"><a href=\"#内存控制\" class=\"headerlink\" title=\"内存控制\"></a>内存控制</h4><ul>\n<li><p>V8 的对象分配</p>\n<ul>\n<li>在V8中，所有的JavaScript对象都是通过堆来进行分配的。</li>\n<li>V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制</li>\n<li>Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小</li>\n</ul>\n</li>\n<li><p>V8 的垃圾回收机制</p>\n<ul>\n<li>V8主要的垃圾回收算法<ul>\n<li>V8的垃圾回收策略主要基于分代式垃圾回收机制。</li>\n<li>V8的内存分代在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象</li>\n<li>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提及的–max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，-max-new-space-size命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错</li>\n<li>在默认设置下，如果一直分配内存，在64位系统和32位系统下会分别只能使用约1.4 GB和约0.7 GB的大小</li>\n<li>新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB</li>\n</ul>\n</li>\n<li>Scavenge算法<ul>\n<li>在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法</li>\n<li>Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</li>\n<li>在单纯的Scavenge过程中，From空间中的存活对象会被复制到To空间中去，然后对From空间和To空间进行角色对换（又称翻转）。但在分代式垃圾回收的前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</li>\n<li><img src=\"/nodejs/images/v8-promot.png\" alt=\"晋升流程\"></li>\n<li><img src=\"/nodejs/images/v8-promot2.png\" alt=\"晋升流程\"></li>\n</ul>\n</li>\n<li>Mark-Sweep &amp; Mark-Compact<ul>\n<li>V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象</li>\n<li>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态</li>\n<li>Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存</li>\n<li><img src=\"/nodejs/images/sweep-compact.png\" alt=\"标记移动\"></li>\n<li><img src=\"/nodejs/images/collect-diff.png\" alt=\"算法对比\"></li>\n<li>V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact</li>\n</ul>\n</li>\n<li>Incremental Marking<ul>\n<li>垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。</li>\n<li>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成</li>\n<li><img src=\"/nodejs/images/increase-target.png\" alt=\"增量标记\"></li>\n</ul>\n</li>\n<li>查看垃圾回收日志<ul>\n<li>查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数</li>\n<li>通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间<h6 id=\"高效使用内存\"><a href=\"#高效使用内存\" class=\"headerlink\" title=\"高效使用内存\"></a>高效使用内存</h6></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>作用域</p>\n<ul>\n<li>标识符查找</li>\n<li>作用域链</li>\n<li>变量的主动释放</li>\n</ul>\n</li>\n<li><p>闭包</p>\n<ul>\n<li>实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）</li>\n</ul>\n</li>\n<li><p>内存指标: process.memoryUsage()可以查看内存使用情况。除此之外，os模块中的totalmem()和freemem()方法也可以查看内存使用情况</p>\n<ul>\n<li>查看内存使用情况<ul>\n<li>查看进程的内存占用<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node </span><br><span class=\"line\">&gt; process.memoryUsage() </span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">13852672</span>, </span><br><span class=\"line\"> <span class=\"attr\">heapTotal</span>: <span class=\"number\">6131200</span>, </span><br><span class=\"line\"> <span class=\"attr\">heapUsed</span>: <span class=\"number\">2757120</span> &#125; </span><br></pre></td></tr></table></figure></li>\n<li>rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>查看系统的内存占用</li>\n</ol>\n<ul>\n<li>与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>堆外内存: 将那些不是通过V8分配的内存称为堆外内存</p>\n<ul>\n<li>Buffer对象并非通过V8分配<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var useMem = function () &#123; </span><br><span class=\"line\"> var size = 200 * 1024 * 1024; </span><br><span class=\"line\"> var buffer = new Buffer(size); </span><br><span class=\"line\"> for (var i = 0; i &lt; size; i++) &#123; </span><br><span class=\"line\"> buffer[i] = 0; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> return buffer; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<h6 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h6>Node对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃</li>\n</ul>\n</li>\n</ul>\n<p>造成内存泄漏的原因</p>\n<ul>\n<li>缓存。<ul>\n<li>在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功</li>\n<li>用对象的键值对来缓存东西，与严格意义上的缓存有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有</li>\n</ul>\n</li>\n<li>解决手段：限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长<ul>\n<li>缓存限制策略<ul>\n<li>记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰</li>\n<li>LRU算法的缓存，地址为<a href=\"https://github.com/isaacs/node-lru-cache\">https://github.com/isaacs/node-lru-cache</a></li>\n</ul>\n</li>\n<li>缓存的解决方案<ul>\n<li>采用进程外的缓存，进程自身不存储状态<ul>\n<li>(1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。</li>\n<li>(2) 进程之间可以共享缓存</li>\n<li>Redis：<a href=\"https://github.com/mranney/node_redis%E3%80%82\">https://github.com/mranney/node_redis。</a></li>\n<li>Memcached：<a href=\"https://github.com/3rd-Eden/node-memcached%E3%80%82\">https://github.com/3rd-Eden/node-memcached。</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>队列消费不及时。<ul>\n<li>监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。</li>\n<li>任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值</li>\n</ul>\n</li>\n<li>作用域未释放</li>\n</ul>\n<h6 id=\"内存泄漏排查\"><a href=\"#内存泄漏排查\" class=\"headerlink\" title=\"内存泄漏排查\"></a>内存泄漏排查</h6><p>常见工具：</p>\n<ul>\n<li>v8-profiler</li>\n<li>node-heapdump<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var leakArray = []; </span><br><span class=\"line\">var leak = function () &#123; </span><br><span class=\"line\"> leakArray.push(&quot;leak&quot; + Math.random()); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> leak(); </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;Hello World\\n&#x27;); </span><br><span class=\"line\">&#125;).listen(1337); </span><br><span class=\"line\">console.log(&#x27;Server running at http://127.0.0.1:1337/&#x27;); </span><br></pre></td></tr></table></figure></li>\n<li>node-mtrace</li>\n<li>dtrace</li>\n<li>node-memwatch<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var memwatch = require(&#x27;memwatch&#x27;); </span><br><span class=\"line\">memwatch.on(&#x27;leak&#x27;, function (info) &#123; </span><br><span class=\"line\"> console.log(&#x27;leak:&#x27;); </span><br><span class=\"line\"> console.log(info); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">memwatch.on(&#x27;stats&#x27;, function (stats) &#123; </span><br><span class=\"line\"> console.log(&#x27;stats:&#x27;) </span><br><span class=\"line\"> console.log(stats); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">var leakArray = []; </span><br><span class=\"line\">var leak = function () &#123; </span><br><span class=\"line\"> leakArray.push(&quot;leak&quot; + Math.random()); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> leak(); </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;Hello World\\n&#x27;); </span><br><span class=\"line\">&#125;).listen(1337); </span><br><span class=\"line\">console.log(&#x27;Server running at http://127.0.0.1:1337/&#x27;); </span><br></pre></td></tr></table></figure>\n<ul>\n<li>stats事件<ul>\n<li>每次进行全堆垃圾回收时，将会触发一次stats事件<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stats: </span><br><span class=\"line\">&#123; num_full_gc: 4, // 第几次全堆垃圾回收</span><br><span class=\"line\"> num_inc_gc: 23, // 第几次增量垃圾回收</span><br><span class=\"line\"> heap_compactions: 4, // 第几次对老生代进行整理</span><br><span class=\"line\"> usage_trend: 0, // 使用趋势</span><br><span class=\"line\"> estimated_base: 7152944, // 预估基数</span><br><span class=\"line\"> current_base: 7152944, // 当前基数</span><br><span class=\"line\"> min: 6720776, // 最小</span><br><span class=\"line\"> max: 7152944 &#125; // 最大</span><br><span class=\"line\">在这些数据中，num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>leak事件<ul>\n<li>如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件</li>\n</ul>\n</li>\n<li>堆内存比较<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var memwatch = require(&#x27;memwatch&#x27;); </span><br><span class=\"line\">var leakArray = []; </span><br><span class=\"line\">var leak = function () &#123; </span><br><span class=\"line\"> leakArray.push(&quot;leak&quot; + Math.random()); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">// Take first snapshot </span><br><span class=\"line\">var hd = new memwatch.HeapDiff(); </span><br><span class=\"line\">for (var i = 0; i &lt; 10000; i++) &#123; </span><br><span class=\"line\"> leak(); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// Take the second snapshot and compute the diff </span><br><span class=\"line\">var diff = hd.end(); </span><br><span class=\"line\">console.log(JSON.stringify(diff, null, 2));</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"大内存应用\"><a href=\"#大内存应用\" class=\"headerlink\" title=\"大内存应用\"></a>大内存应用</h6><p>stream模块用于处理大文件。stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种</p>\n<p>由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reader = fs.createReadStream(&#x27;in.txt&#x27;); </span><br><span class=\"line\">var writer = fs.createWriteStream(&#x27;out.txt&#x27;); </span><br><span class=\"line\">reader.pipe(writer); </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"理解Buffer\"><a href=\"#理解Buffer\" class=\"headerlink\" title=\"理解Buffer\"></a>理解Buffer</h4><p>Buffer是一个像Array的对象，但它主要用于操作字节</p>\n<ul>\n<li>模块结构<ul>\n<li>Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现</li>\n<li><img src=\"/nodejs/images/buffer.png\" alt=\"buffer\"></li>\n<li>由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用</li>\n</ul>\n</li>\n<li>Buffer对象<ul>\n<li>Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值</li>\n<li>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只保留整数部分<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf[20] = -100; </span><br><span class=\"line\">console.log(buf[20]); // 156 </span><br><span class=\"line\">buf[21] = 300; </span><br><span class=\"line\">console.log(buf[21]); // 44 </span><br><span class=\"line\">buf[22] = 3.1415; </span><br><span class=\"line\">console.log(buf[22]); // 3 </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>Buffer内存分配<ul>\n<li>Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的</li>\n<li>此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略</li>\n<li>为了高效地使用申请来的内存，Node采用了slab分配机制,一种动态内存管理机制<ul>\n<li>full：完全分配状态。</li>\n<li>partial：部分分配状态。</li>\n<li>empty：没有被分配状态。</li>\n</ul>\n</li>\n<li>Node以8 KB为界限来区分Buffer是大对象还是小对象,这个8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配<ul>\n<li>分配小Buffer对象<ul>\n<li>如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它</li>\n<li><img src=\"/nodejs/images/buffer-1.png\" alt=\"buffer\"></li>\n<li>当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态</li>\n<li><img src=\"/nodejs/images/buffer-2.png\" alt=\"buffer\"></li>\n<li>如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费</li>\n<li><img src=\"/nodejs/images/buffer-3.png\" alt=\"buffer\"></li>\n<li>注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放</li>\n</ul>\n</li>\n<li>分配大Buffer对象<ul>\n<li>如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Buffer-的转换\"><a href=\"#Buffer-的转换\" class=\"headerlink\" title=\"Buffer 的转换\"></a>Buffer 的转换</h6><p>Buffer对象可以与字符串之间相互转换,目前支持的字符串编码类型有如下这几种:</p>\n<ul>\n<li><p>ASCII</p>\n</li>\n<li><p>UTF-8</p>\n</li>\n<li><p>UTF-16LE/UCS-2</p>\n</li>\n<li><p>Base64</p>\n</li>\n<li><p>Binary</p>\n</li>\n<li><p>Hex</p>\n</li>\n<li><p>字符串转Buffer</p>\n<ul>\n<li>字符串转Buffer对象主要是通过构造函数完成的：new Buffer(str, [encoding]);</li>\n<li>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储</li>\n<li>需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理</li>\n</ul>\n</li>\n<li><p>Buffer转字符串</p>\n<ul>\n<li>实现Buffer向字符串的转换也十分简单，Buffer对象的toString()可以将Buffer对象转换为字符串，代码如下：buf.toString([encoding], [start], [end]) </li>\n<li>可以设置encoding（默认为UTF-8）、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</li>\n</ul>\n</li>\n<li><p>Buffer不支持的编码类型</p>\n<ul>\n<li>Buffer提供了一个isEncoding()函数来判断编码是否支持转换：Buffer.isEncoding(encoding)</li>\n<li>在中国常用的GBK、GB2312和BIG-5编码都不在支持的行列中</li>\n<li>对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。iconv和iconv-lite两个模块可以支持更多的编码类型转换，包括Windows 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KOI8系列，以及Latin1、US-ASCII，也支持宽字节编码GBK和GB2312</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Buffer-的拼接\"><a href=\"#Buffer-的拼接\" class=\"headerlink\" title=\"Buffer 的拼接\"></a>Buffer 的拼接</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var rs = fs.createReadStream(&#x27;test.md&#x27;); </span><br><span class=\"line\">var data = &#x27;&#x27;; </span><br><span class=\"line\">rs.on(&quot;data&quot;, function (chunk)&#123; </span><br><span class=\"line\"> data += chunk; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">rs.on(&quot;end&quot;, function () &#123; </span><br><span class=\"line\"> console.log(data); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<ul>\n<li>原因在于文件可读流在读取时会逐个读取Buffer</li>\n<li>setEncoding()与string_decoder()<ul>\n<li>setEncoding该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串</li>\n<li>string_decoder目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题。</li>\n</ul>\n</li>\n<li>正确拼接Buffer<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var chunks = []; </span><br><span class=\"line\">var size = 0; </span><br><span class=\"line\">res.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> chunks.push(chunk); </span><br><span class=\"line\"> size += chunk.length; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">res.on(&#x27;end&#x27;, function () &#123; </span><br><span class=\"line\">   var buf = Buffer.concat(chunks, size); </span><br><span class=\"line\"> var str = iconv.decode(buf, &#x27;utf8&#x27;); </span><br><span class=\"line\"> console.log(str); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个合并的Buffer对象</li>\n<li>Buffer.concat()方法封装的从小Buffer对象向大Buffer对象的复制过程：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Buffer.concat = function(list, length) &#123; </span><br><span class=\"line\"> if (!Array.isArray(list)) &#123; </span><br><span class=\"line\"> throw new Error(&#x27;Usage: Buffer.concat(list, [length])&#x27;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> if (list.length === 0) &#123; </span><br><span class=\"line\"> return new Buffer(0); </span><br><span class=\"line\"> &#125; else if (list.length === 1) &#123; </span><br><span class=\"line\"> return list[0]; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> if (typeof length !== &#x27;number&#x27;) &#123; </span><br><span class=\"line\"> length = 0; </span><br><span class=\"line\"> for (var i = 0; i &lt; list.length; i++) &#123; </span><br><span class=\"line\"> var buf = list[i]; </span><br><span class=\"line\"> length += buf.length; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> var buffer = new Buffer(length); </span><br><span class=\"line\"> var pos = 0; </span><br><span class=\"line\"> for (var i = 0; i &lt; list.length; i++) &#123; </span><br><span class=\"line\"> var buf = list[i]; </span><br><span class=\"line\"> buf.copy(buffer, pos); </span><br><span class=\"line\"> pos += buf.length; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> return buffer; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<h6 id=\"Buffer-与性能\"><a href=\"#Buffer-与性能\" class=\"headerlink\" title=\"Buffer 与性能\"></a>Buffer 与性能</h6>通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗</li>\n</ul>\n</li>\n<li>文件读取<ul>\n<li>在文件的读取时，有一个highWaterMark设置对性能的影响至关重要<ul>\n<li>highWaterMark的大小对性能有两个影响的点<ul>\n<li>highWaterMark设置对Buffer内存的分配和使用有一定影响。</li>\n<li>highWaterMark设置过小，可能导致系统调用次数过多。</li>\n</ul>\n</li>\n<li>highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h4><p>Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端</p>\n<ul>\n<li>构建 TCP 服务<ul>\n<li>TCP<ul>\n<li>TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议</li>\n<li><img src=\"/nodejs/images/net-1.png\" alt=\"七层协议\"></li>\n<li>TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话</li>\n<li><img src=\"/nodejs/images/net-2.png\" alt=\"七层协议\"></li>\n</ul>\n</li>\n<li>创建TCP服务器端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var net = require(&#x27;net&#x27;); </span><br><span class=\"line\">var server = net.createServer(function (socket) &#123; </span><br><span class=\"line\"> // 新的连接</span><br><span class=\"line\"> socket.on(&#x27;data&#x27;, function (data) &#123; </span><br><span class=\"line\"> socket.write(&quot;你好&quot;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> socket.on(&#x27;end&#x27;, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;连接断开&#x27;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> socket.write(&quot;欢迎光临《深入浅出Node.js》示例：\\n&quot;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.listen(8124, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;server bound&#x27;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>TCP服务的事件<ul>\n<li>服务器事件<ul>\n<li>listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。</li>\n<li>connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过net.create\u0002Server()，最后一个参数传递。</li>\n<li>close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li>\n<li>error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常</li>\n</ul>\n</li>\n<li>连接事件<ul>\n<li>data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。</li>\n<li>end：当连接中的任意一端发送了FIN数据时，将会触发该事件。</li>\n<li>connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。</li>\n<li>drain：当任意一端调用write()发送数据时，当前这端会触发该事件。</li>\n<li>error：当异常发生时，触发该事件。</li>\n<li>close：当套接字完全关闭时，触发该事件。</li>\n<li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了</li>\n</ul>\n</li>\n<li>TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。</li>\n<li>在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中</li>\n<li>另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件<h6 id=\"构建-UDP-服务\"><a href=\"#构建-UDP-服务\" class=\"headerlink\" title=\"构建 UDP 服务\"></a>构建 UDP 服务</h6>UDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>创建UDP套接字<ul>\n<li>创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。</li>\n<li>var dgram = require(‘dgram’); var socket = dgram.createSocket(“udp4”);</li>\n</ul>\n</li>\n<li>创建UDP服务器端<ul>\n<li>若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dgram = require(&quot;dgram&quot;); </span><br><span class=\"line\">var server = dgram.createSocket(&quot;udp4&quot;); </span><br><span class=\"line\">server.on(&quot;message&quot;, function (msg, rinfo) &#123; </span><br><span class=\"line\"> console.log(&quot;server got: &quot; + msg + &quot; from &quot; + </span><br><span class=\"line\"> rinfo.address + &quot;:&quot; + rinfo.port); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.on(&quot;listening&quot;, function () &#123; </span><br><span class=\"line\"> var address = server.address();</span><br><span class=\"line\"> console.log(&quot;server listening &quot; + </span><br><span class=\"line\"> address.address + &quot;:&quot; + address.port); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.bind(41234);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>创建UDP客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dgram = require(&#x27;dgram&#x27;); </span><br><span class=\"line\">var message = new Buffer(&quot;深入浅出Node.js&quot;); </span><br><span class=\"line\">var client = dgram.createSocket(&quot;udp4&quot;); </span><br><span class=\"line\">client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err, bytes) &#123; </span><br><span class=\"line\"> client.close(); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">socket.send(buf, offset, length, port, address, [callback])</span><br><span class=\"line\">// 参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调</span><br></pre></td></tr></table></figure></li>\n<li>UDP套接字事件<ul>\n<li>UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。它具备如下自定义事件<ul>\n<li>message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。</li>\n<li>listening：当UDP套接字开始侦听时触发该事件。</li>\n<li>close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。</li>\n<li>error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"构建-HTTP-服务\"><a href=\"#构建-HTTP-服务\" class=\"headerlink\" title=\"构建 HTTP 服务\"></a>构建 HTTP 服务</h6><ul>\n<li>HTTP<ul>\n<li>初识HTTP<ul>\n<li>HTTP的全称是超文本传输协议，英文写作HyperText Transfer Protocol</li>\n<li>HTTP构建在TCP之上，属于应用层协议。在HTTP的两端是服务器和浏览器，即著名的B/S模式，如今精彩纷呈的Web即是HTTP的应用。</li>\n<li>HTTP得以发展是W3C和IETF两个组织合作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。</li>\n</ul>\n</li>\n<li> HTTP报文<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -v http://127.0.0.1:1337 </span><br><span class=\"line\">* About to connect() to 127.0.0.1 port 1337 (#0) </span><br><span class=\"line\">* Trying 127.0.0.1... </span><br><span class=\"line\">* connected </span><br><span class=\"line\">* Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) </span><br><span class=\"line\">&gt; GET / HTTP/1.1 </span><br><span class=\"line\">&gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 </span><br><span class=\"line\">&gt; Host: 127.0.0.1:1337 </span><br><span class=\"line\">&gt; Accept: */* </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&lt; HTTP/1.1 200 OK </span><br><span class=\"line\">&lt; Content-Type: text/plain </span><br><span class=\"line\">&lt; Date: Sat, 06 Apr 2013 08:01:44 GMT </span><br><span class=\"line\">&lt; Connection: keep-alive </span><br><span class=\"line\">&lt; Transfer-Encoding: chunked </span><br><span class=\"line\">&lt; </span><br><span class=\"line\">Hello World</span><br><span class=\"line\">* Connection #0 to host 127.0.0.1 left intact </span><br><span class=\"line\">* Closing connection #0</span><br></pre></td></tr></table></figure></li>\n<li>HTTP服务只做两件事情：处理HTTP请求和发送HTTP响应</li>\n<li>http模块<ul>\n<li>在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。</li>\n<li><img src=\"/nodejs/images/net-3.png\" alt=\"http\"></li>\n<li>http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑</li>\n<li><img src=\"/nodejs/images/net-4.png\" alt=\"http\"><ul>\n<li>HTTP服务的事件<ul>\n<li>connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。</li>\n<li>request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。</li>\n<li>close事件：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。</li>\n<li>checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。</li>\n<li>connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭</li>\n<li>upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。</li>\n<li>clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件<h6 id=\"HTTP客户端\"><a href=\"#HTTP客户端\" class=\"headerlink\" title=\"HTTP客户端\"></a>HTTP客户端</h6>http模块提供了一个底层API：http.request(options, connect)，用于构造HTTP客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> hostname: &#x27;127.0.0.1&#x27;, </span><br><span class=\"line\"> port: 1334, </span><br><span class=\"line\"> path: &#x27;/&#x27;, </span><br><span class=\"line\"> method: &#x27;GET&#x27; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var req = http.request(options, function(res) &#123; </span><br><span class=\"line\"> console.log(&#x27;STATUS: &#x27; + res.statusCode); </span><br><span class=\"line\"> console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers)); </span><br><span class=\"line\"> res.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\"> res.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> console.log(chunk); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\nHTTP请求头中的选项有:</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>host：服务器的域名或IP地址，默认为localhost。</li>\n<li>hostname：服务器名称。</li>\n<li>port：服务器端口，默认为80。</li>\n<li>localAddress：建立网络连接的本地网卡。</li>\n<li>socketPath：Domain套接字路径。</li>\n<li>method：HTTP请求方法，默认为GET。</li>\n<li>path：请求路径，默认为/。</li>\n<li>headers：请求头对象。</li>\n<li>auth：Basic认证，这个值将被计算成请求头中的Authorization部分。</li>\n</ul>\n<ul>\n<li>HTTP响应<ul>\n<li>HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(res) &#123; </span><br><span class=\"line\"> console.log(&#x27;STATUS: &#x27; + res.statusCode); </span><br><span class=\"line\"> console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers)); </span><br><span class=\"line\"> res.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\"> res.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> console.log(chunk); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>HTTP 代理<ul>\n<li>http提供的ClientRequest对象也是基于TCP层实现的，在keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5个连接</li>\n<li><img src=\"./images/http.png\" alt=\"http\"></li>\n<li>调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接数的限制是相同的行为</li>\n<li>如果你在服务器端通过ClientRequest调用网络中的其他HTTP服务，记得关注代理对象对网络请求的限制。一旦请求量过大，连接限制将会限制服务性能。如需要改变，可以在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var agent = new http.Agent(&#123; </span><br><span class=\"line\"> maxSockets: 10 </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> hostname: &#x27;127.0.0.1&#x27;, </span><br><span class=\"line\"> port: 1334, </span><br><span class=\"line\"> path: &#x27;/&#x27;, </span><br><span class=\"line\"> method: &#x27;GET&#x27;, </span><br><span class=\"line\"> agent: agent </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure></li>\n<li>可以设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制</li>\n</ul>\n</li>\n<li>HTTP客户端事件<ul>\n<li>response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。</li>\n<li>socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li>\n<li>connect：当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。</li>\n<li>upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。</li>\n<li>continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"构建-WebSocket-服务\"><a href=\"#构建-WebSocket-服务\" class=\"headerlink\" title=\"构建 WebSocket 服务\"></a>构建 WebSocket 服务</h6><ul>\n<li>WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。</li>\n<li>WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。</li>\n</ul>\n<p>websocket与http相比的优点：</p>\n<ul>\n<li>客户端与服务器端只建立一个TCP连接，可以使用更少的连接。</li>\n<li>WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。</li>\n<li>有更轻量级的协议头，减少数据传送量。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&#x27;ws://127.0.0.1:12010/updates&#x27;); </span><br><span class=\"line\">socket.onopen = function () &#123; </span><br><span class=\"line\"> setInterval(function() &#123; </span><br><span class=\"line\"> if (socket.bufferedAmount == 0) </span><br><span class=\"line\"> socket.send(getUpdateData()); </span><br><span class=\"line\"> &#125;, 50); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">socket.onmessage = function (event) &#123; </span><br><span class=\"line\"> // TODO：event.data </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用Comet（彗星）来命名它</p>\n<ul>\n<li>WebSocket握手<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1 </span><br><span class=\"line\">Host: server.example.com </span><br><span class=\"line\">Upgrade: websocket </span><br><span class=\"line\">Connection: Upgrade </span><br><span class=\"line\">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== </span><br><span class=\"line\">Sec-WebSocket-Protocol: chat, superchat </span><br><span class=\"line\">Sec-WebSocket-Version: 13 </span><br></pre></td></tr></table></figure>\n<ul>\n<li>Upgrade/Connection两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验</li>\n<li>Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端</li>\n<li>服务器端在处理完请求后，响应如下报文：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols </span><br><span class=\"line\">Upgrade: websocket </span><br><span class=\"line\">Connection: Upgrade </span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= </span><br><span class=\"line\">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"WebSocket数据传输\"><a href=\"#WebSocket数据传输\" class=\"headerlink\" title=\"WebSocket数据传输\"></a>WebSocket数据传输</h6><p><img src=\"/nodejs/images/websocket.png\" alt=\"websocket\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket.prototype.setSocket = function (socket) &#123; </span><br><span class=\"line\"> this.socket = socket; </span><br><span class=\"line\"> this.socket.on(&#x27;data&#x27;, this.receiver); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">WebSocket.prototype.send = function (data) &#123; </span><br><span class=\"line\"> this._send(data); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭</li>\n<li><img src=\"/nodejs/images/websocket-1.png\" alt=\"websocket\"></li>\n<li>fin：如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为多帧时，它既是第一帧也是最后一帧。</li>\n<li>rsv1、rsv2、rsv3：各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为1，其余情况为0。</li>\n<li>opcode：长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示ping数据帧，10表示pong数据帧，其余值暂时没有定义。ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。</li>\n<li>masked：表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。</li>\n<li>payload length：一个7、7+16或7+64位长的数据位，标识数据的长度，如果值在0~125之间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，则后面64位的值是数据的真实长度。</li>\n<li>masking key：当masked为1时存在，是一个32位长的数据位，用于解密数据。</li>\n<li>payload data：我们的目标数据，位数为8的倍数。</li>\n</ul>\n<p>node与websocket共性</p>\n<ul>\n<li>基于事件的编程接口。</li>\n<li>基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。</li>\n</ul>\n<h6 id=\"网络服务与安全\"><a href=\"#网络服务与安全\" class=\"headerlink\" title=\"网络服务与安全\"></a>网络服务与安全</h6><p>Node在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上</p>\n<ul>\n<li>TLS/SSL<ul>\n<li>密钥<ul>\n<li>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥</li>\n<li><img src=\"/nodejs/images/tls-ssl.png\" alt=\"TLS/SSL\"></li>\n<li>Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 私钥</span><br><span class=\"line\">// 生成服务器端私钥</span><br><span class=\"line\">$ openssl genrsa -out server.key 1024 </span><br><span class=\"line\">// 生成客户端私钥</span><br><span class=\"line\">$ openssl genrsa -out client.key 1024</span><br><span class=\"line\"></span><br><span class=\"line\">#公钥</span><br><span class=\"line\">$ openssl rsa -in server.key -pubout -out server.pem </span><br><span class=\"line\">$ openssl rsa -in client.key -pubout -out client.pem </span><br></pre></td></tr></table></figure></li>\n<li>传递公私钥中可能存在中间人攻击，为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名</li>\n</ul>\n</li>\n<li>数字证书<ul>\n<li>CA（Certificate Authority，数字证书认证中心）。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名</li>\n<li>通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ openssl genrsa -out ca.key 1024 </span><br><span class=\"line\">$ openssl req -new -key ca.key -out ca.csr </span><br><span class=\"line\">$ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure></li>\n<li><img src=\"/nodejs/images/ca.png\" alt=\"CA\"></li>\n<li><img src=\"/nodejs/images/ca-1.png\" alt=\"CA\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"TLS服务\"><a href=\"#TLS服务\" class=\"headerlink\" title=\"TLS服务\"></a>TLS服务</h6><ul>\n<li>创建服务器端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tls = require(&#x27;tls&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/server.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/server.crt&#x27;), </span><br><span class=\"line\"> requestCert: true, </span><br><span class=\"line\"> ca: [ fs.readFileSync(&#x27;./keys/ca.crt&#x27;) ] </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var server = tls.createServer(options, function (stream) &#123; </span><br><span class=\"line\"> console.log(&#x27;server connected&#x27;, stream.authorized ? &#x27;authorized&#x27; : &#x27;unauthorized&#x27;); </span><br><span class=\"line\"> stream.write(&quot;welcome!\\n&quot;); </span><br><span class=\"line\"> stream.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\"> stream.pipe(stream); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.listen(8000, function() &#123;</span><br><span class=\"line\">  console.log(&#x27;server bound&#x27;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"># 通过下面的命令可以测试证书是否正常</span><br><span class=\"line\">$ openssl s_client -connect 127.0.0.1:8000</span><br></pre></td></tr></table></figure></li>\n<li>TLS客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建私钥</span><br><span class=\"line\">$ openssl genrsa -out client.key 1024 </span><br><span class=\"line\">// 生成CSR </span><br><span class=\"line\">$ openssl req -new -key client.key -out client.csr </span><br><span class=\"line\">// 生成签名证书</span><br><span class=\"line\">$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt</span><br><span class=\"line\"></span><br><span class=\"line\">var tls = require(&#x27;tls&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/client.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/client.crt&#x27;), </span><br><span class=\"line\"> ca: [ fs.readFileSync(&#x27;./keys/ca.crt&#x27;) ] </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var stream = tls.connect(8000, options, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;client connected&#x27;, stream.authorized ? &#x27;authorized&#x27; : &#x27;unauthorized&#x27;); </span><br><span class=\"line\"> process.stdin.pipe(stream); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">stream.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\">stream.on(&#x27;data&#x27;, function(data) &#123; </span><br><span class=\"line\"> console.log(data); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">stream.on(&#x27;end&#x27;, function() &#123; </span><br><span class=\"line\"> server.close(); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"HTTPS服务\"><a href=\"#HTTPS服务\" class=\"headerlink\" title=\"HTTPS服务\"></a>HTTPS服务</h6><ul>\n<li>创建HTTPS服务<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var https = require(&#x27;https&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/server.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/server.crt&#x27;) </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">https.createServer(options, function (req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200); </span><br><span class=\"line\"> res.end(&quot;hello world\\n&quot;); </span><br><span class=\"line\">&#125;).listen(8000);</span><br><span class=\"line\"></span><br><span class=\"line\">$ curl https://localhost:8000/ </span><br><span class=\"line\">curl: (60) SSL certificate problem, verify that the CA cert is OK. Details: </span><br><span class=\"line\">error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed </span><br><span class=\"line\">More details here: http://curl.haxx.se/docs/sslcerts.html </span><br><span class=\"line\">curl performs SSL certificate verification by default, using a &quot;bundle&quot; </span><br><span class=\"line\"> of Certificate Authority (CA) public keys (CA certs). If the default </span><br><span class=\"line\"> bundle file isn&#x27;t adequate, you can specify an alternate file </span><br><span class=\"line\"> using the --cacert option. </span><br><span class=\"line\">If this HTTPS server uses a certificate signed by a CA represented in </span><br><span class=\"line\"> the bundle, the certificate verification probably failed due to a </span><br><span class=\"line\"> problem with the certificate (it might be expired, or the name might </span><br><span class=\"line\"> not match the domain name in the URL). </span><br><span class=\"line\">If you&#x27;d like to turn off curl&#x27;s verification of the certificate, use </span><br><span class=\"line\"> the -k (or --insecure) option.</span><br></pre></td></tr></table></figure>\n由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，解决方案：<ul>\n<li>一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险</li>\n<li>一种解决的方式是给curl设置–cacert选项，告知CA证书使之完成对服务器证书的验证<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -k https://localhost:8000/ </span><br><span class=\"line\">hello world</span><br><span class=\"line\"></span><br><span class=\"line\">$ curl --cacert keys/ca.crt https://localhost:8000/ </span><br><span class=\"line\">hello world </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>HTTPS客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var https = require(&#x27;https&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> hostname: &#x27;localhost&#x27;, </span><br><span class=\"line\"> port: 8000, </span><br><span class=\"line\"> path: &#x27;/&#x27;, </span><br><span class=\"line\"> method: &#x27;GET&#x27;, </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/client.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/client.crt&#x27;), </span><br><span class=\"line\"> ca: [fs.readFileSync(&#x27;./keys/ca.crt&#x27;)] </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">options.agent = new https.Agent(options); </span><br><span class=\"line\">var req = https.request(options, function(res) &#123; </span><br><span class=\"line\"> res.setEncoding(&#x27;utf-8&#x27;); </span><br><span class=\"line\"> res.on(&#x27;data&#x27;, function(d) &#123; </span><br><span class=\"line\"> console.log(d); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">req.end(); </span><br><span class=\"line\">req.on(&#x27;error&#x27;, function(e) &#123; </span><br><span class=\"line\"> console.log(e); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n如果不设置ca选项，将会得到如下异常: [Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE]<br>解决该异常的方案是添加选项属性rejectUnauthorized为false，它的效果与curl工具加-k一样，都会在数据传输过程中会加密，但是无法保证服务器端的证书不是伪造的</li>\n</ul>\n<p>??? 当客户端调用send()发送数据时，服务器端触发onmessage()；当服务器端调用send()发送数<br>据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装<br>为一帧或多帧数据，然后逐帧发送</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"内存控制\"><a href=\"#内存控制\" class=\"headerlink\" title=\"内存控制\"></a>内存控制</h4><ul>\n<li><p>V8 的对象分配</p>\n<ul>\n<li>在V8中，所有的JavaScript对象都是通过堆来进行分配的。</li>\n<li>V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制</li>\n<li>Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小</li>\n</ul>\n</li>\n<li><p>V8 的垃圾回收机制</p>\n<ul>\n<li>V8主要的垃圾回收算法<ul>\n<li>V8的垃圾回收策略主要基于分代式垃圾回收机制。</li>\n<li>V8的内存分代在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象</li>\n<li>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提及的–max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，-max-new-space-size命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错</li>\n<li>在默认设置下，如果一直分配内存，在64位系统和32位系统下会分别只能使用约1.4 GB和约0.7 GB的大小</li>\n<li>新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB</li>\n</ul>\n</li>\n<li>Scavenge算法<ul>\n<li>在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法</li>\n<li>Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</li>\n<li>在单纯的Scavenge过程中，From空间中的存活对象会被复制到To空间中去，然后对From空间和To空间进行角色对换（又称翻转）。但在分代式垃圾回收的前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</li>\n<li><img src=\"/nodejs/images/v8-promot.png\" alt=\"晋升流程\"></li>\n<li><img src=\"/nodejs/images/v8-promot2.png\" alt=\"晋升流程\"></li>\n</ul>\n</li>\n<li>Mark-Sweep &amp; Mark-Compact<ul>\n<li>V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象</li>\n<li>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态</li>\n<li>Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存</li>\n<li><img src=\"/nodejs/images/sweep-compact.png\" alt=\"标记移动\"></li>\n<li><img src=\"/nodejs/images/collect-diff.png\" alt=\"算法对比\"></li>\n<li>V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact</li>\n</ul>\n</li>\n<li>Incremental Marking<ul>\n<li>垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。</li>\n<li>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成</li>\n<li><img src=\"/nodejs/images/increase-target.png\" alt=\"增量标记\"></li>\n</ul>\n</li>\n<li>查看垃圾回收日志<ul>\n<li>查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数</li>\n<li>通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间<h6 id=\"高效使用内存\"><a href=\"#高效使用内存\" class=\"headerlink\" title=\"高效使用内存\"></a>高效使用内存</h6></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>作用域</p>\n<ul>\n<li>标识符查找</li>\n<li>作用域链</li>\n<li>变量的主动释放</li>\n</ul>\n</li>\n<li><p>闭包</p>\n<ul>\n<li>实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）</li>\n</ul>\n</li>\n<li><p>内存指标: process.memoryUsage()可以查看内存使用情况。除此之外，os模块中的totalmem()和freemem()方法也可以查看内存使用情况</p>\n<ul>\n<li>查看内存使用情况<ul>\n<li>查看进程的内存占用<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node </span><br><span class=\"line\">&gt; process.memoryUsage() </span><br><span class=\"line\">&#123; <span class=\"attr\">rss</span>: <span class=\"number\">13852672</span>, </span><br><span class=\"line\"> <span class=\"attr\">heapTotal</span>: <span class=\"number\">6131200</span>, </span><br><span class=\"line\"> <span class=\"attr\">heapUsed</span>: <span class=\"number\">2757120</span> &#125; </span><br></pre></td></tr></table></figure></li>\n<li>rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>查看系统的内存占用</li>\n</ol>\n<ul>\n<li>与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>堆外内存: 将那些不是通过V8分配的内存称为堆外内存</p>\n<ul>\n<li>Buffer对象并非通过V8分配<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var useMem = function () &#123; </span><br><span class=\"line\"> var size = 200 * 1024 * 1024; </span><br><span class=\"line\"> var buffer = new Buffer(size); </span><br><span class=\"line\"> for (var i = 0; i &lt; size; i++) &#123; </span><br><span class=\"line\"> buffer[i] = 0; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> return buffer; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<h6 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h6>Node对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃</li>\n</ul>\n</li>\n</ul>\n<p>造成内存泄漏的原因</p>\n<ul>\n<li>缓存。<ul>\n<li>在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功</li>\n<li>用对象的键值对来缓存东西，与严格意义上的缓存有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有</li>\n</ul>\n</li>\n<li>解决手段：限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长<ul>\n<li>缓存限制策略<ul>\n<li>记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰</li>\n<li>LRU算法的缓存，地址为<a href=\"https://github.com/isaacs/node-lru-cache\">https://github.com/isaacs/node-lru-cache</a></li>\n</ul>\n</li>\n<li>缓存的解决方案<ul>\n<li>采用进程外的缓存，进程自身不存储状态<ul>\n<li>(1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。</li>\n<li>(2) 进程之间可以共享缓存</li>\n<li>Redis：<a href=\"https://github.com/mranney/node_redis%E3%80%82\">https://github.com/mranney/node_redis。</a></li>\n<li>Memcached：<a href=\"https://github.com/3rd-Eden/node-memcached%E3%80%82\">https://github.com/3rd-Eden/node-memcached。</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>队列消费不及时。<ul>\n<li>监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。</li>\n<li>任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值</li>\n</ul>\n</li>\n<li>作用域未释放</li>\n</ul>\n<h6 id=\"内存泄漏排查\"><a href=\"#内存泄漏排查\" class=\"headerlink\" title=\"内存泄漏排查\"></a>内存泄漏排查</h6><p>常见工具：</p>\n<ul>\n<li>v8-profiler</li>\n<li>node-heapdump<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var leakArray = []; </span><br><span class=\"line\">var leak = function () &#123; </span><br><span class=\"line\"> leakArray.push(&quot;leak&quot; + Math.random()); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> leak(); </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;Hello World\\n&#x27;); </span><br><span class=\"line\">&#125;).listen(1337); </span><br><span class=\"line\">console.log(&#x27;Server running at http://127.0.0.1:1337/&#x27;); </span><br></pre></td></tr></table></figure></li>\n<li>node-mtrace</li>\n<li>dtrace</li>\n<li>node-memwatch<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var memwatch = require(&#x27;memwatch&#x27;); </span><br><span class=\"line\">memwatch.on(&#x27;leak&#x27;, function (info) &#123; </span><br><span class=\"line\"> console.log(&#x27;leak:&#x27;); </span><br><span class=\"line\"> console.log(info); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">memwatch.on(&#x27;stats&#x27;, function (stats) &#123; </span><br><span class=\"line\"> console.log(&#x27;stats:&#x27;) </span><br><span class=\"line\"> console.log(stats); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var http = require(&#x27;http&#x27;); </span><br><span class=\"line\">var leakArray = []; </span><br><span class=\"line\">var leak = function () &#123; </span><br><span class=\"line\"> leakArray.push(&quot;leak&quot; + Math.random()); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">http.createServer(function (req, res) &#123; </span><br><span class=\"line\"> leak(); </span><br><span class=\"line\"> res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); </span><br><span class=\"line\"> res.end(&#x27;Hello World\\n&#x27;); </span><br><span class=\"line\">&#125;).listen(1337); </span><br><span class=\"line\">console.log(&#x27;Server running at http://127.0.0.1:1337/&#x27;); </span><br></pre></td></tr></table></figure>\n<ul>\n<li>stats事件<ul>\n<li>每次进行全堆垃圾回收时，将会触发一次stats事件<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stats: </span><br><span class=\"line\">&#123; num_full_gc: 4, // 第几次全堆垃圾回收</span><br><span class=\"line\"> num_inc_gc: 23, // 第几次增量垃圾回收</span><br><span class=\"line\"> heap_compactions: 4, // 第几次对老生代进行整理</span><br><span class=\"line\"> usage_trend: 0, // 使用趋势</span><br><span class=\"line\"> estimated_base: 7152944, // 预估基数</span><br><span class=\"line\"> current_base: 7152944, // 当前基数</span><br><span class=\"line\"> min: 6720776, // 最小</span><br><span class=\"line\"> max: 7152944 &#125; // 最大</span><br><span class=\"line\">在这些数据中，num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>leak事件<ul>\n<li>如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件</li>\n</ul>\n</li>\n<li>堆内存比较<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var memwatch = require(&#x27;memwatch&#x27;); </span><br><span class=\"line\">var leakArray = []; </span><br><span class=\"line\">var leak = function () &#123; </span><br><span class=\"line\"> leakArray.push(&quot;leak&quot; + Math.random()); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">// Take first snapshot </span><br><span class=\"line\">var hd = new memwatch.HeapDiff(); </span><br><span class=\"line\">for (var i = 0; i &lt; 10000; i++) &#123; </span><br><span class=\"line\"> leak(); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// Take the second snapshot and compute the diff </span><br><span class=\"line\">var diff = hd.end(); </span><br><span class=\"line\">console.log(JSON.stringify(diff, null, 2));</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"大内存应用\"><a href=\"#大内存应用\" class=\"headerlink\" title=\"大内存应用\"></a>大内存应用</h6><p>stream模块用于处理大文件。stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种</p>\n<p>由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reader = fs.createReadStream(&#x27;in.txt&#x27;); </span><br><span class=\"line\">var writer = fs.createWriteStream(&#x27;out.txt&#x27;); </span><br><span class=\"line\">reader.pipe(writer); </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"理解Buffer\"><a href=\"#理解Buffer\" class=\"headerlink\" title=\"理解Buffer\"></a>理解Buffer</h4><p>Buffer是一个像Array的对象，但它主要用于操作字节</p>\n<ul>\n<li>模块结构<ul>\n<li>Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现</li>\n<li><img src=\"/nodejs/images/buffer.png\" alt=\"buffer\"></li>\n<li>由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用</li>\n</ul>\n</li>\n<li>Buffer对象<ul>\n<li>Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值</li>\n<li>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只保留整数部分<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf[20] = -100; </span><br><span class=\"line\">console.log(buf[20]); // 156 </span><br><span class=\"line\">buf[21] = 300; </span><br><span class=\"line\">console.log(buf[21]); // 44 </span><br><span class=\"line\">buf[22] = 3.1415; </span><br><span class=\"line\">console.log(buf[22]); // 3 </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>Buffer内存分配<ul>\n<li>Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的</li>\n<li>此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略</li>\n<li>为了高效地使用申请来的内存，Node采用了slab分配机制,一种动态内存管理机制<ul>\n<li>full：完全分配状态。</li>\n<li>partial：部分分配状态。</li>\n<li>empty：没有被分配状态。</li>\n</ul>\n</li>\n<li>Node以8 KB为界限来区分Buffer是大对象还是小对象,这个8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配<ul>\n<li>分配小Buffer对象<ul>\n<li>如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它</li>\n<li><img src=\"/nodejs/images/buffer-1.png\" alt=\"buffer\"></li>\n<li>当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态</li>\n<li><img src=\"/nodejs/images/buffer-2.png\" alt=\"buffer\"></li>\n<li>如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费</li>\n<li><img src=\"/nodejs/images/buffer-3.png\" alt=\"buffer\"></li>\n<li>注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放</li>\n</ul>\n</li>\n<li>分配大Buffer对象<ul>\n<li>如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Buffer-的转换\"><a href=\"#Buffer-的转换\" class=\"headerlink\" title=\"Buffer 的转换\"></a>Buffer 的转换</h6><p>Buffer对象可以与字符串之间相互转换,目前支持的字符串编码类型有如下这几种:</p>\n<ul>\n<li><p>ASCII</p>\n</li>\n<li><p>UTF-8</p>\n</li>\n<li><p>UTF-16LE/UCS-2</p>\n</li>\n<li><p>Base64</p>\n</li>\n<li><p>Binary</p>\n</li>\n<li><p>Hex</p>\n</li>\n<li><p>字符串转Buffer</p>\n<ul>\n<li>字符串转Buffer对象主要是通过构造函数完成的：new Buffer(str, [encoding]);</li>\n<li>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储</li>\n<li>需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理</li>\n</ul>\n</li>\n<li><p>Buffer转字符串</p>\n<ul>\n<li>实现Buffer向字符串的转换也十分简单，Buffer对象的toString()可以将Buffer对象转换为字符串，代码如下：buf.toString([encoding], [start], [end]) </li>\n<li>可以设置encoding（默认为UTF-8）、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</li>\n</ul>\n</li>\n<li><p>Buffer不支持的编码类型</p>\n<ul>\n<li>Buffer提供了一个isEncoding()函数来判断编码是否支持转换：Buffer.isEncoding(encoding)</li>\n<li>在中国常用的GBK、GB2312和BIG-5编码都不在支持的行列中</li>\n<li>对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。iconv和iconv-lite两个模块可以支持更多的编码类型转换，包括Windows 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KOI8系列，以及Latin1、US-ASCII，也支持宽字节编码GBK和GB2312</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Buffer-的拼接\"><a href=\"#Buffer-的拼接\" class=\"headerlink\" title=\"Buffer 的拼接\"></a>Buffer 的拼接</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var rs = fs.createReadStream(&#x27;test.md&#x27;); </span><br><span class=\"line\">var data = &#x27;&#x27;; </span><br><span class=\"line\">rs.on(&quot;data&quot;, function (chunk)&#123; </span><br><span class=\"line\"> data += chunk; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">rs.on(&quot;end&quot;, function () &#123; </span><br><span class=\"line\"> console.log(data); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n<ul>\n<li>原因在于文件可读流在读取时会逐个读取Buffer</li>\n<li>setEncoding()与string_decoder()<ul>\n<li>setEncoding该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串</li>\n<li>string_decoder目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题。</li>\n</ul>\n</li>\n<li>正确拼接Buffer<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var chunks = []; </span><br><span class=\"line\">var size = 0; </span><br><span class=\"line\">res.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> chunks.push(chunk); </span><br><span class=\"line\"> size += chunk.length; </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">res.on(&#x27;end&#x27;, function () &#123; </span><br><span class=\"line\">   var buf = Buffer.concat(chunks, size); </span><br><span class=\"line\"> var str = iconv.decode(buf, &#x27;utf8&#x27;); </span><br><span class=\"line\"> console.log(str); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个合并的Buffer对象</li>\n<li>Buffer.concat()方法封装的从小Buffer对象向大Buffer对象的复制过程：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Buffer.concat = function(list, length) &#123; </span><br><span class=\"line\"> if (!Array.isArray(list)) &#123; </span><br><span class=\"line\"> throw new Error(&#x27;Usage: Buffer.concat(list, [length])&#x27;); </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> if (list.length === 0) &#123; </span><br><span class=\"line\"> return new Buffer(0); </span><br><span class=\"line\"> &#125; else if (list.length === 1) &#123; </span><br><span class=\"line\"> return list[0]; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> if (typeof length !== &#x27;number&#x27;) &#123; </span><br><span class=\"line\"> length = 0; </span><br><span class=\"line\"> for (var i = 0; i &lt; list.length; i++) &#123; </span><br><span class=\"line\"> var buf = list[i]; </span><br><span class=\"line\"> length += buf.length; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> var buffer = new Buffer(length); </span><br><span class=\"line\"> var pos = 0; </span><br><span class=\"line\"> for (var i = 0; i &lt; list.length; i++) &#123; </span><br><span class=\"line\"> var buf = list[i]; </span><br><span class=\"line\"> buf.copy(buffer, pos); </span><br><span class=\"line\"> pos += buf.length; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> return buffer; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<h6 id=\"Buffer-与性能\"><a href=\"#Buffer-与性能\" class=\"headerlink\" title=\"Buffer 与性能\"></a>Buffer 与性能</h6>通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗</li>\n</ul>\n</li>\n<li>文件读取<ul>\n<li>在文件的读取时，有一个highWaterMark设置对性能的影响至关重要<ul>\n<li>highWaterMark的大小对性能有两个影响的点<ul>\n<li>highWaterMark设置对Buffer内存的分配和使用有一定影响。</li>\n<li>highWaterMark设置过小，可能导致系统调用次数过多。</li>\n</ul>\n</li>\n<li>highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h4><p>Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端</p>\n<ul>\n<li>构建 TCP 服务<ul>\n<li>TCP<ul>\n<li>TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议</li>\n<li><img src=\"/nodejs/images/net-1.png\" alt=\"七层协议\"></li>\n<li>TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话</li>\n<li><img src=\"/nodejs/images/net-2.png\" alt=\"七层协议\"></li>\n</ul>\n</li>\n<li>创建TCP服务器端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var net = require(&#x27;net&#x27;); </span><br><span class=\"line\">var server = net.createServer(function (socket) &#123; </span><br><span class=\"line\"> // 新的连接</span><br><span class=\"line\"> socket.on(&#x27;data&#x27;, function (data) &#123; </span><br><span class=\"line\"> socket.write(&quot;你好&quot;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> socket.on(&#x27;end&#x27;, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;连接断开&#x27;); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\"> socket.write(&quot;欢迎光临《深入浅出Node.js》示例：\\n&quot;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.listen(8124, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;server bound&#x27;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>TCP服务的事件<ul>\n<li>服务器事件<ul>\n<li>listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。</li>\n<li>connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过net.create\u0002Server()，最后一个参数传递。</li>\n<li>close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li>\n<li>error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常</li>\n</ul>\n</li>\n<li>连接事件<ul>\n<li>data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。</li>\n<li>end：当连接中的任意一端发送了FIN数据时，将会触发该事件。</li>\n<li>connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。</li>\n<li>drain：当任意一端调用write()发送数据时，当前这端会触发该事件。</li>\n<li>error：当异常发生时，触发该事件。</li>\n<li>close：当套接字完全关闭时，触发该事件。</li>\n<li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了</li>\n</ul>\n</li>\n<li>TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。</li>\n<li>在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中</li>\n<li>另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件<h6 id=\"构建-UDP-服务\"><a href=\"#构建-UDP-服务\" class=\"headerlink\" title=\"构建 UDP 服务\"></a>构建 UDP 服务</h6>UDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>创建UDP套接字<ul>\n<li>创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。</li>\n<li>var dgram = require(‘dgram’); var socket = dgram.createSocket(“udp4”);</li>\n</ul>\n</li>\n<li>创建UDP服务器端<ul>\n<li>若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dgram = require(&quot;dgram&quot;); </span><br><span class=\"line\">var server = dgram.createSocket(&quot;udp4&quot;); </span><br><span class=\"line\">server.on(&quot;message&quot;, function (msg, rinfo) &#123; </span><br><span class=\"line\"> console.log(&quot;server got: &quot; + msg + &quot; from &quot; + </span><br><span class=\"line\"> rinfo.address + &quot;:&quot; + rinfo.port); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.on(&quot;listening&quot;, function () &#123; </span><br><span class=\"line\"> var address = server.address();</span><br><span class=\"line\"> console.log(&quot;server listening &quot; + </span><br><span class=\"line\"> address.address + &quot;:&quot; + address.port); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.bind(41234);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>创建UDP客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dgram = require(&#x27;dgram&#x27;); </span><br><span class=\"line\">var message = new Buffer(&quot;深入浅出Node.js&quot;); </span><br><span class=\"line\">var client = dgram.createSocket(&quot;udp4&quot;); </span><br><span class=\"line\">client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err, bytes) &#123; </span><br><span class=\"line\"> client.close(); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">socket.send(buf, offset, length, port, address, [callback])</span><br><span class=\"line\">// 参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调</span><br></pre></td></tr></table></figure></li>\n<li>UDP套接字事件<ul>\n<li>UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。它具备如下自定义事件<ul>\n<li>message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。</li>\n<li>listening：当UDP套接字开始侦听时触发该事件。</li>\n<li>close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。</li>\n<li>error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"构建-HTTP-服务\"><a href=\"#构建-HTTP-服务\" class=\"headerlink\" title=\"构建 HTTP 服务\"></a>构建 HTTP 服务</h6><ul>\n<li>HTTP<ul>\n<li>初识HTTP<ul>\n<li>HTTP的全称是超文本传输协议，英文写作HyperText Transfer Protocol</li>\n<li>HTTP构建在TCP之上，属于应用层协议。在HTTP的两端是服务器和浏览器，即著名的B/S模式，如今精彩纷呈的Web即是HTTP的应用。</li>\n<li>HTTP得以发展是W3C和IETF两个组织合作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。</li>\n</ul>\n</li>\n<li> HTTP报文<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -v http://127.0.0.1:1337 </span><br><span class=\"line\">* About to connect() to 127.0.0.1 port 1337 (#0) </span><br><span class=\"line\">* Trying 127.0.0.1... </span><br><span class=\"line\">* connected </span><br><span class=\"line\">* Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) </span><br><span class=\"line\">&gt; GET / HTTP/1.1 </span><br><span class=\"line\">&gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 </span><br><span class=\"line\">&gt; Host: 127.0.0.1:1337 </span><br><span class=\"line\">&gt; Accept: */* </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&lt; HTTP/1.1 200 OK </span><br><span class=\"line\">&lt; Content-Type: text/plain </span><br><span class=\"line\">&lt; Date: Sat, 06 Apr 2013 08:01:44 GMT </span><br><span class=\"line\">&lt; Connection: keep-alive </span><br><span class=\"line\">&lt; Transfer-Encoding: chunked </span><br><span class=\"line\">&lt; </span><br><span class=\"line\">Hello World</span><br><span class=\"line\">* Connection #0 to host 127.0.0.1 left intact </span><br><span class=\"line\">* Closing connection #0</span><br></pre></td></tr></table></figure></li>\n<li>HTTP服务只做两件事情：处理HTTP请求和发送HTTP响应</li>\n<li>http模块<ul>\n<li>在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。</li>\n<li><img src=\"/nodejs/images/net-3.png\" alt=\"http\"></li>\n<li>http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑</li>\n<li><img src=\"/nodejs/images/net-4.png\" alt=\"http\"><ul>\n<li>HTTP服务的事件<ul>\n<li>connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。</li>\n<li>request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。</li>\n<li>close事件：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。</li>\n<li>checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。</li>\n<li>connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭</li>\n<li>upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。</li>\n<li>clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件<h6 id=\"HTTP客户端\"><a href=\"#HTTP客户端\" class=\"headerlink\" title=\"HTTP客户端\"></a>HTTP客户端</h6>http模块提供了一个底层API：http.request(options, connect)，用于构造HTTP客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> hostname: &#x27;127.0.0.1&#x27;, </span><br><span class=\"line\"> port: 1334, </span><br><span class=\"line\"> path: &#x27;/&#x27;, </span><br><span class=\"line\"> method: &#x27;GET&#x27; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var req = http.request(options, function(res) &#123; </span><br><span class=\"line\"> console.log(&#x27;STATUS: &#x27; + res.statusCode); </span><br><span class=\"line\"> console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers)); </span><br><span class=\"line\"> res.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\"> res.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> console.log(chunk); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\nHTTP请求头中的选项有:</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>host：服务器的域名或IP地址，默认为localhost。</li>\n<li>hostname：服务器名称。</li>\n<li>port：服务器端口，默认为80。</li>\n<li>localAddress：建立网络连接的本地网卡。</li>\n<li>socketPath：Domain套接字路径。</li>\n<li>method：HTTP请求方法，默认为GET。</li>\n<li>path：请求路径，默认为/。</li>\n<li>headers：请求头对象。</li>\n<li>auth：Basic认证，这个值将被计算成请求头中的Authorization部分。</li>\n</ul>\n<ul>\n<li>HTTP响应<ul>\n<li>HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(res) &#123; </span><br><span class=\"line\"> console.log(&#x27;STATUS: &#x27; + res.statusCode); </span><br><span class=\"line\"> console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers)); </span><br><span class=\"line\"> res.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\"> res.on(&#x27;data&#x27;, function (chunk) &#123; </span><br><span class=\"line\"> console.log(chunk); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>HTTP 代理<ul>\n<li>http提供的ClientRequest对象也是基于TCP层实现的，在keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5个连接</li>\n<li><img src=\"./images/http.png\" alt=\"http\"></li>\n<li>调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接数的限制是相同的行为</li>\n<li>如果你在服务器端通过ClientRequest调用网络中的其他HTTP服务，记得关注代理对象对网络请求的限制。一旦请求量过大，连接限制将会限制服务性能。如需要改变，可以在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var agent = new http.Agent(&#123; </span><br><span class=\"line\"> maxSockets: 10 </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> hostname: &#x27;127.0.0.1&#x27;, </span><br><span class=\"line\"> port: 1334, </span><br><span class=\"line\"> path: &#x27;/&#x27;, </span><br><span class=\"line\"> method: &#x27;GET&#x27;, </span><br><span class=\"line\"> agent: agent </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure></li>\n<li>可以设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制</li>\n</ul>\n</li>\n<li>HTTP客户端事件<ul>\n<li>response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。</li>\n<li>socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li>\n<li>connect：当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。</li>\n<li>upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。</li>\n<li>continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"构建-WebSocket-服务\"><a href=\"#构建-WebSocket-服务\" class=\"headerlink\" title=\"构建 WebSocket 服务\"></a>构建 WebSocket 服务</h6><ul>\n<li>WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。</li>\n<li>WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。</li>\n</ul>\n<p>websocket与http相比的优点：</p>\n<ul>\n<li>客户端与服务器端只建立一个TCP连接，可以使用更少的连接。</li>\n<li>WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。</li>\n<li>有更轻量级的协议头，减少数据传送量。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&#x27;ws://127.0.0.1:12010/updates&#x27;); </span><br><span class=\"line\">socket.onopen = function () &#123; </span><br><span class=\"line\"> setInterval(function() &#123; </span><br><span class=\"line\"> if (socket.bufferedAmount == 0) </span><br><span class=\"line\"> socket.send(getUpdateData()); </span><br><span class=\"line\"> &#125;, 50); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">socket.onmessage = function (event) &#123; </span><br><span class=\"line\"> // TODO：event.data </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用Comet（彗星）来命名它</p>\n<ul>\n<li>WebSocket握手<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1 </span><br><span class=\"line\">Host: server.example.com </span><br><span class=\"line\">Upgrade: websocket </span><br><span class=\"line\">Connection: Upgrade </span><br><span class=\"line\">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== </span><br><span class=\"line\">Sec-WebSocket-Protocol: chat, superchat </span><br><span class=\"line\">Sec-WebSocket-Version: 13 </span><br></pre></td></tr></table></figure>\n<ul>\n<li>Upgrade/Connection两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验</li>\n<li>Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端</li>\n<li>服务器端在处理完请求后，响应如下报文：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols </span><br><span class=\"line\">Upgrade: websocket </span><br><span class=\"line\">Connection: Upgrade </span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= </span><br><span class=\"line\">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"WebSocket数据传输\"><a href=\"#WebSocket数据传输\" class=\"headerlink\" title=\"WebSocket数据传输\"></a>WebSocket数据传输</h6><p><img src=\"/nodejs/images/websocket.png\" alt=\"websocket\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket.prototype.setSocket = function (socket) &#123; </span><br><span class=\"line\"> this.socket = socket; </span><br><span class=\"line\"> this.socket.on(&#x27;data&#x27;, this.receiver); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">WebSocket.prototype.send = function (data) &#123; </span><br><span class=\"line\"> this._send(data); </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭</li>\n<li><img src=\"/nodejs/images/websocket-1.png\" alt=\"websocket\"></li>\n<li>fin：如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为多帧时，它既是第一帧也是最后一帧。</li>\n<li>rsv1、rsv2、rsv3：各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为1，其余情况为0。</li>\n<li>opcode：长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示ping数据帧，10表示pong数据帧，其余值暂时没有定义。ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。</li>\n<li>masked：表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。</li>\n<li>payload length：一个7、7+16或7+64位长的数据位，标识数据的长度，如果值在0~125之间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，则后面64位的值是数据的真实长度。</li>\n<li>masking key：当masked为1时存在，是一个32位长的数据位，用于解密数据。</li>\n<li>payload data：我们的目标数据，位数为8的倍数。</li>\n</ul>\n<p>node与websocket共性</p>\n<ul>\n<li>基于事件的编程接口。</li>\n<li>基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。</li>\n</ul>\n<h6 id=\"网络服务与安全\"><a href=\"#网络服务与安全\" class=\"headerlink\" title=\"网络服务与安全\"></a>网络服务与安全</h6><p>Node在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上</p>\n<ul>\n<li>TLS/SSL<ul>\n<li>密钥<ul>\n<li>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥</li>\n<li><img src=\"/nodejs/images/tls-ssl.png\" alt=\"TLS/SSL\"></li>\n<li>Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 私钥</span><br><span class=\"line\">// 生成服务器端私钥</span><br><span class=\"line\">$ openssl genrsa -out server.key 1024 </span><br><span class=\"line\">// 生成客户端私钥</span><br><span class=\"line\">$ openssl genrsa -out client.key 1024</span><br><span class=\"line\"></span><br><span class=\"line\">#公钥</span><br><span class=\"line\">$ openssl rsa -in server.key -pubout -out server.pem </span><br><span class=\"line\">$ openssl rsa -in client.key -pubout -out client.pem </span><br></pre></td></tr></table></figure></li>\n<li>传递公私钥中可能存在中间人攻击，为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名</li>\n</ul>\n</li>\n<li>数字证书<ul>\n<li>CA（Certificate Authority，数字证书认证中心）。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名</li>\n<li>通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ openssl genrsa -out ca.key 1024 </span><br><span class=\"line\">$ openssl req -new -key ca.key -out ca.csr </span><br><span class=\"line\">$ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure></li>\n<li><img src=\"/nodejs/images/ca.png\" alt=\"CA\"></li>\n<li><img src=\"/nodejs/images/ca-1.png\" alt=\"CA\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"TLS服务\"><a href=\"#TLS服务\" class=\"headerlink\" title=\"TLS服务\"></a>TLS服务</h6><ul>\n<li>创建服务器端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tls = require(&#x27;tls&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/server.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/server.crt&#x27;), </span><br><span class=\"line\"> requestCert: true, </span><br><span class=\"line\"> ca: [ fs.readFileSync(&#x27;./keys/ca.crt&#x27;) ] </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var server = tls.createServer(options, function (stream) &#123; </span><br><span class=\"line\"> console.log(&#x27;server connected&#x27;, stream.authorized ? &#x27;authorized&#x27; : &#x27;unauthorized&#x27;); </span><br><span class=\"line\"> stream.write(&quot;welcome!\\n&quot;); </span><br><span class=\"line\"> stream.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\"> stream.pipe(stream); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">server.listen(8000, function() &#123;</span><br><span class=\"line\">  console.log(&#x27;server bound&#x27;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"># 通过下面的命令可以测试证书是否正常</span><br><span class=\"line\">$ openssl s_client -connect 127.0.0.1:8000</span><br></pre></td></tr></table></figure></li>\n<li>TLS客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建私钥</span><br><span class=\"line\">$ openssl genrsa -out client.key 1024 </span><br><span class=\"line\">// 生成CSR </span><br><span class=\"line\">$ openssl req -new -key client.key -out client.csr </span><br><span class=\"line\">// 生成签名证书</span><br><span class=\"line\">$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt</span><br><span class=\"line\"></span><br><span class=\"line\">var tls = require(&#x27;tls&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/client.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/client.crt&#x27;), </span><br><span class=\"line\"> ca: [ fs.readFileSync(&#x27;./keys/ca.crt&#x27;) ] </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var stream = tls.connect(8000, options, function () &#123; </span><br><span class=\"line\"> console.log(&#x27;client connected&#x27;, stream.authorized ? &#x27;authorized&#x27; : &#x27;unauthorized&#x27;); </span><br><span class=\"line\"> process.stdin.pipe(stream); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">stream.setEncoding(&#x27;utf8&#x27;); </span><br><span class=\"line\">stream.on(&#x27;data&#x27;, function(data) &#123; </span><br><span class=\"line\"> console.log(data); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">stream.on(&#x27;end&#x27;, function() &#123; </span><br><span class=\"line\"> server.close(); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"HTTPS服务\"><a href=\"#HTTPS服务\" class=\"headerlink\" title=\"HTTPS服务\"></a>HTTPS服务</h6><ul>\n<li>创建HTTPS服务<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var https = require(&#x27;https&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/server.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/server.crt&#x27;) </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">https.createServer(options, function (req, res) &#123; </span><br><span class=\"line\"> res.writeHead(200); </span><br><span class=\"line\"> res.end(&quot;hello world\\n&quot;); </span><br><span class=\"line\">&#125;).listen(8000);</span><br><span class=\"line\"></span><br><span class=\"line\">$ curl https://localhost:8000/ </span><br><span class=\"line\">curl: (60) SSL certificate problem, verify that the CA cert is OK. Details: </span><br><span class=\"line\">error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed </span><br><span class=\"line\">More details here: http://curl.haxx.se/docs/sslcerts.html </span><br><span class=\"line\">curl performs SSL certificate verification by default, using a &quot;bundle&quot; </span><br><span class=\"line\"> of Certificate Authority (CA) public keys (CA certs). If the default </span><br><span class=\"line\"> bundle file isn&#x27;t adequate, you can specify an alternate file </span><br><span class=\"line\"> using the --cacert option. </span><br><span class=\"line\">If this HTTPS server uses a certificate signed by a CA represented in </span><br><span class=\"line\"> the bundle, the certificate verification probably failed due to a </span><br><span class=\"line\"> problem with the certificate (it might be expired, or the name might </span><br><span class=\"line\"> not match the domain name in the URL). </span><br><span class=\"line\">If you&#x27;d like to turn off curl&#x27;s verification of the certificate, use </span><br><span class=\"line\"> the -k (or --insecure) option.</span><br></pre></td></tr></table></figure>\n由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，解决方案：<ul>\n<li>一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险</li>\n<li>一种解决的方式是给curl设置–cacert选项，告知CA证书使之完成对服务器证书的验证<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -k https://localhost:8000/ </span><br><span class=\"line\">hello world</span><br><span class=\"line\"></span><br><span class=\"line\">$ curl --cacert keys/ca.crt https://localhost:8000/ </span><br><span class=\"line\">hello world </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>HTTPS客户端<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var https = require(&#x27;https&#x27;); </span><br><span class=\"line\">var fs = require(&#x27;fs&#x27;); </span><br><span class=\"line\">var options = &#123; </span><br><span class=\"line\"> hostname: &#x27;localhost&#x27;, </span><br><span class=\"line\"> port: 8000, </span><br><span class=\"line\"> path: &#x27;/&#x27;, </span><br><span class=\"line\"> method: &#x27;GET&#x27;, </span><br><span class=\"line\"> key: fs.readFileSync(&#x27;./keys/client.key&#x27;), </span><br><span class=\"line\"> cert: fs.readFileSync(&#x27;./keys/client.crt&#x27;), </span><br><span class=\"line\"> ca: [fs.readFileSync(&#x27;./keys/ca.crt&#x27;)] </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">options.agent = new https.Agent(options); </span><br><span class=\"line\">var req = https.request(options, function(res) &#123; </span><br><span class=\"line\"> res.setEncoding(&#x27;utf-8&#x27;); </span><br><span class=\"line\"> res.on(&#x27;data&#x27;, function(d) &#123; </span><br><span class=\"line\"> console.log(d); </span><br><span class=\"line\"> &#125;); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">req.end(); </span><br><span class=\"line\">req.on(&#x27;error&#x27;, function(e) &#123; </span><br><span class=\"line\"> console.log(e); </span><br><span class=\"line\">&#125;); </span><br></pre></td></tr></table></figure>\n如果不设置ca选项，将会得到如下异常: [Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE]<br>解决该异常的方案是添加选项属性rejectUnauthorized为false，它的效果与curl工具加-k一样，都会在数据传输过程中会加密，但是无法保证服务器端的证书不是伪造的</li>\n</ul>\n<p>??? 当客户端调用send()发送数据时，服务器端触发onmessage()；当服务器端调用send()发送数<br>据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装<br>为一帧或多帧数据，然后逐帧发送</p>\n"},{"title":"nodejs基础知识(3)","date":"2022-12-28T04:18:33.000Z","tags":["node","buffer"],"_content":"\n###### Buffer(缓冲)\n\n**buf.entries()**\n从 buf 的内容中，创建并返回一个 [index, byte] 形式的迭代器\n```\nconst buf = Buffer.from('buffer');\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n// 输出:\n// [ 0, 0 ]\n// [ 1, 0 ]\n// [ 2, 0 ]\n// [ 3, 0 ]\n// [ 4, 0 ]\n// [ 5, 0 ]\n// [ 6, 0 ]\n// [ 7, 0 ]\n// [ 8, 0 ]\n// [ 9, 0 ]\n```\n\n**buf.equals(otherBuffer)**\n如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。\n```\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// 输出: true\n\nconsole.log(buf1.equals(buf3));\n// 输出: false\n```\n\n**buf.fill(value[, offset[, end]][, encoding])**\nvalue <string> | <Buffer> | <integer> 用来填充 buf 的值。\noffset <integer> 开始填充 buf 前要跳过的字节数。默认: 0。\nend <integer> 结束填充 buf 的位置（不包含）。默认: buf.length。\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。默认: 'utf8'。\n返回: <Buffer> buf 的引用。\n如果未指定 offset 和 end，则填充整个 buf。 这个简化使得一个 Buffer 的创建与填充可以在一行内完成。\n```\nconst b = Buffer.allocUnsafe(50).fill('h');\nconsole.log(b.toString());\n// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n```\nvalue 如果不是一个字符串或整数，则会被强行转换为 uint32 值。\n如果 fill() 操作的最后一次写入的是一个多字节字符，则只有字符中适合 buf 的第一个字节会被写入。\n```\nconsole.log(Buffer.allocUnsafe(3).fill('\\u0222'));\n// 输出: <Buffer c8 a2 c8>\n\nconst buf = Buffer.allocUnsafe(5);\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\n```\n\n**buf.includes(value[, byteOffset][, encoding])**\nvalue <string> | <Buffer> | <integer> 要搜索的值\nbyteOffset <integer> buf 中开始搜索的位置。默认: 0\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: 'utf8'\n返回: <boolean> 如果 buf 找到 value，则返回 true，否则返回 false\n相当于 buf.indexOf() !== -1。\n\n**buf.indexOf(value[, byteOffset][, encoding])**\nvalue <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值\nbyteOffset <integer> buf 中开始搜索的位置。默认: 0\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: 'utf8'\n返回: <integer> buf 中 value 首次出现的索引，如果 buf 没包含 value 则返回 -1\n如果 value 是：\n- 字符串，则 value 根据 encoding 的字符编码进行解析。\n- Buffer 或 Uint8Array，则 value 会被作为一个整体使用。如果要比较部分 Buffer，可使用 buf.slice()。\n- 数值, 则 value 会解析为一个 0 至 255 之间的无符号八位整数值。\n\n如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。\n\n如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN 或者 0, 像 {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#indexOf() 保持一致。\n\n如果 value 是一个空字符串或空 Buffer，并且 byteOffset 小于 buf.length，返回 byteOffset。如果 value 是一个空字符串，并且 byteOffset 大于 buf.length，返回 buf.length。\n```\nconst b = Buffer.from('abcdef');\n\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n// 传入一个不是有效字节的数字\n// 输出：2，相当于搜索 99 或 'c'\n\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n// 传入 byteOffset，其值强制转换为 NaN 或 0\n// 输出：1，搜索整个 buffer\n```\n\n**buf.keys()**\n创建并返回一个包含 buf 键名（索引）的迭代器。\n\n**buf.lastIndexOf(value[, byteOffset][, encoding])**\nvalue <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值\nbyteOffset <integer> buf 中开始搜索的位置。 默认: buf.length- 1\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: 'utf8'\n返回: <integer> buf 中 value 最后一次出现的索引，如果 buf 没包含 value 则返回 -1\n与 buf.indexOf() 类似，除了 buf 是从后往前搜索而不是从前往后。\n\n如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。\n\n如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN or 0, like {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#lastIndexOf() 保持一致。\n\n如果 value 是一个空字符串或者空 Buffer，返回 byteOffset。\n\n```\nconst b = Buffer.from('abcdef');\n\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n// 传入一个不是有效字节的数字\n// 输出：2，相当于搜索 99 或 'c'\n\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n// 传入 byteOffset，其值强制转换为 NaN\n// 输出：-1，搜索整个 buffer\n\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n// 传入 byteOffset，其值强制转换为 0\n// 输出：-1，相当于传入 0\n```\n\n**buf.length**\n返回 buf 在字节数上分配的内存量。 注意，这并不一定反映 buf 内可用的数据量。\n```\nconst buf = Buffer.alloc(1234);\n\n// 输出: 1234\nconsole.log(buf.length);\n\nbuf.write('some string', 0, 'ascii');\n\n// 输出: 1234\nconsole.log(buf.length);\n```\n虽然 length 属性不是不可变的，但改变 length 的值可能会导致不确定、不一致的行为。 那些希望修改一个 Buffer 的长度的应用程序应当将 length 视为只读的，且使用 buf.slice() 创建一个新的 Buffer\n```\nlet buf = Buffer.allocUnsafe(10);\n\nbuf.write('abcdefghj', 0, 'ascii');\n\nconsole.log(buf.length);\n// 输出: 10\n\nbuf = buf.slice(0, 5);\n\nconsole.log(buf.length);\n// 输出: 5\n```\n\n**buf.readDoubleBE(offset[, noAssert])、buf.readDoubleLE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 8。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <number>\n用指定的字节序格式（readDoubleBE() 返回大端序，readDoubleLE() 返回小端序）从 buf 中指定的 offset 读取一个64位双精度值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n```\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE());\n// 输出: 8.20788039913184e-304\n\nconsole.log(buf.readDoubleLE());\n// 输出: 5.447603722011605e-270\n\nconsole.log(buf.readDoubleLE(1));\n// 抛出异常: RangeError: Index out of range\n\nconsole.log(buf.readDoubleLE(1, true));\n// 警告: 读取超出 buffer 的最后一位字节！\n// 这会导致内存区段错误！不要这么做！\n```\n\n**buf.readFloatBE(offset[, noAssert])、buf.readFloatLE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 4。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <number>\n用指定的字节序格式（readFloatBE() 返回大端序，readFloatLE() 返回小端序）从 buf 中指定的 offset 读取一个32位浮点值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n```\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE());\n// 输出: 2.387939260590663e-38\n\nconsole.log(buf.readFloatLE());\n// 输出: 1.539989614439558e-36\n\nconsole.log(buf.readFloatLE(1));\n// 抛出异常: RangeError: Index out of range\n\nconsole.log(buf.readFloatLE(1, true));\n// 警告: 读取超出 buffer 的最后一位字节！\n// 这会导致内存区段错误！不要这么做！\n```\n\n**buf.readInt8(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 1。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取一个有符号的8位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n从 Buffer 中读取的整数值会被解析为二进制补码值。\n\n**buf.readInt16BE(offset[, noAssert])、buf.readInt16LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 2。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readInt16BE() 返回大端序，readInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的16位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n从 Buffer 中读取的整数值会被解析为二进制补码值。\n\n**buf.readInt32BE(offset[, noAssert])、buf.readInt32LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 4。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readInt32BE() 返回大端序，readInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的32位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n从 Buffer 中读取的整数值会被解析为二进制补码值。\n\n**buf.readIntBE(offset, byteLength[, noAssert])、buf.readIntLE(offset, byteLength[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - byteLength。\nbyteLength <integer> 要读取的字节数。必须满足：0 < byteLength <= 6。\nnoAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为二进制补码值。 最高支持48位精度。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUInt8(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 1。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取一个无符号的8位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUInt16BE(offset[, noAssert])、buf.readUInt16LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 2。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readUInt16BE() 返回大端序，readUInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的16位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUInt32BE(offset[, noAssert])、buf.readUInt32LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 4。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readUInt32BE() 返回大端序，readUInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的32位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUIntBE(offset, byteLength[, noAssert])、buf.readUIntLE(offset, byteLength[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - byteLength。\nbyteLength <integer> 要读取的字节数。必须满足：0 < byteLength <= 6。\nnoAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为无符号的整数。 最高支持48位精度。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.slice([start[, end]])**\nstart <integer> 新建的 Buffer 开始的位置。 默认: 0\nend <integer> 新建的 Buffer 结束的位置（不包含）。 默认: buf.length\n返回: <Buffer>\n返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪。\n\n指定大于buf.length的结束值，与结束值设置为buf.length的结果一样。\n\n*注意，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的。*\n\n*指定负的索引会导致切片的生成是相对于 buf 的末尾而不是开头*\n```\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 是 'a' 的十进制 ASCII 值 \n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.slice(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// 输出: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// 输出: !bc\n\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.slice(-6, -1).toString());\n// 输出: buffe\n// (相当于 buf.slice(0, 5))\n\nconsole.log(buf.slice(-6, -2).toString());\n// 输出: buff\n// (相当于 buf.slice(0, 4))\n\nconsole.log(buf.slice(-5, -2).toString());\n// 输出: uff\n// (相当于 buf.slice(1, 4))\n```\n\n**buf.swap16()**\n将 buf 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是2的倍数，则抛出 RangeError 错误。\n```\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: <Buffer 01 02 03 04 05 06 07 08>\nconsole.log(buf1);\n\nbuf1.swap16();\n\n// 输出: <Buffer 02 01 04 03 06 05 08 07>\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 16-bits\nbuf2.swap16();\n```\n**buf.swap32()**\n将 buf 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是4的倍数，则抛出 RangeError 错误。\n```\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: <Buffer 01 02 03 04 05 06 07 08>\nconsole.log(buf1);\n\nbuf1.swap32();\n\n// 输出: <Buffer 04 03 02 01 08 07 06 05>\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 32-bits\nbuf2.swap32();\n```\n\n**buf.swap64()**\n将 buf 解析为一个64位的数值数组，并且以字节顺序原地进行交换。 如果 buf.length 不是8的倍数，则抛出 RangeError 错误。\n*注意，JavaScript 不能编码64位整数。 该方法是用来处理64位浮点数的。*\n\n**buf.toJSON()**\n返回 buf 的 JSON 格式。 当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该函数。\n```\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value && value.type === 'Buffer' ?\n    Buffer.from(value.data) :\n    value;\n});\n\n// 输出: <Buffer 01 02 03 04 05>\nconsole.log(copy);\n```\n\n**buf.toString([encoding[, start[, end]]])**\nencoding <string> 解码使用的字符编码。默认: 'utf8'\nstart <integer> 开始解码的字节偏移量。默认: 0\nend <integer> 结束解码的字节偏移量（不包含）。 默认: buf.length\n返回: <string>\n根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。\n\n字符串实例的最大长度（以UTF-16代码为单位）可查看buffer.constants.MAX_STRING_LENGTH。\n\n**buf.values()**\n创建并返回一个包含 buf 的值（字节）的迭代器。 当 Buffer 使用 for..of 时会自动调用该函数。\n\n**buf.write(string[, offset[, length]][, encoding])**\nstring <string> 要写入 buf 的字符串。\noffset <integer> 开始写入 string 前要跳过的字节数。默认: 0。\nlength <integer> 要写入的字节数。默认: buf.length - offset。\nencoding <string> string 的字符编码。默认: 'utf8'。\n返回: <integer> 写入的字节数。\n根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。\n\n**buf.writeDoubleBE(value, offset[, noAssert])、buf.writeDoubleLE(value, offset[, noAssert])**\n用指定的字节序格式（writeDoubleBE() 写入大端序，writeDoubleLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的64位双精度值。 当 value 不是一个64位双精度值时，反应是不确定的。\n\n**buf.writeFloatBE(value, offset[, noAssert])、buf.writeFloatLE(value, offset[, noAssert])**\n用指定的字节序格式（writeFloatBE() 写入大端序，writeFloatLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的32位浮点值。 当 value 不是一个32位浮点值时，反应是不确定的\n\n**buf.writeInt8(value, offset[, noAssert])**\n写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的8位整数。 当 value 不是一个有符号的8位整数时，反应是不确定的。\n\n**buf.writeInt16BE(value, offset[, noAssert])、buf.writeInt16LE(value, offset[, noAssert])**\n用指定的字节序格式（writeInt16BE() 写入大端序，writeInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的16位整数。 当 value 不是一个有符号的16位整数时，反应是不确定的。\n\n**buf.writeInt32BE(value, offset[, noAssert])、buf.writeInt32LE(value, offset[, noAssert])**\n用指定的字节序格式（writeInt32BE() 写入大端序，writeInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的32位整数。 当 value 不是一个有符号的32位整数时，反应是不确定的。\n\n**buf.writeIntBE(value, offset, byteLength[, noAssert])、buf.writeIntLE(value, offset, byteLength[, noAssert])**\n写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个有符号的整数时，反应是不确定的。\n\n**buf.writeUInt8(value, offset[, noAssert])**\n写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的8位整数。 当 value 不是一个无符号的8位整数时，反应是不确定的。\n\n**buf.writeUInt16BE(value, offset[, noAssert])、buf.writeUInt16LE(value, offset[, noAssert])**\n用指定的字节序格式（writeUInt16BE() 写入大端序，writeUInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的16位整数。 当 value 不是一个无符号的16位整数时，反应是不确定的。\n\n**buf.writeUInt32BE(value, offset[, noAssert])、buf.writeUInt32LE(value, offset[, noAssert])**\n用指定的字节序格式（writeUInt32BE() 写入大端序，writeUInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的32位整数。 当 value 不是一个无符号的32位整数时，反应是不确定的。\n\n**buf.writeUIntBE(value, offset, byteLength[, noAssert])、buf.writeUIntLE(value, offset, byteLength[, noAssert])**\n写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个无符号的整数时，反应是不确定的。\n\n**buffer.INSPECT_MAX_BYTES**\n当调用 buf.inspect() 时返回的最大字节数。 可以被用户模块重写。 详见 util.inspect() 了解更多 buf.inspect() 的行为。\n\n注意，这个属性是在通过 require('buffer') 返回的 buffer 模块上，而不是在 Buffer 的全局变量或 Buffer 实例上。默认值：50\n\n**buffer.kMaxLength**\n分配给单个 Buffer 实例的最大内存\n注意整个属性是通过 require('buffer') 返回的 buffer 模块的属性，而不是全局 Buffer 对象或 Buffer 实例的属性。\n\n**buffer.transcode(source, fromEnc, toEnc)**\nsource <Buffer> | <Uint8Array> 一个 Buffer 或 Uint8Array 实例\nfromEnc <string> 当前编码\ntoEnc <string> 目标编码\n将给定的 Buffer 或 Uint8Array 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。\n如果 fromEnc 或 toEnc 指定的字符串编码无效，或者不允许从 fromEnc 转换为 toEnc，将抛出异常。\n如果给定的字节序列不能在目标编码中充分表示，转码过程将使用替代字符。\n```\nconst buffer = require('buffer');\n\nconst newBuf = buffer.transcode(Buffer.from('€'), 'utf8', 'ascii');\nconsole.log(newBuf.toString('ascii'));\n// 输出: '?'\n```\n因为欧元符号（€）不能在 US-ASCII 中表示，所以在转换 Buffer 的时候使用 ? 代替。\n\n**Buffer Constants**\n请注意buffer.constants是通过require('buffer')返回的buffer模块的一个属性，而不是全局Buffer或Buffer实例\n- buffer.constants.MAX_LENGTH\n  - 单个Buffer实例允许的最大量度。在32位体系结构上，这个值是(2^30)-1 (~1GB)。 在64位体系结构上，这个值是(2^31)-1 (~2GB)。也可在buffer.kMaxLength查看该值。\n- buffer.constants.MAX_STRING_LENGTH\n  - 单个string实例允许的最大长度。代表string能有的原始最大长度，以UTF-16代码为单位。该值可能取决于正在使用的JS引擎。","source":"nodejs/nodejs-note-8.md","raw":"---\ntitle: nodejs基础知识(3)\ndate: 2022-12-28 12:18:33\ntags: [node, buffer]\n---\n\n###### Buffer(缓冲)\n\n**buf.entries()**\n从 buf 的内容中，创建并返回一个 [index, byte] 形式的迭代器\n```\nconst buf = Buffer.from('buffer');\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n// 输出:\n// [ 0, 0 ]\n// [ 1, 0 ]\n// [ 2, 0 ]\n// [ 3, 0 ]\n// [ 4, 0 ]\n// [ 5, 0 ]\n// [ 6, 0 ]\n// [ 7, 0 ]\n// [ 8, 0 ]\n// [ 9, 0 ]\n```\n\n**buf.equals(otherBuffer)**\n如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。\n```\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// 输出: true\n\nconsole.log(buf1.equals(buf3));\n// 输出: false\n```\n\n**buf.fill(value[, offset[, end]][, encoding])**\nvalue <string> | <Buffer> | <integer> 用来填充 buf 的值。\noffset <integer> 开始填充 buf 前要跳过的字节数。默认: 0。\nend <integer> 结束填充 buf 的位置（不包含）。默认: buf.length。\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。默认: 'utf8'。\n返回: <Buffer> buf 的引用。\n如果未指定 offset 和 end，则填充整个 buf。 这个简化使得一个 Buffer 的创建与填充可以在一行内完成。\n```\nconst b = Buffer.allocUnsafe(50).fill('h');\nconsole.log(b.toString());\n// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n```\nvalue 如果不是一个字符串或整数，则会被强行转换为 uint32 值。\n如果 fill() 操作的最后一次写入的是一个多字节字符，则只有字符中适合 buf 的第一个字节会被写入。\n```\nconsole.log(Buffer.allocUnsafe(3).fill('\\u0222'));\n// 输出: <Buffer c8 a2 c8>\n\nconst buf = Buffer.allocUnsafe(5);\nconsole.log(buf.fill('a'));\n// Prints: <Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Prints: <Buffer aa aa aa aa aa>\n```\n\n**buf.includes(value[, byteOffset][, encoding])**\nvalue <string> | <Buffer> | <integer> 要搜索的值\nbyteOffset <integer> buf 中开始搜索的位置。默认: 0\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: 'utf8'\n返回: <boolean> 如果 buf 找到 value，则返回 true，否则返回 false\n相当于 buf.indexOf() !== -1。\n\n**buf.indexOf(value[, byteOffset][, encoding])**\nvalue <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值\nbyteOffset <integer> buf 中开始搜索的位置。默认: 0\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: 'utf8'\n返回: <integer> buf 中 value 首次出现的索引，如果 buf 没包含 value 则返回 -1\n如果 value 是：\n- 字符串，则 value 根据 encoding 的字符编码进行解析。\n- Buffer 或 Uint8Array，则 value 会被作为一个整体使用。如果要比较部分 Buffer，可使用 buf.slice()。\n- 数值, 则 value 会解析为一个 0 至 255 之间的无符号八位整数值。\n\n如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。\n\n如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN 或者 0, 像 {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#indexOf() 保持一致。\n\n如果 value 是一个空字符串或空 Buffer，并且 byteOffset 小于 buf.length，返回 byteOffset。如果 value 是一个空字符串，并且 byteOffset 大于 buf.length，返回 buf.length。\n```\nconst b = Buffer.from('abcdef');\n\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n// 传入一个不是有效字节的数字\n// 输出：2，相当于搜索 99 或 'c'\n\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n// 传入 byteOffset，其值强制转换为 NaN 或 0\n// 输出：1，搜索整个 buffer\n```\n\n**buf.keys()**\n创建并返回一个包含 buf 键名（索引）的迭代器。\n\n**buf.lastIndexOf(value[, byteOffset][, encoding])**\nvalue <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值\nbyteOffset <integer> buf 中开始搜索的位置。 默认: buf.length- 1\nencoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: 'utf8'\n返回: <integer> buf 中 value 最后一次出现的索引，如果 buf 没包含 value 则返回 -1\n与 buf.indexOf() 类似，除了 buf 是从后往前搜索而不是从前往后。\n\n如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。\n\n如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN or 0, like {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#lastIndexOf() 保持一致。\n\n如果 value 是一个空字符串或者空 Buffer，返回 byteOffset。\n\n```\nconst b = Buffer.from('abcdef');\n\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n// 传入一个不是有效字节的数字\n// 输出：2，相当于搜索 99 或 'c'\n\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n// 传入 byteOffset，其值强制转换为 NaN\n// 输出：-1，搜索整个 buffer\n\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n// 传入 byteOffset，其值强制转换为 0\n// 输出：-1，相当于传入 0\n```\n\n**buf.length**\n返回 buf 在字节数上分配的内存量。 注意，这并不一定反映 buf 内可用的数据量。\n```\nconst buf = Buffer.alloc(1234);\n\n// 输出: 1234\nconsole.log(buf.length);\n\nbuf.write('some string', 0, 'ascii');\n\n// 输出: 1234\nconsole.log(buf.length);\n```\n虽然 length 属性不是不可变的，但改变 length 的值可能会导致不确定、不一致的行为。 那些希望修改一个 Buffer 的长度的应用程序应当将 length 视为只读的，且使用 buf.slice() 创建一个新的 Buffer\n```\nlet buf = Buffer.allocUnsafe(10);\n\nbuf.write('abcdefghj', 0, 'ascii');\n\nconsole.log(buf.length);\n// 输出: 10\n\nbuf = buf.slice(0, 5);\n\nconsole.log(buf.length);\n// 输出: 5\n```\n\n**buf.readDoubleBE(offset[, noAssert])、buf.readDoubleLE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 8。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <number>\n用指定的字节序格式（readDoubleBE() 返回大端序，readDoubleLE() 返回小端序）从 buf 中指定的 offset 读取一个64位双精度值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n```\nconst buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE());\n// 输出: 8.20788039913184e-304\n\nconsole.log(buf.readDoubleLE());\n// 输出: 5.447603722011605e-270\n\nconsole.log(buf.readDoubleLE(1));\n// 抛出异常: RangeError: Index out of range\n\nconsole.log(buf.readDoubleLE(1, true));\n// 警告: 读取超出 buffer 的最后一位字节！\n// 这会导致内存区段错误！不要这么做！\n```\n\n**buf.readFloatBE(offset[, noAssert])、buf.readFloatLE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 4。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <number>\n用指定的字节序格式（readFloatBE() 返回大端序，readFloatLE() 返回小端序）从 buf 中指定的 offset 读取一个32位浮点值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n```\nconst buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE());\n// 输出: 2.387939260590663e-38\n\nconsole.log(buf.readFloatLE());\n// 输出: 1.539989614439558e-36\n\nconsole.log(buf.readFloatLE(1));\n// 抛出异常: RangeError: Index out of range\n\nconsole.log(buf.readFloatLE(1, true));\n// 警告: 读取超出 buffer 的最后一位字节！\n// 这会导致内存区段错误！不要这么做！\n```\n\n**buf.readInt8(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 1。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取一个有符号的8位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n从 Buffer 中读取的整数值会被解析为二进制补码值。\n\n**buf.readInt16BE(offset[, noAssert])、buf.readInt16LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 2。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readInt16BE() 返回大端序，readInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的16位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n从 Buffer 中读取的整数值会被解析为二进制补码值。\n\n**buf.readInt32BE(offset[, noAssert])、buf.readInt32LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 4。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readInt32BE() 返回大端序，readInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的32位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n从 Buffer 中读取的整数值会被解析为二进制补码值。\n\n**buf.readIntBE(offset, byteLength[, noAssert])、buf.readIntLE(offset, byteLength[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - byteLength。\nbyteLength <integer> 要读取的字节数。必须满足：0 < byteLength <= 6。\nnoAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为二进制补码值。 最高支持48位精度。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUInt8(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 1。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取一个无符号的8位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUInt16BE(offset[, noAssert])、buf.readUInt16LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 2。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readUInt16BE() 返回大端序，readUInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的16位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUInt32BE(offset[, noAssert])、buf.readUInt32LE(offset[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - 4。\nnoAssert <boolean> 是否跳过 offset 检验？默认: false。\n返回: <integer>\n用指定的字节序格式（readUInt32BE() 返回大端序，readUInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的32位整数值。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.readUIntBE(offset, byteLength[, noAssert])、buf.readUIntLE(offset, byteLength[, noAssert])**\noffset <integer> 开始读取前要跳过的字节数，必须满足：0 <= offset <= buf.length - byteLength。\nbyteLength <integer> 要读取的字节数。必须满足：0 < byteLength <= 6。\nnoAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。\n返回: <integer>\n从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为无符号的整数。 最高支持48位精度。\n\n设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。\n\n**buf.slice([start[, end]])**\nstart <integer> 新建的 Buffer 开始的位置。 默认: 0\nend <integer> 新建的 Buffer 结束的位置（不包含）。 默认: buf.length\n返回: <Buffer>\n返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪。\n\n指定大于buf.length的结束值，与结束值设置为buf.length的结果一样。\n\n*注意，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的。*\n\n*指定负的索引会导致切片的生成是相对于 buf 的末尾而不是开头*\n```\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 是 'a' 的十进制 ASCII 值 \n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.slice(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// 输出: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// 输出: !bc\n\n\nconst buf = Buffer.from('buffer');\n\nconsole.log(buf.slice(-6, -1).toString());\n// 输出: buffe\n// (相当于 buf.slice(0, 5))\n\nconsole.log(buf.slice(-6, -2).toString());\n// 输出: buff\n// (相当于 buf.slice(0, 4))\n\nconsole.log(buf.slice(-5, -2).toString());\n// 输出: uff\n// (相当于 buf.slice(1, 4))\n```\n\n**buf.swap16()**\n将 buf 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是2的倍数，则抛出 RangeError 错误。\n```\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: <Buffer 01 02 03 04 05 06 07 08>\nconsole.log(buf1);\n\nbuf1.swap16();\n\n// 输出: <Buffer 02 01 04 03 06 05 08 07>\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 16-bits\nbuf2.swap16();\n```\n**buf.swap32()**\n将 buf 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是4的倍数，则抛出 RangeError 错误。\n```\nconst buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: <Buffer 01 02 03 04 05 06 07 08>\nconsole.log(buf1);\n\nbuf1.swap32();\n\n// 输出: <Buffer 04 03 02 01 08 07 06 05>\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 32-bits\nbuf2.swap32();\n```\n\n**buf.swap64()**\n将 buf 解析为一个64位的数值数组，并且以字节顺序原地进行交换。 如果 buf.length 不是8的倍数，则抛出 RangeError 错误。\n*注意，JavaScript 不能编码64位整数。 该方法是用来处理64位浮点数的。*\n\n**buf.toJSON()**\n返回 buf 的 JSON 格式。 当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该函数。\n```\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value && value.type === 'Buffer' ?\n    Buffer.from(value.data) :\n    value;\n});\n\n// 输出: <Buffer 01 02 03 04 05>\nconsole.log(copy);\n```\n\n**buf.toString([encoding[, start[, end]]])**\nencoding <string> 解码使用的字符编码。默认: 'utf8'\nstart <integer> 开始解码的字节偏移量。默认: 0\nend <integer> 结束解码的字节偏移量（不包含）。 默认: buf.length\n返回: <string>\n根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。\n\n字符串实例的最大长度（以UTF-16代码为单位）可查看buffer.constants.MAX_STRING_LENGTH。\n\n**buf.values()**\n创建并返回一个包含 buf 的值（字节）的迭代器。 当 Buffer 使用 for..of 时会自动调用该函数。\n\n**buf.write(string[, offset[, length]][, encoding])**\nstring <string> 要写入 buf 的字符串。\noffset <integer> 开始写入 string 前要跳过的字节数。默认: 0。\nlength <integer> 要写入的字节数。默认: buf.length - offset。\nencoding <string> string 的字符编码。默认: 'utf8'。\n返回: <integer> 写入的字节数。\n根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。\n\n**buf.writeDoubleBE(value, offset[, noAssert])、buf.writeDoubleLE(value, offset[, noAssert])**\n用指定的字节序格式（writeDoubleBE() 写入大端序，writeDoubleLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的64位双精度值。 当 value 不是一个64位双精度值时，反应是不确定的。\n\n**buf.writeFloatBE(value, offset[, noAssert])、buf.writeFloatLE(value, offset[, noAssert])**\n用指定的字节序格式（writeFloatBE() 写入大端序，writeFloatLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的32位浮点值。 当 value 不是一个32位浮点值时，反应是不确定的\n\n**buf.writeInt8(value, offset[, noAssert])**\n写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的8位整数。 当 value 不是一个有符号的8位整数时，反应是不确定的。\n\n**buf.writeInt16BE(value, offset[, noAssert])、buf.writeInt16LE(value, offset[, noAssert])**\n用指定的字节序格式（writeInt16BE() 写入大端序，writeInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的16位整数。 当 value 不是一个有符号的16位整数时，反应是不确定的。\n\n**buf.writeInt32BE(value, offset[, noAssert])、buf.writeInt32LE(value, offset[, noAssert])**\n用指定的字节序格式（writeInt32BE() 写入大端序，writeInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的32位整数。 当 value 不是一个有符号的32位整数时，反应是不确定的。\n\n**buf.writeIntBE(value, offset, byteLength[, noAssert])、buf.writeIntLE(value, offset, byteLength[, noAssert])**\n写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个有符号的整数时，反应是不确定的。\n\n**buf.writeUInt8(value, offset[, noAssert])**\n写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的8位整数。 当 value 不是一个无符号的8位整数时，反应是不确定的。\n\n**buf.writeUInt16BE(value, offset[, noAssert])、buf.writeUInt16LE(value, offset[, noAssert])**\n用指定的字节序格式（writeUInt16BE() 写入大端序，writeUInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的16位整数。 当 value 不是一个无符号的16位整数时，反应是不确定的。\n\n**buf.writeUInt32BE(value, offset[, noAssert])、buf.writeUInt32LE(value, offset[, noAssert])**\n用指定的字节序格式（writeUInt32BE() 写入大端序，writeUInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的32位整数。 当 value 不是一个无符号的32位整数时，反应是不确定的。\n\n**buf.writeUIntBE(value, offset, byteLength[, noAssert])、buf.writeUIntLE(value, offset, byteLength[, noAssert])**\n写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个无符号的整数时，反应是不确定的。\n\n**buffer.INSPECT_MAX_BYTES**\n当调用 buf.inspect() 时返回的最大字节数。 可以被用户模块重写。 详见 util.inspect() 了解更多 buf.inspect() 的行为。\n\n注意，这个属性是在通过 require('buffer') 返回的 buffer 模块上，而不是在 Buffer 的全局变量或 Buffer 实例上。默认值：50\n\n**buffer.kMaxLength**\n分配给单个 Buffer 实例的最大内存\n注意整个属性是通过 require('buffer') 返回的 buffer 模块的属性，而不是全局 Buffer 对象或 Buffer 实例的属性。\n\n**buffer.transcode(source, fromEnc, toEnc)**\nsource <Buffer> | <Uint8Array> 一个 Buffer 或 Uint8Array 实例\nfromEnc <string> 当前编码\ntoEnc <string> 目标编码\n将给定的 Buffer 或 Uint8Array 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。\n如果 fromEnc 或 toEnc 指定的字符串编码无效，或者不允许从 fromEnc 转换为 toEnc，将抛出异常。\n如果给定的字节序列不能在目标编码中充分表示，转码过程将使用替代字符。\n```\nconst buffer = require('buffer');\n\nconst newBuf = buffer.transcode(Buffer.from('€'), 'utf8', 'ascii');\nconsole.log(newBuf.toString('ascii'));\n// 输出: '?'\n```\n因为欧元符号（€）不能在 US-ASCII 中表示，所以在转换 Buffer 的时候使用 ? 代替。\n\n**Buffer Constants**\n请注意buffer.constants是通过require('buffer')返回的buffer模块的一个属性，而不是全局Buffer或Buffer实例\n- buffer.constants.MAX_LENGTH\n  - 单个Buffer实例允许的最大量度。在32位体系结构上，这个值是(2^30)-1 (~1GB)。 在64位体系结构上，这个值是(2^31)-1 (~2GB)。也可在buffer.kMaxLength查看该值。\n- buffer.constants.MAX_STRING_LENGTH\n  - 单个string实例允许的最大长度。代表string能有的原始最大长度，以UTF-16代码为单位。该值可能取决于正在使用的JS引擎。","updated":"2022-12-28T09:11:41.079Z","path":"nodejs/nodejs-note-8.html","comments":1,"layout":"page","_id":"clchh4gww0012cktth0td3u8d","content":"<h6 id=\"Buffer-缓冲\"><a href=\"#Buffer-缓冲\" class=\"headerlink\" title=\"Buffer(缓冲)\"></a>Buffer(缓冲)</h6><p><strong>buf.entries()</strong><br>从 buf 的内容中，创建并返回一个 [index, byte] 形式的迭代器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from(&#x27;buffer&#x27;);</span><br><span class=\"line\">for (const pair of buf.entries()) &#123;</span><br><span class=\"line\">  console.log(pair);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出:</span><br><span class=\"line\">// [ 0, 0 ]</span><br><span class=\"line\">// [ 1, 0 ]</span><br><span class=\"line\">// [ 2, 0 ]</span><br><span class=\"line\">// [ 3, 0 ]</span><br><span class=\"line\">// [ 4, 0 ]</span><br><span class=\"line\">// [ 5, 0 ]</span><br><span class=\"line\">// [ 6, 0 ]</span><br><span class=\"line\">// [ 7, 0 ]</span><br><span class=\"line\">// [ 8, 0 ]</span><br><span class=\"line\">// [ 9, 0 ]</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.equals(otherBuffer)</strong><br>如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from(&#x27;ABC&#x27;);</span><br><span class=\"line\">const buf2 = Buffer.from(&#x27;414243&#x27;, &#x27;hex&#x27;);</span><br><span class=\"line\">const buf3 = Buffer.from(&#x27;ABCD&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.equals(buf2));</span><br><span class=\"line\">// 输出: true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.equals(buf3));</span><br><span class=\"line\">// 输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.fill(value[, offset[, end]][, encoding])</strong><br>value <string> | <Buffer> | <integer> 用来填充 buf 的值。<br>offset <integer> 开始填充 buf 前要跳过的字节数。默认: 0。<br>end <integer> 结束填充 buf 的位置（不包含）。默认: buf.length。<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。默认: ‘utf8’。<br>返回: <Buffer> buf 的引用。<br>如果未指定 offset 和 end，则填充整个 buf。 这个简化使得一个 Buffer 的创建与填充可以在一行内完成。</Buffer></string></integer></integer></integer></Buffer></string></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b = Buffer.allocUnsafe(50).fill(&#x27;h&#x27;);</span><br><span class=\"line\">console.log(b.toString());</span><br><span class=\"line\">// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</span><br></pre></td></tr></table></figure>\n<p>value 如果不是一个字符串或整数，则会被强行转换为 uint32 值。<br>如果 fill() 操作的最后一次写入的是一个多字节字符，则只有字符中适合 buf 的第一个字节会被写入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Buffer.allocUnsafe(3).fill(&#x27;\\u0222&#x27;));</span><br><span class=\"line\">// 输出: &lt;Buffer c8 a2 c8&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const buf = Buffer.allocUnsafe(5);</span><br><span class=\"line\">console.log(buf.fill(&#x27;a&#x27;));</span><br><span class=\"line\">// Prints: &lt;Buffer 61 61 61 61 61&gt;</span><br><span class=\"line\">console.log(buf.fill(&#x27;aazz&#x27;, &#x27;hex&#x27;));</span><br><span class=\"line\">// Prints: &lt;Buffer aa aa aa aa aa&gt;</span><br><span class=\"line\">console.log(buf.fill(&#x27;zz&#x27;, &#x27;hex&#x27;));</span><br><span class=\"line\">// Prints: &lt;Buffer aa aa aa aa aa&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.includes(value[, byteOffset][, encoding])</strong><br>value <string> | <Buffer> | <integer> 要搜索的值<br>byteOffset <integer> buf 中开始搜索的位置。默认: 0<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’<br>返回: <boolean> 如果 buf 找到 value，则返回 true，否则返回 false<br>相当于 buf.indexOf() !== -1。</boolean></string></integer></integer></Buffer></string></p>\n<p><strong>buf.indexOf(value[, byteOffset][, encoding])</strong><br>value <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值<br>byteOffset <integer> buf 中开始搜索的位置。默认: 0<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’<br>返回: <integer> buf 中 value 首次出现的索引，如果 buf 没包含 value 则返回 -1<br>如果 value 是：</integer></string></integer></integer></Uint8Array></Buffer></string></p>\n<ul>\n<li>字符串，则 value 根据 encoding 的字符编码进行解析。</li>\n<li>Buffer 或 Uint8Array，则 value 会被作为一个整体使用。如果要比较部分 Buffer，可使用 buf.slice()。</li>\n<li>数值, 则 value 会解析为一个 0 至 255 之间的无符号八位整数值。</li>\n</ul>\n<p>如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。</p>\n<p>如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN 或者 0, 像 {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#indexOf() 保持一致。</p>\n<p>如果 value 是一个空字符串或空 Buffer，并且 byteOffset 小于 buf.length，返回 byteOffset。如果 value 是一个空字符串，并且 byteOffset 大于 buf.length，返回 buf.length。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b = Buffer.from(&#x27;abcdef&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(99.9));</span><br><span class=\"line\">console.log(b.indexOf(256 + 99));</span><br><span class=\"line\">// 传入一个不是有效字节的数字</span><br><span class=\"line\">// 输出：2，相当于搜索 99 或 &#x27;c&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, undefined));</span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, &#123;&#125;));</span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, null));</span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, []));</span><br><span class=\"line\">// 传入 byteOffset，其值强制转换为 NaN 或 0</span><br><span class=\"line\">// 输出：1，搜索整个 buffer</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.keys()</strong><br>创建并返回一个包含 buf 键名（索引）的迭代器。</p>\n<p><strong>buf.lastIndexOf(value[, byteOffset][, encoding])</strong><br>value <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值<br>byteOffset <integer> buf 中开始搜索的位置。 默认: buf.length- 1<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’<br>返回: <integer> buf 中 value 最后一次出现的索引，如果 buf 没包含 value 则返回 -1<br>与 buf.indexOf() 类似，除了 buf 是从后往前搜索而不是从前往后。</integer></string></integer></integer></Uint8Array></Buffer></string></p>\n<p>如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。</p>\n<p>如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN or 0, like {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#lastIndexOf() 保持一致。</p>\n<p>如果 value 是一个空字符串或者空 Buffer，返回 byteOffset。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b = Buffer.from(&#x27;abcdef&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.lastIndexOf(99.9));</span><br><span class=\"line\">console.log(b.lastIndexOf(256 + 99));</span><br><span class=\"line\">// 传入一个不是有效字节的数字</span><br><span class=\"line\">// 输出：2，相当于搜索 99 或 &#x27;c&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, undefined));</span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, &#123;&#125;));</span><br><span class=\"line\">// 传入 byteOffset，其值强制转换为 NaN</span><br><span class=\"line\">// 输出：-1，搜索整个 buffer</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, null));</span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, []));</span><br><span class=\"line\">// 传入 byteOffset，其值强制转换为 0</span><br><span class=\"line\">// 输出：-1，相当于传入 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.length</strong><br>返回 buf 在字节数上分配的内存量。 注意，这并不一定反映 buf 内可用的数据量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.alloc(1234);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: 1234</span><br><span class=\"line\">console.log(buf.length);</span><br><span class=\"line\"></span><br><span class=\"line\">buf.write(&#x27;some string&#x27;, 0, &#x27;ascii&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: 1234</span><br><span class=\"line\">console.log(buf.length);</span><br></pre></td></tr></table></figure>\n<p>虽然 length 属性不是不可变的，但改变 length 的值可能会导致不确定、不一致的行为。 那些希望修改一个 Buffer 的长度的应用程序应当将 length 视为只读的，且使用 buf.slice() 创建一个新的 Buffer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let buf = Buffer.allocUnsafe(10);</span><br><span class=\"line\"></span><br><span class=\"line\">buf.write(&#x27;abcdefghj&#x27;, 0, &#x27;ascii&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.length);</span><br><span class=\"line\">// 输出: 10</span><br><span class=\"line\"></span><br><span class=\"line\">buf = buf.slice(0, 5);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.length);</span><br><span class=\"line\">// 输出: 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.readDoubleBE(offset[, noAssert])、buf.readDoubleLE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 8。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <number><br>用指定的字节序格式（readDoubleBE() 返回大端序，readDoubleLE() 返回小端序）从 buf 中指定的 offset 读取一个64位双精度值。</number></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleBE());</span><br><span class=\"line\">// 输出: 8.20788039913184e-304</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleLE());</span><br><span class=\"line\">// 输出: 5.447603722011605e-270</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleLE(1));</span><br><span class=\"line\">// 抛出异常: RangeError: Index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleLE(1, true));</span><br><span class=\"line\">// 警告: 读取超出 buffer 的最后一位字节！</span><br><span class=\"line\">// 这会导致内存区段错误！不要这么做！</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.readFloatBE(offset[, noAssert])、buf.readFloatLE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <number><br>用指定的字节序格式（readFloatBE() 返回大端序，readFloatLE() 返回小端序）从 buf 中指定的 offset 读取一个32位浮点值。</number></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from([1, 2, 3, 4]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatBE());</span><br><span class=\"line\">// 输出: 2.387939260590663e-38</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatLE());</span><br><span class=\"line\">// 输出: 1.539989614439558e-36</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatLE(1));</span><br><span class=\"line\">// 抛出异常: RangeError: Index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatLE(1, true));</span><br><span class=\"line\">// 警告: 读取超出 buffer 的最后一位字节！</span><br><span class=\"line\">// 这会导致内存区段错误！不要这么做！</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.readInt8(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取一个有符号的8位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p>从 Buffer 中读取的整数值会被解析为二进制补码值。</p>\n<p><strong>buf.readInt16BE(offset[, noAssert])、buf.readInt16LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 2。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readInt16BE() 返回大端序，readInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的16位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p>从 Buffer 中读取的整数值会被解析为二进制补码值。</p>\n<p><strong>buf.readInt32BE(offset[, noAssert])、buf.readInt32LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readInt32BE() 返回大端序，readInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的32位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p>从 Buffer 中读取的整数值会被解析为二进制补码值。</p>\n<p><strong>buf.readIntBE(offset, byteLength[, noAssert])、buf.readIntLE(offset, byteLength[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - byteLength。<br>byteLength <integer> 要读取的字节数。必须满足：0 &lt; byteLength &lt;= 6。<br>noAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为二进制补码值。 最高支持48位精度。</integer></boolean></integer></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUInt8(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取一个无符号的8位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUInt16BE(offset[, noAssert])、buf.readUInt16LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 2。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readUInt16BE() 返回大端序，readUInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的16位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUInt32BE(offset[, noAssert])、buf.readUInt32LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readUInt32BE() 返回大端序，readUInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的32位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUIntBE(offset, byteLength[, noAssert])、buf.readUIntLE(offset, byteLength[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - byteLength。<br>byteLength <integer> 要读取的字节数。必须满足：0 &lt; byteLength &lt;= 6。<br>noAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为无符号的整数。 最高支持48位精度。</integer></boolean></integer></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.slice([start[, end]])</strong><br>start <integer> 新建的 Buffer 开始的位置。 默认: 0<br>end <integer> 新建的 Buffer 结束的位置（不包含）。 默认: buf.length<br>返回: <Buffer><br>返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪。</Buffer></integer></integer></p>\n<p>指定大于buf.length的结束值，与结束值设置为buf.length的结果一样。</p>\n<p><em>注意，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的。</em></p>\n<p><em>指定负的索引会导致切片的生成是相对于 buf 的末尾而不是开头</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.allocUnsafe(26);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; 26; i++) &#123;</span><br><span class=\"line\">  // 97 是 &#x27;a&#x27; 的十进制 ASCII 值 </span><br><span class=\"line\">  buf1[i] = i + 97;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const buf2 = buf1.slice(0, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));</span><br><span class=\"line\">// 输出: abc</span><br><span class=\"line\"></span><br><span class=\"line\">buf1[0] = 33;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));</span><br><span class=\"line\">// 输出: !bc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buf = Buffer.from(&#x27;buffer&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.slice(-6, -1).toString());</span><br><span class=\"line\">// 输出: buffe</span><br><span class=\"line\">// (相当于 buf.slice(0, 5))</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.slice(-6, -2).toString());</span><br><span class=\"line\">// 输出: buff</span><br><span class=\"line\">// (相当于 buf.slice(0, 4))</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.slice(-5, -2).toString());</span><br><span class=\"line\">// 输出: uff</span><br><span class=\"line\">// (相当于 buf.slice(1, 4))</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.swap16()</strong><br>将 buf 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是2的倍数，则抛出 RangeError 错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\">buf1.swap16();</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 02 01 04 03 06 05 08 07&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 抛出异常: RangeError: Buffer size must be a multiple of 16-bits</span><br><span class=\"line\">buf2.swap16();</span><br></pre></td></tr></table></figure>\n<p><strong>buf.swap32()</strong><br>将 buf 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是4的倍数，则抛出 RangeError 错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\">buf1.swap32();</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 04 03 02 01 08 07 06 05&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 抛出异常: RangeError: Buffer size must be a multiple of 32-bits</span><br><span class=\"line\">buf2.swap32();</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.swap64()</strong><br>将 buf 解析为一个64位的数值数组，并且以字节顺序原地进行交换。 如果 buf.length 不是8的倍数，则抛出 RangeError 错误。<br><em>注意，JavaScript 不能编码64位整数。 该方法是用来处理64位浮点数的。</em></p>\n<p><strong>buf.toJSON()</strong><br>返回 buf 的 JSON 格式。 当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);</span><br><span class=\"line\">const json = JSON.stringify(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class=\"line\">console.log(json);</span><br><span class=\"line\"></span><br><span class=\"line\">const copy = JSON.parse(json, (key, value) =&gt; &#123;</span><br><span class=\"line\">  return value &amp;&amp; value.type === &#x27;Buffer&#x27; ?</span><br><span class=\"line\">    Buffer.from(value.data) :</span><br><span class=\"line\">    value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class=\"line\">console.log(copy);</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.toString([encoding[, start[, end]]])</strong><br>encoding <string> 解码使用的字符编码。默认: ‘utf8’<br>start <integer> 开始解码的字节偏移量。默认: 0<br>end <integer> 结束解码的字节偏移量（不包含）。 默认: buf.length<br>返回: <string><br>根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。</string></integer></integer></string></p>\n<p>字符串实例的最大长度（以UTF-16代码为单位）可查看buffer.constants.MAX_STRING_LENGTH。</p>\n<p><strong>buf.values()</strong><br>创建并返回一个包含 buf 的值（字节）的迭代器。 当 Buffer 使用 for..of 时会自动调用该函数。</p>\n<p><strong>buf.write(string[, offset[, length]][, encoding])</strong><br>string <string> 要写入 buf 的字符串。<br>offset <integer> 开始写入 string 前要跳过的字节数。默认: 0。<br>length <integer> 要写入的字节数。默认: buf.length - offset。<br>encoding <string> string 的字符编码。默认: ‘utf8’。<br>返回: <integer> 写入的字节数。<br>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</integer></string></integer></integer></string></p>\n<p><strong>buf.writeDoubleBE(value, offset[, noAssert])、buf.writeDoubleLE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeDoubleBE() 写入大端序，writeDoubleLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的64位双精度值。 当 value 不是一个64位双精度值时，反应是不确定的。</p>\n<p><strong>buf.writeFloatBE(value, offset[, noAssert])、buf.writeFloatLE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeFloatBE() 写入大端序，writeFloatLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的32位浮点值。 当 value 不是一个32位浮点值时，反应是不确定的</p>\n<p><strong>buf.writeInt8(value, offset[, noAssert])</strong><br>写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的8位整数。 当 value 不是一个有符号的8位整数时，反应是不确定的。</p>\n<p><strong>buf.writeInt16BE(value, offset[, noAssert])、buf.writeInt16LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeInt16BE() 写入大端序，writeInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的16位整数。 当 value 不是一个有符号的16位整数时，反应是不确定的。</p>\n<p><strong>buf.writeInt32BE(value, offset[, noAssert])、buf.writeInt32LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeInt32BE() 写入大端序，writeInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的32位整数。 当 value 不是一个有符号的32位整数时，反应是不确定的。</p>\n<p><strong>buf.writeIntBE(value, offset, byteLength[, noAssert])、buf.writeIntLE(value, offset, byteLength[, noAssert])</strong><br>写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个有符号的整数时，反应是不确定的。</p>\n<p><strong>buf.writeUInt8(value, offset[, noAssert])</strong><br>写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的8位整数。 当 value 不是一个无符号的8位整数时，反应是不确定的。</p>\n<p><strong>buf.writeUInt16BE(value, offset[, noAssert])、buf.writeUInt16LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeUInt16BE() 写入大端序，writeUInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的16位整数。 当 value 不是一个无符号的16位整数时，反应是不确定的。</p>\n<p><strong>buf.writeUInt32BE(value, offset[, noAssert])、buf.writeUInt32LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeUInt32BE() 写入大端序，writeUInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的32位整数。 当 value 不是一个无符号的32位整数时，反应是不确定的。</p>\n<p><strong>buf.writeUIntBE(value, offset, byteLength[, noAssert])、buf.writeUIntLE(value, offset, byteLength[, noAssert])</strong><br>写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个无符号的整数时，反应是不确定的。</p>\n<p><strong>buffer.INSPECT_MAX_BYTES</strong><br>当调用 buf.inspect() 时返回的最大字节数。 可以被用户模块重写。 详见 util.inspect() 了解更多 buf.inspect() 的行为。</p>\n<p>注意，这个属性是在通过 require(‘buffer’) 返回的 buffer 模块上，而不是在 Buffer 的全局变量或 Buffer 实例上。默认值：50</p>\n<p><strong>buffer.kMaxLength</strong><br>分配给单个 Buffer 实例的最大内存<br>注意整个属性是通过 require(‘buffer’) 返回的 buffer 模块的属性，而不是全局 Buffer 对象或 Buffer 实例的属性。</p>\n<p><strong>buffer.transcode(source, fromEnc, toEnc)</strong><br>source <Buffer> | <Uint8Array> 一个 Buffer 或 Uint8Array 实例<br>fromEnc <string> 当前编码<br>toEnc <string> 目标编码<br>将给定的 Buffer 或 Uint8Array 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。<br>如果 fromEnc 或 toEnc 指定的字符串编码无效，或者不允许从 fromEnc 转换为 toEnc，将抛出异常。<br>如果给定的字节序列不能在目标编码中充分表示，转码过程将使用替代字符。</string></string></Uint8Array></Buffer></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buffer = require(&#x27;buffer&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const newBuf = buffer.transcode(Buffer.from(&#x27;€&#x27;), &#x27;utf8&#x27;, &#x27;ascii&#x27;);</span><br><span class=\"line\">console.log(newBuf.toString(&#x27;ascii&#x27;));</span><br><span class=\"line\">// 输出: &#x27;?&#x27;</span><br></pre></td></tr></table></figure>\n<p>因为欧元符号（€）不能在 US-ASCII 中表示，所以在转换 Buffer 的时候使用 ? 代替。</p>\n<p><strong>Buffer Constants</strong><br>请注意buffer.constants是通过require(‘buffer’)返回的buffer模块的一个属性，而不是全局Buffer或Buffer实例</p>\n<ul>\n<li>buffer.constants.MAX_LENGTH<ul>\n<li>单个Buffer实例允许的最大量度。在32位体系结构上，这个值是(2^30)-1 (<del>1GB)。 在64位体系结构上，这个值是(2^31)-1 (</del>2GB)。也可在buffer.kMaxLength查看该值。</li>\n</ul>\n</li>\n<li>buffer.constants.MAX_STRING_LENGTH<ul>\n<li>单个string实例允许的最大长度。代表string能有的原始最大长度，以UTF-16代码为单位。该值可能取决于正在使用的JS引擎。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"Buffer-缓冲\"><a href=\"#Buffer-缓冲\" class=\"headerlink\" title=\"Buffer(缓冲)\"></a>Buffer(缓冲)</h6><p><strong>buf.entries()</strong><br>从 buf 的内容中，创建并返回一个 [index, byte] 形式的迭代器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from(&#x27;buffer&#x27;);</span><br><span class=\"line\">for (const pair of buf.entries()) &#123;</span><br><span class=\"line\">  console.log(pair);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出:</span><br><span class=\"line\">// [ 0, 0 ]</span><br><span class=\"line\">// [ 1, 0 ]</span><br><span class=\"line\">// [ 2, 0 ]</span><br><span class=\"line\">// [ 3, 0 ]</span><br><span class=\"line\">// [ 4, 0 ]</span><br><span class=\"line\">// [ 5, 0 ]</span><br><span class=\"line\">// [ 6, 0 ]</span><br><span class=\"line\">// [ 7, 0 ]</span><br><span class=\"line\">// [ 8, 0 ]</span><br><span class=\"line\">// [ 9, 0 ]</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.equals(otherBuffer)</strong><br>如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from(&#x27;ABC&#x27;);</span><br><span class=\"line\">const buf2 = Buffer.from(&#x27;414243&#x27;, &#x27;hex&#x27;);</span><br><span class=\"line\">const buf3 = Buffer.from(&#x27;ABCD&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.equals(buf2));</span><br><span class=\"line\">// 输出: true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.equals(buf3));</span><br><span class=\"line\">// 输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.fill(value[, offset[, end]][, encoding])</strong><br>value <string> | <Buffer> | <integer> 用来填充 buf 的值。<br>offset <integer> 开始填充 buf 前要跳过的字节数。默认: 0。<br>end <integer> 结束填充 buf 的位置（不包含）。默认: buf.length。<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。默认: ‘utf8’。<br>返回: <Buffer> buf 的引用。<br>如果未指定 offset 和 end，则填充整个 buf。 这个简化使得一个 Buffer 的创建与填充可以在一行内完成。</Buffer></string></integer></integer></integer></Buffer></string></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b = Buffer.allocUnsafe(50).fill(&#x27;h&#x27;);</span><br><span class=\"line\">console.log(b.toString());</span><br><span class=\"line\">// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</span><br></pre></td></tr></table></figure>\n<p>value 如果不是一个字符串或整数，则会被强行转换为 uint32 值。<br>如果 fill() 操作的最后一次写入的是一个多字节字符，则只有字符中适合 buf 的第一个字节会被写入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Buffer.allocUnsafe(3).fill(&#x27;\\u0222&#x27;));</span><br><span class=\"line\">// 输出: &lt;Buffer c8 a2 c8&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const buf = Buffer.allocUnsafe(5);</span><br><span class=\"line\">console.log(buf.fill(&#x27;a&#x27;));</span><br><span class=\"line\">// Prints: &lt;Buffer 61 61 61 61 61&gt;</span><br><span class=\"line\">console.log(buf.fill(&#x27;aazz&#x27;, &#x27;hex&#x27;));</span><br><span class=\"line\">// Prints: &lt;Buffer aa aa aa aa aa&gt;</span><br><span class=\"line\">console.log(buf.fill(&#x27;zz&#x27;, &#x27;hex&#x27;));</span><br><span class=\"line\">// Prints: &lt;Buffer aa aa aa aa aa&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.includes(value[, byteOffset][, encoding])</strong><br>value <string> | <Buffer> | <integer> 要搜索的值<br>byteOffset <integer> buf 中开始搜索的位置。默认: 0<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’<br>返回: <boolean> 如果 buf 找到 value，则返回 true，否则返回 false<br>相当于 buf.indexOf() !== -1。</boolean></string></integer></integer></Buffer></string></p>\n<p><strong>buf.indexOf(value[, byteOffset][, encoding])</strong><br>value <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值<br>byteOffset <integer> buf 中开始搜索的位置。默认: 0<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’<br>返回: <integer> buf 中 value 首次出现的索引，如果 buf 没包含 value 则返回 -1<br>如果 value 是：</integer></string></integer></integer></Uint8Array></Buffer></string></p>\n<ul>\n<li>字符串，则 value 根据 encoding 的字符编码进行解析。</li>\n<li>Buffer 或 Uint8Array，则 value 会被作为一个整体使用。如果要比较部分 Buffer，可使用 buf.slice()。</li>\n<li>数值, 则 value 会解析为一个 0 至 255 之间的无符号八位整数值。</li>\n</ul>\n<p>如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。</p>\n<p>如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN 或者 0, 像 {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#indexOf() 保持一致。</p>\n<p>如果 value 是一个空字符串或空 Buffer，并且 byteOffset 小于 buf.length，返回 byteOffset。如果 value 是一个空字符串，并且 byteOffset 大于 buf.length，返回 buf.length。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b = Buffer.from(&#x27;abcdef&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(99.9));</span><br><span class=\"line\">console.log(b.indexOf(256 + 99));</span><br><span class=\"line\">// 传入一个不是有效字节的数字</span><br><span class=\"line\">// 输出：2，相当于搜索 99 或 &#x27;c&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, undefined));</span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, &#123;&#125;));</span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, null));</span><br><span class=\"line\">console.log(b.indexOf(&#x27;b&#x27;, []));</span><br><span class=\"line\">// 传入 byteOffset，其值强制转换为 NaN 或 0</span><br><span class=\"line\">// 输出：1，搜索整个 buffer</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.keys()</strong><br>创建并返回一个包含 buf 键名（索引）的迭代器。</p>\n<p><strong>buf.lastIndexOf(value[, byteOffset][, encoding])</strong><br>value <string> | <Buffer> | <Uint8Array> | <integer> 要搜索的值<br>byteOffset <integer> buf 中开始搜索的位置。 默认: buf.length- 1<br>encoding <string> 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’<br>返回: <integer> buf 中 value 最后一次出现的索引，如果 buf 没包含 value 则返回 -1<br>与 buf.indexOf() 类似，除了 buf 是从后往前搜索而不是从前往后。</integer></string></integer></integer></Uint8Array></Buffer></string></p>\n<p>如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。</p>\n<p>如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN or 0, like {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#lastIndexOf() 保持一致。</p>\n<p>如果 value 是一个空字符串或者空 Buffer，返回 byteOffset。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b = Buffer.from(&#x27;abcdef&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.lastIndexOf(99.9));</span><br><span class=\"line\">console.log(b.lastIndexOf(256 + 99));</span><br><span class=\"line\">// 传入一个不是有效字节的数字</span><br><span class=\"line\">// 输出：2，相当于搜索 99 或 &#x27;c&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, undefined));</span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, &#123;&#125;));</span><br><span class=\"line\">// 传入 byteOffset，其值强制转换为 NaN</span><br><span class=\"line\">// 输出：-1，搜索整个 buffer</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, null));</span><br><span class=\"line\">console.log(b.lastIndexOf(&#x27;b&#x27;, []));</span><br><span class=\"line\">// 传入 byteOffset，其值强制转换为 0</span><br><span class=\"line\">// 输出：-1，相当于传入 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.length</strong><br>返回 buf 在字节数上分配的内存量。 注意，这并不一定反映 buf 内可用的数据量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.alloc(1234);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: 1234</span><br><span class=\"line\">console.log(buf.length);</span><br><span class=\"line\"></span><br><span class=\"line\">buf.write(&#x27;some string&#x27;, 0, &#x27;ascii&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: 1234</span><br><span class=\"line\">console.log(buf.length);</span><br></pre></td></tr></table></figure>\n<p>虽然 length 属性不是不可变的，但改变 length 的值可能会导致不确定、不一致的行为。 那些希望修改一个 Buffer 的长度的应用程序应当将 length 视为只读的，且使用 buf.slice() 创建一个新的 Buffer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let buf = Buffer.allocUnsafe(10);</span><br><span class=\"line\"></span><br><span class=\"line\">buf.write(&#x27;abcdefghj&#x27;, 0, &#x27;ascii&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.length);</span><br><span class=\"line\">// 输出: 10</span><br><span class=\"line\"></span><br><span class=\"line\">buf = buf.slice(0, 5);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.length);</span><br><span class=\"line\">// 输出: 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.readDoubleBE(offset[, noAssert])、buf.readDoubleLE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 8。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <number><br>用指定的字节序格式（readDoubleBE() 返回大端序，readDoubleLE() 返回小端序）从 buf 中指定的 offset 读取一个64位双精度值。</number></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleBE());</span><br><span class=\"line\">// 输出: 8.20788039913184e-304</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleLE());</span><br><span class=\"line\">// 输出: 5.447603722011605e-270</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleLE(1));</span><br><span class=\"line\">// 抛出异常: RangeError: Index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readDoubleLE(1, true));</span><br><span class=\"line\">// 警告: 读取超出 buffer 的最后一位字节！</span><br><span class=\"line\">// 这会导致内存区段错误！不要这么做！</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.readFloatBE(offset[, noAssert])、buf.readFloatLE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <number><br>用指定的字节序格式（readFloatBE() 返回大端序，readFloatLE() 返回小端序）从 buf 中指定的 offset 读取一个32位浮点值。</number></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from([1, 2, 3, 4]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatBE());</span><br><span class=\"line\">// 输出: 2.387939260590663e-38</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatLE());</span><br><span class=\"line\">// 输出: 1.539989614439558e-36</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatLE(1));</span><br><span class=\"line\">// 抛出异常: RangeError: Index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.readFloatLE(1, true));</span><br><span class=\"line\">// 警告: 读取超出 buffer 的最后一位字节！</span><br><span class=\"line\">// 这会导致内存区段错误！不要这么做！</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.readInt8(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取一个有符号的8位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p>从 Buffer 中读取的整数值会被解析为二进制补码值。</p>\n<p><strong>buf.readInt16BE(offset[, noAssert])、buf.readInt16LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 2。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readInt16BE() 返回大端序，readInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的16位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p>从 Buffer 中读取的整数值会被解析为二进制补码值。</p>\n<p><strong>buf.readInt32BE(offset[, noAssert])、buf.readInt32LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readInt32BE() 返回大端序，readInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的32位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p>从 Buffer 中读取的整数值会被解析为二进制补码值。</p>\n<p><strong>buf.readIntBE(offset, byteLength[, noAssert])、buf.readIntLE(offset, byteLength[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - byteLength。<br>byteLength <integer> 要读取的字节数。必须满足：0 &lt; byteLength &lt;= 6。<br>noAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为二进制补码值。 最高支持48位精度。</integer></boolean></integer></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUInt8(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取一个无符号的8位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUInt16BE(offset[, noAssert])、buf.readUInt16LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 2。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readUInt16BE() 返回大端序，readUInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的16位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUInt32BE(offset[, noAssert])、buf.readUInt32LE(offset[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。<br>noAssert <boolean> 是否跳过 offset 检验？默认: false。<br>返回: <integer><br>用指定的字节序格式（readUInt32BE() 返回大端序，readUInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的32位整数值。</integer></boolean></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.readUIntBE(offset, byteLength[, noAssert])、buf.readUIntLE(offset, byteLength[, noAssert])</strong><br>offset <integer> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - byteLength。<br>byteLength <integer> 要读取的字节数。必须满足：0 &lt; byteLength &lt;= 6。<br>noAssert <boolean> 是否跳过 offset 和 byteLength 校验？ 默认: false。<br>返回: <integer><br>从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为无符号的整数。 最高支持48位精度。</integer></boolean></integer></integer></p>\n<p>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。</p>\n<p><strong>buf.slice([start[, end]])</strong><br>start <integer> 新建的 Buffer 开始的位置。 默认: 0<br>end <integer> 新建的 Buffer 结束的位置（不包含）。 默认: buf.length<br>返回: <Buffer><br>返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪。</Buffer></integer></integer></p>\n<p>指定大于buf.length的结束值，与结束值设置为buf.length的结果一样。</p>\n<p><em>注意，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的。</em></p>\n<p><em>指定负的索引会导致切片的生成是相对于 buf 的末尾而不是开头</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.allocUnsafe(26);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; 26; i++) &#123;</span><br><span class=\"line\">  // 97 是 &#x27;a&#x27; 的十进制 ASCII 值 </span><br><span class=\"line\">  buf1[i] = i + 97;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const buf2 = buf1.slice(0, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));</span><br><span class=\"line\">// 输出: abc</span><br><span class=\"line\"></span><br><span class=\"line\">buf1[0] = 33;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));</span><br><span class=\"line\">// 输出: !bc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buf = Buffer.from(&#x27;buffer&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.slice(-6, -1).toString());</span><br><span class=\"line\">// 输出: buffe</span><br><span class=\"line\">// (相当于 buf.slice(0, 5))</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.slice(-6, -2).toString());</span><br><span class=\"line\">// 输出: buff</span><br><span class=\"line\">// (相当于 buf.slice(0, 4))</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.slice(-5, -2).toString());</span><br><span class=\"line\">// 输出: uff</span><br><span class=\"line\">// (相当于 buf.slice(1, 4))</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.swap16()</strong><br>将 buf 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是2的倍数，则抛出 RangeError 错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\">buf1.swap16();</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 02 01 04 03 06 05 08 07&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 抛出异常: RangeError: Buffer size must be a multiple of 16-bits</span><br><span class=\"line\">buf2.swap16();</span><br></pre></td></tr></table></figure>\n<p><strong>buf.swap32()</strong><br>将 buf 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是4的倍数，则抛出 RangeError 错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\">buf1.swap32();</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 04 03 02 01 08 07 06 05&gt;</span><br><span class=\"line\">console.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 抛出异常: RangeError: Buffer size must be a multiple of 32-bits</span><br><span class=\"line\">buf2.swap32();</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.swap64()</strong><br>将 buf 解析为一个64位的数值数组，并且以字节顺序原地进行交换。 如果 buf.length 不是8的倍数，则抛出 RangeError 错误。<br><em>注意，JavaScript 不能编码64位整数。 该方法是用来处理64位浮点数的。</em></p>\n<p><strong>buf.toJSON()</strong><br>返回 buf 的 JSON 格式。 当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);</span><br><span class=\"line\">const json = JSON.stringify(buf);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class=\"line\">console.log(json);</span><br><span class=\"line\"></span><br><span class=\"line\">const copy = JSON.parse(json, (key, value) =&gt; &#123;</span><br><span class=\"line\">  return value &amp;&amp; value.type === &#x27;Buffer&#x27; ?</span><br><span class=\"line\">    Buffer.from(value.data) :</span><br><span class=\"line\">    value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class=\"line\">console.log(copy);</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.toString([encoding[, start[, end]]])</strong><br>encoding <string> 解码使用的字符编码。默认: ‘utf8’<br>start <integer> 开始解码的字节偏移量。默认: 0<br>end <integer> 结束解码的字节偏移量（不包含）。 默认: buf.length<br>返回: <string><br>根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。</string></integer></integer></string></p>\n<p>字符串实例的最大长度（以UTF-16代码为单位）可查看buffer.constants.MAX_STRING_LENGTH。</p>\n<p><strong>buf.values()</strong><br>创建并返回一个包含 buf 的值（字节）的迭代器。 当 Buffer 使用 for..of 时会自动调用该函数。</p>\n<p><strong>buf.write(string[, offset[, length]][, encoding])</strong><br>string <string> 要写入 buf 的字符串。<br>offset <integer> 开始写入 string 前要跳过的字节数。默认: 0。<br>length <integer> 要写入的字节数。默认: buf.length - offset。<br>encoding <string> string 的字符编码。默认: ‘utf8’。<br>返回: <integer> 写入的字节数。<br>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</integer></string></integer></integer></string></p>\n<p><strong>buf.writeDoubleBE(value, offset[, noAssert])、buf.writeDoubleLE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeDoubleBE() 写入大端序，writeDoubleLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的64位双精度值。 当 value 不是一个64位双精度值时，反应是不确定的。</p>\n<p><strong>buf.writeFloatBE(value, offset[, noAssert])、buf.writeFloatLE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeFloatBE() 写入大端序，writeFloatLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的32位浮点值。 当 value 不是一个32位浮点值时，反应是不确定的</p>\n<p><strong>buf.writeInt8(value, offset[, noAssert])</strong><br>写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的8位整数。 当 value 不是一个有符号的8位整数时，反应是不确定的。</p>\n<p><strong>buf.writeInt16BE(value, offset[, noAssert])、buf.writeInt16LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeInt16BE() 写入大端序，writeInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的16位整数。 当 value 不是一个有符号的16位整数时，反应是不确定的。</p>\n<p><strong>buf.writeInt32BE(value, offset[, noAssert])、buf.writeInt32LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeInt32BE() 写入大端序，writeInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的32位整数。 当 value 不是一个有符号的32位整数时，反应是不确定的。</p>\n<p><strong>buf.writeIntBE(value, offset, byteLength[, noAssert])、buf.writeIntLE(value, offset, byteLength[, noAssert])</strong><br>写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个有符号的整数时，反应是不确定的。</p>\n<p><strong>buf.writeUInt8(value, offset[, noAssert])</strong><br>写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的8位整数。 当 value 不是一个无符号的8位整数时，反应是不确定的。</p>\n<p><strong>buf.writeUInt16BE(value, offset[, noAssert])、buf.writeUInt16LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeUInt16BE() 写入大端序，writeUInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的16位整数。 当 value 不是一个无符号的16位整数时，反应是不确定的。</p>\n<p><strong>buf.writeUInt32BE(value, offset[, noAssert])、buf.writeUInt32LE(value, offset[, noAssert])</strong><br>用指定的字节序格式（writeUInt32BE() 写入大端序，writeUInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的32位整数。 当 value 不是一个无符号的32位整数时，反应是不确定的。</p>\n<p><strong>buf.writeUIntBE(value, offset, byteLength[, noAssert])、buf.writeUIntLE(value, offset, byteLength[, noAssert])</strong><br>写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个无符号的整数时，反应是不确定的。</p>\n<p><strong>buffer.INSPECT_MAX_BYTES</strong><br>当调用 buf.inspect() 时返回的最大字节数。 可以被用户模块重写。 详见 util.inspect() 了解更多 buf.inspect() 的行为。</p>\n<p>注意，这个属性是在通过 require(‘buffer’) 返回的 buffer 模块上，而不是在 Buffer 的全局变量或 Buffer 实例上。默认值：50</p>\n<p><strong>buffer.kMaxLength</strong><br>分配给单个 Buffer 实例的最大内存<br>注意整个属性是通过 require(‘buffer’) 返回的 buffer 模块的属性，而不是全局 Buffer 对象或 Buffer 实例的属性。</p>\n<p><strong>buffer.transcode(source, fromEnc, toEnc)</strong><br>source <Buffer> | <Uint8Array> 一个 Buffer 或 Uint8Array 实例<br>fromEnc <string> 当前编码<br>toEnc <string> 目标编码<br>将给定的 Buffer 或 Uint8Array 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。<br>如果 fromEnc 或 toEnc 指定的字符串编码无效，或者不允许从 fromEnc 转换为 toEnc，将抛出异常。<br>如果给定的字节序列不能在目标编码中充分表示，转码过程将使用替代字符。</string></string></Uint8Array></Buffer></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buffer = require(&#x27;buffer&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const newBuf = buffer.transcode(Buffer.from(&#x27;€&#x27;), &#x27;utf8&#x27;, &#x27;ascii&#x27;);</span><br><span class=\"line\">console.log(newBuf.toString(&#x27;ascii&#x27;));</span><br><span class=\"line\">// 输出: &#x27;?&#x27;</span><br></pre></td></tr></table></figure>\n<p>因为欧元符号（€）不能在 US-ASCII 中表示，所以在转换 Buffer 的时候使用 ? 代替。</p>\n<p><strong>Buffer Constants</strong><br>请注意buffer.constants是通过require(‘buffer’)返回的buffer模块的一个属性，而不是全局Buffer或Buffer实例</p>\n<ul>\n<li>buffer.constants.MAX_LENGTH<ul>\n<li>单个Buffer实例允许的最大量度。在32位体系结构上，这个值是(2^30)-1 (<del>1GB)。 在64位体系结构上，这个值是(2^31)-1 (</del>2GB)。也可在buffer.kMaxLength查看该值。</li>\n</ul>\n</li>\n<li>buffer.constants.MAX_STRING_LENGTH<ul>\n<li>单个string实例允许的最大长度。代表string能有的原始最大长度，以UTF-16代码为单位。该值可能取决于正在使用的JS引擎。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"nodejs基础知识(3)","date":"2022-12-28T09:12:45.000Z","tags":["node","C++ 插件"],"_content":"\nNode.js 插件是用 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行在 Node.js 中的 JavaScript 与 C/C++ 库之间提供接口。\n\n目前用于实现插件的方法相当复杂，涉及多个组件和 API 的知识：\n- V8：Node.js 目前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等的机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h），也可以在查看 [V8 在线文档](https://v8docs.nodesource.com/)。\n- [libuv](https://github.com/libuv/libuv)：实现了 Node.js 的事件循环、工作线程、以及平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器、以及系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 建议插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。\n- 内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C++ API。 其中最重要的是 node::ObjectWrap 类。\n- Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 开放的，并且通过插件被用于不同的场景。\n\n1. 创建 hello.cc 文件\n```\n// hello.cc\n#include <node.h>\n\nnamespace demo {\n\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid Method(const FunctionCallbackInfo<Value>& args) {\n  Isolate* isolate = args.GetIsolate();\n  args.GetReturnValue().Set(String::NewFromUtf8(isolate, \"world\"));\n}\n\nvoid init(Local<Object> exports) {\n  NODE_SET_METHOD(exports, \"hello\", Method);\n}\n\nNODE_MODULE(NODE_GYP_MODULE_NAME, init)\n\n}  // namespace demo\n```\n注意，所有的 Node.js 插件必须导出一个如下模式的初始化函数：\n```\nvoid Initialize(Local<Object> exports);\nNODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)\n```\nNODE_MODULE 后面没有分号，因为它不是一个函数（详见 node.h）。\n\nmodule_name 必须匹配最终的二进制文件名（不包括 .node 后缀）。\n\n在 hello.cc 示例中，初始化函数是 init，插件模块名是 addon。\n\n**构建**\n\n当源代码已被编写，它必须被编译成二进制 addon.node 文件。 要做到这点，需在项目的顶层创建一个名为 binding.gyp 的文件，它使用一个类似 JSON 的格式来描述模块的构建配置。 该文件会被 node-gyp（一个用于编译 Node.js 插件的工具）使用。\n```\n{\n  \"targets\": [\n    {\n      \"target_name\": \"addon\",\n      \"sources\": [ \"hello.cc\" ]\n    }\n  ]\n}\n```\n\n当使用 npm install 安装一个 Node.js 插件时，npm 会使用自身捆绑的 node-gyp 版本来执行同样的一套动作，为用户要求的平台生成一个插件编译后的版本。\n\n当构建完成时，二进制插件就可以在 Node.js 中被使用，通过 require() 构建后的 addon.node 模块\n```\n// hello.js\nconst addon = require('./build/Release/addon');\n\nconsole.log(addon.hello());\n// 打印: 'world'\n```\n\n*因为编译后的二进制插件的确切路径取决于它如何被编译（比如有时它可能在 ./build/Debug/ 中），所以插件可以使用 bindings 包加载编译后的模块。*\n\n注意，虽然 bindings 包在如何定位插件模块的实现上更复杂，但它本质上使用了一个 try-catch 模式\n```\ntry {\n  return require('./build/Release/addon.node');\n} catch (err) {\n  return require('./build/Debug/addon.node');\n}\n```\n\n**链接到 Node.js 自有的依赖**\nNode.js 使用了一些静态链接库，所有的插件都需要链接到 V8，也可能链接到任何其他依赖。 通常情况下，只要简单地包含相应的 #include <...> 声明（如 #include <v8.h>），则 node-gyp 会自动定位到相应的头文件。 但是也有一些注意事项需要注意：\n- 当 node-gyp 运行时，它会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件对全套的 Node.js 依赖有完全的访问权限。 如果只下载了 Node.js 的文件头，则只有 Node.js 导出的符号可用。\n\n- node-gyp 可使用指向一个本地 Node.js 源代码镜像的 --nodedir 标志来运行。 如果使用该选项，则插件有全套依赖的访问权限。\n\n**使用 require() 加载插件**\n编译后的二进制插件的文件扩展名是 .node（而不是 .dll 或 .so）。 require() 函数用于查找具有 .node 文件扩展名的文件，并初始化为动态链接库。\n\n当调用 require() 时，.node 拓展名通常可被省略，Node.js 仍会找到并初始化该插件。 注意，Node.js 会优先尝试查找并加载同名的模块或 JavaScript 文件。 例如，如果与二进制的 addon.node 同一目录下有一个 addon.js 文件，则 require('addon') 会优先加载 addon.js 文件。","source":"nodejs/nodejs-note-9.md","raw":"---\ntitle: nodejs基础知识(3)\ndate: 2022-12-28 17:12:45\ntags: [node, C++ 插件]\n---\n\nNode.js 插件是用 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行在 Node.js 中的 JavaScript 与 C/C++ 库之间提供接口。\n\n目前用于实现插件的方法相当复杂，涉及多个组件和 API 的知识：\n- V8：Node.js 目前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等的机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h），也可以在查看 [V8 在线文档](https://v8docs.nodesource.com/)。\n- [libuv](https://github.com/libuv/libuv)：实现了 Node.js 的事件循环、工作线程、以及平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器、以及系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 建议插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。\n- 内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C++ API。 其中最重要的是 node::ObjectWrap 类。\n- Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 开放的，并且通过插件被用于不同的场景。\n\n1. 创建 hello.cc 文件\n```\n// hello.cc\n#include <node.h>\n\nnamespace demo {\n\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid Method(const FunctionCallbackInfo<Value>& args) {\n  Isolate* isolate = args.GetIsolate();\n  args.GetReturnValue().Set(String::NewFromUtf8(isolate, \"world\"));\n}\n\nvoid init(Local<Object> exports) {\n  NODE_SET_METHOD(exports, \"hello\", Method);\n}\n\nNODE_MODULE(NODE_GYP_MODULE_NAME, init)\n\n}  // namespace demo\n```\n注意，所有的 Node.js 插件必须导出一个如下模式的初始化函数：\n```\nvoid Initialize(Local<Object> exports);\nNODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)\n```\nNODE_MODULE 后面没有分号，因为它不是一个函数（详见 node.h）。\n\nmodule_name 必须匹配最终的二进制文件名（不包括 .node 后缀）。\n\n在 hello.cc 示例中，初始化函数是 init，插件模块名是 addon。\n\n**构建**\n\n当源代码已被编写，它必须被编译成二进制 addon.node 文件。 要做到这点，需在项目的顶层创建一个名为 binding.gyp 的文件，它使用一个类似 JSON 的格式来描述模块的构建配置。 该文件会被 node-gyp（一个用于编译 Node.js 插件的工具）使用。\n```\n{\n  \"targets\": [\n    {\n      \"target_name\": \"addon\",\n      \"sources\": [ \"hello.cc\" ]\n    }\n  ]\n}\n```\n\n当使用 npm install 安装一个 Node.js 插件时，npm 会使用自身捆绑的 node-gyp 版本来执行同样的一套动作，为用户要求的平台生成一个插件编译后的版本。\n\n当构建完成时，二进制插件就可以在 Node.js 中被使用，通过 require() 构建后的 addon.node 模块\n```\n// hello.js\nconst addon = require('./build/Release/addon');\n\nconsole.log(addon.hello());\n// 打印: 'world'\n```\n\n*因为编译后的二进制插件的确切路径取决于它如何被编译（比如有时它可能在 ./build/Debug/ 中），所以插件可以使用 bindings 包加载编译后的模块。*\n\n注意，虽然 bindings 包在如何定位插件模块的实现上更复杂，但它本质上使用了一个 try-catch 模式\n```\ntry {\n  return require('./build/Release/addon.node');\n} catch (err) {\n  return require('./build/Debug/addon.node');\n}\n```\n\n**链接到 Node.js 自有的依赖**\nNode.js 使用了一些静态链接库，所有的插件都需要链接到 V8，也可能链接到任何其他依赖。 通常情况下，只要简单地包含相应的 #include <...> 声明（如 #include <v8.h>），则 node-gyp 会自动定位到相应的头文件。 但是也有一些注意事项需要注意：\n- 当 node-gyp 运行时，它会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件对全套的 Node.js 依赖有完全的访问权限。 如果只下载了 Node.js 的文件头，则只有 Node.js 导出的符号可用。\n\n- node-gyp 可使用指向一个本地 Node.js 源代码镜像的 --nodedir 标志来运行。 如果使用该选项，则插件有全套依赖的访问权限。\n\n**使用 require() 加载插件**\n编译后的二进制插件的文件扩展名是 .node（而不是 .dll 或 .so）。 require() 函数用于查找具有 .node 文件扩展名的文件，并初始化为动态链接库。\n\n当调用 require() 时，.node 拓展名通常可被省略，Node.js 仍会找到并初始化该插件。 注意，Node.js 会优先尝试查找并加载同名的模块或 JavaScript 文件。 例如，如果与二进制的 addon.node 同一目录下有一个 addon.js 文件，则 require('addon') 会优先加载 addon.js 文件。","updated":"2022-12-29T03:06:48.248Z","path":"nodejs/nodejs-note-9.html","comments":1,"layout":"page","_id":"clchh4gwx0014cktt7a69ek3m","content":"<p>Node.js 插件是用 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行在 Node.js 中的 JavaScript 与 C/C++ 库之间提供接口。</p>\n<p>目前用于实现插件的方法相当复杂，涉及多个组件和 API 的知识：</p>\n<ul>\n<li>V8：Node.js 目前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等的机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h），也可以在查看 <a href=\"https://v8docs.nodesource.com/\">V8 在线文档</a>。</li>\n<li><a href=\"https://github.com/libuv/libuv\">libuv</a>：实现了 Node.js 的事件循环、工作线程、以及平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器、以及系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 建议插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。</li>\n<li>内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C++ API。 其中最重要的是 node::ObjectWrap 类。</li>\n<li>Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 开放的，并且通过插件被用于不同的场景。</li>\n</ul>\n<ol>\n<li>创建 hello.cc 文件<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hello.cc</span><br><span class=\"line\">#include &lt;node.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">using v8::FunctionCallbackInfo;</span><br><span class=\"line\">using v8::Isolate;</span><br><span class=\"line\">using v8::Local;</span><br><span class=\"line\">using v8::Object;</span><br><span class=\"line\">using v8::String;</span><br><span class=\"line\">using v8::Value;</span><br><span class=\"line\"></span><br><span class=\"line\">void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class=\"line\">  Isolate* isolate = args.GetIsolate();</span><br><span class=\"line\">  args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;world&quot;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void init(Local&lt;Object&gt; exports) &#123;</span><br><span class=\"line\">  NODE_SET_METHOD(exports, &quot;hello&quot;, Method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  // namespace demo</span><br></pre></td></tr></table></figure>\n注意，所有的 Node.js 插件必须导出一个如下模式的初始化函数：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Initialize(Local&lt;Object&gt; exports);</span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\nNODE_MODULE 后面没有分号，因为它不是一个函数（详见 node.h）。</li>\n</ol>\n<p>module_name 必须匹配最终的二进制文件名（不包括 .node 后缀）。</p>\n<p>在 hello.cc 示例中，初始化函数是 init，插件模块名是 addon。</p>\n<p><strong>构建</strong></p>\n<p>当源代码已被编写，它必须被编译成二进制 addon.node 文件。 要做到这点，需在项目的顶层创建一个名为 binding.gyp 的文件，它使用一个类似 JSON 的格式来描述模块的构建配置。 该文件会被 node-gyp（一个用于编译 Node.js 插件的工具）使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;addon&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当使用 npm install 安装一个 Node.js 插件时，npm 会使用自身捆绑的 node-gyp 版本来执行同样的一套动作，为用户要求的平台生成一个插件编译后的版本。</p>\n<p>当构建完成时，二进制插件就可以在 Node.js 中被使用，通过 require() 构建后的 addon.node 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hello.js</span><br><span class=\"line\">const addon = require(&#x27;./build/Release/addon&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(addon.hello());</span><br><span class=\"line\">// 打印: &#x27;world&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><em>因为编译后的二进制插件的确切路径取决于它如何被编译（比如有时它可能在 ./build/Debug/ 中），所以插件可以使用 bindings 包加载编译后的模块。</em></p>\n<p>注意，虽然 bindings 包在如何定位插件模块的实现上更复杂，但它本质上使用了一个 try-catch 模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  return require(&#x27;./build/Release/addon.node&#x27;);</span><br><span class=\"line\">&#125; catch (err) &#123;</span><br><span class=\"line\">  return require(&#x27;./build/Debug/addon.node&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>链接到 Node.js 自有的依赖</strong><br>Node.js 使用了一些静态链接库，所有的插件都需要链接到 V8，也可能链接到任何其他依赖。 通常情况下，只要简单地包含相应的 #include &lt;…&gt; 声明（如 #include &lt;v8.h&gt;），则 node-gyp 会自动定位到相应的头文件。 但是也有一些注意事项需要注意：</p>\n<ul>\n<li><p>当 node-gyp 运行时，它会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件对全套的 Node.js 依赖有完全的访问权限。 如果只下载了 Node.js 的文件头，则只有 Node.js 导出的符号可用。</p>\n</li>\n<li><p>node-gyp 可使用指向一个本地 Node.js 源代码镜像的 –nodedir 标志来运行。 如果使用该选项，则插件有全套依赖的访问权限。</p>\n</li>\n</ul>\n<p><strong>使用 require() 加载插件</strong><br>编译后的二进制插件的文件扩展名是 .node（而不是 .dll 或 .so）。 require() 函数用于查找具有 .node 文件扩展名的文件，并初始化为动态链接库。</p>\n<p>当调用 require() 时，.node 拓展名通常可被省略，Node.js 仍会找到并初始化该插件。 注意，Node.js 会优先尝试查找并加载同名的模块或 JavaScript 文件。 例如，如果与二进制的 addon.node 同一目录下有一个 addon.js 文件，则 require(‘addon’) 会优先加载 addon.js 文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Node.js 插件是用 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行在 Node.js 中的 JavaScript 与 C/C++ 库之间提供接口。</p>\n<p>目前用于实现插件的方法相当复杂，涉及多个组件和 API 的知识：</p>\n<ul>\n<li>V8：Node.js 目前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等的机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h），也可以在查看 <a href=\"https://v8docs.nodesource.com/\">V8 在线文档</a>。</li>\n<li><a href=\"https://github.com/libuv/libuv\">libuv</a>：实现了 Node.js 的事件循环、工作线程、以及平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器、以及系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 建议插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。</li>\n<li>内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C++ API。 其中最重要的是 node::ObjectWrap 类。</li>\n<li>Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 开放的，并且通过插件被用于不同的场景。</li>\n</ul>\n<ol>\n<li>创建 hello.cc 文件<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hello.cc</span><br><span class=\"line\">#include &lt;node.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">using v8::FunctionCallbackInfo;</span><br><span class=\"line\">using v8::Isolate;</span><br><span class=\"line\">using v8::Local;</span><br><span class=\"line\">using v8::Object;</span><br><span class=\"line\">using v8::String;</span><br><span class=\"line\">using v8::Value;</span><br><span class=\"line\"></span><br><span class=\"line\">void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class=\"line\">  Isolate* isolate = args.GetIsolate();</span><br><span class=\"line\">  args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;world&quot;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void init(Local&lt;Object&gt; exports) &#123;</span><br><span class=\"line\">  NODE_SET_METHOD(exports, &quot;hello&quot;, Method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  // namespace demo</span><br></pre></td></tr></table></figure>\n注意，所有的 Node.js 插件必须导出一个如下模式的初始化函数：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Initialize(Local&lt;Object&gt; exports);</span><br><span class=\"line\">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span><br></pre></td></tr></table></figure>\nNODE_MODULE 后面没有分号，因为它不是一个函数（详见 node.h）。</li>\n</ol>\n<p>module_name 必须匹配最终的二进制文件名（不包括 .node 后缀）。</p>\n<p>在 hello.cc 示例中，初始化函数是 init，插件模块名是 addon。</p>\n<p><strong>构建</strong></p>\n<p>当源代码已被编写，它必须被编译成二进制 addon.node 文件。 要做到这点，需在项目的顶层创建一个名为 binding.gyp 的文件，它使用一个类似 JSON 的格式来描述模块的构建配置。 该文件会被 node-gyp（一个用于编译 Node.js 插件的工具）使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;addon&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当使用 npm install 安装一个 Node.js 插件时，npm 会使用自身捆绑的 node-gyp 版本来执行同样的一套动作，为用户要求的平台生成一个插件编译后的版本。</p>\n<p>当构建完成时，二进制插件就可以在 Node.js 中被使用，通过 require() 构建后的 addon.node 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hello.js</span><br><span class=\"line\">const addon = require(&#x27;./build/Release/addon&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(addon.hello());</span><br><span class=\"line\">// 打印: &#x27;world&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><em>因为编译后的二进制插件的确切路径取决于它如何被编译（比如有时它可能在 ./build/Debug/ 中），所以插件可以使用 bindings 包加载编译后的模块。</em></p>\n<p>注意，虽然 bindings 包在如何定位插件模块的实现上更复杂，但它本质上使用了一个 try-catch 模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  return require(&#x27;./build/Release/addon.node&#x27;);</span><br><span class=\"line\">&#125; catch (err) &#123;</span><br><span class=\"line\">  return require(&#x27;./build/Debug/addon.node&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>链接到 Node.js 自有的依赖</strong><br>Node.js 使用了一些静态链接库，所有的插件都需要链接到 V8，也可能链接到任何其他依赖。 通常情况下，只要简单地包含相应的 #include &lt;…&gt; 声明（如 #include &lt;v8.h&gt;），则 node-gyp 会自动定位到相应的头文件。 但是也有一些注意事项需要注意：</p>\n<ul>\n<li><p>当 node-gyp 运行时，它会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件对全套的 Node.js 依赖有完全的访问权限。 如果只下载了 Node.js 的文件头，则只有 Node.js 导出的符号可用。</p>\n</li>\n<li><p>node-gyp 可使用指向一个本地 Node.js 源代码镜像的 –nodedir 标志来运行。 如果使用该选项，则插件有全套依赖的访问权限。</p>\n</li>\n</ul>\n<p><strong>使用 require() 加载插件</strong><br>编译后的二进制插件的文件扩展名是 .node（而不是 .dll 或 .so）。 require() 函数用于查找具有 .node 文件扩展名的文件，并初始化为动态链接库。</p>\n<p>当调用 require() 时，.node 拓展名通常可被省略，Node.js 仍会找到并初始化该插件。 注意，Node.js 会优先尝试查找并加载同名的模块或 JavaScript 文件。 例如，如果与二进制的 addon.node 同一目录下有一个 addon.js 文件，则 require(‘addon’) 会优先加载 addon.js 文件。</p>\n"},{"title":"nodejs基础知识(2)","date":"2022-10-19T11:12:12.000Z","tags":["node","buffer"],"_content":"\n###### Buffer(缓冲)\nES6引入TypedArray???之前，JavaScript 语言没有读取或操作二进制数据流的机制。\nBuffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。\n\nTypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。\n\n*Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require('buffer').Buffer。*\n```javascript\n// 创建一个长度为 10、且用 0 填充的 Buffer。\nconst buf1 = Buffer.alloc(10);\n\n// 创建一个长度为 10、且用 0x1 填充的 Buffer。 \nconst buf2 = Buffer.alloc(10, 1);\n\n// 创建一个长度为 10、且未初始化的 Buffer。\n// 这个方法比调用 Buffer.alloc() 更快，\n// 但返回的 Buffer 实例可能包含旧数据，\n// 因此需要使用 fill() 或 write() 重写。\nconst buf3 = Buffer.allocUnsafe(10);\n\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\nconst buf5 = Buffer.from('tést');\n\n// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\nconst buf6 = Buffer.from('tést', 'latin1');\n```\n\n*Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()*\n注意：nodejs v6之前，uffer 实例是通过 Buffer 构造函数创建的，它根据提供的参数返回不同的 Buffer\n- nodejs 8.0.0之前分配给Buffer实例的内存是没有初始化的，且可能包含敏感数据；8.0.0之后，返回的是初始化内存之后的buffer\n- 传递一个字符串、数组 或 Buffer 作为第一个参数，会将所传对象的数据拷贝到Buffer中\n- 传入 ArrayBuffer 或 SharedArrayBuffer，则返回一个与传入的 ArrayBuffer 共享所分配内存的 Buffer\n\n出于安全性和可靠性考虑，new Buffer()构造函数已被废弃，由Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()方法代替\n\n- Buffer.from(array) 返回**一个新建的包含所提供的字节数组的副本**的 Buffer。\n- [Buffer.from(arrayBuffer[, byteOffset [, length]])]Buffer.from(arrayBuffer) 返回**一个新建的与给定的 ArrayBuffer 共享同一内存**的 Buffer。\n- Buffer.from(buffer) 返回**一个新建的包含所提供的 Buffer 的内容的副本**的 Buffer。\n- Buffer.from(string[, encoding]) 返回**一个新建的包含所提供的字符串的副本**的 Buffer。\n- [Buffer.alloc(size[, fill[, encoding]])]Buffer.alloc() 返回**一个指定大小的被填满的 Buffer 实例**。 这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝**不会包含旧的和潜在的敏感数据**。\n- Buffer.allocUnsafe(size) 与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。\n*如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例**可能**会被分配进一个共享的内部内存池。*\n\n*--zero-fill-buffers命令行选项*\n强制所有新分配的buffer实例在**创建时自动用0填充**\n注意：使用这个选项会改变新建buffer实例方法的默认行为，对性能有明显的影响。建议只在需要强制新分配的 Buffer 实例不能包含潜在的敏感数据时才使用 --zero-fill-buffers 选项。\n\n*buffer.allocUnsafe()和buffer.allocUnsafeSlow()不安全的原因*\nbuffer.allocUnsafe()和buffer.allocUnsafeSlow()创建的buffer实例，被分配的内存段是**未初始化的(未用0填充)**，这样的设计使得内存的分配很快，但分配的内存可能含有潜在的敏感旧数据，从而给程序引入安全漏洞\n\n*buffer与字符编码*\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\n```javascript\nconst buf = Buffer.from('hello world', 'ascii');\nconsole.log(buf.toString('hex'));\n// 输出 68656c6c6f20776f726c64\n\nconsole.log(buf.toString('base64'));\n// 输出 aGVsbG8gd29ybGQ=\n```\n\nnodejs目前支持的字符编码\n- ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，编码非常快\n- utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8\n- utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）\n- ucs2 - 'utf16le' 的别名\n- base64 - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”\n- latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）\n- binary - 'latin1' 的别名\n- hex - 将每个字节编码为两个十六进制字符\n\n**注意**：现代浏览器遵循 WHATWG 编码标准 将 'latin1' 和 ISO-8859-1 别名为 win-1252。 这意味着当进行例如 http.get() 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 'latin1' 字符编码可能会错误地解码数据\n\n*Buffer 与 TypedArray*\nBuffer 实例也是 Uint8Array 实例\n从一个 Buffer 创建一个新的 TypedArray 实例需要遵循的注意事项：\n- Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的。\n- Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。 也就是说，new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array，而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array \n```javascript\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// 拷贝 `arr` 的内容\nconst buf1 = Buffer.from(arr);\n\n// 与 `arr` 共享内存\nconst buf2 = Buffer.from(arr.buffer);\n\n// 输出: <Buffer 88 a0>\nconsole.log(buf1);\n\n// 输出: <Buffer 88 13 a0 0f>\nconsole.log(buf2);\n\narr[1] = 6000;\n\n// 输出: <Buffer 88 a0>\nconsole.log(buf1);\n\n// 输出: <Buffer 88 13 70 17>\nconsole.log(buf2);\n```\n*注意，当使用 TypedArray 的 .buffer 创建 Buffer 时，也可以通过传入 byteOffset 和 length 参数只使用 ArrayBuffer 的一部分*\n```javascript\nconst arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\n// 输出: 16\nconsole.log(buf.length);\n```\n\nBuffer 实例可以使用 ECMAScript 2015 (ES6) 的 for..of 语法进行遍历\n\n```javascript\nconst buf = Buffer.from([1, 2, 3]);\n\n// 输出:\n//   1\n//   2\n//   3\nfor (const b of buf) {\n  console.log(b);\n}\n```\nbuf.values() 、buf.keys() 和 buf.entries() 方法可用于创建迭代器\n\n*Buffer类*\nBuffer 类是一个全局变量类型，用来直接处理二进制数据的。 它能够使用多种方式构建。\n\n**类方法：Buffer.allocUnsafe(size)**\n分配一个大小为 size 字节的新建的 Buffer 。 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误。 如果 size 为 0，则创建一个长度为 0 的 Buffer。\n以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。\n\n```javascript\nconst buf = Buffer.allocUnsafe(10);\nconsole.log(buf);\n// 输出: (内容可能不同): <Buffer 00 00 00 00 00 00 00 00 00 00>\n\nbuf.fill(0);\n\n// 输出: <Buffer 00 00 00 00 00 00 00 00 00 00>\nconsole.log(buf);\n```\n如果 size 不是一个数值，则抛出 TypeError 错误。\n\n注意，Buffer 模块会预分配一个大小为 Buffer.poolSize 的内部 Buffer 实例作为快速分配池， 用于使用 Buffer.allocUnsafe() 新创建的 Buffer 实例，以及废弃的 new Buffer(size) 构造器， 仅限于当 size 小于或等于 Buffer.poolSize >> 1 （Buffer.poolSize 除以2后的最大整数值）。\n\n对这个预分配的内部内存池的使用，是调用 Buffer.alloc(size, fill) 和 Buffer.allocUnsafe(size).fill(fill) 的关键区别。 *具体地说，Buffer.alloc(size, fill) 永远不会使用这个内部的 Buffer 池，但如果 size 小于或等于 Buffer.poolSize 的一半， Buffer.allocUnsafe(size).fill(fill) 会使用这个内部的 Buffer 池。 当应用程序需要 Buffer.allocUnsafe() 提供额外的性能时，这个细微的区别是非常重要的。*\n\n**类方法：Buffer.allocUnsafeSlow(size)**\n当使用 Buffer.allocUnsafe() 分配新建的 Buffer 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 Buffer 切割出来。 这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 Buffer 实例而过度使用。 这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。\n\n当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 Buffer.allocUnsafeSlow() 创建一个非池的 Buffer 实例然后拷贝出相关的位元是合适的做法。\n```javascript\n// 需要保留一小块内存块\nconst store = [];\n\nsocket.on('readable', () => {\n  const data = socket.read();\n\n  // 为保留的数据分配内存\n  const sb = Buffer.allocUnsafeSlow(10);\n\n  // 拷贝数据进新分配的内存\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n```\n*Buffer.allocUnsafeSlow() 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。*\n\n**类方法：Buffer.byteLength(string[, encoding])**\n返回一个字符串的实际字节长度。 这与 String.prototype.length 不同，因为那返回字符串的字符数。\n\n注意 对于 'base64' 和 'hex'， 该函数假定有效的输入。 对于包含 non-Base64/Hex-encoded 数据的字符串 (e.g. 空格)， 返回值可能大于 从字符串中创建的 Buffer 的长度。\n\n当 string 是一个 Buffer/DataView/TypedArray/ArrayBuffer/SharedArrayBuffer 时，返回实际的字节长度。\n\n**类方法：Buffer.compare(buf1, buf2)**\n比较 buf1 和 buf2 ，通常用于 Buffer 实例数组的排序。 相当于调用 buf1.compare(buf2) 。\n```javascript\nconst buf1 = Buffer.from('1234');\nconst buf2 = Buffer.from('0123');\nconst arr = [buf1, buf2];\n\nconsole.log(arr.sort(Buffer.compare));\n// 输出: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]\n// (结果相当于: [buf2, buf1])\n```\n\n**类方法：Buffer.concat(list[, totalLength])**\n返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。\n\n如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。\n\n*如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。*\n*如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。*\n\n```javascript\nconst buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\n// 输出: 42\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\nconsole.log(bufA);\n// 输出: <Buffer 00 00 00 00 ...>\n\nconsole.log(bufA.length);\n// 输出: 42\n```\n\n**类方法：Buffer.from(array)**\n如果 array 不是一个数组，则抛出 TypeError 错误\n**类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])**\narrayBuffer <ArrayBuffer> | <SharedArrayBuffer> ArrayBuffer 或 SharedArrayBuffer 或 TypedArray 的 .buffer 属性。\nbyteOffset <integer> 开始拷贝的索引。默认为 0。\nlength <integer> 拷贝的字节数。默认为 arrayBuffer.length - byteOffset。\n\n该方法将创建一个 ArrayBuffer 的视图，而不会复制底层内存。例如，当传入一个 TypedArray 实例的 .buffer 属性的引用时，这个新建的 Buffer 会像 TypedArray 那样共享同一分配的内存。\n\n```javascript\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = Buffer.from(arr.buffer);\n// 与 `arr` 共享内存\n\nconsole.log(buf);\n// 输出: <Buffer 88 13 a0 0f>\n\narr[1] = 6000;\n// 改变原始的 Uint16Array 也会改变 Buffer\n\nconsole.log(buf);\n// 输出: <Buffer 88 13 70 17>\n```\n可选的 byteOffset 和 length 参数指定将与 Buffer 共享的 arrayBuffer 的内存范围\n```javascript\nconst ab = new ArrayBuffer(10);\nconst buff = Buffer.from(ab, 0, 2);\nconsole.log(buff.length);\n// 输出: 2\n```\n如果 arrayBuffer 不是 ArrayBuffer 或 SharedArrayBuffer，则抛出 TypeError 错误\n\n**类方法：Buffer.from(buffer)**\n将传入的 buffer 数据拷贝到一个新建的 Buffer 实例。\n```javascript\nconst buf1 = Buffer.from('buffer');\nconst buf2 = Buffer.from(buf1);\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n// 输出: auffer\n\nconsole.log(buf2.toString());\n// 输出: buffer\n```\n\n**类方法：Buffer.from(string[, encoding])**\n新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码。\n```javascript\nconst buf1 = Buffer.from('this is a tést');\n\nconsole.log(buf1.toString());\n// 输出: this is a tést\n\nconsole.log(buf1.toString('ascii'));\n// 输出: this is a tC)st\n\nconst buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n\nconsole.log(buf2.toString());\n// 输出: this is a tést\n```\n\n**Class Method: Buffer.from(object[, offsetOrEncoding[, length]])**\nobject <Object> 一个支持 Symbol.toPrimitive 或 valueOf() 的对象\noffsetOrEncoding <number> | <string> 字节偏移量或编码，取决于 object.valueOf() 或 object[Symbol.toPrimitive]() 的返回值。\nlength <number> 长度值，取决于 object.valueOf() 或 object[Symbol.toPrimitive]() 的返回值。\n那些其 valueOf() 方法返回值如果不严格等于 object 的对象，返回Buffer.from(object.valueOf(), offsetOrEncoding, length)。\n```\nconst buf = Buffer.from(new String('this is a test'));\n// <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n```\n那些支持 Symbol.toPrimitive 的对象， 返回 Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)。\n```\nclass Foo {\n  [Symbol.toPrimitive]() {\n    return 'this is a test';\n  }\n}\n\nconst buf = Buffer.from(new Foo(), 'utf8');\n// <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n```\n\n**类方法：Buffer.isBuffer(obj)**\n如果 obj 是一个 Buffer 则返回 true ，否则返回 false \n**类方法：Buffer.isEncoding(encoding)**\n如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。\n**类属性：Buffer.poolSize**\n这是用于决定预分配的、内部 Buffer 实例池的大小的字节数。 这个值可以修改。默认值：8192\n\n**buf[index]**\n索引操作符 [index] 可用于获取或设置 buf 中指定 index 位置的八位字节。 这个值指向的是单个字节，所以合法的值范围是的 0x00 至 0xFF（十六进制），或 0 至 255（十进制）。\n\n该操作符继承自 Uint8Array，所以它对越界访问的处理与 UInt8Array 相同（也就是说，获取时返回 undefined，设置时什么也不做）。\n```\nconst str = 'Node.js';\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i < str.length; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString('ascii'));\n// 输出: Node.js\n```\n\n**buf.buffer**\nbuffer 属性指向创建该 Buffer 的底层的 ArrayBuffer 对象。\n```\nconst arrayBuffer = new ArrayBuffer(16);\nconst buffer = Buffer.from(arrayBuffer);\n\nconsole.log(buffer.buffer === arrayBuffer);\n// 输出: true\n```\n\n**buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])**\ntarget <Buffer> | <Uint8Array> 要比较的 Buffer 或 Uint8Array。\ntargetStart <integer> target 中开始对比的偏移量。 默认: 0\ntargetEnd <integer> target 中结束对比的偏移量（不包含）。 默认: target.length\nsourceStart <integer> buf 中开始对比的偏移量。 默认: 0\nsourceEnd <integer> buf 中结束对比的偏移量（不包含）。 默认: buf.length\n返回: <integer>\n比较 buf 与 target，返回表明 buf 在排序上是否排在 target 之前、或之后、或相同。 对比是基于各自 Buffer 实际的字节序列。\n\n如果 target 与 buf 相同，则返回 0 。\n如果 target 排在 buf 前面，则返回 1 。\n如果 target 排在 buf 后面，则返回 -1 。\n\n```\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// 输出: 0\n\nconsole.log(buf1.compare(buf2));\n// 输出: -1\n\nconsole.log(buf1.compare(buf3));\n// 输出: -1\n\nconsole.log(buf2.compare(buf1));\n// 输出: 1\n\nconsole.log(buf2.compare(buf3));\n// 输出: 1\n\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// 输出: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (结果相当于: [buf1, buf3, buf2])\n```\n可选的 targetStart 、 targetEnd 、 sourceStart 与 sourceEnd 参数可用于分别在 target 与 buf 中限制对比在指定的范围内。\n```\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// 输出: 0\n\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// 输出: -1\n\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// 输出: 1\n```\n如果 targetStart < 0 、 sourceStart < 0 、 targetEnd > target.byteLength 或 sourceEnd > source.byteLength，则抛出 RangeError 错误。\n\n**buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])**\ntarget <Buffer> | <Uint8Array> 要拷贝进的 Buffer 或 Uint8Array。\ntargetStart <integer> target 中开始拷贝进的偏移量。 默认: 0\nsourceStart <integer> buf 中开始拷贝的偏移量。 默认: 0\nsourceEnd <integer> buf 中结束拷贝的偏移量（不包含）。 默认: buf.length\n返回: <integer> 被拷贝的字节数。\n拷贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠。\n```\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 是 'a' 的十进制 ASCII 值\n  buf1[i] = i + 97;\n}\n\nbuf1.copy(buf2, 8, 16, 20);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// 输出: !!!!!!!!qrst!!!!!!!!!!!!!\n\n// 创建一个 Buffer ，并拷贝同一 Buffer 中一个区域的数据到另一个重叠的区域。\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 是 'a' 的十进制 ASCII 值\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// 输出: efghijghijklmnopqrstuvwxyz\n```\n","source":"nodejs/nodejs-note-7.md","raw":"---\ntitle: nodejs基础知识(2)\ndate: 2022-10-19 19:12:12\ntags: [node, buffer]\n---\n\n###### Buffer(缓冲)\nES6引入TypedArray???之前，JavaScript 语言没有读取或操作二进制数据流的机制。\nBuffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。\n\nTypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。\n\n*Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require('buffer').Buffer。*\n```javascript\n// 创建一个长度为 10、且用 0 填充的 Buffer。\nconst buf1 = Buffer.alloc(10);\n\n// 创建一个长度为 10、且用 0x1 填充的 Buffer。 \nconst buf2 = Buffer.alloc(10, 1);\n\n// 创建一个长度为 10、且未初始化的 Buffer。\n// 这个方法比调用 Buffer.alloc() 更快，\n// 但返回的 Buffer 实例可能包含旧数据，\n// 因此需要使用 fill() 或 write() 重写。\nconst buf3 = Buffer.allocUnsafe(10);\n\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\nconst buf5 = Buffer.from('tést');\n\n// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\nconst buf6 = Buffer.from('tést', 'latin1');\n```\n\n*Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()*\n注意：nodejs v6之前，uffer 实例是通过 Buffer 构造函数创建的，它根据提供的参数返回不同的 Buffer\n- nodejs 8.0.0之前分配给Buffer实例的内存是没有初始化的，且可能包含敏感数据；8.0.0之后，返回的是初始化内存之后的buffer\n- 传递一个字符串、数组 或 Buffer 作为第一个参数，会将所传对象的数据拷贝到Buffer中\n- 传入 ArrayBuffer 或 SharedArrayBuffer，则返回一个与传入的 ArrayBuffer 共享所分配内存的 Buffer\n\n出于安全性和可靠性考虑，new Buffer()构造函数已被废弃，由Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()方法代替\n\n- Buffer.from(array) 返回**一个新建的包含所提供的字节数组的副本**的 Buffer。\n- [Buffer.from(arrayBuffer[, byteOffset [, length]])]Buffer.from(arrayBuffer) 返回**一个新建的与给定的 ArrayBuffer 共享同一内存**的 Buffer。\n- Buffer.from(buffer) 返回**一个新建的包含所提供的 Buffer 的内容的副本**的 Buffer。\n- Buffer.from(string[, encoding]) 返回**一个新建的包含所提供的字符串的副本**的 Buffer。\n- [Buffer.alloc(size[, fill[, encoding]])]Buffer.alloc() 返回**一个指定大小的被填满的 Buffer 实例**。 这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝**不会包含旧的和潜在的敏感数据**。\n- Buffer.allocUnsafe(size) 与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。\n*如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例**可能**会被分配进一个共享的内部内存池。*\n\n*--zero-fill-buffers命令行选项*\n强制所有新分配的buffer实例在**创建时自动用0填充**\n注意：使用这个选项会改变新建buffer实例方法的默认行为，对性能有明显的影响。建议只在需要强制新分配的 Buffer 实例不能包含潜在的敏感数据时才使用 --zero-fill-buffers 选项。\n\n*buffer.allocUnsafe()和buffer.allocUnsafeSlow()不安全的原因*\nbuffer.allocUnsafe()和buffer.allocUnsafeSlow()创建的buffer实例，被分配的内存段是**未初始化的(未用0填充)**，这样的设计使得内存的分配很快，但分配的内存可能含有潜在的敏感旧数据，从而给程序引入安全漏洞\n\n*buffer与字符编码*\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\n```javascript\nconst buf = Buffer.from('hello world', 'ascii');\nconsole.log(buf.toString('hex'));\n// 输出 68656c6c6f20776f726c64\n\nconsole.log(buf.toString('base64'));\n// 输出 aGVsbG8gd29ybGQ=\n```\n\nnodejs目前支持的字符编码\n- ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，编码非常快\n- utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8\n- utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）\n- ucs2 - 'utf16le' 的别名\n- base64 - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”\n- latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）\n- binary - 'latin1' 的别名\n- hex - 将每个字节编码为两个十六进制字符\n\n**注意**：现代浏览器遵循 WHATWG 编码标准 将 'latin1' 和 ISO-8859-1 别名为 win-1252。 这意味着当进行例如 http.get() 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 'latin1' 字符编码可能会错误地解码数据\n\n*Buffer 与 TypedArray*\nBuffer 实例也是 Uint8Array 实例\n从一个 Buffer 创建一个新的 TypedArray 实例需要遵循的注意事项：\n- Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的。\n- Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。 也就是说，new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array，而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array \n```javascript\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// 拷贝 `arr` 的内容\nconst buf1 = Buffer.from(arr);\n\n// 与 `arr` 共享内存\nconst buf2 = Buffer.from(arr.buffer);\n\n// 输出: <Buffer 88 a0>\nconsole.log(buf1);\n\n// 输出: <Buffer 88 13 a0 0f>\nconsole.log(buf2);\n\narr[1] = 6000;\n\n// 输出: <Buffer 88 a0>\nconsole.log(buf1);\n\n// 输出: <Buffer 88 13 70 17>\nconsole.log(buf2);\n```\n*注意，当使用 TypedArray 的 .buffer 创建 Buffer 时，也可以通过传入 byteOffset 和 length 参数只使用 ArrayBuffer 的一部分*\n```javascript\nconst arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\n// 输出: 16\nconsole.log(buf.length);\n```\n\nBuffer 实例可以使用 ECMAScript 2015 (ES6) 的 for..of 语法进行遍历\n\n```javascript\nconst buf = Buffer.from([1, 2, 3]);\n\n// 输出:\n//   1\n//   2\n//   3\nfor (const b of buf) {\n  console.log(b);\n}\n```\nbuf.values() 、buf.keys() 和 buf.entries() 方法可用于创建迭代器\n\n*Buffer类*\nBuffer 类是一个全局变量类型，用来直接处理二进制数据的。 它能够使用多种方式构建。\n\n**类方法：Buffer.allocUnsafe(size)**\n分配一个大小为 size 字节的新建的 Buffer 。 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误。 如果 size 为 0，则创建一个长度为 0 的 Buffer。\n以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。\n\n```javascript\nconst buf = Buffer.allocUnsafe(10);\nconsole.log(buf);\n// 输出: (内容可能不同): <Buffer 00 00 00 00 00 00 00 00 00 00>\n\nbuf.fill(0);\n\n// 输出: <Buffer 00 00 00 00 00 00 00 00 00 00>\nconsole.log(buf);\n```\n如果 size 不是一个数值，则抛出 TypeError 错误。\n\n注意，Buffer 模块会预分配一个大小为 Buffer.poolSize 的内部 Buffer 实例作为快速分配池， 用于使用 Buffer.allocUnsafe() 新创建的 Buffer 实例，以及废弃的 new Buffer(size) 构造器， 仅限于当 size 小于或等于 Buffer.poolSize >> 1 （Buffer.poolSize 除以2后的最大整数值）。\n\n对这个预分配的内部内存池的使用，是调用 Buffer.alloc(size, fill) 和 Buffer.allocUnsafe(size).fill(fill) 的关键区别。 *具体地说，Buffer.alloc(size, fill) 永远不会使用这个内部的 Buffer 池，但如果 size 小于或等于 Buffer.poolSize 的一半， Buffer.allocUnsafe(size).fill(fill) 会使用这个内部的 Buffer 池。 当应用程序需要 Buffer.allocUnsafe() 提供额外的性能时，这个细微的区别是非常重要的。*\n\n**类方法：Buffer.allocUnsafeSlow(size)**\n当使用 Buffer.allocUnsafe() 分配新建的 Buffer 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 Buffer 切割出来。 这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 Buffer 实例而过度使用。 这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。\n\n当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 Buffer.allocUnsafeSlow() 创建一个非池的 Buffer 实例然后拷贝出相关的位元是合适的做法。\n```javascript\n// 需要保留一小块内存块\nconst store = [];\n\nsocket.on('readable', () => {\n  const data = socket.read();\n\n  // 为保留的数据分配内存\n  const sb = Buffer.allocUnsafeSlow(10);\n\n  // 拷贝数据进新分配的内存\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n```\n*Buffer.allocUnsafeSlow() 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。*\n\n**类方法：Buffer.byteLength(string[, encoding])**\n返回一个字符串的实际字节长度。 这与 String.prototype.length 不同，因为那返回字符串的字符数。\n\n注意 对于 'base64' 和 'hex'， 该函数假定有效的输入。 对于包含 non-Base64/Hex-encoded 数据的字符串 (e.g. 空格)， 返回值可能大于 从字符串中创建的 Buffer 的长度。\n\n当 string 是一个 Buffer/DataView/TypedArray/ArrayBuffer/SharedArrayBuffer 时，返回实际的字节长度。\n\n**类方法：Buffer.compare(buf1, buf2)**\n比较 buf1 和 buf2 ，通常用于 Buffer 实例数组的排序。 相当于调用 buf1.compare(buf2) 。\n```javascript\nconst buf1 = Buffer.from('1234');\nconst buf2 = Buffer.from('0123');\nconst arr = [buf1, buf2];\n\nconsole.log(arr.sort(Buffer.compare));\n// 输出: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]\n// (结果相当于: [buf2, buf1])\n```\n\n**类方法：Buffer.concat(list[, totalLength])**\n返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。\n\n如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。\n\n*如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。*\n*如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。*\n\n```javascript\nconst buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\n// 输出: 42\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\nconsole.log(bufA);\n// 输出: <Buffer 00 00 00 00 ...>\n\nconsole.log(bufA.length);\n// 输出: 42\n```\n\n**类方法：Buffer.from(array)**\n如果 array 不是一个数组，则抛出 TypeError 错误\n**类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])**\narrayBuffer <ArrayBuffer> | <SharedArrayBuffer> ArrayBuffer 或 SharedArrayBuffer 或 TypedArray 的 .buffer 属性。\nbyteOffset <integer> 开始拷贝的索引。默认为 0。\nlength <integer> 拷贝的字节数。默认为 arrayBuffer.length - byteOffset。\n\n该方法将创建一个 ArrayBuffer 的视图，而不会复制底层内存。例如，当传入一个 TypedArray 实例的 .buffer 属性的引用时，这个新建的 Buffer 会像 TypedArray 那样共享同一分配的内存。\n\n```javascript\nconst arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = Buffer.from(arr.buffer);\n// 与 `arr` 共享内存\n\nconsole.log(buf);\n// 输出: <Buffer 88 13 a0 0f>\n\narr[1] = 6000;\n// 改变原始的 Uint16Array 也会改变 Buffer\n\nconsole.log(buf);\n// 输出: <Buffer 88 13 70 17>\n```\n可选的 byteOffset 和 length 参数指定将与 Buffer 共享的 arrayBuffer 的内存范围\n```javascript\nconst ab = new ArrayBuffer(10);\nconst buff = Buffer.from(ab, 0, 2);\nconsole.log(buff.length);\n// 输出: 2\n```\n如果 arrayBuffer 不是 ArrayBuffer 或 SharedArrayBuffer，则抛出 TypeError 错误\n\n**类方法：Buffer.from(buffer)**\n将传入的 buffer 数据拷贝到一个新建的 Buffer 实例。\n```javascript\nconst buf1 = Buffer.from('buffer');\nconst buf2 = Buffer.from(buf1);\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n// 输出: auffer\n\nconsole.log(buf2.toString());\n// 输出: buffer\n```\n\n**类方法：Buffer.from(string[, encoding])**\n新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码。\n```javascript\nconst buf1 = Buffer.from('this is a tést');\n\nconsole.log(buf1.toString());\n// 输出: this is a tést\n\nconsole.log(buf1.toString('ascii'));\n// 输出: this is a tC)st\n\nconst buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n\nconsole.log(buf2.toString());\n// 输出: this is a tést\n```\n\n**Class Method: Buffer.from(object[, offsetOrEncoding[, length]])**\nobject <Object> 一个支持 Symbol.toPrimitive 或 valueOf() 的对象\noffsetOrEncoding <number> | <string> 字节偏移量或编码，取决于 object.valueOf() 或 object[Symbol.toPrimitive]() 的返回值。\nlength <number> 长度值，取决于 object.valueOf() 或 object[Symbol.toPrimitive]() 的返回值。\n那些其 valueOf() 方法返回值如果不严格等于 object 的对象，返回Buffer.from(object.valueOf(), offsetOrEncoding, length)。\n```\nconst buf = Buffer.from(new String('this is a test'));\n// <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n```\n那些支持 Symbol.toPrimitive 的对象， 返回 Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)。\n```\nclass Foo {\n  [Symbol.toPrimitive]() {\n    return 'this is a test';\n  }\n}\n\nconst buf = Buffer.from(new Foo(), 'utf8');\n// <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n```\n\n**类方法：Buffer.isBuffer(obj)**\n如果 obj 是一个 Buffer 则返回 true ，否则返回 false \n**类方法：Buffer.isEncoding(encoding)**\n如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。\n**类属性：Buffer.poolSize**\n这是用于决定预分配的、内部 Buffer 实例池的大小的字节数。 这个值可以修改。默认值：8192\n\n**buf[index]**\n索引操作符 [index] 可用于获取或设置 buf 中指定 index 位置的八位字节。 这个值指向的是单个字节，所以合法的值范围是的 0x00 至 0xFF（十六进制），或 0 至 255（十进制）。\n\n该操作符继承自 Uint8Array，所以它对越界访问的处理与 UInt8Array 相同（也就是说，获取时返回 undefined，设置时什么也不做）。\n```\nconst str = 'Node.js';\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i < str.length; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString('ascii'));\n// 输出: Node.js\n```\n\n**buf.buffer**\nbuffer 属性指向创建该 Buffer 的底层的 ArrayBuffer 对象。\n```\nconst arrayBuffer = new ArrayBuffer(16);\nconst buffer = Buffer.from(arrayBuffer);\n\nconsole.log(buffer.buffer === arrayBuffer);\n// 输出: true\n```\n\n**buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])**\ntarget <Buffer> | <Uint8Array> 要比较的 Buffer 或 Uint8Array。\ntargetStart <integer> target 中开始对比的偏移量。 默认: 0\ntargetEnd <integer> target 中结束对比的偏移量（不包含）。 默认: target.length\nsourceStart <integer> buf 中开始对比的偏移量。 默认: 0\nsourceEnd <integer> buf 中结束对比的偏移量（不包含）。 默认: buf.length\n返回: <integer>\n比较 buf 与 target，返回表明 buf 在排序上是否排在 target 之前、或之后、或相同。 对比是基于各自 Buffer 实际的字节序列。\n\n如果 target 与 buf 相同，则返回 0 。\n如果 target 排在 buf 前面，则返回 1 。\n如果 target 排在 buf 后面，则返回 -1 。\n\n```\nconst buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// 输出: 0\n\nconsole.log(buf1.compare(buf2));\n// 输出: -1\n\nconsole.log(buf1.compare(buf3));\n// 输出: -1\n\nconsole.log(buf2.compare(buf1));\n// 输出: 1\n\nconsole.log(buf2.compare(buf3));\n// 输出: 1\n\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// 输出: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n// (结果相当于: [buf1, buf3, buf2])\n```\n可选的 targetStart 、 targetEnd 、 sourceStart 与 sourceEnd 参数可用于分别在 target 与 buf 中限制对比在指定的范围内。\n```\nconst buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// 输出: 0\n\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// 输出: -1\n\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// 输出: 1\n```\n如果 targetStart < 0 、 sourceStart < 0 、 targetEnd > target.byteLength 或 sourceEnd > source.byteLength，则抛出 RangeError 错误。\n\n**buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])**\ntarget <Buffer> | <Uint8Array> 要拷贝进的 Buffer 或 Uint8Array。\ntargetStart <integer> target 中开始拷贝进的偏移量。 默认: 0\nsourceStart <integer> buf 中开始拷贝的偏移量。 默认: 0\nsourceEnd <integer> buf 中结束拷贝的偏移量（不包含）。 默认: buf.length\n返回: <integer> 被拷贝的字节数。\n拷贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠。\n```\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i < 26; i++) {\n  // 97 是 'a' 的十进制 ASCII 值\n  buf1[i] = i + 97;\n}\n\nbuf1.copy(buf2, 8, 16, 20);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// 输出: !!!!!!!!qrst!!!!!!!!!!!!!\n\n// 创建一个 Buffer ，并拷贝同一 Buffer 中一个区域的数据到另一个重叠的区域。\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i < 26; i++) {\n  // 97 是 'a' 的十进制 ASCII 值\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// 输出: efghijghijklmnopqrstuvwxyz\n```\n","updated":"2022-12-28T09:10:43.846Z","path":"nodejs/nodejs-note-7.html","comments":1,"layout":"page","_id":"clchh4gwy0016cktt61wk9ec0","content":"<h6 id=\"Buffer-缓冲\"><a href=\"#Buffer-缓冲\" class=\"headerlink\" title=\"Buffer(缓冲)\"></a>Buffer(缓冲)</h6><p>ES6引入TypedArray???之前，JavaScript 语言没有读取或操作二进制数据流的机制。<br>Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>\n<p>TypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。</p>\n<p><em>Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’).Buffer。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个长度为 10、且用 0 填充的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.alloc(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.alloc(<span class=\"number\">10</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个长度为 10、且未初始化的 Buffer。</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法比调用 Buffer.alloc() 更快，</span></span><br><span class=\"line\"><span class=\"comment\">// 但返回的 Buffer 实例可能包含旧数据，</span></span><br><span class=\"line\"><span class=\"comment\">// 因此需要使用 fill() 或 write() 重写。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf3 = Buffer.allocUnsafe(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf4 = Buffer.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf5 = Buffer.from(<span class=\"string\">&#x27;tést&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf6 = Buffer.from(<span class=\"string\">&#x27;tést&#x27;</span>, <span class=\"string\">&#x27;latin1&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()</em><br>注意：nodejs v6之前，uffer 实例是通过 Buffer 构造函数创建的，它根据提供的参数返回不同的 Buffer</p>\n<ul>\n<li>nodejs 8.0.0之前分配给Buffer实例的内存是没有初始化的，且可能包含敏感数据；8.0.0之后，返回的是初始化内存之后的buffer</li>\n<li>传递一个字符串、数组 或 Buffer 作为第一个参数，会将所传对象的数据拷贝到Buffer中</li>\n<li>传入 ArrayBuffer 或 SharedArrayBuffer，则返回一个与传入的 ArrayBuffer 共享所分配内存的 Buffer</li>\n</ul>\n<p>出于安全性和可靠性考虑，new Buffer()构造函数已被废弃，由Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()方法代替</p>\n<ul>\n<li>Buffer.from(array) 返回<strong>一个新建的包含所提供的字节数组的副本</strong>的 Buffer。</li>\n<li>[Buffer.from(arrayBuffer[, byteOffset [, length]])]Buffer.from(arrayBuffer) 返回<strong>一个新建的与给定的 ArrayBuffer 共享同一内存</strong>的 Buffer。</li>\n<li>Buffer.from(buffer) 返回<strong>一个新建的包含所提供的 Buffer 的内容的副本</strong>的 Buffer。</li>\n<li>Buffer.from(string[, encoding]) 返回<strong>一个新建的包含所提供的字符串的副本</strong>的 Buffer。</li>\n<li>[Buffer.alloc(size[, fill[, encoding]])]Buffer.alloc() 返回<strong>一个指定大小的被填满的 Buffer 实例</strong>。 这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝<strong>不会包含旧的和潜在的敏感数据</strong>。</li>\n<li>Buffer.allocUnsafe(size) 与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。</li>\n</ul>\n<p><em>如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例<strong>可能</strong>会被分配进一个共享的内部内存池。</em></p>\n<p><em>–zero-fill-buffers命令行选项</em><br>强制所有新分配的buffer实例在<strong>创建时自动用0填充</strong><br>注意：使用这个选项会改变新建buffer实例方法的默认行为，对性能有明显的影响。建议只在需要强制新分配的 Buffer 实例不能包含潜在的敏感数据时才使用 –zero-fill-buffers 选项。</p>\n<p><em>buffer.allocUnsafe()和buffer.allocUnsafeSlow()不安全的原因</em><br>buffer.allocUnsafe()和buffer.allocUnsafeSlow()创建的buffer实例，被分配的内存段是**未初始化的(未用0填充)**，这样的设计使得内存的分配很快，但分配的内存可能含有潜在的敏感旧数据，从而给程序引入安全漏洞</p>\n<p><em>buffer与字符编码</em><br>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from(<span class=\"string\">&#x27;hello world&#x27;</span>, <span class=\"string\">&#x27;ascii&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf.toString(<span class=\"string\">&#x27;hex&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 输出 68656c6c6f20776f726c64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf.toString(<span class=\"string\">&#x27;base64&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 输出 aGVsbG8gd29ybGQ=</span></span><br></pre></td></tr></table></figure>\n\n<p>nodejs目前支持的字符编码</p>\n<ul>\n<li>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，编码非常快</li>\n<li>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8</li>\n<li>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）</li>\n<li>ucs2 - ‘utf16le’ 的别名</li>\n<li>base64 - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”</li>\n<li>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）</li>\n<li>binary - ‘latin1’ 的别名</li>\n<li>hex - 将每个字节编码为两个十六进制字符</li>\n</ul>\n<p><strong>注意</strong>：现代浏览器遵循 WHATWG 编码标准 将 ‘latin1’ 和 ISO-8859-1 别名为 win-1252。 这意味着当进行例如 http.get() 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 ‘latin1’ 字符编码可能会错误地解码数据</p>\n<p><em>Buffer 与 TypedArray</em><br>Buffer 实例也是 Uint8Array 实例<br>从一个 Buffer 创建一个新的 TypedArray 实例需要遵循的注意事项：</p>\n<ul>\n<li>Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的。</li>\n<li>Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。 也就是说，new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array，而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5000</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拷贝 `arr` 的内容</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与 `arr` 共享内存</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(arr.buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 a0&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 a0 0f&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2);</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">6000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 a0&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 70 17&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>注意，当使用 TypedArray 的 .buffer 创建 Buffer 时，也可以通过传入 byteOffset 和 length 参数只使用 ArrayBuffer 的一部分</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from(arr.buffer, <span class=\"number\">0</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: 16</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf.length);</span><br></pre></td></tr></table></figure>\n\n<p>Buffer 实例可以使用 ECMAScript 2015 (ES6) 的 for..of 语法进行遍历</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出:</span></span><br><span class=\"line\"><span class=\"comment\">//   1</span></span><br><span class=\"line\"><span class=\"comment\">//   2</span></span><br><span class=\"line\"><span class=\"comment\">//   3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> b <span class=\"keyword\">of</span> buf) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>buf.values() 、buf.keys() 和 buf.entries() 方法可用于创建迭代器</p>\n<p><em>Buffer类</em><br>Buffer 类是一个全局变量类型，用来直接处理二进制数据的。 它能够使用多种方式构建。</p>\n<p><strong>类方法：Buffer.allocUnsafe(size)</strong><br>分配一个大小为 size 字节的新建的 Buffer 。 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误。 如果 size 为 0，则创建一个长度为 0 的 Buffer。<br>以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.allocUnsafe(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br><span class=\"line\"><span class=\"comment\">// 输出: (内容可能不同): &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf.fill(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br></pre></td></tr></table></figure>\n<p>如果 size 不是一个数值，则抛出 TypeError 错误。</p>\n<p>注意，Buffer 模块会预分配一个大小为 Buffer.poolSize 的内部 Buffer 实例作为快速分配池， 用于使用 Buffer.allocUnsafe() 新创建的 Buffer 实例，以及废弃的 new Buffer(size) 构造器， 仅限于当 size 小于或等于 Buffer.poolSize &gt;&gt; 1 （Buffer.poolSize 除以2后的最大整数值）。</p>\n<p>对这个预分配的内部内存池的使用，是调用 Buffer.alloc(size, fill) 和 Buffer.allocUnsafe(size).fill(fill) 的关键区别。 <em>具体地说，Buffer.alloc(size, fill) 永远不会使用这个内部的 Buffer 池，但如果 size 小于或等于 Buffer.poolSize 的一半， Buffer.allocUnsafe(size).fill(fill) 会使用这个内部的 Buffer 池。 当应用程序需要 Buffer.allocUnsafe() 提供额外的性能时，这个细微的区别是非常重要的。</em></p>\n<p><strong>类方法：Buffer.allocUnsafeSlow(size)</strong><br>当使用 Buffer.allocUnsafe() 分配新建的 Buffer 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 Buffer 切割出来。 这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 Buffer 实例而过度使用。 这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。</p>\n<p>当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 Buffer.allocUnsafeSlow() 创建一个非池的 Buffer 实例然后拷贝出相关的位元是合适的做法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要保留一小块内存块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = [];</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">&#x27;readable&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = socket.read();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 为保留的数据分配内存</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> sb = Buffer.allocUnsafeSlow(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拷贝数据进新分配的内存</span></span><br><span class=\"line\">  data.copy(sb, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  store.push(sb);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><em>Buffer.allocUnsafeSlow() 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。</em></p>\n<p><strong>类方法：Buffer.byteLength(string[, encoding])</strong><br>返回一个字符串的实际字节长度。 这与 String.prototype.length 不同，因为那返回字符串的字符数。</p>\n<p>注意 对于 ‘base64’ 和 ‘hex’， 该函数假定有效的输入。 对于包含 non-Base64/Hex-encoded 数据的字符串 (e.g. 空格)， 返回值可能大于 从字符串中创建的 Buffer 的长度。</p>\n<p>当 string 是一个 Buffer/DataView/TypedArray/ArrayBuffer/SharedArrayBuffer 时，返回实际的字节长度。</p>\n<p><strong>类方法：Buffer.compare(buf1, buf2)</strong><br>比较 buf1 和 buf2 ，通常用于 Buffer 实例数组的排序。 相当于调用 buf1.compare(buf2) 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(<span class=\"string\">&#x27;1234&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(<span class=\"string\">&#x27;0123&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [buf1, buf2];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(Buffer.compare));</span><br><span class=\"line\"><span class=\"comment\">// 输出: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]</span></span><br><span class=\"line\"><span class=\"comment\">// (结果相当于: [buf2, buf1])</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.concat(list[, totalLength])</strong><br>返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。</p>\n<p>如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。</p>\n<p><em>如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。</em><br><em>如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.alloc(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.alloc(<span class=\"number\">14</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf3 = Buffer.alloc(<span class=\"number\">18</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> totalLength = buf1.length + buf2.length + buf3.length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(totalLength);</span><br><span class=\"line\"><span class=\"comment\">// 输出: 42</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bufA = Buffer.concat([buf1, buf2, buf3], totalLength);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bufA);</span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 00 00 00 00 ...&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bufA.length);</span><br><span class=\"line\"><span class=\"comment\">// 输出: 42</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.from(array)</strong><br>如果 array 不是一个数组，则抛出 TypeError 错误<br><strong>类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])</strong><br>arrayBuffer <ArrayBuffer> | <SharedArrayBuffer> ArrayBuffer 或 SharedArrayBuffer 或 TypedArray 的 .buffer 属性。<br>byteOffset <integer> 开始拷贝的索引。默认为 0。<br>length <integer> 拷贝的字节数。默认为 arrayBuffer.length - byteOffset。</integer></integer></SharedArrayBuffer></ArrayBuffer></p>\n<p>该方法将创建一个 ArrayBuffer 的视图，而不会复制底层内存。例如，当传入一个 TypedArray 实例的 .buffer 属性的引用时，这个新建的 Buffer 会像 TypedArray 那样共享同一分配的内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5000</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from(arr.buffer);</span><br><span class=\"line\"><span class=\"comment\">// 与 `arr` 共享内存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 a0 0f&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">6000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 改变原始的 Uint16Array 也会改变 Buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 70 17&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可选的 byteOffset 和 length 参数指定将与 Buffer 共享的 arrayBuffer 的内存范围</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ab = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buff = Buffer.from(ab, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buff.length);</span><br><span class=\"line\"><span class=\"comment\">// 输出: 2</span></span><br></pre></td></tr></table></figure>\n<p>如果 arrayBuffer 不是 ArrayBuffer 或 SharedArrayBuffer，则抛出 TypeError 错误</p>\n<p><strong>类方法：Buffer.from(buffer)</strong><br>将传入的 buffer 数据拷贝到一个新建的 Buffer 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(<span class=\"string\">&#x27;buffer&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(buf1);</span><br><span class=\"line\">buf1[<span class=\"number\">0</span>] = <span class=\"number\">0x61</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: auffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: buffer</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.from(string[, encoding])</strong><br>新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(<span class=\"string\">&#x27;this is a tést&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: this is a tést</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1.toString(<span class=\"string\">&#x27;ascii&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 输出: this is a tC)st</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(<span class=\"string\">&#x27;7468697320697320612074c3a97374&#x27;</span>, <span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: this is a tést</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Class Method: Buffer.from(object[, offsetOrEncoding[, length]])</strong><br>object <Object> 一个支持 Symbol.toPrimitive 或 valueOf() 的对象<br>offsetOrEncoding <number> | <string> 字节偏移量或编码，取决于 object.valueOf() 或 object<a href>Symbol.toPrimitive</a> 的返回值。<br>length <number> 长度值，取决于 object.valueOf() 或 object<a href>Symbol.toPrimitive</a> 的返回值。<br>那些其 valueOf() 方法返回值如果不严格等于 object 的对象，返回Buffer.from(object.valueOf(), offsetOrEncoding, length)。</number></string></number></Object></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from(new String(&#x27;this is a test&#x27;));</span><br><span class=\"line\">// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</span><br></pre></td></tr></table></figure>\n<p>那些支持 Symbol.toPrimitive 的对象， 返回 Buffer.from(object<a href>Symbol.toPrimitive</a>, offsetOrEncoding, length)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">  [Symbol.toPrimitive]() &#123;</span><br><span class=\"line\">    return &#x27;this is a test&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const buf = Buffer.from(new Foo(), &#x27;utf8&#x27;);</span><br><span class=\"line\">// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.isBuffer(obj)</strong><br>如果 obj 是一个 Buffer 则返回 true ，否则返回 false<br><strong>类方法：Buffer.isEncoding(encoding)</strong><br>如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。<br><strong>类属性：Buffer.poolSize</strong><br>这是用于决定预分配的、内部 Buffer 实例池的大小的字节数。 这个值可以修改。默认值：8192</p>\n<p><strong>buf[index]</strong><br>索引操作符 [index] 可用于获取或设置 buf 中指定 index 位置的八位字节。 这个值指向的是单个字节，所以合法的值范围是的 0x00 至 0xFF（十六进制），或 0 至 255（十进制）。</p>\n<p>该操作符继承自 Uint8Array，所以它对越界访问的处理与 UInt8Array 相同（也就是说，获取时返回 undefined，设置时什么也不做）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &#x27;Node.js&#x27;;</span><br><span class=\"line\">const buf = Buffer.allocUnsafe(str.length);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class=\"line\">  buf[i] = str.charCodeAt(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.toString(&#x27;ascii&#x27;));</span><br><span class=\"line\">// 输出: Node.js</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.buffer</strong><br>buffer 属性指向创建该 Buffer 的底层的 ArrayBuffer 对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arrayBuffer = new ArrayBuffer(16);</span><br><span class=\"line\">const buffer = Buffer.from(arrayBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buffer.buffer === arrayBuffer);</span><br><span class=\"line\">// 输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</strong><br>target <Buffer> | <Uint8Array> 要比较的 Buffer 或 Uint8Array。<br>targetStart <integer> target 中开始对比的偏移量。 默认: 0<br>targetEnd <integer> target 中结束对比的偏移量（不包含）。 默认: target.length<br>sourceStart <integer> buf 中开始对比的偏移量。 默认: 0<br>sourceEnd <integer> buf 中结束对比的偏移量（不包含）。 默认: buf.length<br>返回: <integer><br>比较 buf 与 target，返回表明 buf 在排序上是否排在 target 之前、或之后、或相同。 对比是基于各自 Buffer 实际的字节序列。</integer></integer></integer></integer></integer></Uint8Array></Buffer></p>\n<p>如果 target 与 buf 相同，则返回 0 。<br>如果 target 排在 buf 前面，则返回 1 。<br>如果 target 排在 buf 后面，则返回 -1 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from(&#x27;ABC&#x27;);</span><br><span class=\"line\">const buf2 = Buffer.from(&#x27;BCD&#x27;);</span><br><span class=\"line\">const buf3 = Buffer.from(&#x27;ABCD&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf1));</span><br><span class=\"line\">// 输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2));</span><br><span class=\"line\">// 输出: -1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf3));</span><br><span class=\"line\">// 输出: -1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.compare(buf1));</span><br><span class=\"line\">// 输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.compare(buf3));</span><br><span class=\"line\">// 输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([buf1, buf2, buf3].sort(Buffer.compare));</span><br><span class=\"line\">// 输出: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]</span><br><span class=\"line\">// (结果相当于: [buf1, buf3, buf2])</span><br></pre></td></tr></table></figure>\n<p>可选的 targetStart 、 targetEnd 、 sourceStart 与 sourceEnd 参数可用于分别在 target 与 buf 中限制对比在指定的范围内。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);</span><br><span class=\"line\">const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2, 5, 9, 0, 4));</span><br><span class=\"line\">// 输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2, 0, 6, 4));</span><br><span class=\"line\">// 输出: -1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2, 5, 6, 5));</span><br><span class=\"line\">// 输出: 1</span><br></pre></td></tr></table></figure>\n<p>如果 targetStart &lt; 0 、 sourceStart &lt; 0 、 targetEnd &gt; target.byteLength 或 sourceEnd &gt; source.byteLength，则抛出 RangeError 错误。</p>\n<p><strong>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</strong><br>target <Buffer> | <Uint8Array> 要拷贝进的 Buffer 或 Uint8Array。<br>targetStart <integer> target 中开始拷贝进的偏移量。 默认: 0<br>sourceStart <integer> buf 中开始拷贝的偏移量。 默认: 0<br>sourceEnd <integer> buf 中结束拷贝的偏移量（不包含）。 默认: buf.length<br>返回: <integer> 被拷贝的字节数。<br>拷贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠。</integer></integer></integer></integer></Uint8Array></Buffer></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.allocUnsafe(26);</span><br><span class=\"line\">const buf2 = Buffer.allocUnsafe(26).fill(&#x27;!&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; 26; i++) &#123;</span><br><span class=\"line\">  // 97 是 &#x27;a&#x27; 的十进制 ASCII 值</span><br><span class=\"line\">  buf1[i] = i + 97;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">buf1.copy(buf2, 8, 16, 20);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.toString(&#x27;ascii&#x27;, 0, 25));</span><br><span class=\"line\">// 输出: !!!!!!!!qrst!!!!!!!!!!!!!</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个 Buffer ，并拷贝同一 Buffer 中一个区域的数据到另一个重叠的区域。</span><br><span class=\"line\">const buf = Buffer.allocUnsafe(26);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; 26; i++) &#123;</span><br><span class=\"line\">  // 97 是 &#x27;a&#x27; 的十进制 ASCII 值</span><br><span class=\"line\">  buf[i] = i + 97;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">buf.copy(buf, 0, 4, 10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.toString());</span><br><span class=\"line\">// 输出: efghijghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"Buffer-缓冲\"><a href=\"#Buffer-缓冲\" class=\"headerlink\" title=\"Buffer(缓冲)\"></a>Buffer(缓冲)</h6><p>ES6引入TypedArray???之前，JavaScript 语言没有读取或操作二进制数据流的机制。<br>Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>\n<p>TypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。</p>\n<p><em>Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’).Buffer。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个长度为 10、且用 0 填充的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.alloc(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.alloc(<span class=\"number\">10</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个长度为 10、且未初始化的 Buffer。</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法比调用 Buffer.alloc() 更快，</span></span><br><span class=\"line\"><span class=\"comment\">// 但返回的 Buffer 实例可能包含旧数据，</span></span><br><span class=\"line\"><span class=\"comment\">// 因此需要使用 fill() 或 write() 重写。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf3 = Buffer.allocUnsafe(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf4 = Buffer.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf5 = Buffer.from(<span class=\"string\">&#x27;tést&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf6 = Buffer.from(<span class=\"string\">&#x27;tést&#x27;</span>, <span class=\"string\">&#x27;latin1&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()</em><br>注意：nodejs v6之前，uffer 实例是通过 Buffer 构造函数创建的，它根据提供的参数返回不同的 Buffer</p>\n<ul>\n<li>nodejs 8.0.0之前分配给Buffer实例的内存是没有初始化的，且可能包含敏感数据；8.0.0之后，返回的是初始化内存之后的buffer</li>\n<li>传递一个字符串、数组 或 Buffer 作为第一个参数，会将所传对象的数据拷贝到Buffer中</li>\n<li>传入 ArrayBuffer 或 SharedArrayBuffer，则返回一个与传入的 ArrayBuffer 共享所分配内存的 Buffer</li>\n</ul>\n<p>出于安全性和可靠性考虑，new Buffer()构造函数已被废弃，由Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()方法代替</p>\n<ul>\n<li>Buffer.from(array) 返回<strong>一个新建的包含所提供的字节数组的副本</strong>的 Buffer。</li>\n<li>[Buffer.from(arrayBuffer[, byteOffset [, length]])]Buffer.from(arrayBuffer) 返回<strong>一个新建的与给定的 ArrayBuffer 共享同一内存</strong>的 Buffer。</li>\n<li>Buffer.from(buffer) 返回<strong>一个新建的包含所提供的 Buffer 的内容的副本</strong>的 Buffer。</li>\n<li>Buffer.from(string[, encoding]) 返回<strong>一个新建的包含所提供的字符串的副本</strong>的 Buffer。</li>\n<li>[Buffer.alloc(size[, fill[, encoding]])]Buffer.alloc() 返回<strong>一个指定大小的被填满的 Buffer 实例</strong>。 这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝<strong>不会包含旧的和潜在的敏感数据</strong>。</li>\n<li>Buffer.allocUnsafe(size) 与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。</li>\n</ul>\n<p><em>如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例<strong>可能</strong>会被分配进一个共享的内部内存池。</em></p>\n<p><em>–zero-fill-buffers命令行选项</em><br>强制所有新分配的buffer实例在<strong>创建时自动用0填充</strong><br>注意：使用这个选项会改变新建buffer实例方法的默认行为，对性能有明显的影响。建议只在需要强制新分配的 Buffer 实例不能包含潜在的敏感数据时才使用 –zero-fill-buffers 选项。</p>\n<p><em>buffer.allocUnsafe()和buffer.allocUnsafeSlow()不安全的原因</em><br>buffer.allocUnsafe()和buffer.allocUnsafeSlow()创建的buffer实例，被分配的内存段是**未初始化的(未用0填充)**，这样的设计使得内存的分配很快，但分配的内存可能含有潜在的敏感旧数据，从而给程序引入安全漏洞</p>\n<p><em>buffer与字符编码</em><br>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from(<span class=\"string\">&#x27;hello world&#x27;</span>, <span class=\"string\">&#x27;ascii&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf.toString(<span class=\"string\">&#x27;hex&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 输出 68656c6c6f20776f726c64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf.toString(<span class=\"string\">&#x27;base64&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 输出 aGVsbG8gd29ybGQ=</span></span><br></pre></td></tr></table></figure>\n\n<p>nodejs目前支持的字符编码</p>\n<ul>\n<li>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，编码非常快</li>\n<li>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8</li>\n<li>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）</li>\n<li>ucs2 - ‘utf16le’ 的别名</li>\n<li>base64 - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表”</li>\n<li>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）</li>\n<li>binary - ‘latin1’ 的别名</li>\n<li>hex - 将每个字节编码为两个十六进制字符</li>\n</ul>\n<p><strong>注意</strong>：现代浏览器遵循 WHATWG 编码标准 将 ‘latin1’ 和 ISO-8859-1 别名为 win-1252。 这意味着当进行例如 http.get() 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 ‘latin1’ 字符编码可能会错误地解码数据</p>\n<p><em>Buffer 与 TypedArray</em><br>Buffer 实例也是 Uint8Array 实例<br>从一个 Buffer 创建一个新的 TypedArray 实例需要遵循的注意事项：</p>\n<ul>\n<li>Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的。</li>\n<li>Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。 也就是说，new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array，而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5000</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拷贝 `arr` 的内容</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与 `arr` 共享内存</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(arr.buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 a0&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 a0 0f&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2);</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">6000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 a0&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 70 17&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><em>注意，当使用 TypedArray 的 .buffer 创建 Buffer 时，也可以通过传入 byteOffset 和 length 参数只使用 ArrayBuffer 的一部分</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from(arr.buffer, <span class=\"number\">0</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: 16</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf.length);</span><br></pre></td></tr></table></figure>\n\n<p>Buffer 实例可以使用 ECMAScript 2015 (ES6) 的 for..of 语法进行遍历</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出:</span></span><br><span class=\"line\"><span class=\"comment\">//   1</span></span><br><span class=\"line\"><span class=\"comment\">//   2</span></span><br><span class=\"line\"><span class=\"comment\">//   3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> b <span class=\"keyword\">of</span> buf) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>buf.values() 、buf.keys() 和 buf.entries() 方法可用于创建迭代器</p>\n<p><em>Buffer类</em><br>Buffer 类是一个全局变量类型，用来直接处理二进制数据的。 它能够使用多种方式构建。</p>\n<p><strong>类方法：Buffer.allocUnsafe(size)</strong><br>分配一个大小为 size 字节的新建的 Buffer 。 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误。 如果 size 为 0，则创建一个长度为 0 的 Buffer。<br>以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.allocUnsafe(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br><span class=\"line\"><span class=\"comment\">// 输出: (内容可能不同): &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf.fill(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br></pre></td></tr></table></figure>\n<p>如果 size 不是一个数值，则抛出 TypeError 错误。</p>\n<p>注意，Buffer 模块会预分配一个大小为 Buffer.poolSize 的内部 Buffer 实例作为快速分配池， 用于使用 Buffer.allocUnsafe() 新创建的 Buffer 实例，以及废弃的 new Buffer(size) 构造器， 仅限于当 size 小于或等于 Buffer.poolSize &gt;&gt; 1 （Buffer.poolSize 除以2后的最大整数值）。</p>\n<p>对这个预分配的内部内存池的使用，是调用 Buffer.alloc(size, fill) 和 Buffer.allocUnsafe(size).fill(fill) 的关键区别。 <em>具体地说，Buffer.alloc(size, fill) 永远不会使用这个内部的 Buffer 池，但如果 size 小于或等于 Buffer.poolSize 的一半， Buffer.allocUnsafe(size).fill(fill) 会使用这个内部的 Buffer 池。 当应用程序需要 Buffer.allocUnsafe() 提供额外的性能时，这个细微的区别是非常重要的。</em></p>\n<p><strong>类方法：Buffer.allocUnsafeSlow(size)</strong><br>当使用 Buffer.allocUnsafe() 分配新建的 Buffer 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 Buffer 切割出来。 这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 Buffer 实例而过度使用。 这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。</p>\n<p>当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 Buffer.allocUnsafeSlow() 创建一个非池的 Buffer 实例然后拷贝出相关的位元是合适的做法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要保留一小块内存块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = [];</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">&#x27;readable&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = socket.read();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 为保留的数据分配内存</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> sb = Buffer.allocUnsafeSlow(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拷贝数据进新分配的内存</span></span><br><span class=\"line\">  data.copy(sb, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  store.push(sb);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><em>Buffer.allocUnsafeSlow() 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。</em></p>\n<p><strong>类方法：Buffer.byteLength(string[, encoding])</strong><br>返回一个字符串的实际字节长度。 这与 String.prototype.length 不同，因为那返回字符串的字符数。</p>\n<p>注意 对于 ‘base64’ 和 ‘hex’， 该函数假定有效的输入。 对于包含 non-Base64/Hex-encoded 数据的字符串 (e.g. 空格)， 返回值可能大于 从字符串中创建的 Buffer 的长度。</p>\n<p>当 string 是一个 Buffer/DataView/TypedArray/ArrayBuffer/SharedArrayBuffer 时，返回实际的字节长度。</p>\n<p><strong>类方法：Buffer.compare(buf1, buf2)</strong><br>比较 buf1 和 buf2 ，通常用于 Buffer 实例数组的排序。 相当于调用 buf1.compare(buf2) 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(<span class=\"string\">&#x27;1234&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(<span class=\"string\">&#x27;0123&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [buf1, buf2];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(Buffer.compare));</span><br><span class=\"line\"><span class=\"comment\">// 输出: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]</span></span><br><span class=\"line\"><span class=\"comment\">// (结果相当于: [buf2, buf1])</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.concat(list[, totalLength])</strong><br>返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。</p>\n<p>如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。</p>\n<p><em>如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。</em><br><em>如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.alloc(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.alloc(<span class=\"number\">14</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf3 = Buffer.alloc(<span class=\"number\">18</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> totalLength = buf1.length + buf2.length + buf3.length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(totalLength);</span><br><span class=\"line\"><span class=\"comment\">// 输出: 42</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bufA = Buffer.concat([buf1, buf2, buf3], totalLength);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bufA);</span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 00 00 00 00 ...&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bufA.length);</span><br><span class=\"line\"><span class=\"comment\">// 输出: 42</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.from(array)</strong><br>如果 array 不是一个数组，则抛出 TypeError 错误<br><strong>类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])</strong><br>arrayBuffer <ArrayBuffer> | <SharedArrayBuffer> ArrayBuffer 或 SharedArrayBuffer 或 TypedArray 的 .buffer 属性。<br>byteOffset <integer> 开始拷贝的索引。默认为 0。<br>length <integer> 拷贝的字节数。默认为 arrayBuffer.length - byteOffset。</integer></integer></SharedArrayBuffer></ArrayBuffer></p>\n<p>该方法将创建一个 ArrayBuffer 的视图，而不会复制底层内存。例如，当传入一个 TypedArray 实例的 .buffer 属性的引用时，这个新建的 Buffer 会像 TypedArray 那样共享同一分配的内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5000</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf = Buffer.from(arr.buffer);</span><br><span class=\"line\"><span class=\"comment\">// 与 `arr` 共享内存</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 a0 0f&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">6000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 改变原始的 Uint16Array 也会改变 Buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf);</span><br><span class=\"line\"><span class=\"comment\">// 输出: &lt;Buffer 88 13 70 17&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可选的 byteOffset 和 length 参数指定将与 Buffer 共享的 arrayBuffer 的内存范围</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ab = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buff = Buffer.from(ab, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buff.length);</span><br><span class=\"line\"><span class=\"comment\">// 输出: 2</span></span><br></pre></td></tr></table></figure>\n<p>如果 arrayBuffer 不是 ArrayBuffer 或 SharedArrayBuffer，则抛出 TypeError 错误</p>\n<p><strong>类方法：Buffer.from(buffer)</strong><br>将传入的 buffer 数据拷贝到一个新建的 Buffer 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(<span class=\"string\">&#x27;buffer&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(buf1);</span><br><span class=\"line\">buf1[<span class=\"number\">0</span>] = <span class=\"number\">0x61</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: auffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: buffer</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.from(string[, encoding])</strong><br>新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.from(<span class=\"string\">&#x27;this is a tést&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: this is a tést</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf1.toString(<span class=\"string\">&#x27;ascii&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 输出: this is a tC)st</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(<span class=\"string\">&#x27;7468697320697320612074c3a97374&#x27;</span>, <span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buf2.toString());</span><br><span class=\"line\"><span class=\"comment\">// 输出: this is a tést</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Class Method: Buffer.from(object[, offsetOrEncoding[, length]])</strong><br>object <Object> 一个支持 Symbol.toPrimitive 或 valueOf() 的对象<br>offsetOrEncoding <number> | <string> 字节偏移量或编码，取决于 object.valueOf() 或 object<a href>Symbol.toPrimitive</a> 的返回值。<br>length <number> 长度值，取决于 object.valueOf() 或 object<a href>Symbol.toPrimitive</a> 的返回值。<br>那些其 valueOf() 方法返回值如果不严格等于 object 的对象，返回Buffer.from(object.valueOf(), offsetOrEncoding, length)。</number></string></number></Object></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf = Buffer.from(new String(&#x27;this is a test&#x27;));</span><br><span class=\"line\">// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</span><br></pre></td></tr></table></figure>\n<p>那些支持 Symbol.toPrimitive 的对象， 返回 Buffer.from(object<a href>Symbol.toPrimitive</a>, offsetOrEncoding, length)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">  [Symbol.toPrimitive]() &#123;</span><br><span class=\"line\">    return &#x27;this is a test&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const buf = Buffer.from(new Foo(), &#x27;utf8&#x27;);</span><br><span class=\"line\">// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>类方法：Buffer.isBuffer(obj)</strong><br>如果 obj 是一个 Buffer 则返回 true ，否则返回 false<br><strong>类方法：Buffer.isEncoding(encoding)</strong><br>如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。<br><strong>类属性：Buffer.poolSize</strong><br>这是用于决定预分配的、内部 Buffer 实例池的大小的字节数。 这个值可以修改。默认值：8192</p>\n<p><strong>buf[index]</strong><br>索引操作符 [index] 可用于获取或设置 buf 中指定 index 位置的八位字节。 这个值指向的是单个字节，所以合法的值范围是的 0x00 至 0xFF（十六进制），或 0 至 255（十进制）。</p>\n<p>该操作符继承自 Uint8Array，所以它对越界访问的处理与 UInt8Array 相同（也就是说，获取时返回 undefined，设置时什么也不做）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &#x27;Node.js&#x27;;</span><br><span class=\"line\">const buf = Buffer.allocUnsafe(str.length);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class=\"line\">  buf[i] = str.charCodeAt(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.toString(&#x27;ascii&#x27;));</span><br><span class=\"line\">// 输出: Node.js</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.buffer</strong><br>buffer 属性指向创建该 Buffer 的底层的 ArrayBuffer 对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arrayBuffer = new ArrayBuffer(16);</span><br><span class=\"line\">const buffer = Buffer.from(arrayBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buffer.buffer === arrayBuffer);</span><br><span class=\"line\">// 输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</strong><br>target <Buffer> | <Uint8Array> 要比较的 Buffer 或 Uint8Array。<br>targetStart <integer> target 中开始对比的偏移量。 默认: 0<br>targetEnd <integer> target 中结束对比的偏移量（不包含）。 默认: target.length<br>sourceStart <integer> buf 中开始对比的偏移量。 默认: 0<br>sourceEnd <integer> buf 中结束对比的偏移量（不包含）。 默认: buf.length<br>返回: <integer><br>比较 buf 与 target，返回表明 buf 在排序上是否排在 target 之前、或之后、或相同。 对比是基于各自 Buffer 实际的字节序列。</integer></integer></integer></integer></integer></Uint8Array></Buffer></p>\n<p>如果 target 与 buf 相同，则返回 0 。<br>如果 target 排在 buf 前面，则返回 1 。<br>如果 target 排在 buf 后面，则返回 -1 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from(&#x27;ABC&#x27;);</span><br><span class=\"line\">const buf2 = Buffer.from(&#x27;BCD&#x27;);</span><br><span class=\"line\">const buf3 = Buffer.from(&#x27;ABCD&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf1));</span><br><span class=\"line\">// 输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2));</span><br><span class=\"line\">// 输出: -1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf3));</span><br><span class=\"line\">// 输出: -1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.compare(buf1));</span><br><span class=\"line\">// 输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.compare(buf3));</span><br><span class=\"line\">// 输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([buf1, buf2, buf3].sort(Buffer.compare));</span><br><span class=\"line\">// 输出: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]</span><br><span class=\"line\">// (结果相当于: [buf1, buf3, buf2])</span><br></pre></td></tr></table></figure>\n<p>可选的 targetStart 、 targetEnd 、 sourceStart 与 sourceEnd 参数可用于分别在 target 与 buf 中限制对比在指定的范围内。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);</span><br><span class=\"line\">const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2, 5, 9, 0, 4));</span><br><span class=\"line\">// 输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2, 0, 6, 4));</span><br><span class=\"line\">// 输出: -1</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf1.compare(buf2, 5, 6, 5));</span><br><span class=\"line\">// 输出: 1</span><br></pre></td></tr></table></figure>\n<p>如果 targetStart &lt; 0 、 sourceStart &lt; 0 、 targetEnd &gt; target.byteLength 或 sourceEnd &gt; source.byteLength，则抛出 RangeError 错误。</p>\n<p><strong>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</strong><br>target <Buffer> | <Uint8Array> 要拷贝进的 Buffer 或 Uint8Array。<br>targetStart <integer> target 中开始拷贝进的偏移量。 默认: 0<br>sourceStart <integer> buf 中开始拷贝的偏移量。 默认: 0<br>sourceEnd <integer> buf 中结束拷贝的偏移量（不包含）。 默认: buf.length<br>返回: <integer> 被拷贝的字节数。<br>拷贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠。</integer></integer></integer></integer></Uint8Array></Buffer></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const buf1 = Buffer.allocUnsafe(26);</span><br><span class=\"line\">const buf2 = Buffer.allocUnsafe(26).fill(&#x27;!&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; 26; i++) &#123;</span><br><span class=\"line\">  // 97 是 &#x27;a&#x27; 的十进制 ASCII 值</span><br><span class=\"line\">  buf1[i] = i + 97;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">buf1.copy(buf2, 8, 16, 20);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf2.toString(&#x27;ascii&#x27;, 0, 25));</span><br><span class=\"line\">// 输出: !!!!!!!!qrst!!!!!!!!!!!!!</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个 Buffer ，并拷贝同一 Buffer 中一个区域的数据到另一个重叠的区域。</span><br><span class=\"line\">const buf = Buffer.allocUnsafe(26);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; 26; i++) &#123;</span><br><span class=\"line\">  // 97 是 &#x27;a&#x27; 的十进制 ASCII 值</span><br><span class=\"line\">  buf[i] = i + 97;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">buf.copy(buf, 0, 4, 10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(buf.toString());</span><br><span class=\"line\">// 输出: efghijghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>\n"},{"_content":"// console(控制台)\n// const fs = require('fs');\n// const { Console } = require('console');\n// const output = fs.createWriteStream('./stdout.log');\n// const errorOutput = fs.createWriteStream('./stderr.log');\n// // 自定义的简单记录器\n// const logger = new Console(output, errorOutput);\n// // 像 console 一样使用\n// // const count = 5;\n// // logger.log('count: %d', count);\n// // // stdout.log 中打印: count 5\n// // logger.error(new Error(`error: ${count}`));\n// // logger.warn('test warn');\n\n// console.assert(true, 'does nothing');\n// // 通过\n// console.assert(false, 'Whoops %s', \"didn't work\");\n// Assertion failed: Whoops didn't work\n\n// const crypto = require('crypto');\n\n// const secret = 'abcdefg';\n// const hash = crypto\n//   .createHmac('sha256', secret)\n//   .update('I love cupcakes')\n//   .digest('hex');\n// console.log(hash);\n// c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n\n// const cert = require('crypto').Certificate();\n// const spkac = getSpkacSomehow();\n// const challenge = cert.exportChallenge(spkac);\n// console.log(challenge.toString('utf8'));\n\n// const crypto = require('crypto');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// let encrypted = '';\n// cipher.on('readable', () => {\n//   const data = cipher.read();\n//   if (data) encrypted += data.toString('hex');\n// });\n// cipher.on('end', () => {\n//   console.log(encrypted);\n//   // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n// });\n\n// cipher.write('some clear text data');\n// cipher.end();\n\n// const crypto = require('crypto');\n// const fs = require('fs');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// const input = fs.createReadStream('test.js');\n// const output = fs.createWriteStream('test.enc');\n\n// input.pipe(cipher).pipe(output);\n\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = cipher.update('some clear text data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n","source":"nodejs/file/test.js","raw":"// console(控制台)\n// const fs = require('fs');\n// const { Console } = require('console');\n// const output = fs.createWriteStream('./stdout.log');\n// const errorOutput = fs.createWriteStream('./stderr.log');\n// // 自定义的简单记录器\n// const logger = new Console(output, errorOutput);\n// // 像 console 一样使用\n// // const count = 5;\n// // logger.log('count: %d', count);\n// // // stdout.log 中打印: count 5\n// // logger.error(new Error(`error: ${count}`));\n// // logger.warn('test warn');\n\n// console.assert(true, 'does nothing');\n// // 通过\n// console.assert(false, 'Whoops %s', \"didn't work\");\n// Assertion failed: Whoops didn't work\n\n// const crypto = require('crypto');\n\n// const secret = 'abcdefg';\n// const hash = crypto\n//   .createHmac('sha256', secret)\n//   .update('I love cupcakes')\n//   .digest('hex');\n// console.log(hash);\n// c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n\n// const cert = require('crypto').Certificate();\n// const spkac = getSpkacSomehow();\n// const challenge = cert.exportChallenge(spkac);\n// console.log(challenge.toString('utf8'));\n\n// const crypto = require('crypto');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// let encrypted = '';\n// cipher.on('readable', () => {\n//   const data = cipher.read();\n//   if (data) encrypted += data.toString('hex');\n// });\n// cipher.on('end', () => {\n//   console.log(encrypted);\n//   // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n// });\n\n// cipher.write('some clear text data');\n// cipher.end();\n\n// const crypto = require('crypto');\n// const fs = require('fs');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// const input = fs.createReadStream('test.js');\n// const output = fs.createWriteStream('test.enc');\n\n// input.pipe(cipher).pipe(output);\n\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = cipher.update('some clear text data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n","date":"2023-01-04T09:17:09.617Z","updated":"2023-01-04T09:17:09.617Z","path":"nodejs/file/test.js","layout":"false","title":"","comments":1,"_id":"clchh4gwz0018ckttfanygbgb","content":"// console(控制台)\n// const fs = require('fs');\n// const { Console } = require('console');\n// const output = fs.createWriteStream('./stdout.log');\n// const errorOutput = fs.createWriteStream('./stderr.log');\n// // 自定义的简单记录器\n// const logger = new Console(output, errorOutput);\n// // 像 console 一样使用\n// // const count = 5;\n// // logger.log('count: %d', count);\n// // // stdout.log 中打印: count 5\n// // logger.error(new Error(`error: ${count}`));\n// // logger.warn('test warn');\n\n// console.assert(true, 'does nothing');\n// // 通过\n// console.assert(false, 'Whoops %s', \"didn't work\");\n// Assertion failed: Whoops didn't work\n\n// const crypto = require('crypto');\n\n// const secret = 'abcdefg';\n// const hash = crypto\n//   .createHmac('sha256', secret)\n//   .update('I love cupcakes')\n//   .digest('hex');\n// console.log(hash);\n// c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n\n// const cert = require('crypto').Certificate();\n// const spkac = getSpkacSomehow();\n// const challenge = cert.exportChallenge(spkac);\n// console.log(challenge.toString('utf8'));\n\n// const crypto = require('crypto');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// let encrypted = '';\n// cipher.on('readable', () => {\n//   const data = cipher.read();\n//   if (data) encrypted += data.toString('hex');\n// });\n// cipher.on('end', () => {\n//   console.log(encrypted);\n//   // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n// });\n\n// cipher.write('some clear text data');\n// cipher.end();\n\n// const crypto = require('crypto');\n// const fs = require('fs');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// const input = fs.createReadStream('test.js');\n// const output = fs.createWriteStream('test.enc');\n\n// input.pipe(cipher).pipe(output);\n\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = cipher.update('some clear text data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n","site":{"data":{}},"excerpt":"","more":"// console(控制台)\n// const fs = require('fs');\n// const { Console } = require('console');\n// const output = fs.createWriteStream('./stdout.log');\n// const errorOutput = fs.createWriteStream('./stderr.log');\n// // 自定义的简单记录器\n// const logger = new Console(output, errorOutput);\n// // 像 console 一样使用\n// // const count = 5;\n// // logger.log('count: %d', count);\n// // // stdout.log 中打印: count 5\n// // logger.error(new Error(`error: ${count}`));\n// // logger.warn('test warn');\n\n// console.assert(true, 'does nothing');\n// // 通过\n// console.assert(false, 'Whoops %s', \"didn't work\");\n// Assertion failed: Whoops didn't work\n\n// const crypto = require('crypto');\n\n// const secret = 'abcdefg';\n// const hash = crypto\n//   .createHmac('sha256', secret)\n//   .update('I love cupcakes')\n//   .digest('hex');\n// console.log(hash);\n// c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n\n// const cert = require('crypto').Certificate();\n// const spkac = getSpkacSomehow();\n// const challenge = cert.exportChallenge(spkac);\n// console.log(challenge.toString('utf8'));\n\n// const crypto = require('crypto');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// let encrypted = '';\n// cipher.on('readable', () => {\n//   const data = cipher.read();\n//   if (data) encrypted += data.toString('hex');\n// });\n// cipher.on('end', () => {\n//   console.log(encrypted);\n//   // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n// });\n\n// cipher.write('some clear text data');\n// cipher.end();\n\n// const crypto = require('crypto');\n// const fs = require('fs');\n// const cipher = crypto.createCipher('aes192', 'a password');\n\n// const input = fs.createReadStream('test.js');\n// const output = fs.createWriteStream('test.enc');\n\n// input.pipe(cipher).pipe(output);\n\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes192', 'a password');\n\nlet encrypted = cipher.update('some clear text data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n"}],"Post":[{"title":"github生成令牌(Personal_access_tokens)操作步骤","date":"2022-06-30T03:23:56.000Z","_content":"\n#### github生成令牌\n(1)登录[GitHub网站](https://github.com/)\n(2)找到setting页面 -> Developer setting\n(3)选择 Personal access tokens ，点击 Generate new token 按钮\n(4)需要填写token的权限范围\n(5)**<font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font>**","source":"_posts/12-create-github-tokens.md","raw":"---\ntitle: github生成令牌(Personal_access_tokens)操作步骤\ndate: 2022-06-30 11:23:56\ntags:\n---\n\n#### github生成令牌\n(1)登录[GitHub网站](https://github.com/)\n(2)找到setting页面 -> Developer setting\n(3)选择 Personal access tokens ，点击 Generate new token 按钮\n(4)需要填写token的权限范围\n(5)**<font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font>**","slug":"12-create-github-tokens","published":1,"updated":"2022-06-30T05:18:19.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwc0001ckttdakgd6cw","content":"<h4 id=\"github生成令牌\"><a href=\"#github生成令牌\" class=\"headerlink\" title=\"github生成令牌\"></a>github生成令牌</h4><p>(1)登录<a href=\"https://github.com/\">GitHub网站</a><br>(2)找到setting页面 -&gt; Developer setting<br>(3)选择 Personal access tokens ，点击 Generate new token 按钮<br>(4)需要填写token的权限范围<br>(5)<strong><font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"github生成令牌\"><a href=\"#github生成令牌\" class=\"headerlink\" title=\"github生成令牌\"></a>github生成令牌</h4><p>(1)登录<a href=\"https://github.com/\">GitHub网站</a><br>(2)找到setting页面 -&gt; Developer setting<br>(3)选择 Personal access tokens ，点击 Generate new token 按钮<br>(4)需要填写token的权限范围<br>(5)<strong><font color=\"Red\">注意：生成的token只在生成后可以看一次，一定要记得保存！！！</font></strong></p>\n"},{"title":"github推送代码弹窗应该怎么输入？","date":"2022-06-30T02:45:15.000Z","_content":"\n#### github推送代码弹窗应该怎么输入?\n\n当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，\n鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。\n\n(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。\n```javascript\ngit push\n```\n---- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试\n```javascript\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': Failed to connect to github.com port 443: Timed out\n\n// --------\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': OpenSSL SSL_read: Connection was aborted, errno 10053\n```\n(2)第一个GitHub登录弹窗\n![github_login]()\n该弹窗中 **username为github的登录邮箱，password为GitHub的登录密码**\n---- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败\n```javascript\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n```\n(3)第二个登录弹窗\n![login_insert]\n该弹窗会出现两次，第一次输入username，第二次输入password，**username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章[github生成令牌](/2022/06/30/github生成令牌-Personal-access-tokens-操作步骤/))</font>**\n---- 注意：如果password输入错误，会导致无法提交\n```javascript\n$ git push\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\nfatal: Authentication failed for 'https://github.com/xxxxxxx.git/'\n```\n\n当username和password输入完成后，就可以正常push代码啦","source":"_posts/11-github-push-insert-password.md","raw":"---\ntitle: github推送代码弹窗应该怎么输入？\ndate: 2022-06-30 10:45:15\ntags:\n---\n\n#### github推送代码弹窗应该怎么输入?\n\n当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，\n鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。\n\n(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。\n```javascript\ngit push\n```\n---- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试\n```javascript\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': Failed to connect to github.com port 443: Timed out\n\n// --------\n$ git push\nfatal: unable to access 'https://github.com/sunjinkang/test_vue3_sql.git/': OpenSSL SSL_read: Connection was aborted, errno 10053\n```\n(2)第一个GitHub登录弹窗\n![github_login]()\n该弹窗中 **username为github的登录邮箱，password为GitHub的登录密码**\n---- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败\n```javascript\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n```\n(3)第二个登录弹窗\n![login_insert]\n该弹窗会出现两次，第一次输入username，第二次输入password，**username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章[github生成令牌](/2022/06/30/github生成令牌-Personal-access-tokens-操作步骤/))</font>**\n---- 注意：如果password输入错误，会导致无法提交\n```javascript\n$ git push\nLogon failed, use ctrl+c to cancel basic credential prompt.\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\nfatal: Authentication failed for 'https://github.com/xxxxxxx.git/'\n```\n\n当username和password输入完成后，就可以正常push代码啦","slug":"11-github-push-insert-password","published":1,"updated":"2022-06-30T05:22:12.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwg0003cktt2wq64994","content":"<h4 id=\"github推送代码弹窗应该怎么输入\"><a href=\"#github推送代码弹窗应该怎么输入\" class=\"headerlink\" title=\"github推送代码弹窗应该怎么输入?\"></a>github推送代码弹窗应该怎么输入?</h4><p>当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，<br>鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。</p>\n<p>(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>—- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: Failed to connect to github.com port <span class=\"number\">443</span>: Timed out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --------</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: OpenSSL SSL_read: Connection was aborted, errno <span class=\"number\">10053</span></span><br></pre></td></tr></table></figure>\n<p>(2)第一个GitHub登录弹窗<br><img src alt=\"github_login\"><br>该弹窗中 <strong>username为github的登录邮箱，password为GitHub的登录密码</strong><br>—- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br></pre></td></tr></table></figure>\n<p>(3)第二个登录弹窗<br>![login_insert]<br>该弹窗会出现两次，第一次输入username，第二次输入password，<strong>username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章<a href=\"/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/\">github生成令牌</a>)</font></strong><br>—- 注意：如果password输入错误，会导致无法提交</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Please see https:<span class=\"comment\">//github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span></span><br><span class=\"line\">fatal: Authentication failed <span class=\"keyword\">for</span> <span class=\"string\">&#x27;https://github.com/xxxxxxx.git/&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>当username和password输入完成后，就可以正常push代码啦</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"github推送代码弹窗应该怎么输入\"><a href=\"#github推送代码弹窗应该怎么输入\" class=\"headerlink\" title=\"github推送代码弹窗应该怎么输入?\"></a>github推送代码弹窗应该怎么输入?</h4><p>当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，<br>鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。</p>\n<p>(1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>—- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: Failed to connect to github.com port <span class=\"number\">443</span>: Timed out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --------</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\"><span class=\"attr\">fatal</span>: unable to access <span class=\"string\">&#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;</span>: OpenSSL SSL_read: Connection was aborted, errno <span class=\"number\">10053</span></span><br></pre></td></tr></table></figure>\n<p>(2)第一个GitHub登录弹窗<br><img src alt=\"github_login\"><br>该弹窗中 <strong>username为github的登录邮箱，password为GitHub的登录密码</strong><br>—- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br></pre></td></tr></table></figure>\n<p>(3)第二个登录弹窗<br>![login_insert]<br>该弹窗会出现两次，第一次输入username，第二次输入password，<strong>username为GitHub的登录邮箱，<font color=\"Red\">password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章<a href=\"/2022/06/30/github%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8C-Personal-access-tokens-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/\">github生成令牌</a>)</font></strong><br>—- 注意：如果password输入错误，会导致无法提交</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br><span class=\"line\">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Support <span class=\"keyword\">for</span> password authentication was removed on August <span class=\"number\">13</span>, <span class=\"number\">2021.</span> Please use a personal access token instead.</span><br><span class=\"line\"><span class=\"attr\">remote</span>: Please see https:<span class=\"comment\">//github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span></span><br><span class=\"line\">fatal: Authentication failed <span class=\"keyword\">for</span> <span class=\"string\">&#x27;https://github.com/xxxxxxx.git/&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>当username和password输入完成后，就可以正常push代码啦</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### deploy产生如下错误的解决方法\n(1)使用hexo部署报错Error: Spawn failed\n解决办法：删除.deploy_git文件夹 -> 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -> 按顺序执行命令hexo clean、hexo generate、hexo deploy\n","source":"_posts/1-hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### deploy产生如下错误的解决方法\n(1)使用hexo部署报错Error: Spawn failed\n解决办法：删除.deploy_git文件夹 -> 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -> 按顺序执行命令hexo clean、hexo generate、hexo deploy\n","slug":"1-hello-world","published":1,"date":"2022-01-05T09:20:43.363Z","updated":"2022-06-23T01:58:33.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwi0005cktt5d7ld2xe","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"deploy产生如下错误的解决方法\"><a href=\"#deploy产生如下错误的解决方法\" class=\"headerlink\" title=\"deploy产生如下错误的解决方法\"></a>deploy产生如下错误的解决方法</h3><p>(1)使用hexo部署报错Error: Spawn failed<br>解决办法：删除.deploy_git文件夹 -&gt; 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -&gt; 按顺序执行命令hexo clean、hexo generate、hexo deploy</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"deploy产生如下错误的解决方法\"><a href=\"#deploy产生如下错误的解决方法\" class=\"headerlink\" title=\"deploy产生如下错误的解决方法\"></a>deploy产生如下错误的解决方法</h3><p>(1)使用hexo部署报错Error: Spawn failed<br>解决办法：删除.deploy_git文件夹 -&gt; 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -&gt; 按顺序执行命令hexo clean、hexo generate、hexo deploy</p>\n"},{"title":"meta标签的使用","date":"2022-06-28T14:16:30.000Z","_content":"\n#### meta标签的使用\n\n###### <meta>文档级元数据元素\nmeta标签一般放在HTML页面的head里面，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta)定义：\n>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(\\<base\\>,\\<link\\>,\\<script\\>,\\<style\\> 或 \\<title\\>）之一表示的任何元数据信息。\n\n###### meta定义的元数据类型\n(1)name属性：meta元素提供文档级别元数据，应用于整个页面\n-- name和content一起使用，name表示元数据名称，content表示元数据的值\n---- name=\"author\"，表示网页作者的名字，例如某个组织或机构\n```\n<mate name=\"author\" content=\"xxx@mail.com\">\n```\n\n---- name=\"description\"，是一段简短而精确的，对页面内容的描述\n```javascript\n//淘宝网页的meta\n<meta name=\"description\" content=\"淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！\">\n```\n\n---- name=\"keywords\"，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类\n```javascript\n//淘宝网页的meta\n<meta name=\"keyword\" content=\"淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺\">\n```\n\n---- name=\"viewport\"，为viewport（视口）的初始大小提供指示，目前仅用于移动设备\n```javascript\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\nwidth：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？\ninitial-scale：为设备宽度与viewport大小之间的缩放比例\nmaximum-scale：？？？？\nminimum-scale：？？？？\nuser-scalable：？？？？\nminimal-ui：？？？？\n\n---- name=\"robots\"，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的\ncontent类型：\nall：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索\nnone：搜索引擎将忽略此网页\nindex：搜索引擎索引此网页\nfollow：搜索引擎继续通过此网页的链接索引搜索其它的网页\n\n---- name=\"renderer\"，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式\n```javascript\n<meta name=\"renderer\" content=\"webkit\"> //默认webkit内核\n<meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式\n<meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式\n```\ncontent类型：\n？？？？\n\n---- name=\"spm-id\"，？？？？\n```javascript\n// 淘宝\n<meta name=\"spm-id\" content=\"a21bo\">\n```\n---- name=\"aplus-xplug\"，？？？？\n```javascript\n// 淘宝网\n<meta name=\"aplus-xplug\" content=\"NONE\">\n```\n\n\n(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同\n-- http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值\n-- http-equiv所有允许的值都是特定http头部的名称\n---- http-equiv=\"X-UA-Compatible\"\n```javascript\n// 淘宝网\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=10,chrome=1\">//IE浏览器适配\n```\nIE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。\nchrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。\n两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。\n另外，这个属性支持的范围是IE8-IE11\n如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。\n\n---- http-equiv=\"content-type\"，用来声明文档类型和字符集\n```javascript\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n```\n\n---- http-equiv=\"x-dns-prefetch-control\"\n一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：\n```javascript\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n```\n\n---- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？\n\n(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码\n(4)itemprop属性：meta元素提供用户定义的元数据","source":"_posts/10-about-meta.md","raw":"---\ntitle: meta标签的使用\ndate: 2022-06-28 22:16:30\ntags:\n---\n\n#### meta标签的使用\n\n###### <meta>文档级元数据元素\nmeta标签一般放在HTML页面的head里面，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta)定义：\n>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(\\<base\\>,\\<link\\>,\\<script\\>,\\<style\\> 或 \\<title\\>）之一表示的任何元数据信息。\n\n###### meta定义的元数据类型\n(1)name属性：meta元素提供文档级别元数据，应用于整个页面\n-- name和content一起使用，name表示元数据名称，content表示元数据的值\n---- name=\"author\"，表示网页作者的名字，例如某个组织或机构\n```\n<mate name=\"author\" content=\"xxx@mail.com\">\n```\n\n---- name=\"description\"，是一段简短而精确的，对页面内容的描述\n```javascript\n//淘宝网页的meta\n<meta name=\"description\" content=\"淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！\">\n```\n\n---- name=\"keywords\"，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类\n```javascript\n//淘宝网页的meta\n<meta name=\"keyword\" content=\"淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺\">\n```\n\n---- name=\"viewport\"，为viewport（视口）的初始大小提供指示，目前仅用于移动设备\n```javascript\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\nwidth：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？\ninitial-scale：为设备宽度与viewport大小之间的缩放比例\nmaximum-scale：？？？？\nminimum-scale：？？？？\nuser-scalable：？？？？\nminimal-ui：？？？？\n\n---- name=\"robots\"，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的\ncontent类型：\nall：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索\nnone：搜索引擎将忽略此网页\nindex：搜索引擎索引此网页\nfollow：搜索引擎继续通过此网页的链接索引搜索其它的网页\n\n---- name=\"renderer\"，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式\n```javascript\n<meta name=\"renderer\" content=\"webkit\"> //默认webkit内核\n<meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式\n<meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式\n```\ncontent类型：\n？？？？\n\n---- name=\"spm-id\"，？？？？\n```javascript\n// 淘宝\n<meta name=\"spm-id\" content=\"a21bo\">\n```\n---- name=\"aplus-xplug\"，？？？？\n```javascript\n// 淘宝网\n<meta name=\"aplus-xplug\" content=\"NONE\">\n```\n\n\n(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同\n-- http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值\n-- http-equiv所有允许的值都是特定http头部的名称\n---- http-equiv=\"X-UA-Compatible\"\n```javascript\n// 淘宝网\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=10,chrome=1\">//IE浏览器适配\n```\nIE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。\nchrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。\n两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。\n另外，这个属性支持的范围是IE8-IE11\n如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。\n\n---- http-equiv=\"content-type\"，用来声明文档类型和字符集\n```javascript\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n```\n\n---- http-equiv=\"x-dns-prefetch-control\"\n一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：\n```javascript\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n```\n\n---- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？\n\n(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码\n(4)itemprop属性：meta元素提供用户定义的元数据","slug":"10-about-meta","published":1,"updated":"2022-07-21T07:48:28.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwj0007cktt32b69q0u","content":"<h4 id=\"meta标签的使用\"><a href=\"#meta标签的使用\" class=\"headerlink\" title=\"meta标签的使用\"></a>meta标签的使用</h4><h6 id=\"文档级元数据元素\"><a href=\"#文档级元数据元素\" class=\"headerlink\" title=\"文档级元数据元素\"></a><meta>文档级元数据元素</h6><p>meta标签一般放在HTML页面的head里面，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta\">MDN</a>定义：</p>\n<blockquote>\n<p>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。</p>\n</blockquote>\n<h6 id=\"meta定义的元数据类型\"><a href=\"#meta定义的元数据类型\" class=\"headerlink\" title=\"meta定义的元数据类型\"></a>meta定义的元数据类型</h6><p>(1)name属性：meta元素提供文档级别元数据，应用于整个页面<br>– name和content一起使用，name表示元数据名称，content表示元数据的值<br>—- name=”author”，表示网页作者的名字，例如某个组织或机构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mate name=&quot;author&quot; content=&quot;xxx@mail.com&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”description”，是一段简短而精确的，对页面内容的描述</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;description&quot;</span> content=<span class=\"string\">&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”keywords”，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;keyword&quot;</span> content=<span class=\"string\">&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”viewport”，为viewport（视口）的初始大小提供指示，目前仅用于移动设备</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;viewport&quot;</span> content=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>width：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？<br>initial-scale：为设备宽度与viewport大小之间的缩放比例<br>maximum-scale：？？？？<br>minimum-scale：？？？？<br>user-scalable：？？？？<br>minimal-ui：？？？？</p>\n<p>—- name=”robots”，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的<br>content类型：<br>all：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索<br>none：搜索引擎将忽略此网页<br>index：搜索引擎索引此网页<br>follow：搜索引擎继续通过此网页的链接索引搜索其它的网页</p>\n<p>—- name=”renderer”，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;renderer&quot;</span> content=<span class=\"string\">&quot;webkit&quot;</span>&gt; <span class=\"comment\">//默认webkit内核</span></span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式</span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式</span><br></pre></td></tr></table></figure>\n<p>content类型：<br>？？？？</p>\n<p>—- name=”spm-id”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;spm-id&quot;</span> content=<span class=\"string\">&quot;a21bo&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>—- name=”aplus-xplug”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;aplus-xplug&quot;</span> content=<span class=\"string\">&quot;NONE&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同<br>– http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值<br>– http-equiv所有允许的值都是特定http头部的名称<br>—- http-equiv=”X-UA-Compatible”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> content=<span class=\"string\">&quot;IE=10,chrome=1&quot;</span>&gt;<span class=\"comment\">//IE浏览器适配</span></span><br></pre></td></tr></table></figure>\n<p>IE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。<br>chrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。<br>两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。<br>另外，这个属性支持的范围是IE8-IE11<br>如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。</p>\n<p>—- http-equiv=”content-type”，用来声明文档类型和字符集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;content-type&quot;</span> content=<span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- http-equiv=”x-dns-prefetch-control”<br>一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;x-dns-prefetch-control&quot;</span> content=<span class=\"string\">&quot;on&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？</p>\n<p>(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码<br>(4)itemprop属性：meta元素提供用户定义的元数据</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"meta标签的使用\"><a href=\"#meta标签的使用\" class=\"headerlink\" title=\"meta标签的使用\"></a>meta标签的使用</h4><h6 id=\"文档级元数据元素\"><a href=\"#文档级元数据元素\" class=\"headerlink\" title=\"文档级元数据元素\"></a><meta>文档级元数据元素</h6><p>meta标签一般放在HTML页面的head里面，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta\">MDN</a>定义：</p>\n<blockquote>\n<p>HTML <meta> 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。</p>\n</blockquote>\n<h6 id=\"meta定义的元数据类型\"><a href=\"#meta定义的元数据类型\" class=\"headerlink\" title=\"meta定义的元数据类型\"></a>meta定义的元数据类型</h6><p>(1)name属性：meta元素提供文档级别元数据，应用于整个页面<br>– name和content一起使用，name表示元数据名称，content表示元数据的值<br>—- name=”author”，表示网页作者的名字，例如某个组织或机构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mate name=&quot;author&quot; content=&quot;xxx@mail.com&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”description”，是一段简短而精确的，对页面内容的描述</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;description&quot;</span> content=<span class=\"string\">&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”keywords”，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//淘宝网页的meta</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;keyword&quot;</span> content=<span class=\"string\">&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- name=”viewport”，为viewport（视口）的初始大小提供指示，目前仅用于移动设备</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;viewport&quot;</span> content=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>width：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？<br>initial-scale：为设备宽度与viewport大小之间的缩放比例<br>maximum-scale：？？？？<br>minimum-scale：？？？？<br>user-scalable：？？？？<br>minimal-ui：？？？？</p>\n<p>—- name=”robots”，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的<br>content类型：<br>all：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索<br>none：搜索引擎将忽略此网页<br>index：搜索引擎索引此网页<br>follow：搜索引擎继续通过此网页的链接索引搜索其它的网页</p>\n<p>—- name=”renderer”，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;renderer&quot;</span> content=<span class=\"string\">&quot;webkit&quot;</span>&gt; <span class=\"comment\">//默认webkit内核</span></span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式</span><br><span class=\"line\">&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式</span><br></pre></td></tr></table></figure>\n<p>content类型：<br>？？？？</p>\n<p>—- name=”spm-id”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;spm-id&quot;</span> content=<span class=\"string\">&quot;a21bo&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>—- name=”aplus-xplug”，？？？？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;aplus-xplug&quot;</span> content=<span class=\"string\">&quot;NONE&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>(2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同<br>– http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值<br>– http-equiv所有允许的值都是特定http头部的名称<br>—- http-equiv=”X-UA-Compatible”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 淘宝网</span></span><br><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> content=<span class=\"string\">&quot;IE=10,chrome=1&quot;</span>&gt;<span class=\"comment\">//IE浏览器适配</span></span><br></pre></td></tr></table></figure>\n<p>IE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。<br>chrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。<br>两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。<br>另外，这个属性支持的范围是IE8-IE11<br>如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。</p>\n<p>—- http-equiv=”content-type”，用来声明文档类型和字符集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;content-type&quot;</span> content=<span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- http-equiv=”x-dns-prefetch-control”<br>一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=<span class=\"string\">&quot;x-dns-prefetch-control&quot;</span> content=<span class=\"string\">&quot;on&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略  ？？？？</p>\n<p>(3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码<br>(4)itemprop属性：meta元素提供用户定义的元数据</p>\n"},{"title":"前端概念相关-渐进增强与优雅降级","date":"2022-07-12T02:37:56.000Z","_content":"\n#### 渐进增强(Progressive Enhancement)(相当于向上兼容)\n一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验\n\n#### 优雅降级(Graceful Degradation)(相当于向下兼容)\n一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览\n\n向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少\n大多数软件都是向下兼容的\n\n#### 渐进增强与优雅降级的区别\n优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度\n关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程\n\n优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n渐进增强观点则认为应关注于内容本身。\n```javascript\n.transition { /*渐进增强写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*优雅降级写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n```\n前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：\n\n1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；\n2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；\n3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；\n4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.\n\n渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。\n","source":"_posts/14-about-fe-theory.md","raw":"---\ntitle: 前端概念相关-渐进增强与优雅降级\ndate: 2022-07-12 10:37:56\ntags:\n---\n\n#### 渐进增强(Progressive Enhancement)(相当于向上兼容)\n一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验\n\n#### 优雅降级(Graceful Degradation)(相当于向下兼容)\n一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览\n\n向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少\n大多数软件都是向下兼容的\n\n#### 渐进增强与优雅降级的区别\n优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度\n关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程\n\n优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n渐进增强观点则认为应关注于内容本身。\n```javascript\n.transition { /*渐进增强写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*优雅降级写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n```\n前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：\n\n1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；\n2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；\n3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；\n4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.\n\n渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。\n","slug":"14-about-fe-theory","published":1,"updated":"2022-07-18T05:47:25.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwk0009cktt08pugcq1","content":"<h4 id=\"渐进增强-Progressive-Enhancement-相当于向上兼容\"><a href=\"#渐进增强-Progressive-Enhancement-相当于向上兼容\" class=\"headerlink\" title=\"渐进增强(Progressive Enhancement)(相当于向上兼容)\"></a>渐进增强(Progressive Enhancement)(相当于向上兼容)</h4><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验</p>\n<h4 id=\"优雅降级-Graceful-Degradation-相当于向下兼容\"><a href=\"#优雅降级-Graceful-Degradation-相当于向下兼容\" class=\"headerlink\" title=\"优雅降级(Graceful Degradation)(相当于向下兼容)\"></a>优雅降级(Graceful Degradation)(相当于向下兼容)</h4><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览</p>\n<p>向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少<br>大多数软件都是向下兼容的</p>\n<h4 id=\"渐进增强与优雅降级的区别\"><a href=\"#渐进增强与优雅降级的区别\" class=\"headerlink\" title=\"渐进增强与优雅降级的区别\"></a>渐进增强与优雅降级的区别</h4><p>优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度<br>关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程</p>\n<p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>渐进增强观点则认为应关注于内容本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition &#123; <span class=\"comment\">/*渐进增强写法*/</span></span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">          transition: all .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.transition &#123; <span class=\"comment\">/*优雅降级写法*/</span></span><br><span class=\"line\">          <span class=\"attr\">transition</span>: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：</p>\n<p>1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；<br>2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；<br>3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；<br>4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>\n<p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"渐进增强-Progressive-Enhancement-相当于向上兼容\"><a href=\"#渐进增强-Progressive-Enhancement-相当于向上兼容\" class=\"headerlink\" title=\"渐进增强(Progressive Enhancement)(相当于向上兼容)\"></a>渐进增强(Progressive Enhancement)(相当于向上兼容)</h4><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验</p>\n<h4 id=\"优雅降级-Graceful-Degradation-相当于向下兼容\"><a href=\"#优雅降级-Graceful-Degradation-相当于向下兼容\" class=\"headerlink\" title=\"优雅降级(Graceful Degradation)(相当于向下兼容)\"></a>优雅降级(Graceful Degradation)(相当于向下兼容)</h4><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览</p>\n<p>向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少<br>大多数软件都是向下兼容的</p>\n<h4 id=\"渐进增强与优雅降级的区别\"><a href=\"#渐进增强与优雅降级的区别\" class=\"headerlink\" title=\"渐进增强与优雅降级的区别\"></a>渐进增强与优雅降级的区别</h4><p>优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度<br>关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程</p>\n<p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>渐进增强观点则认为应关注于内容本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transition &#123; <span class=\"comment\">/*渐进增强写法*/</span></span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">          transition: all .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.transition &#123; <span class=\"comment\">/*优雅降级写法*/</span></span><br><span class=\"line\">          <span class=\"attr\">transition</span>: all .5s;</span><br><span class=\"line\">       -o-transition: all .5s;</span><br><span class=\"line\">     -moz-transition: all .5s;</span><br><span class=\"line\">  -webkit-transition: all .5s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的：</p>\n<p>1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；<br>2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；<br>3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；<br>4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>\n<p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</p>\n"},{"title":"各类文档地址","date":"2022-07-05T08:17:32.000Z","_content":"\n#### code spell checker配置项说明\n[文档地址](https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker)\n\n#### 查看chrome各个版本功能变更\n[chrome status](https://chromestatus.com/features)\n\n#### 查看== 、=== 、if()在不同情况下的执行结果\n[地址](https://dorey.github.io/JavaScript-Equality-Table/)\n\n#### css层叠样式表\n[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)\n\n#### Recoil\n[官方文档](https://recoiljs.org/)\n\n#### React\n[官方文档](https://reactjs.org/)\n\n#### vue\n[官方文档](https://vuejs.org/)\n\n#### VueUse--vue使用的hooks库\n[官方文档](https://vueuse.org/)\n\n#### HTML\n[官方文档](https://html.spec.whatwg.org/)\n\n#### testing-library/react\n[官方文档](https://testing-library.com/)\n\n#### nodejs\n[官方文档-英文版](https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html)\n[中文文档](https://www.nodeapp.cn/assert.html)\n\n#### ahooks\n[官方文档](https://ahooks.js.org/)","source":"_posts/13-document-location.md","raw":"---\ntitle: 各类文档地址\ndate: 2022-07-05 16:17:32\ntags:\n---\n\n#### code spell checker配置项说明\n[文档地址](https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker)\n\n#### 查看chrome各个版本功能变更\n[chrome status](https://chromestatus.com/features)\n\n#### 查看== 、=== 、if()在不同情况下的执行结果\n[地址](https://dorey.github.io/JavaScript-Equality-Table/)\n\n#### css层叠样式表\n[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)\n\n#### Recoil\n[官方文档](https://recoiljs.org/)\n\n#### React\n[官方文档](https://reactjs.org/)\n\n#### vue\n[官方文档](https://vuejs.org/)\n\n#### VueUse--vue使用的hooks库\n[官方文档](https://vueuse.org/)\n\n#### HTML\n[官方文档](https://html.spec.whatwg.org/)\n\n#### testing-library/react\n[官方文档](https://testing-library.com/)\n\n#### nodejs\n[官方文档-英文版](https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html)\n[中文文档](https://www.nodeapp.cn/assert.html)\n\n#### ahooks\n[官方文档](https://ahooks.js.org/)","slug":"13-document-location","published":1,"updated":"2022-10-25T07:04:14.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwl000bcktt6dd4dyly","content":"<h4 id=\"code-spell-checker配置项说明\"><a href=\"#code-spell-checker配置项说明\" class=\"headerlink\" title=\"code spell checker配置项说明\"></a>code spell checker配置项说明</h4><p><a href=\"https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker\">文档地址</a></p>\n<h4 id=\"查看chrome各个版本功能变更\"><a href=\"#查看chrome各个版本功能变更\" class=\"headerlink\" title=\"查看chrome各个版本功能变更\"></a>查看chrome各个版本功能变更</h4><p><a href=\"https://chromestatus.com/features\">chrome status</a></p>\n<h4 id=\"查看-、-、if-在不同情况下的执行结果\"><a href=\"#查看-、-、if-在不同情况下的执行结果\" class=\"headerlink\" title=\"查看== 、=== 、if()在不同情况下的执行结果\"></a>查看== 、=== 、if()在不同情况下的执行结果</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">地址</a></p>\n<h4 id=\"css层叠样式表\"><a href=\"#css层叠样式表\" class=\"headerlink\" title=\"css层叠样式表\"></a>css层叠样式表</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade\">官方文档</a></p>\n<h4 id=\"Recoil\"><a href=\"#Recoil\" class=\"headerlink\" title=\"Recoil\"></a>Recoil</h4><p><a href=\"https://recoiljs.org/\">官方文档</a></p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p><a href=\"https://reactjs.org/\">官方文档</a></p>\n<h4 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h4><p><a href=\"https://vuejs.org/\">官方文档</a></p>\n<h4 id=\"VueUse–vue使用的hooks库\"><a href=\"#VueUse–vue使用的hooks库\" class=\"headerlink\" title=\"VueUse–vue使用的hooks库\"></a>VueUse–vue使用的hooks库</h4><p><a href=\"https://vueuse.org/\">官方文档</a></p>\n<h4 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h4><p><a href=\"https://html.spec.whatwg.org/\">官方文档</a></p>\n<h4 id=\"testing-library-react\"><a href=\"#testing-library-react\" class=\"headerlink\" title=\"testing-library/react\"></a>testing-library/react</h4><p><a href=\"https://testing-library.com/\">官方文档</a></p>\n<h4 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h4><p><a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html\">官方文档-英文版</a><br><a href=\"https://www.nodeapp.cn/assert.html\">中文文档</a></p>\n<h4 id=\"ahooks\"><a href=\"#ahooks\" class=\"headerlink\" title=\"ahooks\"></a>ahooks</h4><p><a href=\"https://ahooks.js.org/\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"code-spell-checker配置项说明\"><a href=\"#code-spell-checker配置项说明\" class=\"headerlink\" title=\"code spell checker配置项说明\"></a>code spell checker配置项说明</h4><p><a href=\"https://streetsidesoftware.com/vscode-spell-checker/docs/configuration/#code-spell-checker\">文档地址</a></p>\n<h4 id=\"查看chrome各个版本功能变更\"><a href=\"#查看chrome各个版本功能变更\" class=\"headerlink\" title=\"查看chrome各个版本功能变更\"></a>查看chrome各个版本功能变更</h4><p><a href=\"https://chromestatus.com/features\">chrome status</a></p>\n<h4 id=\"查看-、-、if-在不同情况下的执行结果\"><a href=\"#查看-、-、if-在不同情况下的执行结果\" class=\"headerlink\" title=\"查看== 、=== 、if()在不同情况下的执行结果\"></a>查看== 、=== 、if()在不同情况下的执行结果</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">地址</a></p>\n<h4 id=\"css层叠样式表\"><a href=\"#css层叠样式表\" class=\"headerlink\" title=\"css层叠样式表\"></a>css层叠样式表</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade\">官方文档</a></p>\n<h4 id=\"Recoil\"><a href=\"#Recoil\" class=\"headerlink\" title=\"Recoil\"></a>Recoil</h4><p><a href=\"https://recoiljs.org/\">官方文档</a></p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p><a href=\"https://reactjs.org/\">官方文档</a></p>\n<h4 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h4><p><a href=\"https://vuejs.org/\">官方文档</a></p>\n<h4 id=\"VueUse–vue使用的hooks库\"><a href=\"#VueUse–vue使用的hooks库\" class=\"headerlink\" title=\"VueUse–vue使用的hooks库\"></a>VueUse–vue使用的hooks库</h4><p><a href=\"https://vueuse.org/\">官方文档</a></p>\n<h4 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h4><p><a href=\"https://html.spec.whatwg.org/\">官方文档</a></p>\n<h4 id=\"testing-library-react\"><a href=\"#testing-library-react\" class=\"headerlink\" title=\"testing-library/react\"></a>testing-library/react</h4><p><a href=\"https://testing-library.com/\">官方文档</a></p>\n<h4 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h4><p><a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/documentation.html\">官方文档-英文版</a><br><a href=\"https://www.nodeapp.cn/assert.html\">中文文档</a></p>\n<h4 id=\"ahooks\"><a href=\"#ahooks\" class=\"headerlink\" title=\"ahooks\"></a>ahooks</h4><p><a href=\"https://ahooks.js.org/\">官方文档</a></p>\n"},{"title":"js-基本类型与引用类型","date":"2022-07-19T08:23:28.000Z","_content":"","source":"_posts/16-origin-type-and-reference-type.md","raw":"---\ntitle: js-基本类型与引用类型\ndate: 2022-07-19 16:23:28\ntags:\n---\n","slug":"16-origin-type-and-reference-type","published":1,"updated":"2022-08-10T03:14:27.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwm000dcktt2f5i0jp0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"js-类型转换","date":"2022-07-19T07:59:15.000Z","_content":"\n在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。\n== ：比较两个数据是否相等，允许进行类型转化\n比如：1==true、'1'==true，结果都是true\n===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false\n比如：1===true、'1'===true，结果为false\n\n#### 数学运算符中的类型转换\n\n1、减、乘、除运算\n**非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型**\n```javascript\n1 - true // 0, true先转换乘1，然后执行 1 - 1\n1 - false // 1, true先转换乘0，然后执行 1 - 0\n1 - null // 1, true先转换乘0，然后执行 1 - 0\n1 - undefined // NaN, undefined转换为数字为 NaN\n2 * ['5'] // 10, ['5']先变成'5'（这一步涉及拆箱操作）,然后变成数字5\n```\n{% btn /2022/08/09/devan-operation/, 拆箱操作, %}\n\n2、加运算\n**js中的加法运算，还可以用来拼接字符串**\n* 加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型\n* 加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型\n* 加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接\n**以上三点，优先级从高到低**\n\n```javascript\n123 + '123' // '123123' (规则1)\n123 + null //  123 (规则2)\n123 + true //  124 (规则2)\n123 + {}   //  '123[object Object]' (规则3)\n```\n\n#### 逻辑运算中的类型转换\n1、单个变量\n先将变量转换为Boolean值\n**只有null、undefined、''、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]**\n\n2、使用 == 比较中的5条规则\n**建议使用 ===**\n* 规则1：NaN和其他任何类型比较永远返回false(包括和他自己)\n```javascript\nNaN == NaN // false\n```\n* 规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型\n```javascript\ntrue == 1 // true\ntrue == '2' // false,先将true转换为1，而不是把'2'变成true\ntrue == ['1'] // true, 先将true转换为1，['1']拆箱成'1',在参考规则3\ntrue == ['2'] // false, 同上\nundefined == false // false, 首先false变成0，然后参考规则4\nnull == false // false, 同上\n```\n* String和Number比较，先将String转换为Number类型\n```javascript\n123 == '123' // true, '123'会变成123\n'' == 0 // true，''会变成 0\n```\n* null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false\n```javascript\nnull == undefined  // true\nnull == '' // false\nnull == 0 // false\nnull == false // false\nundefined == '' // false\nundefined == 0 // false\nundefined == false // false\n```\n* 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型\n**ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError**\n```javascript\n'[object Object]' == {} // true, 对象和字符串比较，对象通过toString 得到一个基本类型值\n'1,2,3' == [1,2,3] // true, [1,2,3]通过toString得到一个基本类型\n```\n\n#### 类型转换表\n![类型转换对照表](convert-table.png)\n\n#### 类型转换对照网站\nhttps://dorey.github.io/JavaScript-Equality-Table/\n\n{% btn /,, home %}","source":"_posts/15-js-transform.md","raw":"---\ntitle: js-类型转换\ndate: 2022-07-19 15:59:15\ntags:\n---\n\n在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。\n== ：比较两个数据是否相等，允许进行类型转化\n比如：1==true、'1'==true，结果都是true\n===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false\n比如：1===true、'1'===true，结果为false\n\n#### 数学运算符中的类型转换\n\n1、减、乘、除运算\n**非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型**\n```javascript\n1 - true // 0, true先转换乘1，然后执行 1 - 1\n1 - false // 1, true先转换乘0，然后执行 1 - 0\n1 - null // 1, true先转换乘0，然后执行 1 - 0\n1 - undefined // NaN, undefined转换为数字为 NaN\n2 * ['5'] // 10, ['5']先变成'5'（这一步涉及拆箱操作）,然后变成数字5\n```\n{% btn /2022/08/09/devan-operation/, 拆箱操作, %}\n\n2、加运算\n**js中的加法运算，还可以用来拼接字符串**\n* 加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型\n* 加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型\n* 加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接\n**以上三点，优先级从高到低**\n\n```javascript\n123 + '123' // '123123' (规则1)\n123 + null //  123 (规则2)\n123 + true //  124 (规则2)\n123 + {}   //  '123[object Object]' (规则3)\n```\n\n#### 逻辑运算中的类型转换\n1、单个变量\n先将变量转换为Boolean值\n**只有null、undefined、''、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]**\n\n2、使用 == 比较中的5条规则\n**建议使用 ===**\n* 规则1：NaN和其他任何类型比较永远返回false(包括和他自己)\n```javascript\nNaN == NaN // false\n```\n* 规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型\n```javascript\ntrue == 1 // true\ntrue == '2' // false,先将true转换为1，而不是把'2'变成true\ntrue == ['1'] // true, 先将true转换为1，['1']拆箱成'1',在参考规则3\ntrue == ['2'] // false, 同上\nundefined == false // false, 首先false变成0，然后参考规则4\nnull == false // false, 同上\n```\n* String和Number比较，先将String转换为Number类型\n```javascript\n123 == '123' // true, '123'会变成123\n'' == 0 // true，''会变成 0\n```\n* null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false\n```javascript\nnull == undefined  // true\nnull == '' // false\nnull == 0 // false\nnull == false // false\nundefined == '' // false\nundefined == 0 // false\nundefined == false // false\n```\n* 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型\n**ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError**\n```javascript\n'[object Object]' == {} // true, 对象和字符串比较，对象通过toString 得到一个基本类型值\n'1,2,3' == [1,2,3] // true, [1,2,3]通过toString得到一个基本类型\n```\n\n#### 类型转换表\n![类型转换对照表](convert-table.png)\n\n#### 类型转换对照网站\nhttps://dorey.github.io/JavaScript-Equality-Table/\n\n{% btn /,, home %}","slug":"15-js-transform","published":1,"updated":"2022-08-10T03:11:17.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwn000fckttde89euf3","content":"<p>在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。<br>== ：比较两个数据是否相等，允许进行类型转化<br>比如：1==true、’1’==true，结果都是true<br>===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false<br>比如：1===true、’1’===true，结果为false</p>\n<h4 id=\"数学运算符中的类型转换\"><a href=\"#数学运算符中的类型转换\" class=\"headerlink\" title=\"数学运算符中的类型转换\"></a>数学运算符中的类型转换</h4><p>1、减、乘、除运算<br><strong>非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">true</span> <span class=\"comment\">// 0, true先转换乘1，然后执行 1 - 1</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">false</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">null</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN, undefined转换为数字为 NaN</span></span><br><span class=\"line\"><span class=\"number\">2</span> * [<span class=\"string\">&#x27;5&#x27;</span>] <span class=\"comment\">// 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5</span></span><br></pre></td></tr></table></figure>\n<a class=\"btn\" href=\"/2022/08/09/devan-operation/\">拆箱操作</a>\n\n<p>2、加运算<br><strong>js中的加法运算，还可以用来拼接字符串</strong></p>\n<ul>\n<li>加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型</li>\n<li>加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li>\n<li>加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接</li>\n<li><em>以上三点，优先级从高到低</em>*</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> + <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// &#x27;123123&#x27; (规则1)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">null</span> <span class=\"comment\">//  123 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">true</span> <span class=\"comment\">//  124 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + &#123;&#125;   <span class=\"comment\">//  &#x27;123[object Object]&#x27; (规则3)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逻辑运算中的类型转换\"><a href=\"#逻辑运算中的类型转换\" class=\"headerlink\" title=\"逻辑运算中的类型转换\"></a>逻辑运算中的类型转换</h4><p>1、单个变量<br>先将变量转换为Boolean值<br><strong>只有null、undefined、’’、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]</strong></p>\n<p>2、使用 == 比较中的5条规则<br><strong>建议使用 ===</strong></p>\n<ul>\n<li>规则1：NaN和其他任何类型比较永远返回false(包括和他自己)<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"string\">&#x27;2&#x27;</span> <span class=\"comment\">// false,先将true转换为1，而不是把&#x27;2&#x27;变成true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;1&#x27;</span>] <span class=\"comment\">// true, 先将true转换为1，[&#x27;1&#x27;]拆箱成&#x27;1&#x27;,在参考规则3</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;2&#x27;</span>] <span class=\"comment\">// false, 同上</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 首先false变成0，然后参考规则4</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 同上</span></span><br></pre></td></tr></table></figure></li>\n<li>String和Number比较，先将String转换为Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> == <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// true, &#x27;123&#x27;会变成123</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> == <span class=\"number\">0</span> <span class=\"comment\">// true，&#x27;&#x27;会变成 0</span></span><br></pre></td></tr></table></figure></li>\n<li>null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型</li>\n<li><em>ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError</em>*<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class=\"comment\">// true, 对象和字符串比较，对象通过toString 得到一个基本类型值</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1,2,3&#x27;</span> == [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// true, [1,2,3]通过toString得到一个基本类型</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"类型转换表\"><a href=\"#类型转换表\" class=\"headerlink\" title=\"类型转换表\"></a>类型转换表</h4><p><img src=\"/2022/07/19/15-js-transform/convert-table.png\" alt=\"类型转换对照表\"></p>\n<h4 id=\"类型转换对照网站\"><a href=\"#类型转换对照网站\" class=\"headerlink\" title=\"类型转换对照网站\"></a>类型转换对照网站</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">https://dorey.github.io/JavaScript-Equality-Table/</a></p>\n<a class=\"btn\" href=\"/\"><i class=\"fa fa-home\"></i></a>","site":{"data":{}},"excerpt":"","more":"<p>在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。<br>== ：比较两个数据是否相等，允许进行类型转化<br>比如：1==true、’1’==true，结果都是true<br>===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false<br>比如：1===true、’1’===true，结果为false</p>\n<h4 id=\"数学运算符中的类型转换\"><a href=\"#数学运算符中的类型转换\" class=\"headerlink\" title=\"数学运算符中的类型转换\"></a>数学运算符中的类型转换</h4><p>1、减、乘、除运算<br><strong>非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">true</span> <span class=\"comment\">// 0, true先转换乘1，然后执行 1 - 1</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">false</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">null</span> <span class=\"comment\">// 1, true先转换乘0，然后执行 1 - 0</span></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN, undefined转换为数字为 NaN</span></span><br><span class=\"line\"><span class=\"number\">2</span> * [<span class=\"string\">&#x27;5&#x27;</span>] <span class=\"comment\">// 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5</span></span><br></pre></td></tr></table></figure>\n<a class=\"btn\" href=\"/2022/08/09/devan-operation/\">拆箱操作</a>\n\n<p>2、加运算<br><strong>js中的加法运算，还可以用来拼接字符串</strong></p>\n<ul>\n<li>加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型</li>\n<li>加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li>\n<li>加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接</li>\n<li><em>以上三点，优先级从高到低</em>*</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> + <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// &#x27;123123&#x27; (规则1)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">null</span> <span class=\"comment\">//  123 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"literal\">true</span> <span class=\"comment\">//  124 (规则2)</span></span><br><span class=\"line\"><span class=\"number\">123</span> + &#123;&#125;   <span class=\"comment\">//  &#x27;123[object Object]&#x27; (规则3)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逻辑运算中的类型转换\"><a href=\"#逻辑运算中的类型转换\" class=\"headerlink\" title=\"逻辑运算中的类型转换\"></a>逻辑运算中的类型转换</h4><p>1、单个变量<br>先将变量转换为Boolean值<br><strong>只有null、undefined、’’、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[]</strong></p>\n<p>2、使用 == 比较中的5条规则<br><strong>建议使用 ===</strong></p>\n<ul>\n<li>规则1：NaN和其他任何类型比较永远返回false(包括和他自己)<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"string\">&#x27;2&#x27;</span> <span class=\"comment\">// false,先将true转换为1，而不是把&#x27;2&#x27;变成true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;1&#x27;</span>] <span class=\"comment\">// true, 先将true转换为1，[&#x27;1&#x27;]拆箱成&#x27;1&#x27;,在参考规则3</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == [<span class=\"string\">&#x27;2&#x27;</span>] <span class=\"comment\">// false, 同上</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 首先false变成0，然后参考规则4</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false, 同上</span></span><br></pre></td></tr></table></figure></li>\n<li>String和Number比较，先将String转换为Number类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span> == <span class=\"string\">&#x27;123&#x27;</span> <span class=\"comment\">// true, &#x27;123&#x27;会变成123</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> == <span class=\"number\">0</span> <span class=\"comment\">// true，&#x27;&#x27;会变成 0</span></span><br></pre></td></tr></table></figure></li>\n<li>null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></li>\n<li>原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型</li>\n<li><em>ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError</em>*<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;[object Object]&#x27;</span> == &#123;&#125; <span class=\"comment\">// true, 对象和字符串比较，对象通过toString 得到一个基本类型值</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1,2,3&#x27;</span> == [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// true, [1,2,3]通过toString得到一个基本类型</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"类型转换表\"><a href=\"#类型转换表\" class=\"headerlink\" title=\"类型转换表\"></a>类型转换表</h4><p><img src=\"/2022/07/19/15-js-transform/convert-table.png\" alt=\"类型转换对照表\"></p>\n<h4 id=\"类型转换对照网站\"><a href=\"#类型转换对照网站\" class=\"headerlink\" title=\"类型转换对照网站\"></a>类型转换对照网站</h4><p><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">https://dorey.github.io/JavaScript-Equality-Table/</a></p>\n<a class=\"btn\" href=\"/\"><i class=\"fa fa-home\"></i></a>"},{"title":"javascript DOM编程艺术阅读笔记","date":"2022-07-31T05:42:45.000Z","_content":"\n#### JavaScript简史\n1、DOM\nDOM是一套对文档的内容进行抽象和概念化的方法。\n\n第0级DOM(DOM Level 0)\n试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。\n\n第1级DMO(DOM Level 1)\nNetscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。\n\n2、浏览器战争\n2.1 DHTML\nDHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:\n(1)利用HTML把网页标记为各种元素;\n(2)利用CSS设置元素样式和它们的显示位置;\n(3)利用JavaScript实时地操控页面和改变样式。\n\n#### JavaScript语法\n循环语句\n1、while循环\n```javascript\nwhile (condition){\n  statements;\n}\n```\ndo...while循环\n```javascript\ndo {\n  statements;\n} while (condition);\n```\n  2、for循环\n```javascript\nfor (initial condition; test condition; alter condition){\n  statements;\n}\n```\n\n函数\n1、变量的作用域\n全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。\n局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。\n\n对象\n对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :\n-属性是隶属于某个特定对象的变量\n-方法是只有某个特定对象才能调用的函数\n对象就是由一些属性和方法组合在一起而构成的一个数据实体\n\n1、用户定义对象(user-defined object)\n由程序员自行创建的对象\n\n2、内建对象(native object)\nJavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object) \nArray、Math、Date等\n\n3、宿主对象(host object)\n由浏览器提供的预定义对象被称为宿主对象(host object ) \n宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息\n\n#### DOM\n1、文档:DOM中的'D'\n如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象\n\n2、对象:DOM中的'O'\n如上对象\n\n3、模型:DOM中的'M'\nDOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图\n\n4、节点\n(1)元素节点\n(2)文本节点\n(3)属性节点\n(4)CSS\n(5)获取元素\n-getElementById 返回一个对象\n-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点\n```javascript\nvar shopping = document.getElementById(\"purchases\") ;\nvar items = shopping.getElementsByTagName(\"*\") ;\n```\n-getElementsByClassName 返回一个对象数组\n使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可\n注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。\n```javascript\nvar shopping = document.getElementById(\"purchases\");\nvar sales = shopping.getElementsByClassName(\"sale\");\n```\n\n5、获取和设置属性\n(1)getAttribute 只能通过元素节点调用\n(2)setAttribute 只能通过元素节点调用，修改属性值\n细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。\n\n#### 案例研究：JavaScript图片库\nDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。\n1、childNodes属性 用来获取任何一个元素的所有子元素\n2、nodeType属性 共有12中可取值\n以下3种具有实用价值：\n-元素节点的nodeType属性值是1\n-属性节点的nodeType属性值是2\n-文本节点的nodeType属性值是3\n3、nodeValue属性 得到和设置节点的值\n4、firstChild和lastChild\n\n#### 最佳实践\n1、平稳退化\n平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成\n2、“javascript:”伪协议\n“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议\n“javascript:”伪协议让我们通过一个链接来调用JavaScript函数\n```javascript\n<a href=\"javascript:popUp('http://www.example.com/');\">Example</a>\n```\n3、CSS\n结构与样式分离\n渐进增强，用一些额外的信息层去包裹原始数据\n4、分离javascript\n5、向后兼容\n(1)对象检测：检测浏览器对JavaScript的支持程度\n(2)浏览器嗅探技术\n通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。\n首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息\n其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长\n最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本\n6、性能考虑\n(1)尽量少访问DOM和尽量减少标记\n(2)合并和放置脚本\n多个脚本合并，减少请求次数\n把所有/<script/>标签都放到文档的末尾，/</body/>标记之前，就可以让页面变得更快\n(3)压缩脚本\n压缩工具：\n-Douglas Crockford的JSMin (http://www.crockford.com/javascript/jsmin.html)\n-雅虎的YUI Compressor (http://developer.yahoo.com/yui/compressor)\n-谷歌的Closure Compiler (http://closure-compiler.appspot.com/home)\n\n#### 动态创建标记\n1、document.write & innerHTML属性\n2、DOM方法\n(1)createElement\n(1)appendChild\n(1)createTextNode\n(1)insertBefore\n3、Ajax\n(1)XMLHttpRequest对象\n```javascript\nfunction getHTTPObject () {\n  if (typeof XMLHttpRequest == \"undefined\") xMLHttpRequest =function () {\n    try { return new Activexobject ( \"Msxm12.XMLHTTP.6.0\"); )catch (e) { }\n    try { return new ActivexObject (\"Msxm12.XMLHTTP.3.0\");)catch (e) { }\n    try { return new ActivexObject ( \"Msxm12.XMLHTTP\"); )catch (e) { }\n    return false;\n  }\n  return new XMLHttpRequest ( ) ;\n}\n```\n\nXHTML5\n本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。\n\n#### CSS-DOM\n1、三位一体的网页\n(1)结构层\n网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建\n(2)表示层\n表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现\n(3)行为层\n行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域\n(4)分离\n-使用(X)HTML去搭建文档的结构\n-使用CSS去设置文档的呈现效果\n-使用DOM脚本去实现文档的行为\n2、style属性\n在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此\nstyle对象只包含在HTML代码里用style属性声明的样式\n3、何时该使用DOM脚本设置样式\n(1)根据元素在节点树里的位置来设置样式\n(2)根据某种条件反复设置某种样式\n(3)响应事件\n4、className属性\n\n#### HTML5\n1、canvas\n2、video和audio\n\n疑问点：\n1、遇到的知识点觉得掌握了，没有记录，后面又忘了\n重要的知识点都记录，不管有没有掌握\n2、任务拆分评估时间不准\n更深入的了解项目代码和业务逻辑\n3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？\n先记录继续阅读，看后面是否有解答\n4、原型链\n不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承\n理解知识的时候，不要添加太多概念，避免混乱","source":"_posts/17-about-dom.md","raw":"---\ntitle: javascript DOM编程艺术阅读笔记\ndate: 2022-07-31 13:42:45\ntags:\n---\n\n#### JavaScript简史\n1、DOM\nDOM是一套对文档的内容进行抽象和概念化的方法。\n\n第0级DOM(DOM Level 0)\n试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。\n\n第1级DMO(DOM Level 1)\nNetscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。\n\n2、浏览器战争\n2.1 DHTML\nDHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:\n(1)利用HTML把网页标记为各种元素;\n(2)利用CSS设置元素样式和它们的显示位置;\n(3)利用JavaScript实时地操控页面和改变样式。\n\n#### JavaScript语法\n循环语句\n1、while循环\n```javascript\nwhile (condition){\n  statements;\n}\n```\ndo...while循环\n```javascript\ndo {\n  statements;\n} while (condition);\n```\n  2、for循环\n```javascript\nfor (initial condition; test condition; alter condition){\n  statements;\n}\n```\n\n函数\n1、变量的作用域\n全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。\n局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。\n\n对象\n对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :\n-属性是隶属于某个特定对象的变量\n-方法是只有某个特定对象才能调用的函数\n对象就是由一些属性和方法组合在一起而构成的一个数据实体\n\n1、用户定义对象(user-defined object)\n由程序员自行创建的对象\n\n2、内建对象(native object)\nJavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object) \nArray、Math、Date等\n\n3、宿主对象(host object)\n由浏览器提供的预定义对象被称为宿主对象(host object ) \n宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息\n\n#### DOM\n1、文档:DOM中的'D'\n如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象\n\n2、对象:DOM中的'O'\n如上对象\n\n3、模型:DOM中的'M'\nDOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图\n\n4、节点\n(1)元素节点\n(2)文本节点\n(3)属性节点\n(4)CSS\n(5)获取元素\n-getElementById 返回一个对象\n-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点\n```javascript\nvar shopping = document.getElementById(\"purchases\") ;\nvar items = shopping.getElementsByTagName(\"*\") ;\n```\n-getElementsByClassName 返回一个对象数组\n使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可\n注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。\n```javascript\nvar shopping = document.getElementById(\"purchases\");\nvar sales = shopping.getElementsByClassName(\"sale\");\n```\n\n5、获取和设置属性\n(1)getAttribute 只能通过元素节点调用\n(2)setAttribute 只能通过元素节点调用，修改属性值\n细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。\n\n#### 案例研究：JavaScript图片库\nDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。\n1、childNodes属性 用来获取任何一个元素的所有子元素\n2、nodeType属性 共有12中可取值\n以下3种具有实用价值：\n-元素节点的nodeType属性值是1\n-属性节点的nodeType属性值是2\n-文本节点的nodeType属性值是3\n3、nodeValue属性 得到和设置节点的值\n4、firstChild和lastChild\n\n#### 最佳实践\n1、平稳退化\n平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成\n2、“javascript:”伪协议\n“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议\n“javascript:”伪协议让我们通过一个链接来调用JavaScript函数\n```javascript\n<a href=\"javascript:popUp('http://www.example.com/');\">Example</a>\n```\n3、CSS\n结构与样式分离\n渐进增强，用一些额外的信息层去包裹原始数据\n4、分离javascript\n5、向后兼容\n(1)对象检测：检测浏览器对JavaScript的支持程度\n(2)浏览器嗅探技术\n通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。\n首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息\n其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长\n最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本\n6、性能考虑\n(1)尽量少访问DOM和尽量减少标记\n(2)合并和放置脚本\n多个脚本合并，减少请求次数\n把所有/<script/>标签都放到文档的末尾，/</body/>标记之前，就可以让页面变得更快\n(3)压缩脚本\n压缩工具：\n-Douglas Crockford的JSMin (http://www.crockford.com/javascript/jsmin.html)\n-雅虎的YUI Compressor (http://developer.yahoo.com/yui/compressor)\n-谷歌的Closure Compiler (http://closure-compiler.appspot.com/home)\n\n#### 动态创建标记\n1、document.write & innerHTML属性\n2、DOM方法\n(1)createElement\n(1)appendChild\n(1)createTextNode\n(1)insertBefore\n3、Ajax\n(1)XMLHttpRequest对象\n```javascript\nfunction getHTTPObject () {\n  if (typeof XMLHttpRequest == \"undefined\") xMLHttpRequest =function () {\n    try { return new Activexobject ( \"Msxm12.XMLHTTP.6.0\"); )catch (e) { }\n    try { return new ActivexObject (\"Msxm12.XMLHTTP.3.0\");)catch (e) { }\n    try { return new ActivexObject ( \"Msxm12.XMLHTTP\"); )catch (e) { }\n    return false;\n  }\n  return new XMLHttpRequest ( ) ;\n}\n```\n\nXHTML5\n本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。\n\n#### CSS-DOM\n1、三位一体的网页\n(1)结构层\n网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建\n(2)表示层\n表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现\n(3)行为层\n行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域\n(4)分离\n-使用(X)HTML去搭建文档的结构\n-使用CSS去设置文档的呈现效果\n-使用DOM脚本去实现文档的行为\n2、style属性\n在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此\nstyle对象只包含在HTML代码里用style属性声明的样式\n3、何时该使用DOM脚本设置样式\n(1)根据元素在节点树里的位置来设置样式\n(2)根据某种条件反复设置某种样式\n(3)响应事件\n4、className属性\n\n#### HTML5\n1、canvas\n2、video和audio\n\n疑问点：\n1、遇到的知识点觉得掌握了，没有记录，后面又忘了\n重要的知识点都记录，不管有没有掌握\n2、任务拆分评估时间不准\n更深入的了解项目代码和业务逻辑\n3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？\n先记录继续阅读，看后面是否有解答\n4、原型链\n不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承\n理解知识的时候，不要添加太多概念，避免混乱","slug":"17-about-dom","published":1,"updated":"2022-08-30T10:54:33.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwo000hckttflhn336g","content":"<h4 id=\"JavaScript简史\"><a href=\"#JavaScript简史\" class=\"headerlink\" title=\"JavaScript简史\"></a>JavaScript简史</h4><p>1、DOM<br>DOM是一套对文档的内容进行抽象和概念化的方法。</p>\n<p>第0级DOM(DOM Level 0)<br>试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。</p>\n<p>第1级DMO(DOM Level 1)<br>Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。</p>\n<p>2、浏览器战争<br>2.1 DHTML<br>DHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:<br>(1)利用HTML把网页标记为各种元素;<br>(2)利用CSS设置元素样式和它们的显示位置;<br>(3)利用JavaScript实时地操控页面和改变样式。</p>\n<h4 id=\"JavaScript语法\"><a href=\"#JavaScript语法\" class=\"headerlink\" title=\"JavaScript语法\"></a>JavaScript语法</h4><p>循环语句<br>1、while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>do…while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (condition);</span><br></pre></td></tr></table></figure>\n<p>  2、for循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (initial condition; test condition; alter condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数<br>1、变量的作用域<br>全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。<br>局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。</p>\n<p>对象<br>对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :<br>-属性是隶属于某个特定对象的变量<br>-方法是只有某个特定对象才能调用的函数<br>对象就是由一些属性和方法组合在一起而构成的一个数据实体</p>\n<p>1、用户定义对象(user-defined object)<br>由程序员自行创建的对象</p>\n<p>2、内建对象(native object)<br>JavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object)<br>Array、Math、Date等</p>\n<p>3、宿主对象(host object)<br>由浏览器提供的预定义对象被称为宿主对象(host object )<br>宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息</p>\n<h4 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h4><p>1、文档:DOM中的’D’<br>如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象</p>\n<p>2、对象:DOM中的’O’<br>如上对象</p>\n<p>3、模型:DOM中的’M’<br>DOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图</p>\n<p>4、节点<br>(1)元素节点<br>(2)文本节点<br>(3)属性节点<br>(4)CSS<br>(5)获取元素<br>-getElementById 返回一个对象<br>-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>) ;</span><br><span class=\"line\"><span class=\"keyword\">var</span> items = shopping.getElementsByTagName(<span class=\"string\">&quot;*&quot;</span>) ;</span><br></pre></td></tr></table></figure>\n<p>-getElementsByClassName 返回一个对象数组<br>使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可<br>注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sales = shopping.getElementsByClassName(<span class=\"string\">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>5、获取和设置属性<br>(1)getAttribute 只能通过元素节点调用<br>(2)setAttribute 只能通过元素节点调用，修改属性值<br>细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。</p>\n<h4 id=\"案例研究：JavaScript图片库\"><a href=\"#案例研究：JavaScript图片库\" class=\"headerlink\" title=\"案例研究：JavaScript图片库\"></a>案例研究：JavaScript图片库</h4><p>DOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。<br>1、childNodes属性 用来获取任何一个元素的所有子元素<br>2、nodeType属性 共有12中可取值<br>以下3种具有实用价值：<br>-元素节点的nodeType属性值是1<br>-属性节点的nodeType属性值是2<br>-文本节点的nodeType属性值是3<br>3、nodeValue属性 得到和设置节点的值<br>4、firstChild和lastChild</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>1、平稳退化<br>平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成<br>2、“javascript:”伪协议<br>“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议<br>“javascript:”伪协议让我们通过一个链接来调用JavaScript函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;javascript:popUp(&#x27;http://www.example.com/&#x27;);&quot;</span>&gt;Example&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>3、CSS<br>结构与样式分离<br>渐进增强，用一些额外的信息层去包裹原始数据<br>4、分离javascript<br>5、向后兼容<br>(1)对象检测：检测浏览器对JavaScript的支持程度<br>(2)浏览器嗅探技术<br>通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。<br>首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息<br>其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长<br>最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本<br>6、性能考虑<br>(1)尽量少访问DOM和尽量减少标记<br>(2)合并和放置脚本<br>多个脚本合并，减少请求次数<br>把所有/<script>标签都放到文档的末尾，/&lt;/body/&gt;标记之前，就可以让页面变得更快<br>(3)压缩脚本<br>压缩工具：<br>-Douglas Crockford的JSMin (<a href=\"http://www.crockford.com/javascript/jsmin.html\">http://www.crockford.com/javascript/jsmin.html</a>)<br>-雅虎的YUI Compressor (<a href=\"http://developer.yahoo.com/yui/compressor\">http://developer.yahoo.com/yui/compressor</a>)<br>-谷歌的Closure Compiler (<a href=\"http://closure-compiler.appspot.com/home\">http://closure-compiler.appspot.com/home</a>)</p>\n<h4 id=\"动态创建标记\"><a href=\"#动态创建标记\" class=\"headerlink\" title=\"动态创建标记\"></a>动态创建标记</h4><p>1、document.write &amp; innerHTML属性<br>2、DOM方法<br>(1)createElement<br>(1)appendChild<br>(1)createTextNode<br>(1)insertBefore<br>3、Ajax<br>(1)XMLHttpRequest对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHTTPObject</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> XMLHttpRequest == <span class=\"string\">&quot;undefined&quot;</span>) xMLHttpRequest =<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Activexobject ( <span class=\"string\">&quot;Msxm12.XMLHTTP.6.0&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject (<span class=\"string\">&quot;Msxm12.XMLHTTP.3.0&quot;</span>);)<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject ( <span class=\"string\">&quot;Msxm12.XMLHTTP&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> XMLHttpRequest ( ) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XHTML5<br>本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。</p>\n<h4 id=\"CSS-DOM\"><a href=\"#CSS-DOM\" class=\"headerlink\" title=\"CSS-DOM\"></a>CSS-DOM</h4><p>1、三位一体的网页<br>(1)结构层<br>网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建<br>(2)表示层<br>表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现<br>(3)行为层<br>行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域<br>(4)分离<br>-使用(X)HTML去搭建文档的结构<br>-使用CSS去设置文档的呈现效果<br>-使用DOM脚本去实现文档的行为<br>2、style属性<br>在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此<br>style对象只包含在HTML代码里用style属性声明的样式<br>3、何时该使用DOM脚本设置样式<br>(1)根据元素在节点树里的位置来设置样式<br>(2)根据某种条件反复设置某种样式<br>(3)响应事件<br>4、className属性</p>\n<h4 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h4><p>1、canvas<br>2、video和audio</p>\n<p>疑问点：<br>1、遇到的知识点觉得掌握了，没有记录，后面又忘了<br>重要的知识点都记录，不管有没有掌握<br>2、任务拆分评估时间不准<br>更深入的了解项目代码和业务逻辑<br>3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？<br>先记录继续阅读，看后面是否有解答<br>4、原型链<br>不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承<br>理解知识的时候，不要添加太多概念，避免混乱</p>\n</script></p>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JavaScript简史\"><a href=\"#JavaScript简史\" class=\"headerlink\" title=\"JavaScript简史\"></a>JavaScript简史</h4><p>1、DOM<br>DOM是一套对文档的内容进行抽象和概念化的方法。</p>\n<p>第0级DOM(DOM Level 0)<br>试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。</p>\n<p>第1级DMO(DOM Level 1)<br>Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。</p>\n<p>2、浏览器战争<br>2.1 DHTML<br>DHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:<br>(1)利用HTML把网页标记为各种元素;<br>(2)利用CSS设置元素样式和它们的显示位置;<br>(3)利用JavaScript实时地操控页面和改变样式。</p>\n<h4 id=\"JavaScript语法\"><a href=\"#JavaScript语法\" class=\"headerlink\" title=\"JavaScript语法\"></a>JavaScript语法</h4><p>循环语句<br>1、while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>do…while循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (condition);</span><br></pre></td></tr></table></figure>\n<p>  2、for循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (initial condition; test condition; alter condition)&#123;</span><br><span class=\"line\">  statements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数<br>1、变量的作用域<br>全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。<br>局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。</p>\n<p>对象<br>对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :<br>-属性是隶属于某个特定对象的变量<br>-方法是只有某个特定对象才能调用的函数<br>对象就是由一些属性和方法组合在一起而构成的一个数据实体</p>\n<p>1、用户定义对象(user-defined object)<br>由程序员自行创建的对象</p>\n<p>2、内建对象(native object)<br>JavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object)<br>Array、Math、Date等</p>\n<p>3、宿主对象(host object)<br>由浏览器提供的预定义对象被称为宿主对象(host object )<br>宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息</p>\n<h4 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h4><p>1、文档:DOM中的’D’<br>如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象</p>\n<p>2、对象:DOM中的’O’<br>如上对象</p>\n<p>3、模型:DOM中的’M’<br>DOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图</p>\n<p>4、节点<br>(1)元素节点<br>(2)文本节点<br>(3)属性节点<br>(4)CSS<br>(5)获取元素<br>-getElementById 返回一个对象<br>-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>) ;</span><br><span class=\"line\"><span class=\"keyword\">var</span> items = shopping.getElementsByTagName(<span class=\"string\">&quot;*&quot;</span>) ;</span><br></pre></td></tr></table></figure>\n<p>-getElementsByClassName 返回一个对象数组<br>使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可<br>注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shopping = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;purchases&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sales = shopping.getElementsByClassName(<span class=\"string\">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>5、获取和设置属性<br>(1)getAttribute 只能通过元素节点调用<br>(2)setAttribute 只能通过元素节点调用，修改属性值<br>细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。</p>\n<h4 id=\"案例研究：JavaScript图片库\"><a href=\"#案例研究：JavaScript图片库\" class=\"headerlink\" title=\"案例研究：JavaScript图片库\"></a>案例研究：JavaScript图片库</h4><p>DOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。<br>1、childNodes属性 用来获取任何一个元素的所有子元素<br>2、nodeType属性 共有12中可取值<br>以下3种具有实用价值：<br>-元素节点的nodeType属性值是1<br>-属性节点的nodeType属性值是2<br>-文本节点的nodeType属性值是3<br>3、nodeValue属性 得到和设置节点的值<br>4、firstChild和lastChild</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>1、平稳退化<br>平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成<br>2、“javascript:”伪协议<br>“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议<br>“javascript:”伪协议让我们通过一个链接来调用JavaScript函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;javascript:popUp(&#x27;http://www.example.com/&#x27;);&quot;</span>&gt;Example&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>3、CSS<br>结构与样式分离<br>渐进增强，用一些额外的信息层去包裹原始数据<br>4、分离javascript<br>5、向后兼容<br>(1)对象检测：检测浏览器对JavaScript的支持程度<br>(2)浏览器嗅探技术<br>通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。<br>首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息<br>其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长<br>最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本<br>6、性能考虑<br>(1)尽量少访问DOM和尽量减少标记<br>(2)合并和放置脚本<br>多个脚本合并，减少请求次数<br>把所有/<script>标签都放到文档的末尾，/&lt;/body/&gt;标记之前，就可以让页面变得更快<br>(3)压缩脚本<br>压缩工具：<br>-Douglas Crockford的JSMin (<a href=\"http://www.crockford.com/javascript/jsmin.html\">http://www.crockford.com/javascript/jsmin.html</a>)<br>-雅虎的YUI Compressor (<a href=\"http://developer.yahoo.com/yui/compressor\">http://developer.yahoo.com/yui/compressor</a>)<br>-谷歌的Closure Compiler (<a href=\"http://closure-compiler.appspot.com/home\">http://closure-compiler.appspot.com/home</a>)</p>\n<h4 id=\"动态创建标记\"><a href=\"#动态创建标记\" class=\"headerlink\" title=\"动态创建标记\"></a>动态创建标记</h4><p>1、document.write &amp; innerHTML属性<br>2、DOM方法<br>(1)createElement<br>(1)appendChild<br>(1)createTextNode<br>(1)insertBefore<br>3、Ajax<br>(1)XMLHttpRequest对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHTTPObject</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> XMLHttpRequest == <span class=\"string\">&quot;undefined&quot;</span>) xMLHttpRequest =<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Activexobject ( <span class=\"string\">&quot;Msxm12.XMLHTTP.6.0&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject (<span class=\"string\">&quot;Msxm12.XMLHTTP.3.0&quot;</span>);)<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivexObject ( <span class=\"string\">&quot;Msxm12.XMLHTTP&quot;</span>); )<span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> XMLHttpRequest ( ) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>XHTML5<br>本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。</p>\n<h4 id=\"CSS-DOM\"><a href=\"#CSS-DOM\" class=\"headerlink\" title=\"CSS-DOM\"></a>CSS-DOM</h4><p>1、三位一体的网页<br>(1)结构层<br>网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建<br>(2)表示层<br>表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现<br>(3)行为层<br>行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域<br>(4)分离<br>-使用(X)HTML去搭建文档的结构<br>-使用CSS去设置文档的呈现效果<br>-使用DOM脚本去实现文档的行为<br>2、style属性<br>在外部样式表里声明的样式不会进入style对象，在文档的<head>部分里声明的样式也是如此<br>style对象只包含在HTML代码里用style属性声明的样式<br>3、何时该使用DOM脚本设置样式<br>(1)根据元素在节点树里的位置来设置样式<br>(2)根据某种条件反复设置某种样式<br>(3)响应事件<br>4、className属性</p>\n<h4 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h4><p>1、canvas<br>2、video和audio</p>\n<p>疑问点：<br>1、遇到的知识点觉得掌握了，没有记录，后面又忘了<br>重要的知识点都记录，不管有没有掌握<br>2、任务拆分评估时间不准<br>更深入的了解项目代码和业务逻辑<br>3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？<br>先记录继续阅读，看后面是否有解答<br>4、原型链<br>不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承<br>理解知识的时候，不要添加太多概念，避免混乱</p>\n</script></p>"},{"title":"伪数组","date":"2022-08-04T02:57:14.000Z","_content":"\n#### 概念\nArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。\n\n#### 特征\n1、具有length属性\n2、按照索引方式存储数据\n3、不具有数组的方法，如push、pop等\n![document获取的伪数组](document.png)\n\n#### 有哪些常见的伪数组\n1、function的arguments对象\n2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象\n3、上传文件是选择的file对象\n4、自定义的某些对象\n\n#### 判断一个数组是不是伪数组的方法\n1、Array.isArray\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nArray.isArray(fakeArray); // false\nArray.isArray(array); // true\n```\n2、instanceof\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nfakeArray instanceof Array; // false\narray instanceof Array; // true\n```\n\n#### 将数组转为真正数组的方法\n1、使用Array.prototype.slice.call()\n![Array.prototype.slice.call转换](prototype_call.png)\n2、使用[].slice.call()\n![slice.call转换](slice_call.png)\n3、使用Array.from()\n![array.from转换](array_from.png)\n","source":"_posts/18-fake-array.md","raw":"---\ntitle: 伪数组\ndate: 2022-08-04 10:57:14\ntags:\n---\n\n#### 概念\nArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。\n\n#### 特征\n1、具有length属性\n2、按照索引方式存储数据\n3、不具有数组的方法，如push、pop等\n![document获取的伪数组](document.png)\n\n#### 有哪些常见的伪数组\n1、function的arguments对象\n2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象\n3、上传文件是选择的file对象\n4、自定义的某些对象\n\n#### 判断一个数组是不是伪数组的方法\n1、Array.isArray\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nArray.isArray(fakeArray); // false\nArray.isArray(array); // true\n```\n2、instanceof\n```javascript\n// fakeArray表示伪数组\n// array 表示正常数组\nfakeArray instanceof Array; // false\narray instanceof Array; // true\n```\n\n#### 将数组转为真正数组的方法\n1、使用Array.prototype.slice.call()\n![Array.prototype.slice.call转换](prototype_call.png)\n2、使用[].slice.call()\n![slice.call转换](slice_call.png)\n3、使用Array.from()\n![array.from转换](array_from.png)\n","slug":"18-fake-array","published":1,"updated":"2022-08-04T07:17:36.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwp000jcktt3n3i9ak4","content":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>ArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。</p>\n<h4 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h4><p>1、具有length属性<br>2、按照索引方式存储数据<br>3、不具有数组的方法，如push、pop等<br><img src=\"/2022/08/04/18-fake-array/document.png\" alt=\"document获取的伪数组\"></p>\n<h4 id=\"有哪些常见的伪数组\"><a href=\"#有哪些常见的伪数组\" class=\"headerlink\" title=\"有哪些常见的伪数组\"></a>有哪些常见的伪数组</h4><p>1、function的arguments对象<br>2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象<br>3、上传文件是选择的file对象<br>4、自定义的某些对象</p>\n<h4 id=\"判断一个数组是不是伪数组的方法\"><a href=\"#判断一个数组是不是伪数组的方法\" class=\"headerlink\" title=\"判断一个数组是不是伪数组的方法\"></a>判断一个数组是不是伪数组的方法</h4><p>1、Array.isArray</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(fakeArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(array); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>2、instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\">fakeArray <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">array <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将数组转为真正数组的方法\"><a href=\"#将数组转为真正数组的方法\" class=\"headerlink\" title=\"将数组转为真正数组的方法\"></a>将数组转为真正数组的方法</h4><p>1、使用Array.prototype.slice.call()<br><img src=\"/2022/08/04/18-fake-array/prototype_call.png\" alt=\"Array.prototype.slice.call转换\"><br>2、使用[].slice.call()<br><img src=\"/2022/08/04/18-fake-array/slice_call.png\" alt=\"slice.call转换\"><br>3、使用Array.from()<br><img src=\"/2022/08/04/18-fake-array/array_from.png\" alt=\"array.from转换\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>ArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。</p>\n<h4 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h4><p>1、具有length属性<br>2、按照索引方式存储数据<br>3、不具有数组的方法，如push、pop等<br><img src=\"/2022/08/04/18-fake-array/document.png\" alt=\"document获取的伪数组\"></p>\n<h4 id=\"有哪些常见的伪数组\"><a href=\"#有哪些常见的伪数组\" class=\"headerlink\" title=\"有哪些常见的伪数组\"></a>有哪些常见的伪数组</h4><p>1、function的arguments对象<br>2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象<br>3、上传文件是选择的file对象<br>4、自定义的某些对象</p>\n<h4 id=\"判断一个数组是不是伪数组的方法\"><a href=\"#判断一个数组是不是伪数组的方法\" class=\"headerlink\" title=\"判断一个数组是不是伪数组的方法\"></a>判断一个数组是不是伪数组的方法</h4><p>1、Array.isArray</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(fakeArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(array); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>2、instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fakeArray表示伪数组</span></span><br><span class=\"line\"><span class=\"comment\">// array 表示正常数组</span></span><br><span class=\"line\">fakeArray <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">array <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将数组转为真正数组的方法\"><a href=\"#将数组转为真正数组的方法\" class=\"headerlink\" title=\"将数组转为真正数组的方法\"></a>将数组转为真正数组的方法</h4><p>1、使用Array.prototype.slice.call()<br><img src=\"/2022/08/04/18-fake-array/prototype_call.png\" alt=\"Array.prototype.slice.call转换\"><br>2、使用[].slice.call()<br><img src=\"/2022/08/04/18-fake-array/slice_call.png\" alt=\"slice.call转换\"><br>3、使用Array.from()<br><img src=\"/2022/08/04/18-fake-array/array_from.png\" alt=\"array.from转换\"></p>\n"},{"title":"var、const、let区别","date":"2022-03-26T13:04:12.000Z","_content":"\n#### 1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\n```javascript\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nlet声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章[let和const声明的变量到底去哪里了？](https://zhuanlan.zhihu.com/p/114128108)\n\n#### 2、","source":"_posts/2-var-const-let.md","raw":"---\ntitle: var、const、let区别\ndate: 2022-03-26 21:04:12\ntags:\n---\n\n#### 1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\n```javascript\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nlet声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章[let和const声明的变量到底去哪里了？](https://zhuanlan.zhihu.com/p/114128108)\n\n#### 2、","slug":"2-var-const-let","published":1,"updated":"2022-08-10T03:16:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwq000lcktt5j0mggzv","content":"<h4 id=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"><a href=\"#1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\" class=\"headerlink\" title=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"></a>1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,<span class=\"built_in\">window</span>.a);    <span class=\"comment\">// 100 100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b,<span class=\"built_in\">window</span>.b);    <span class=\"comment\">// 10 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c,<span class=\"built_in\">window</span>.c);    <span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure>\n<p>let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章<a href=\"https://zhuanlan.zhihu.com/p/114128108\">let和const声明的变量到底去哪里了？</a></p>\n<h4 id=\"2、\"><a href=\"#2、\" class=\"headerlink\" title=\"2、\"></a>2、</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"><a href=\"#1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\" class=\"headerlink\" title=\"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会\"></a>1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,<span class=\"built_in\">window</span>.a);    <span class=\"comment\">// 100 100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b,<span class=\"built_in\">window</span>.b);    <span class=\"comment\">// 10 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c,<span class=\"built_in\">window</span>.c);    <span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure>\n<p>let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章<a href=\"https://zhuanlan.zhihu.com/p/114128108\">let和const声明的变量到底去哪里了？</a></p>\n<h4 id=\"2、\"><a href=\"#2、\" class=\"headerlink\" title=\"2、\"></a>2、</h4>"},{"title":"Map 结构","date":"2022-08-04T06:07:12.000Z","_content":"\n#### 什么是Map?\n由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。\n\n#### 怎么创建map？\n```javascript\nconst map = new Map();\n```\nmap可以使用一个对象作为键\n```javascript\nconst map = new Map();\nconst o = { p: 'string' };\n\nmap.set(o, 'text');\nmap.get(o); // text\n\nmap.has(o); // true\nmap.delete(o);\n```\nmap还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组\n```javascript\nconst map = new Map([['name', 'Tom'], ['age', 12]]);\nmap.size; // 2\nmap.has('name'); // true\nmap.get('age'); // 12\n```\n\n##### 注意点\n如果对同一个键多次赋值，后面的值将覆盖前面的值\n```javascript\nmap.set(1, 'qw').set(1, 'sdf');\nmap.get(1); // sdf\n```\n\n#### map的实例属性和方法\n1、size\n用法：map.size\n作用：获取map结构的大小\n返回：map结构的长度大小\n```javascript\nconst map = new Map();\nmap.size; // 0\nmap.set(1, 12);\nmap.size; // 1\n```\n\n2、set()\n用法：map.set(key, value)\n作用：向map中添加或修改map的数据\n返回：修改后的map\n```javascript\nconst map = new Map();\nmap.set(1, 12);\n```\n\n3、get()\n用法：map.get(key)\n作用：获取对应key的value值\n返回：map结构中key对应的值，不存在对应key时，返回undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.get(1); // 12\nmap.get(2); // undefined\n```\n\n4、has()\n用法：map.has(key)\n作用：判断map中是否有对应的key\n返回：true/false，依据map中是否有对应的key，返回true或false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.has(1); // true\nmap.has(2); // has\n```\n\n5、delete()\n用法：map.delete(key)\n作用：删除map中对应的key及value\n返回：true/false，删除成功返回true，删除失败返回false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.delete(1); // true\nmap.delete(2); // false\n```\n\n6、clear()\n用法：map.clear()\n作用：清空map中的数据\n返回：undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.clear(); // undefined\n```\n\n#### map的遍历方法\n1、keys()\n2、values()\n3、entries()\n4、forEach()\n\n参考：https://www.jianshu.com/p/93b5a5940de8","source":"_posts/19-about-map.md","raw":"---\ntitle: Map 结构\ndate: 2022-08-04 14:07:12\ntags:\n---\n\n#### 什么是Map?\n由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。\n\n#### 怎么创建map？\n```javascript\nconst map = new Map();\n```\nmap可以使用一个对象作为键\n```javascript\nconst map = new Map();\nconst o = { p: 'string' };\n\nmap.set(o, 'text');\nmap.get(o); // text\n\nmap.has(o); // true\nmap.delete(o);\n```\nmap还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组\n```javascript\nconst map = new Map([['name', 'Tom'], ['age', 12]]);\nmap.size; // 2\nmap.has('name'); // true\nmap.get('age'); // 12\n```\n\n##### 注意点\n如果对同一个键多次赋值，后面的值将覆盖前面的值\n```javascript\nmap.set(1, 'qw').set(1, 'sdf');\nmap.get(1); // sdf\n```\n\n#### map的实例属性和方法\n1、size\n用法：map.size\n作用：获取map结构的大小\n返回：map结构的长度大小\n```javascript\nconst map = new Map();\nmap.size; // 0\nmap.set(1, 12);\nmap.size; // 1\n```\n\n2、set()\n用法：map.set(key, value)\n作用：向map中添加或修改map的数据\n返回：修改后的map\n```javascript\nconst map = new Map();\nmap.set(1, 12);\n```\n\n3、get()\n用法：map.get(key)\n作用：获取对应key的value值\n返回：map结构中key对应的值，不存在对应key时，返回undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.get(1); // 12\nmap.get(2); // undefined\n```\n\n4、has()\n用法：map.has(key)\n作用：判断map中是否有对应的key\n返回：true/false，依据map中是否有对应的key，返回true或false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.has(1); // true\nmap.has(2); // has\n```\n\n5、delete()\n用法：map.delete(key)\n作用：删除map中对应的key及value\n返回：true/false，删除成功返回true，删除失败返回false\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.delete(1); // true\nmap.delete(2); // false\n```\n\n6、clear()\n用法：map.clear()\n作用：清空map中的数据\n返回：undefined\n```javascript\nconst map = new Map();\nmap.set(1, 12);\nmap.clear(); // undefined\n```\n\n#### map的遍历方法\n1、keys()\n2、values()\n3、entries()\n4、forEach()\n\n参考：https://www.jianshu.com/p/93b5a5940de8","slug":"19-about-map","published":1,"updated":"2022-08-04T07:31:23.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwr000ncktt2g0h5b6p","content":"<h4 id=\"什么是Map\"><a href=\"#什么是Map\" class=\"headerlink\" title=\"什么是Map?\"></a>什么是Map?</h4><p>由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。</p>\n<h4 id=\"怎么创建map？\"><a href=\"#怎么创建map？\" class=\"headerlink\" title=\"怎么创建map？\"></a>怎么创建map？</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure>\n<p>map可以使用一个对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123; <span class=\"attr\">p</span>: <span class=\"string\">&#x27;string&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(o, <span class=\"string\">&#x27;text&#x27;</span>);</span><br><span class=\"line\">map.get(o); <span class=\"comment\">// text</span></span><br><span class=\"line\"></span><br><span class=\"line\">map.has(o); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(o);</span><br></pre></td></tr></table></figure>\n<p>map还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>], [<span class=\"string\">&#x27;age&#x27;</span>, <span class=\"number\">12</span>]]);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.has(<span class=\"string\">&#x27;name&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&#x27;age&#x27;</span>); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><p>如果对同一个键多次赋值，后面的值将覆盖前面的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;qw&#x27;</span>).set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;sdf&#x27;</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// sdf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的实例属性和方法\"><a href=\"#map的实例属性和方法\" class=\"headerlink\" title=\"map的实例属性和方法\"></a>map的实例属性和方法</h4><p>1、size<br>用法：map.size<br>作用：获取map结构的大小<br>返回：map结构的长度大小</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>2、set()<br>用法：map.set(key, value)<br>作用：向map中添加或修改map的数据<br>返回：修改后的map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>3、get()<br>用法：map.get(key)<br>作用：获取对应key的value值<br>返回：map结构中key对应的值，不存在对应key时，返回undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// 12</span></span><br><span class=\"line\">map.get(<span class=\"number\">2</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>4、has()<br>用法：map.has(key)<br>作用：判断map中是否有对应的key<br>返回：true/false，依据map中是否有对应的key，返回true或false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.has(<span class=\"number\">2</span>); <span class=\"comment\">// has</span></span><br></pre></td></tr></table></figure>\n\n<p>5、delete()<br>用法：map.delete(key)<br>作用：删除map中对应的key及value<br>返回：true/false，删除成功返回true，删除失败返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.delete(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(<span class=\"number\">2</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>6、clear()<br>用法：map.clear()<br>作用：清空map中的数据<br>返回：undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.clear(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的遍历方法\"><a href=\"#map的遍历方法\" class=\"headerlink\" title=\"map的遍历方法\"></a>map的遍历方法</h4><p>1、keys()<br>2、values()<br>3、entries()<br>4、forEach()</p>\n<p>参考：<a href=\"https://www.jianshu.com/p/93b5a5940de8\">https://www.jianshu.com/p/93b5a5940de8</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Map\"><a href=\"#什么是Map\" class=\"headerlink\" title=\"什么是Map?\"></a>什么是Map?</h4><p>由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。</p>\n<h4 id=\"怎么创建map？\"><a href=\"#怎么创建map？\" class=\"headerlink\" title=\"怎么创建map？\"></a>怎么创建map？</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure>\n<p>map可以使用一个对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123; <span class=\"attr\">p</span>: <span class=\"string\">&#x27;string&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(o, <span class=\"string\">&#x27;text&#x27;</span>);</span><br><span class=\"line\">map.get(o); <span class=\"comment\">// text</span></span><br><span class=\"line\"></span><br><span class=\"line\">map.has(o); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(o);</span><br></pre></td></tr></table></figure>\n<p>map还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;Tom&#x27;</span>], [<span class=\"string\">&#x27;age&#x27;</span>, <span class=\"number\">12</span>]]);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.has(<span class=\"string\">&#x27;name&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&#x27;age&#x27;</span>); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><p>如果对同一个键多次赋值，后面的值将覆盖前面的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;qw&#x27;</span>).set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;sdf&#x27;</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// sdf</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的实例属性和方法\"><a href=\"#map的实例属性和方法\" class=\"headerlink\" title=\"map的实例属性和方法\"></a>map的实例属性和方法</h4><p>1、size<br>用法：map.size<br>作用：获取map结构的大小<br>返回：map结构的长度大小</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.size; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>2、set()<br>用法：map.set(key, value)<br>作用：向map中添加或修改map的数据<br>返回：修改后的map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>3、get()<br>用法：map.get(key)<br>作用：获取对应key的value值<br>返回：map结构中key对应的值，不存在对应key时，返回undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.get(<span class=\"number\">1</span>); <span class=\"comment\">// 12</span></span><br><span class=\"line\">map.get(<span class=\"number\">2</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>4、has()<br>用法：map.has(key)<br>作用：判断map中是否有对应的key<br>返回：true/false，依据map中是否有对应的key，返回true或false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.has(<span class=\"number\">2</span>); <span class=\"comment\">// has</span></span><br></pre></td></tr></table></figure>\n\n<p>5、delete()<br>用法：map.delete(key)<br>作用：删除map中对应的key及value<br>返回：true/false，删除成功返回true，删除失败返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.delete(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.delete(<span class=\"number\">2</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>6、clear()<br>用法：map.clear()<br>作用：清空map中的数据<br>返回：undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">map.clear(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"map的遍历方法\"><a href=\"#map的遍历方法\" class=\"headerlink\" title=\"map的遍历方法\"></a>map的遍历方法</h4><p>1、keys()<br>2、values()<br>3、entries()<br>4、forEach()</p>\n<p>参考：<a href=\"https://www.jianshu.com/p/93b5a5940de8\">https://www.jianshu.com/p/93b5a5940de8</a></p>\n"},{"title":"开发一个vscode插件的流程","date":"2022-08-05T02:33:23.000Z","_content":"\n#### vscode中文手册\nhttps://www.bookstack.cn/read/CN-VScode-Docs/README.md\n\n#### vscode插件脚手架\n安装脚手架和代码生成器\n```javascript\nnpm install -g yo generator-code\n```\n生成vscode脚手架项目\n```javascript\nyo code\n```","source":"_posts/20-create-vscode-plugin.md","raw":"---\ntitle: 开发一个vscode插件的流程\ndate: 2022-08-05 10:33:23\ntags:\n---\n\n#### vscode中文手册\nhttps://www.bookstack.cn/read/CN-VScode-Docs/README.md\n\n#### vscode插件脚手架\n安装脚手架和代码生成器\n```javascript\nnpm install -g yo generator-code\n```\n生成vscode脚手架项目\n```javascript\nyo code\n```","slug":"20-create-vscode-plugin","published":1,"updated":"2022-08-05T06:08:56.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gws000pcktth471g859","content":"<h4 id=\"vscode中文手册\"><a href=\"#vscode中文手册\" class=\"headerlink\" title=\"vscode中文手册\"></a>vscode中文手册</h4><p><a href=\"https://www.bookstack.cn/read/CN-VScode-Docs/README.md\">https://www.bookstack.cn/read/CN-VScode-Docs/README.md</a></p>\n<h4 id=\"vscode插件脚手架\"><a href=\"#vscode插件脚手架\" class=\"headerlink\" title=\"vscode插件脚手架\"></a>vscode插件脚手架</h4><p>安装脚手架和代码生成器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g yo generator-code</span><br></pre></td></tr></table></figure>\n<p>生成vscode脚手架项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yo code</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"vscode中文手册\"><a href=\"#vscode中文手册\" class=\"headerlink\" title=\"vscode中文手册\"></a>vscode中文手册</h4><p><a href=\"https://www.bookstack.cn/read/CN-VScode-Docs/README.md\">https://www.bookstack.cn/read/CN-VScode-Docs/README.md</a></p>\n<h4 id=\"vscode插件脚手架\"><a href=\"#vscode插件脚手架\" class=\"headerlink\" title=\"vscode插件脚手架\"></a>vscode插件脚手架</h4><p>安装脚手架和代码生成器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g yo generator-code</span><br></pre></td></tr></table></figure>\n<p>生成vscode脚手架项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yo code</span><br></pre></td></tr></table></figure>"},{"title":"装箱拆箱操作","date":"2022-08-09T05:43:57.000Z","_content":"\n我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：'hello world'.length。这是由于浏览器在内部做了装箱和拆箱操作。\n\n#### 什么是装箱拆箱？\n装箱：把基本数据类型转化为对应的引用类型的操作\n拆箱：把引用类型转化为基本数据类型的操作\n\n基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol\n引用数据类型：对象(Object)、数组(Array)、函数(Function)\n四个基本的包装类型 String、Number、Boolean、Symbol\n\n什么是包装类型？\n在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型\n\n#### 装箱\n装箱分为显式装箱和隐式装箱\n\n###### 显式装箱\n通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据\n```JavaScript\nvar string = new String('test_string');\nvar number = new Number(1);\n```\n显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中\n```JavaScript\nvar string = new String('test_string');\nstring.name = 'for test';\nstring.sayHi = function(){\n    console.log('this is test string');\n}\nconsole.log(string.name); // for test\nstring.sayHi(); // this is test string\n```\n\n###### 隐式装箱\n隐式装箱是引擎自动执行的\n基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：'test_string'.substring()、'test_string'.indexOf()等，这是由于浏览器在内部做了隐式装箱。\n\n下面以一个例子进行说明：\n```JavaScript\n// 第一步\nvar string = 'test_string';\n// 第二步\nvar result = string.substring(4);\nconsole.log(result); // _string\n```\n在上面这段代码里面实际的执行步骤是：\n1、先创建一个String类型的一个实例\n2、在实例中调用方法\n3、销毁这个实例\n```JavaScript\nvar string = 'test_string';\n// 1\nvar newString = new String(string);\n// 2\nvar result = newString.substring(4);\n// 3\nnewString = null;\n```\n基于以上的隐式装箱操作，我们可以在基本类型上使用方法\n隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了\n\n\n显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法\n\n引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。\n#### 拆箱\n拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。\n需要注意的是，toString() 和 valueOf() 返回的值有一定差别\n```JavaScript\nvar numberObj = new Number(64);\nvar stringObj = new String('64');\nconsole.log(typeof numberObj); // object\nconsole.log(typeof stringObj); // object\n// 拆箱\nconsole.log(numberObj.valueOf()); // 64\nconsole.log(typeof numberObj.valueOf()); // number 基本的数字类型\nconsole.log(numberObj.toString()); // '64'\nconsole.log(typeof numberObj.toString()); // string 基本的字符类型\n\nconsole.log(stringObj.valueOf()); // '64'\nconsole.log(typeof stringObj.valueOf()); // string 基本的数据类型\nconsole.log(stringObj.toString()); // '64'\nconsole.log(typeof stringObj.toString()); // string 基本的数据类型\n```\n在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。\n\n这里简单介绍一下Symbol，感兴趣的可以自己去学习。\n\n###### Symbol\nSymbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突\n创建Symbol\n```JavaScript\nlet sym1 = Symbol();\nlet sym2 = Symbol('sym');\n```\n注意：\n1、每次调用Symbol都会创建新的symbol\n2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）\n3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身\n4、创建Symbol包装器对象，可以使用Object()函数\n```JavaScript\n// 1\nSymbol('sym') === Symbol('sym'); // false\n// 2\nlet sym = new Symbol(); // TypeError: Symbol is not a constructor\n// 4\nlet sym2 = Symbol('sym');\ntypeof sym2; // 'symbol'\nlet sym2Obj = Object(sym2);\ntypeof sym2Obj; // 'object'\n```\n在[symbol的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)中，有一个属性[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)。文档中关于它的介绍是：\n\nSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 \"number\"、\"string\" 和 \"default\" 中的任意一个。\n\n我们看一下这个属性是怎么干扰一个对象转换为原始值的\n```JavaScript\n// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果\nvar obj1 = {};\nconsole.log(+obj1);     // NaN\nconsole.log(`${obj1}`); // \"[object Object]\"\nconsole.log(obj1 + \"\"); // \"[object Object]\"\n\n// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果\nvar obj2 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint == \"number\") {\n      return 10;\n    }\n    if (hint == \"string\") {\n      return \"hello\";\n    }\n    return true;\n  }\n};\nconsole.log(+obj2);     // 10      -- hint 参数值是 \"number\"\nconsole.log(`${obj2}`); // \"hello\" -- hint 参数值是 \"string\"\nconsole.log(obj2 + \"\"); // \"true\"  -- hint 参数值是 \"default\"\n```\n注意：\nhint 取值为：\n'number':该场合需要转成数值，\n'string':该场合需要转成字符串，\n'default':该场合可以转成数值，也可以转成字符串。\n\n#### 对象转换成原始值的方法及执行顺序\n以下优先级从上到下依次降低\n1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法\n2、如果预期被转化成字符串类型时，则优先执行toString()方法\n3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法\n注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法\n```JavaScript\nvar obj = {\n  [Symbol.toPrimitive](hint) {\n    console.log(hint);\n    return 'symbol';\n  },\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj)); // string symbol\nconsole.log(Number(obj)); // number NaN\n\nvar obj1 = {\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj1)); // string\nconsole.log(Number(obj1)); // NaN\n\nvar obj2 = {\n  toString() {\n    return '1';\n  },\n};\nconsole.log(String(obj2)); // '1'\nconsole.log(Number(obj2)); // 1\n\nvar obj3 = {\n  valueOf() {\n    return '2';\n  }\n};\nconsole.log(Number(obj3)); // 2\nconsole.log(String(obj3)); // [object Object]\n```","source":"_posts/21-devan-operation.md","raw":"---\ntitle: 装箱拆箱操作\ndate: 2022-08-09 13:43:57\ntags:\n---\n\n我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：'hello world'.length。这是由于浏览器在内部做了装箱和拆箱操作。\n\n#### 什么是装箱拆箱？\n装箱：把基本数据类型转化为对应的引用类型的操作\n拆箱：把引用类型转化为基本数据类型的操作\n\n基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol\n引用数据类型：对象(Object)、数组(Array)、函数(Function)\n四个基本的包装类型 String、Number、Boolean、Symbol\n\n什么是包装类型？\n在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型\n\n#### 装箱\n装箱分为显式装箱和隐式装箱\n\n###### 显式装箱\n通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据\n```JavaScript\nvar string = new String('test_string');\nvar number = new Number(1);\n```\n显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中\n```JavaScript\nvar string = new String('test_string');\nstring.name = 'for test';\nstring.sayHi = function(){\n    console.log('this is test string');\n}\nconsole.log(string.name); // for test\nstring.sayHi(); // this is test string\n```\n\n###### 隐式装箱\n隐式装箱是引擎自动执行的\n基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：'test_string'.substring()、'test_string'.indexOf()等，这是由于浏览器在内部做了隐式装箱。\n\n下面以一个例子进行说明：\n```JavaScript\n// 第一步\nvar string = 'test_string';\n// 第二步\nvar result = string.substring(4);\nconsole.log(result); // _string\n```\n在上面这段代码里面实际的执行步骤是：\n1、先创建一个String类型的一个实例\n2、在实例中调用方法\n3、销毁这个实例\n```JavaScript\nvar string = 'test_string';\n// 1\nvar newString = new String(string);\n// 2\nvar result = newString.substring(4);\n// 3\nnewString = null;\n```\n基于以上的隐式装箱操作，我们可以在基本类型上使用方法\n隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了\n\n\n显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法\n\n引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。\n#### 拆箱\n拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。\n需要注意的是，toString() 和 valueOf() 返回的值有一定差别\n```JavaScript\nvar numberObj = new Number(64);\nvar stringObj = new String('64');\nconsole.log(typeof numberObj); // object\nconsole.log(typeof stringObj); // object\n// 拆箱\nconsole.log(numberObj.valueOf()); // 64\nconsole.log(typeof numberObj.valueOf()); // number 基本的数字类型\nconsole.log(numberObj.toString()); // '64'\nconsole.log(typeof numberObj.toString()); // string 基本的字符类型\n\nconsole.log(stringObj.valueOf()); // '64'\nconsole.log(typeof stringObj.valueOf()); // string 基本的数据类型\nconsole.log(stringObj.toString()); // '64'\nconsole.log(typeof stringObj.toString()); // string 基本的数据类型\n```\n在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。\n\n这里简单介绍一下Symbol，感兴趣的可以自己去学习。\n\n###### Symbol\nSymbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突\n创建Symbol\n```JavaScript\nlet sym1 = Symbol();\nlet sym2 = Symbol('sym');\n```\n注意：\n1、每次调用Symbol都会创建新的symbol\n2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）\n3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身\n4、创建Symbol包装器对象，可以使用Object()函数\n```JavaScript\n// 1\nSymbol('sym') === Symbol('sym'); // false\n// 2\nlet sym = new Symbol(); // TypeError: Symbol is not a constructor\n// 4\nlet sym2 = Symbol('sym');\ntypeof sym2; // 'symbol'\nlet sym2Obj = Object(sym2);\ntypeof sym2Obj; // 'object'\n```\n在[symbol的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)中，有一个属性[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)。文档中关于它的介绍是：\n\nSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 \"number\"、\"string\" 和 \"default\" 中的任意一个。\n\n我们看一下这个属性是怎么干扰一个对象转换为原始值的\n```JavaScript\n// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果\nvar obj1 = {};\nconsole.log(+obj1);     // NaN\nconsole.log(`${obj1}`); // \"[object Object]\"\nconsole.log(obj1 + \"\"); // \"[object Object]\"\n\n// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果\nvar obj2 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint == \"number\") {\n      return 10;\n    }\n    if (hint == \"string\") {\n      return \"hello\";\n    }\n    return true;\n  }\n};\nconsole.log(+obj2);     // 10      -- hint 参数值是 \"number\"\nconsole.log(`${obj2}`); // \"hello\" -- hint 参数值是 \"string\"\nconsole.log(obj2 + \"\"); // \"true\"  -- hint 参数值是 \"default\"\n```\n注意：\nhint 取值为：\n'number':该场合需要转成数值，\n'string':该场合需要转成字符串，\n'default':该场合可以转成数值，也可以转成字符串。\n\n#### 对象转换成原始值的方法及执行顺序\n以下优先级从上到下依次降低\n1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法\n2、如果预期被转化成字符串类型时，则优先执行toString()方法\n3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法\n注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法\n```JavaScript\nvar obj = {\n  [Symbol.toPrimitive](hint) {\n    console.log(hint);\n    return 'symbol';\n  },\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj)); // string symbol\nconsole.log(Number(obj)); // number NaN\n\nvar obj1 = {\n  toString() {\n    return 'string';\n  },\n  valueOf() {\n    return 'valueOf';\n  }\n};\nconsole.log(String(obj1)); // string\nconsole.log(Number(obj1)); // NaN\n\nvar obj2 = {\n  toString() {\n    return '1';\n  },\n};\nconsole.log(String(obj2)); // '1'\nconsole.log(Number(obj2)); // 1\n\nvar obj3 = {\n  valueOf() {\n    return '2';\n  }\n};\nconsole.log(Number(obj3)); // 2\nconsole.log(String(obj3)); // [object Object]\n```","slug":"21-devan-operation","published":1,"updated":"2022-08-18T07:29:53.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwt000rcktt5qkp6b3l","content":"<p>我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。</p>\n<h4 id=\"什么是装箱拆箱？\"><a href=\"#什么是装箱拆箱？\" class=\"headerlink\" title=\"什么是装箱拆箱？\"></a>什么是装箱拆箱？</h4><p>装箱：把基本数据类型转化为对应的引用类型的操作<br>拆箱：把引用类型转化为基本数据类型的操作</p>\n<p>基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)<br>四个基本的包装类型 String、Number、Boolean、Symbol</p>\n<p>什么是包装类型？<br>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型</p>\n<h4 id=\"装箱\"><a href=\"#装箱\" class=\"headerlink\" title=\"装箱\"></a>装箱</h4><p>装箱分为显式装箱和隐式装箱</p>\n<h6 id=\"显式装箱\"><a href=\"#显式装箱\" class=\"headerlink\" title=\"显式装箱\"></a>显式装箱</h6><p>通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\">string.name = <span class=\"string\">&#x27;for test&#x27;</span>;</span><br><span class=\"line\">string.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;this is test string&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.name); <span class=\"comment\">// for test</span></span><br><span class=\"line\">string.sayHi(); <span class=\"comment\">// this is test string</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"隐式装箱\"><a href=\"#隐式装箱\" class=\"headerlink\" title=\"隐式装箱\"></a>隐式装箱</h6><p>隐式装箱是引擎自动执行的<br>基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：’test_string’.substring()、’test_string’.indexOf()等，这是由于浏览器在内部做了隐式装箱。</p>\n<p>下面以一个例子进行说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = string.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// _string</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码里面实际的执行步骤是：<br>1、先创建一个String类型的一个实例<br>2、在实例中调用方法<br>3、销毁这个实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(string);</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = newString.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">newString = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>基于以上的隐式装箱操作，我们可以在基本类型上使用方法<br>隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了</p>\n<p>显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法</p>\n<p>引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。</p>\n<h4 id=\"拆箱\"><a href=\"#拆箱\" class=\"headerlink\" title=\"拆箱\"></a>拆箱</h4><p>拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。<br>需要注意的是，toString() 和 valueOf() 返回的值有一定差别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numberObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">64</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> stringObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;64&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"comment\">// 拆箱</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.valueOf()); <span class=\"comment\">// 64</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.valueOf()); <span class=\"comment\">// number 基本的数字类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.toString()); <span class=\"comment\">// string 基本的字符类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.valueOf()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.valueOf()); <span class=\"comment\">// string 基本的数据类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.toString()); <span class=\"comment\">// string 基本的数据类型</span></span><br></pre></td></tr></table></figure>\n<p>在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。</p>\n<p>这里简单介绍一下Symbol，感兴趣的可以自己去学习。</p>\n<h6 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h6><p>Symbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突<br>创建Symbol</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：<br>1、每次调用Symbol都会创建新的symbol<br>2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）<br>3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身<br>4、创建Symbol包装器对象，可以使用Object()函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">// TypeError: Symbol is not a constructor</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2; <span class=\"comment\">// &#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2Obj = <span class=\"built_in\">Object</span>(sym2);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2Obj; <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">symbol的文档</a>中，有一个属性<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\">Symbol.toPrimitive</a>。文档中关于它的介绍是：</p>\n<p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 “number”、”string” 和 “default” 中的任意一个。</p>\n<p>我们看一下这个属性是怎么干扰一个对象转换为原始值的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj1);     <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj1&#125;</span>`</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj2);     <span class=\"comment\">// 10      -- hint 参数值是 &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj2&#125;</span>`</span>); <span class=\"comment\">// &quot;hello&quot; -- hint 参数值是 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;true&quot;  -- hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure>\n<p>注意：<br>hint 取值为：<br>‘number’:该场合需要转成数值，<br>‘string’:该场合需要转成字符串，<br>‘default’:该场合可以转成数值，也可以转成字符串。</p>\n<h4 id=\"对象转换成原始值的方法及执行顺序\"><a href=\"#对象转换成原始值的方法及执行顺序\" class=\"headerlink\" title=\"对象转换成原始值的方法及执行顺序\"></a>对象转换成原始值的方法及执行顺序</h4><p>以下优先级从上到下依次降低<br>1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法<br>2、如果预期被转化成字符串类型时，则优先执行toString()方法<br>3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法<br>注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(hint);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;symbol&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj)); <span class=\"comment\">// string symbol</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj)); <span class=\"comment\">// number NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj1)); <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj1)); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj2)); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj2)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj3)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj3)); <span class=\"comment\">// [object Object]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。</p>\n<h4 id=\"什么是装箱拆箱？\"><a href=\"#什么是装箱拆箱？\" class=\"headerlink\" title=\"什么是装箱拆箱？\"></a>什么是装箱拆箱？</h4><p>装箱：把基本数据类型转化为对应的引用类型的操作<br>拆箱：把引用类型转化为基本数据类型的操作</p>\n<p>基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)<br>四个基本的包装类型 String、Number、Boolean、Symbol</p>\n<p>什么是包装类型？<br>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型</p>\n<h4 id=\"装箱\"><a href=\"#装箱\" class=\"headerlink\" title=\"装箱\"></a>装箱</h4><p>装箱分为显式装箱和隐式装箱</p>\n<h6 id=\"显式装箱\"><a href=\"#显式装箱\" class=\"headerlink\" title=\"显式装箱\"></a>显式装箱</h6><p>通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;test_string&#x27;</span>);</span><br><span class=\"line\">string.name = <span class=\"string\">&#x27;for test&#x27;</span>;</span><br><span class=\"line\">string.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;this is test string&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.name); <span class=\"comment\">// for test</span></span><br><span class=\"line\">string.sayHi(); <span class=\"comment\">// this is test string</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"隐式装箱\"><a href=\"#隐式装箱\" class=\"headerlink\" title=\"隐式装箱\"></a>隐式装箱</h6><p>隐式装箱是引擎自动执行的<br>基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：’test_string’.substring()、’test_string’.indexOf()等，这是由于浏览器在内部做了隐式装箱。</p>\n<p>下面以一个例子进行说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = string.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// _string</span></span><br></pre></td></tr></table></figure>\n<p>在上面这段代码里面实际的执行步骤是：<br>1、先创建一个String类型的一个实例<br>2、在实例中调用方法<br>3、销毁这个实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">&#x27;test_string&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(string);</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = newString.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">newString = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>基于以上的隐式装箱操作，我们可以在基本类型上使用方法<br>隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了</p>\n<p>显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法</p>\n<p>引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。</p>\n<h4 id=\"拆箱\"><a href=\"#拆箱\" class=\"headerlink\" title=\"拆箱\"></a>拆箱</h4><p>拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。<br>需要注意的是，toString() 和 valueOf() 返回的值有一定差别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numberObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">64</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> stringObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;64&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"comment\">// 拆箱</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.valueOf()); <span class=\"comment\">// 64</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.valueOf()); <span class=\"comment\">// number 基本的数字类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numberObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> numberObj.toString()); <span class=\"comment\">// string 基本的字符类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.valueOf()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.valueOf()); <span class=\"comment\">// string 基本的数据类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj.toString()); <span class=\"comment\">// &#x27;64&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> stringObj.toString()); <span class=\"comment\">// string 基本的数据类型</span></span><br></pre></td></tr></table></figure>\n<p>在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。</p>\n<p>这里简单介绍一下Symbol，感兴趣的可以自己去学习。</p>\n<h6 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h6><p>Symbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突<br>创建Symbol</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：<br>1、每次调用Symbol都会创建新的symbol<br>2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）<br>3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身<br>4、创建Symbol包装器对象，可以使用Object()函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">// TypeError: Symbol is not a constructor</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;sym&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2; <span class=\"comment\">// &#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2Obj = <span class=\"built_in\">Object</span>(sym2);</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> sym2Obj; <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">symbol的文档</a>中，有一个属性<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\">Symbol.toPrimitive</a>。文档中关于它的介绍是：</p>\n<p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 “number”、”string” 和 “default” 中的任意一个。</p>\n<p>我们看一下这个属性是怎么干扰一个对象转换为原始值的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj1);     <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj1&#125;</span>`</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint == <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+obj2);     <span class=\"comment\">// 10      -- hint 参数值是 &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;obj2&#125;</span>`</span>); <span class=\"comment\">// &quot;hello&quot; -- hint 参数值是 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2 + <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// &quot;true&quot;  -- hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure>\n<p>注意：<br>hint 取值为：<br>‘number’:该场合需要转成数值，<br>‘string’:该场合需要转成字符串，<br>‘default’:该场合可以转成数值，也可以转成字符串。</p>\n<h4 id=\"对象转换成原始值的方法及执行顺序\"><a href=\"#对象转换成原始值的方法及执行顺序\" class=\"headerlink\" title=\"对象转换成原始值的方法及执行顺序\"></a>对象转换成原始值的方法及执行顺序</h4><p>以下优先级从上到下依次降低<br>1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法<br>2、如果预期被转化成字符串类型时，则优先执行toString()方法<br>3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法<br>注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(hint);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;symbol&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj)); <span class=\"comment\">// string symbol</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj)); <span class=\"comment\">// number NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;valueOf&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj1)); <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj1)); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj2)); <span class=\"comment\">// &#x27;1&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj2)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">valueOf</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj3)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(obj3)); <span class=\"comment\">// [object Object]</span></span><br></pre></td></tr></table></figure>"},{"title":"JavaScript设计模式读书笔记(2)","date":"2022-09-04T13:29:09.000Z","_content":"\n#### 创建型设计模式\n创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度\n\n###### 简单工厂模式\n(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。\n![simple-factory1](simple-factory1.png)\n![simple-factory2](simple-factory2.png)\n\n(2)一个对象有时也可代替许多类\n![create-pop](create-pop.png)\n\n第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了\n\n###### 工厂方法模式\n安全模式类：可以屏蔽使用这对类的错误使用造成的错误\n![safe-model-class](safe-model-class.png)\n![safe-factory-model](safe-factory-model.png)\n\n###### 抽象工厂模式\n抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例\n\n(1)抽象类\n抽象类是一种声明但不能使用的类\n![abstract-car](abstract-car.png)\n创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类\n中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。\n\n(2)抽象工厂模式：一般用它来作为父类创建一些子类\n![abstract-factory1](abstract-factory1.png)\n![abstract-factory2](abstract-factory2.png)\n抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck\n![abstract-factory3](abstract-factory3.png)\n\n###### 建造者模式\n建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示\n\n工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。\n建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节\n![human](human.png)\n![name](name.png)\n![work](work.png)\n![person](person.png)\n\n工厂模式创建出来的是一个对象，它追求的是创建的结果\n建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象\n\n**注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象**\n\n###### 原型模式\n原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法\n\n原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法\n![prototype-model](prototype-model.png)\n原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法\n\n(1)原型继承\n原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法\n![prototype-inherit1](prototype-inherit1.png)\n![prototype-inherit2](prototype-inherit2.png)\n\n**原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现**\n\n###### 单例模式\n单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法\n\n(1)命名空间\n命名空间就是人们所说的namespace，有人也叫它名称空间。\n它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题\n\n(2)静态变量\n![static-param](static-param.png)\n\n(3)惰性单例\n![lazy-single-instance](lazy-single-instance.png)","source":"_posts/24-about-design-model1.md","raw":"---\ntitle: JavaScript设计模式读书笔记(2)\ndate: 2022-09-04 21:29:09\ntags:\n---\n\n#### 创建型设计模式\n创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度\n\n###### 简单工厂模式\n(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。\n![simple-factory1](simple-factory1.png)\n![simple-factory2](simple-factory2.png)\n\n(2)一个对象有时也可代替许多类\n![create-pop](create-pop.png)\n\n第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了\n\n###### 工厂方法模式\n安全模式类：可以屏蔽使用这对类的错误使用造成的错误\n![safe-model-class](safe-model-class.png)\n![safe-factory-model](safe-factory-model.png)\n\n###### 抽象工厂模式\n抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例\n\n(1)抽象类\n抽象类是一种声明但不能使用的类\n![abstract-car](abstract-car.png)\n创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类\n中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。\n\n(2)抽象工厂模式：一般用它来作为父类创建一些子类\n![abstract-factory1](abstract-factory1.png)\n![abstract-factory2](abstract-factory2.png)\n抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck\n![abstract-factory3](abstract-factory3.png)\n\n###### 建造者模式\n建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示\n\n工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。\n建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节\n![human](human.png)\n![name](name.png)\n![work](work.png)\n![person](person.png)\n\n工厂模式创建出来的是一个对象，它追求的是创建的结果\n建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象\n\n**注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象**\n\n###### 原型模式\n原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法\n\n原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法\n![prototype-model](prototype-model.png)\n原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法\n\n(1)原型继承\n原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法\n![prototype-inherit1](prototype-inherit1.png)\n![prototype-inherit2](prototype-inherit2.png)\n\n**原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现**\n\n###### 单例模式\n单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法\n\n(1)命名空间\n命名空间就是人们所说的namespace，有人也叫它名称空间。\n它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题\n\n(2)静态变量\n![static-param](static-param.png)\n\n(3)惰性单例\n![lazy-single-instance](lazy-single-instance.png)","slug":"24-about-design-model1","published":1,"updated":"2022-09-22T09:16:30.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwt000tcktt1jfgchng","content":"<h4 id=\"创建型设计模式\"><a href=\"#创建型设计模式\" class=\"headerlink\" title=\"创建型设计模式\"></a>创建型设计模式</h4><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度</p>\n<h6 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h6><p>(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。<br><img src=\"/2022/09/04/24-about-design-model1/simple-factory1.png\" alt=\"simple-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/simple-factory2.png\" alt=\"simple-factory2\"></p>\n<p>(2)一个对象有时也可代替许多类<br><img src=\"/2022/09/04/24-about-design-model1/create-pop.png\" alt=\"create-pop\"></p>\n<p>第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了</p>\n<h6 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h6><p>安全模式类：可以屏蔽使用这对类的错误使用造成的错误<br><img src=\"/2022/09/04/24-about-design-model1/safe-model-class.png\" alt=\"safe-model-class\"><br><img src=\"/2022/09/04/24-about-design-model1/safe-factory-model.png\" alt=\"safe-factory-model\"></p>\n<h6 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h6><p>抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例</p>\n<p>(1)抽象类<br>抽象类是一种声明但不能使用的类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-car.png\" alt=\"abstract-car\"><br>创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类<br>中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。</p>\n<p>(2)抽象工厂模式：一般用它来作为父类创建一些子类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory1.png\" alt=\"abstract-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory2.png\" alt=\"abstract-factory2\"><br>抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory3.png\" alt=\"abstract-factory3\"></p>\n<h6 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h6><p>建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示</p>\n<p>工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。<br>建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节<br><img src=\"/2022/09/04/24-about-design-model1/human.png\" alt=\"human\"><br><img src=\"/2022/09/04/24-about-design-model1/name.png\" alt=\"name\"><br><img src=\"/2022/09/04/24-about-design-model1/work.png\" alt=\"work\"><br><img src=\"/2022/09/04/24-about-design-model1/person.png\" alt=\"person\"></p>\n<p>工厂模式创建出来的是一个对象，它追求的是创建的结果<br>建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象</p>\n<p><strong>注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象</strong></p>\n<h6 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h6><p>原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法</p>\n<p>原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-model.png\" alt=\"prototype-model\"><br>原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法</p>\n<p>(1)原型继承<br>原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit1.png\" alt=\"prototype-inherit1\"><br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit2.png\" alt=\"prototype-inherit2\"></p>\n<p><strong>原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现</strong></p>\n<h6 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h6><p>单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法</p>\n<p>(1)命名空间<br>命名空间就是人们所说的namespace，有人也叫它名称空间。<br>它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题</p>\n<p>(2)静态变量<br><img src=\"/2022/09/04/24-about-design-model1/static-param.png\" alt=\"static-param\"></p>\n<p>(3)惰性单例<br><img src=\"/2022/09/04/24-about-design-model1/lazy-single-instance.png\" alt=\"lazy-single-instance\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"创建型设计模式\"><a href=\"#创建型设计模式\" class=\"headerlink\" title=\"创建型设计模式\"></a>创建型设计模式</h4><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度</p>\n<h6 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h6><p>(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。<br><img src=\"/2022/09/04/24-about-design-model1/simple-factory1.png\" alt=\"simple-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/simple-factory2.png\" alt=\"simple-factory2\"></p>\n<p>(2)一个对象有时也可代替许多类<br><img src=\"/2022/09/04/24-about-design-model1/create-pop.png\" alt=\"create-pop\"></p>\n<p>第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了</p>\n<h6 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h6><p>安全模式类：可以屏蔽使用这对类的错误使用造成的错误<br><img src=\"/2022/09/04/24-about-design-model1/safe-model-class.png\" alt=\"safe-model-class\"><br><img src=\"/2022/09/04/24-about-design-model1/safe-factory-model.png\" alt=\"safe-factory-model\"></p>\n<h6 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h6><p>抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例</p>\n<p>(1)抽象类<br>抽象类是一种声明但不能使用的类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-car.png\" alt=\"abstract-car\"><br>创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类<br>中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。</p>\n<p>(2)抽象工厂模式：一般用它来作为父类创建一些子类<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory1.png\" alt=\"abstract-factory1\"><br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory2.png\" alt=\"abstract-factory2\"><br>抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck<br><img src=\"/2022/09/04/24-about-design-model1/abstract-factory3.png\" alt=\"abstract-factory3\"></p>\n<h6 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h6><p>建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示</p>\n<p>工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。<br>建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节<br><img src=\"/2022/09/04/24-about-design-model1/human.png\" alt=\"human\"><br><img src=\"/2022/09/04/24-about-design-model1/name.png\" alt=\"name\"><br><img src=\"/2022/09/04/24-about-design-model1/work.png\" alt=\"work\"><br><img src=\"/2022/09/04/24-about-design-model1/person.png\" alt=\"person\"></p>\n<p>工厂模式创建出来的是一个对象，它追求的是创建的结果<br>建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象</p>\n<p><strong>注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象</strong></p>\n<h6 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h6><p>原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法</p>\n<p>原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-model.png\" alt=\"prototype-model\"><br>原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法</p>\n<p>(1)原型继承<br>原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法<br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit1.png\" alt=\"prototype-inherit1\"><br><img src=\"/2022/09/04/24-about-design-model1/prototype-inherit2.png\" alt=\"prototype-inherit2\"></p>\n<p><strong>原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现</strong></p>\n<h6 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h6><p>单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法</p>\n<p>(1)命名空间<br>命名空间就是人们所说的namespace，有人也叫它名称空间。<br>它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题</p>\n<p>(2)静态变量<br><img src=\"/2022/09/04/24-about-design-model1/static-param.png\" alt=\"static-param\"></p>\n<p>(3)惰性单例<br><img src=\"/2022/09/04/24-about-design-model1/lazy-single-instance.png\" alt=\"lazy-single-instance\"></p>\n"},{"title":"基本数据类型-Symbol","date":"2022-08-19T05:37:24.000Z","_content":"\n#### 什么是Symbol?\n\n\n\n#### 有什么用处？\n\n#### Symbol的属性\n\n#### Symbol的方法\n","source":"_posts/22-about-symbol.md","raw":"---\ntitle: 基本数据类型-Symbol\ndate: 2022-08-19 13:37:24\ntags:\n---\n\n#### 什么是Symbol?\n\n\n\n#### 有什么用处？\n\n#### Symbol的属性\n\n#### Symbol的方法\n","slug":"22-about-symbol","published":1,"updated":"2022-08-19T05:42:42.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwu000vckttft2p3qvq","content":"<h4 id=\"什么是Symbol\"><a href=\"#什么是Symbol\" class=\"headerlink\" title=\"什么是Symbol?\"></a>什么是Symbol?</h4><h4 id=\"有什么用处？\"><a href=\"#有什么用处？\" class=\"headerlink\" title=\"有什么用处？\"></a>有什么用处？</h4><h4 id=\"Symbol的属性\"><a href=\"#Symbol的属性\" class=\"headerlink\" title=\"Symbol的属性\"></a>Symbol的属性</h4><h4 id=\"Symbol的方法\"><a href=\"#Symbol的方法\" class=\"headerlink\" title=\"Symbol的方法\"></a>Symbol的方法</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Symbol\"><a href=\"#什么是Symbol\" class=\"headerlink\" title=\"什么是Symbol?\"></a>什么是Symbol?</h4><h4 id=\"有什么用处？\"><a href=\"#有什么用处？\" class=\"headerlink\" title=\"有什么用处？\"></a>有什么用处？</h4><h4 id=\"Symbol的属性\"><a href=\"#Symbol的属性\" class=\"headerlink\" title=\"Symbol的属性\"></a>Symbol的属性</h4><h4 id=\"Symbol的方法\"><a href=\"#Symbol的方法\" class=\"headerlink\" title=\"Symbol的方法\"></a>Symbol的方法</h4>"},{"title":"JavaScript设计模式读书笔记(1)","date":"2022-08-20T06:47:46.000Z","_content":"\n#### 面向对象\n一、面向过程与面向对象\n面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里\n二、封装\n1、使用原型(prototype)为类添加属性和方法的两种方式(**注意两种不能混用**)：\n(1)为原型对象属性赋值\n```javascript\nBook.prototype.display = function() {\n  // ....\n}\n```\n(2)将一个对象赋值给类的原型对象\n```javascript\nBook.prototype = {\n  display = function() {}\n}\n```\n\n2、使用this和原型(prototype)为类添加属性和方法的区别：\n(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建\n(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法\n\n3、constructor是什么？\nconstructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。\n![prototype](prototype.png)\n\n4、属性与方法的封装\n(1)私有属性与私有方法\n由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法\n(2)共有属性和共有方法\n在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法\n(3)特权方法(类的构造器)\n通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器\n![public-and-private](public-and-private.png)\n\n5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用\n(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法\n(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法\n![static-and-public](static-and-public.png)\n通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。\n\n6、闭包\n闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量\n\n7、创建对象的安全模式\nnew关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量\n![safe-model](safe-model.png)\n\n三、继承\n1、子类的原型对象 - 类式继承\n![class-inherit](class-inherit.png)\n声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型\n类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。\n新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理\n\n(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类\n注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n**instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass**\n\n(2)类式继承的缺点\n其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化\n\n2、创建即继承 - 构造函数继承\n![constructor-inherit](constructor-inherit.png)\nSuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则\n\n3、将优点为我所用 - 组合继承\n(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的\n![combination-inherit](combination-inherit.png)\n在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式\n(2)缺点\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍\n\n4、洁净的继承者 - 原型式继承\n![prototype-inherit](prototype-inherit.png)\n对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象\n![test-prototype-inherit](test-prototype-inherit.png)\n\n5、如虎添翼 - 寄生式继承\n![parasitic-inherit](parasitic-inherit.png)\n寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法\n\n6、终极继承者 - 寄生组合式继承\n寄生式继承和构造函数继承\n\n寄生式继承的改造\n![parasitic-inherit-change](parasitic-inherit-change.png)\n\n![parasitic-combination-inherit](parasitic-combination-inherit.png)\n\n![how-to-inherit](how-to-inherit.png)\n\n**子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象**\n\n四、多继承\n单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性\n![multiple-inherit](multiple-inherit.png)\n\n五、多态\n同一个方法多种调用方式\n![multiple-status](multiple-status.png)","source":"_posts/23-about-design-model.md","raw":"---\ntitle: JavaScript设计模式读书笔记(1)\ndate: 2022-08-20 14:47:46\ntags:\n---\n\n#### 面向对象\n一、面向过程与面向对象\n面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里\n二、封装\n1、使用原型(prototype)为类添加属性和方法的两种方式(**注意两种不能混用**)：\n(1)为原型对象属性赋值\n```javascript\nBook.prototype.display = function() {\n  // ....\n}\n```\n(2)将一个对象赋值给类的原型对象\n```javascript\nBook.prototype = {\n  display = function() {}\n}\n```\n\n2、使用this和原型(prototype)为类添加属性和方法的区别：\n(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建\n(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法\n\n3、constructor是什么？\nconstructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。\n![prototype](prototype.png)\n\n4、属性与方法的封装\n(1)私有属性与私有方法\n由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法\n(2)共有属性和共有方法\n在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法\n(3)特权方法(类的构造器)\n通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器\n![public-and-private](public-and-private.png)\n\n5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用\n(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法\n(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法\n![static-and-public](static-and-public.png)\n通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。\n\n6、闭包\n闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量\n\n7、创建对象的安全模式\nnew关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量\n![safe-model](safe-model.png)\n\n三、继承\n1、子类的原型对象 - 类式继承\n![class-inherit](class-inherit.png)\n声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型\n类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。\n新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理\n\n(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类\n注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构\n**instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass**\n\n(2)类式继承的缺点\n其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类\n其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化\n\n2、创建即继承 - 构造函数继承\n![constructor-inherit](constructor-inherit.png)\nSuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则\n\n3、将优点为我所用 - 组合继承\n(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的\n![combination-inherit](combination-inherit.png)\n在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式\n(2)缺点\n在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍\n\n4、洁净的继承者 - 原型式继承\n![prototype-inherit](prototype-inherit.png)\n对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象\n![test-prototype-inherit](test-prototype-inherit.png)\n\n5、如虎添翼 - 寄生式继承\n![parasitic-inherit](parasitic-inherit.png)\n寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法\n\n6、终极继承者 - 寄生组合式继承\n寄生式继承和构造函数继承\n\n寄生式继承的改造\n![parasitic-inherit-change](parasitic-inherit-change.png)\n\n![parasitic-combination-inherit](parasitic-combination-inherit.png)\n\n![how-to-inherit](how-to-inherit.png)\n\n**子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象**\n\n四、多继承\n单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性\n![multiple-inherit](multiple-inherit.png)\n\n五、多态\n同一个方法多种调用方式\n![multiple-status](multiple-status.png)","slug":"23-about-design-model","published":1,"updated":"2022-09-22T09:15:58.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwv000xcktt5uwdh7ah","content":"<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>一、面向过程与面向对象<br>面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里<br>二、封装<br>1、使用原型(prototype)为类添加属性和方法的两种方式(<strong>注意两种不能混用</strong>)：<br>(1)为原型对象属性赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype.display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)将一个对象赋值给类的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">  display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、使用this和原型(prototype)为类添加属性和方法的区别：<br>(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建<br>(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法</p>\n<p>3、constructor是什么？<br>constructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。<br><img src=\"/2022/08/20/23-about-design-model/prototype.png\" alt=\"prototype\"></p>\n<p>4、属性与方法的封装<br>(1)私有属性与私有方法<br>由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法<br>(2)共有属性和共有方法<br>在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法<br>(3)特权方法(类的构造器)<br>通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器<br><img src=\"/2022/08/20/23-about-design-model/public-and-private.png\" alt=\"public-and-private\"></p>\n<p>5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用<br>(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法<br>(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法<br><img src=\"/2022/08/20/23-about-design-model/static-and-public.png\" alt=\"static-and-public\"><br>通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。</p>\n<p>6、闭包<br>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量</p>\n<p>7、创建对象的安全模式<br>new关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量<br><img src=\"/2022/08/20/23-about-design-model/safe-model.png\" alt=\"safe-model\"></p>\n<p>三、继承<br>1、子类的原型对象 - 类式继承<br><img src=\"/2022/08/20/23-about-design-model/class-inherit.png\" alt=\"class-inherit\"><br>声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型<br>类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。<br>新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理</p>\n<p>(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类<br>注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构<br><strong>instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass</strong></p>\n<p>(2)类式继承的缺点<br>其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类<br>其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</p>\n<p>2、创建即继承 - 构造函数继承<br><img src=\"/2022/08/20/23-about-design-model/constructor-inherit.png\" alt=\"constructor-inherit\"><br>SuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则</p>\n<p>3、将优点为我所用 - 组合继承<br>(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的<br><img src=\"/2022/08/20/23-about-design-model/combination-inherit.png\" alt=\"combination-inherit\"><br>在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式<br>(2)缺点<br>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍</p>\n<p>4、洁净的继承者 - 原型式继承<br><img src=\"/2022/08/20/23-about-design-model/prototype-inherit.png\" alt=\"prototype-inherit\"><br>对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象<br><img src=\"/2022/08/20/23-about-design-model/test-prototype-inherit.png\" alt=\"test-prototype-inherit\"></p>\n<p>5、如虎添翼 - 寄生式继承<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit.png\" alt=\"parasitic-inherit\"><br>寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法</p>\n<p>6、终极继承者 - 寄生组合式继承<br>寄生式继承和构造函数继承</p>\n<p>寄生式继承的改造<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit-change.png\" alt=\"parasitic-inherit-change\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/parasitic-combination-inherit.png\" alt=\"parasitic-combination-inherit\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/how-to-inherit.png\" alt=\"how-to-inherit\"></p>\n<p><strong>子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象</strong></p>\n<p>四、多继承<br>单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性<br><img src=\"/2022/08/20/23-about-design-model/multiple-inherit.png\" alt=\"multiple-inherit\"></p>\n<p>五、多态<br>同一个方法多种调用方式<br><img src=\"/2022/08/20/23-about-design-model/multiple-status.png\" alt=\"multiple-status\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>一、面向过程与面向对象<br>面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里<br>二、封装<br>1、使用原型(prototype)为类添加属性和方法的两种方式(<strong>注意两种不能混用</strong>)：<br>(1)为原型对象属性赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype.display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(2)将一个对象赋值给类的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">  display = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、使用this和原型(prototype)为类添加属性和方法的区别：<br>(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建<br>(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法</p>\n<p>3、constructor是什么？<br>constructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。<br><img src=\"/2022/08/20/23-about-design-model/prototype.png\" alt=\"prototype\"></p>\n<p>4、属性与方法的封装<br>(1)私有属性与私有方法<br>由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法<br>(2)共有属性和共有方法<br>在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法<br>(3)特权方法(类的构造器)<br>通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器<br><img src=\"/2022/08/20/23-about-design-model/public-and-private.png\" alt=\"public-and-private\"></p>\n<p>5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用<br>(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法<br>(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法<br><img src=\"/2022/08/20/23-about-design-model/static-and-public.png\" alt=\"static-and-public\"><br>通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。</p>\n<p>6、闭包<br>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量</p>\n<p>7、创建对象的安全模式<br>new关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量<br><img src=\"/2022/08/20/23-about-design-model/safe-model.png\" alt=\"safe-model\"></p>\n<p>三、继承<br>1、子类的原型对象 - 类式继承<br><img src=\"/2022/08/20/23-about-design-model/class-inherit.png\" alt=\"class-inherit\"><br>声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型<br>类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。<br>新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理</p>\n<p>(1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类<br>注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构<br><strong>instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass</strong></p>\n<p>(2)类式继承的缺点<br>其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类<br>其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</p>\n<p>2、创建即继承 - 构造函数继承<br><img src=\"/2022/08/20/23-about-design-model/constructor-inherit.png\" alt=\"constructor-inherit\"><br>SuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则</p>\n<p>3、将优点为我所用 - 组合继承<br>(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的<br><img src=\"/2022/08/20/23-about-design-model/combination-inherit.png\" alt=\"combination-inherit\"><br>在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式<br>(2)缺点<br>在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍</p>\n<p>4、洁净的继承者 - 原型式继承<br><img src=\"/2022/08/20/23-about-design-model/prototype-inherit.png\" alt=\"prototype-inherit\"><br>对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象<br><img src=\"/2022/08/20/23-about-design-model/test-prototype-inherit.png\" alt=\"test-prototype-inherit\"></p>\n<p>5、如虎添翼 - 寄生式继承<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit.png\" alt=\"parasitic-inherit\"><br>寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法</p>\n<p>6、终极继承者 - 寄生组合式继承<br>寄生式继承和构造函数继承</p>\n<p>寄生式继承的改造<br><img src=\"/2022/08/20/23-about-design-model/parasitic-inherit-change.png\" alt=\"parasitic-inherit-change\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/parasitic-combination-inherit.png\" alt=\"parasitic-combination-inherit\"></p>\n<p><img src=\"/2022/08/20/23-about-design-model/how-to-inherit.png\" alt=\"how-to-inherit\"></p>\n<p><strong>子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象</strong></p>\n<p>四、多继承<br>单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性<br><img src=\"/2022/08/20/23-about-design-model/multiple-inherit.png\" alt=\"multiple-inherit\"></p>\n<p>五、多态<br>同一个方法多种调用方式<br><img src=\"/2022/08/20/23-about-design-model/multiple-status.png\" alt=\"multiple-status\"></p>\n"},{"title":"JavaScript设计模式读书笔记(3)","date":"2022-09-06T07:11:48.000Z","_content":"\n#### 结构型设计模式\n结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计\n\n###### 外观模式\n外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用\n\n多用于兼容模式\n![out-look](out-look.png)\n\n###### 适配器模式\n适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决\n\n(1)适配异类框架\n(2)参数适配器：通常是以一个参数对象方式传入\n(3)数据适配\n比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等\n(4)服务端数据适配\n获取接口的数据，先做一个适配，再使用统一的处理方法\n\n###### 代理模式\n代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用\n\n**代理对象**\n(1)img之类的标签通过src属性可以向其他域下的服务器发送请求\n缺点：请求是get请求，且是单向的，不会有响应数据\n示例：站长统计\n![station-culculate](station-culculate.png)\n\n(2)JSONP\n通过script标签\n需要其他域下的服务端配合前端做出针对处理\n\n(3)代理模板\n不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A\n\n###### 装修者模式\n装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求\n![decorator](decorator.png)\n\n**适配器与装修者的区别**\n适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节\n装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用\n\n###### 桥接模式\n桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦\n\n先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用\n\n![bridge1](bridge1.png)\n![bridge2](bridge2.png)\n![bridge3](bridge3.png)\n\n桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化\n\n###### 组合模式\n组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n组合模式常用语创建表单。\n\n###### 享元模式\n享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。\n\n享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。\n\n在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。","source":"_posts/25-about-design-model2.md","raw":"---\ntitle: JavaScript设计模式读书笔记(3)\ndate: 2022-09-06 15:11:48\ntags:\n---\n\n#### 结构型设计模式\n结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计\n\n###### 外观模式\n外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用\n\n多用于兼容模式\n![out-look](out-look.png)\n\n###### 适配器模式\n适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决\n\n(1)适配异类框架\n(2)参数适配器：通常是以一个参数对象方式传入\n(3)数据适配\n比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等\n(4)服务端数据适配\n获取接口的数据，先做一个适配，再使用统一的处理方法\n\n###### 代理模式\n代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用\n\n**代理对象**\n(1)img之类的标签通过src属性可以向其他域下的服务器发送请求\n缺点：请求是get请求，且是单向的，不会有响应数据\n示例：站长统计\n![station-culculate](station-culculate.png)\n\n(2)JSONP\n通过script标签\n需要其他域下的服务端配合前端做出针对处理\n\n(3)代理模板\n不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A\n\n###### 装修者模式\n装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求\n![decorator](decorator.png)\n\n**适配器与装修者的区别**\n适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节\n装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用\n\n###### 桥接模式\n桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦\n\n先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用\n\n![bridge1](bridge1.png)\n![bridge2](bridge2.png)\n![bridge3](bridge3.png)\n\n桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化\n\n###### 组合模式\n组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n组合模式常用语创建表单。\n\n###### 享元模式\n享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。\n\n享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。\n\n在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。","slug":"25-about-design-model2","published":1,"updated":"2022-09-22T09:16:44.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwv000zcktthfkx2hwg","content":"<h4 id=\"结构型设计模式\"><a href=\"#结构型设计模式\" class=\"headerlink\" title=\"结构型设计模式\"></a>结构型设计模式</h4><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计</p>\n<h6 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h6><p>外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用</p>\n<p>多用于兼容模式<br><img src=\"/2022/09/06/25-about-design-model2/out-look.png\" alt=\"out-look\"></p>\n<h6 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h6><p>适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决</p>\n<p>(1)适配异类框架<br>(2)参数适配器：通常是以一个参数对象方式传入<br>(3)数据适配<br>比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等<br>(4)服务端数据适配<br>获取接口的数据，先做一个适配，再使用统一的处理方法</p>\n<h6 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h6><p>代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用</p>\n<p><strong>代理对象</strong><br>(1)img之类的标签通过src属性可以向其他域下的服务器发送请求<br>缺点：请求是get请求，且是单向的，不会有响应数据<br>示例：站长统计<br><img src=\"/2022/09/06/25-about-design-model2/station-culculate.png\" alt=\"station-culculate\"></p>\n<p>(2)JSONP<br>通过script标签<br>需要其他域下的服务端配合前端做出针对处理</p>\n<p>(3)代理模板<br>不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A</p>\n<h6 id=\"装修者模式\"><a href=\"#装修者模式\" class=\"headerlink\" title=\"装修者模式\"></a>装修者模式</h6><p>装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求<br><img src=\"/2022/09/06/25-about-design-model2/decorator.png\" alt=\"decorator\"></p>\n<p><strong>适配器与装修者的区别</strong><br>适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节<br>装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用</p>\n<h6 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h6><p>桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦</p>\n<p>先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用</p>\n<p><img src=\"/2022/09/06/25-about-design-model2/bridge1.png\" alt=\"bridge1\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge2.png\" alt=\"bridge2\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge3.png\" alt=\"bridge3\"></p>\n<p>桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化</p>\n<h6 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h6><p>组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p>组合模式常用语创建表单。</p>\n<h6 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h6><p>享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>\n<p>享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。</p>\n<p>在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"结构型设计模式\"><a href=\"#结构型设计模式\" class=\"headerlink\" title=\"结构型设计模式\"></a>结构型设计模式</h4><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计</p>\n<h6 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h6><p>外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用</p>\n<p>多用于兼容模式<br><img src=\"/2022/09/06/25-about-design-model2/out-look.png\" alt=\"out-look\"></p>\n<h6 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h6><p>适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决</p>\n<p>(1)适配异类框架<br>(2)参数适配器：通常是以一个参数对象方式传入<br>(3)数据适配<br>比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等<br>(4)服务端数据适配<br>获取接口的数据，先做一个适配，再使用统一的处理方法</p>\n<h6 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h6><p>代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用</p>\n<p><strong>代理对象</strong><br>(1)img之类的标签通过src属性可以向其他域下的服务器发送请求<br>缺点：请求是get请求，且是单向的，不会有响应数据<br>示例：站长统计<br><img src=\"/2022/09/06/25-about-design-model2/station-culculate.png\" alt=\"station-culculate\"></p>\n<p>(2)JSONP<br>通过script标签<br>需要其他域下的服务端配合前端做出针对处理</p>\n<p>(3)代理模板<br>不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A</p>\n<h6 id=\"装修者模式\"><a href=\"#装修者模式\" class=\"headerlink\" title=\"装修者模式\"></a>装修者模式</h6><p>装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求<br><img src=\"/2022/09/06/25-about-design-model2/decorator.png\" alt=\"decorator\"></p>\n<p><strong>适配器与装修者的区别</strong><br>适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节<br>装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用</p>\n<h6 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h6><p>桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦</p>\n<p>先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用</p>\n<p><img src=\"/2022/09/06/25-about-design-model2/bridge1.png\" alt=\"bridge1\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge2.png\" alt=\"bridge2\"><br><img src=\"/2022/09/06/25-about-design-model2/bridge3.png\" alt=\"bridge3\"></p>\n<p>桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化</p>\n<h6 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h6><p>组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p>组合模式常用语创建表单。</p>\n<h6 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h6><p>享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>\n<p>享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。</p>\n<p>在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。</p>\n"},{"title":"JavaScript设计模式读书笔记(4)","date":"2022-09-07T09:40:43.000Z","_content":"\n#### 行为型设计模式\n行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现\n\n###### 模板方法模式\n模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。\n\n多用于归一化组件\n\n![basic-model](basic-model.png)\n![inherit-model](inherit-model.png)\n![inherit-as-basic-model](inherit-as-basic-model.png)\n\n###### 观察者模式\n观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。\n\n观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法\n\n![observer](observer.png)\n![observer-regist](observer-regist.png)\n![observer-fire](observer-fire.png)\n![observer-remove](observer-remove.png)\n\n![regist-message](regist-message.png)\n![regist-change-num](regist-change-num.png)\n![add-message](add-message.png)\n\n###### 状态模式\n状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。\n\n状态模式简化了分支判断遍历逻辑\n\n![vote-status](vote-status.png)\n\n示例\n思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用\n![marry-state](marry-state.png)\n![marry-state1](marry-state1.png)\n\n###### 策略模式\n策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。\n\n**与状态模式异同点**\n相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用\n不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法\n\n![price-strategy](price-strategy.png)\n\n**策略模式的优点**\n第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。\n第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。\n第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。\n\n**策略模式的缺点**\n由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。\n由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费\n\n**优化分支语句的模式**\n工厂方法模式，状态模式与策略模式\n工厂方法模式：一种创建型模式，最终目的是创建对象。\n状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。\n策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。\n\n###### 职责链模式\n职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。\n\n示例\n![send-data](send-data.png)\n![deal-data](deal-data.png)\n![create-component](create-component.png)\n\n**缺点**\n职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费\n多个对象参与请求的传递，在代码调试时增加了调试成本\n\n###### 命令模式\n命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。\n命令模式常用于解耦\n![command-model-1](command-model-1.png)\n![command-model-2](command-model-2.png)\n![command-model-3](command-model-3.png)\n\n命令模式的优点:\n解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。\n命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。\n\n命令模式的缺点:\n命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。\n\n###### 访问者模式\n访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。\n\n![visitor-model](visitor-model.png)\n\n###### 中介者模式\n中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。\n\n(1)观察者模式与中介者模式的区别\n相同点\n都是通过消息的收发机制实现的\n差异点\n在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统\n中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者\n\n![mediator-model](mediator-model.png)\n\n###### 备忘录模式\n备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。\n\n![cache-model](cache-model.png)\n\n###### 迭代器模式\n迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。\n\n![iterator-model](iterator-model.png)\n\n###### 解释器模式\n解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。\n\n![explain-model-1](explain-model-1.png)\n![explain-model-2](explain-model-2.png)\n![explain-model-3](explain-model-3.png)\n\n解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是**能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的**。因为解释器要按照这套规则才能实现相应的功能。","source":"_posts/26-about-design-model3.md","raw":"---\ntitle: JavaScript设计模式读书笔记(4)\ndate: 2022-09-07 17:40:43\ntags:\n---\n\n#### 行为型设计模式\n行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现\n\n###### 模板方法模式\n模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。\n\n多用于归一化组件\n\n![basic-model](basic-model.png)\n![inherit-model](inherit-model.png)\n![inherit-as-basic-model](inherit-as-basic-model.png)\n\n###### 观察者模式\n观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。\n\n观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法\n\n![observer](observer.png)\n![observer-regist](observer-regist.png)\n![observer-fire](observer-fire.png)\n![observer-remove](observer-remove.png)\n\n![regist-message](regist-message.png)\n![regist-change-num](regist-change-num.png)\n![add-message](add-message.png)\n\n###### 状态模式\n状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。\n\n状态模式简化了分支判断遍历逻辑\n\n![vote-status](vote-status.png)\n\n示例\n思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用\n![marry-state](marry-state.png)\n![marry-state1](marry-state1.png)\n\n###### 策略模式\n策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。\n\n**与状态模式异同点**\n相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用\n不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法\n\n![price-strategy](price-strategy.png)\n\n**策略模式的优点**\n第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。\n第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。\n第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。\n\n**策略模式的缺点**\n由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。\n由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费\n\n**优化分支语句的模式**\n工厂方法模式，状态模式与策略模式\n工厂方法模式：一种创建型模式，最终目的是创建对象。\n状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。\n策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。\n\n###### 职责链模式\n职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。\n\n示例\n![send-data](send-data.png)\n![deal-data](deal-data.png)\n![create-component](create-component.png)\n\n**缺点**\n职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费\n多个对象参与请求的传递，在代码调试时增加了调试成本\n\n###### 命令模式\n命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。\n命令模式常用于解耦\n![command-model-1](command-model-1.png)\n![command-model-2](command-model-2.png)\n![command-model-3](command-model-3.png)\n\n命令模式的优点:\n解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。\n命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。\n\n命令模式的缺点:\n命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。\n\n###### 访问者模式\n访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。\n\n![visitor-model](visitor-model.png)\n\n###### 中介者模式\n中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。\n\n(1)观察者模式与中介者模式的区别\n相同点\n都是通过消息的收发机制实现的\n差异点\n在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统\n中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者\n\n![mediator-model](mediator-model.png)\n\n###### 备忘录模式\n备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。\n\n![cache-model](cache-model.png)\n\n###### 迭代器模式\n迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。\n\n![iterator-model](iterator-model.png)\n\n###### 解释器模式\n解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。\n\n![explain-model-1](explain-model-1.png)\n![explain-model-2](explain-model-2.png)\n![explain-model-3](explain-model-3.png)\n\n解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是**能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的**。因为解释器要按照这套规则才能实现相应的功能。","slug":"26-about-design-model3","published":1,"updated":"2022-09-22T09:17:06.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gww0011cktt12x8feua","content":"<h4 id=\"行为型设计模式\"><a href=\"#行为型设计模式\" class=\"headerlink\" title=\"行为型设计模式\"></a>行为型设计模式</h4><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现</p>\n<h6 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h6><p>模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。</p>\n<p>多用于归一化组件</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/basic-model.png\" alt=\"basic-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-model.png\" alt=\"inherit-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-as-basic-model.png\" alt=\"inherit-as-basic-model\"></p>\n<h6 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h6><p>观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>\n<p>观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/observer.png\" alt=\"observer\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-regist.png\" alt=\"observer-regist\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-fire.png\" alt=\"observer-fire\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-remove.png\" alt=\"observer-remove\"></p>\n<p><img src=\"/2022/09/07/26-about-design-model3/regist-message.png\" alt=\"regist-message\"><br><img src=\"/2022/09/07/26-about-design-model3/regist-change-num.png\" alt=\"regist-change-num\"><br><img src=\"/2022/09/07/26-about-design-model3/add-message.png\" alt=\"add-message\"></p>\n<h6 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h6><p>状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>\n<p>状态模式简化了分支判断遍历逻辑</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/vote-status.png\" alt=\"vote-status\"></p>\n<p>示例<br>思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用<br><img src=\"/2022/09/07/26-about-design-model3/marry-state.png\" alt=\"marry-state\"><br><img src=\"/2022/09/07/26-about-design-model3/marry-state1.png\" alt=\"marry-state1\"></p>\n<h6 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h6><p>策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>\n<p><strong>与状态模式异同点</strong><br>相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用<br>不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/price-strategy.png\" alt=\"price-strategy\"></p>\n<p><strong>策略模式的优点</strong><br>第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。<br>第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。<br>第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。</p>\n<p><strong>策略模式的缺点</strong><br>由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。<br>由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费</p>\n<p><strong>优化分支语句的模式</strong><br>工厂方法模式，状态模式与策略模式<br>工厂方法模式：一种创建型模式，最终目的是创建对象。<br>状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。<br>策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。</p>\n<h6 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h6><p>职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。</p>\n<p>示例<br><img src=\"/2022/09/07/26-about-design-model3/send-data.png\" alt=\"send-data\"><br><img src=\"/2022/09/07/26-about-design-model3/deal-data.png\" alt=\"deal-data\"><br><img src=\"/2022/09/07/26-about-design-model3/create-component.png\" alt=\"create-component\"></p>\n<p><strong>缺点</strong><br>职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费<br>多个对象参与请求的传递，在代码调试时增加了调试成本</p>\n<h6 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h6><p>命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。<br>命令模式常用于解耦<br><img src=\"/2022/09/07/26-about-design-model3/command-model-1.png\" alt=\"command-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-2.png\" alt=\"command-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-3.png\" alt=\"command-model-3\"></p>\n<p>命令模式的优点:<br>解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。<br>命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。</p>\n<p>命令模式的缺点:<br>命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。</p>\n<h6 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h6><p>访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/visitor-model.png\" alt=\"visitor-model\"></p>\n<h6 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h6><p>中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。</p>\n<p>(1)观察者模式与中介者模式的区别<br>相同点<br>都是通过消息的收发机制实现的<br>差异点<br>在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统<br>中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/mediator-model.png\" alt=\"mediator-model\"></p>\n<h6 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h6><p>备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/cache-model.png\" alt=\"cache-model\"></p>\n<h6 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h6><p>迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/iterator-model.png\" alt=\"iterator-model\"></p>\n<h6 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h6><p>解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/explain-model-1.png\" alt=\"explain-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-2.png\" alt=\"explain-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-3.png\" alt=\"explain-model-3\"></p>\n<p>解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是<strong>能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的</strong>。因为解释器要按照这套规则才能实现相应的功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"行为型设计模式\"><a href=\"#行为型设计模式\" class=\"headerlink\" title=\"行为型设计模式\"></a>行为型设计模式</h4><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现</p>\n<h6 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h6><p>模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。</p>\n<p>多用于归一化组件</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/basic-model.png\" alt=\"basic-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-model.png\" alt=\"inherit-model\"><br><img src=\"/2022/09/07/26-about-design-model3/inherit-as-basic-model.png\" alt=\"inherit-as-basic-model\"></p>\n<h6 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h6><p>观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>\n<p>观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/observer.png\" alt=\"observer\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-regist.png\" alt=\"observer-regist\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-fire.png\" alt=\"observer-fire\"><br><img src=\"/2022/09/07/26-about-design-model3/observer-remove.png\" alt=\"observer-remove\"></p>\n<p><img src=\"/2022/09/07/26-about-design-model3/regist-message.png\" alt=\"regist-message\"><br><img src=\"/2022/09/07/26-about-design-model3/regist-change-num.png\" alt=\"regist-change-num\"><br><img src=\"/2022/09/07/26-about-design-model3/add-message.png\" alt=\"add-message\"></p>\n<h6 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h6><p>状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。</p>\n<p>状态模式简化了分支判断遍历逻辑</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/vote-status.png\" alt=\"vote-status\"></p>\n<p>示例<br>思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用<br><img src=\"/2022/09/07/26-about-design-model3/marry-state.png\" alt=\"marry-state\"><br><img src=\"/2022/09/07/26-about-design-model3/marry-state1.png\" alt=\"marry-state1\"></p>\n<h6 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h6><p>策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>\n<p><strong>与状态模式异同点</strong><br>相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用<br>不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/price-strategy.png\" alt=\"price-strategy\"></p>\n<p><strong>策略模式的优点</strong><br>第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。<br>第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。<br>第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。</p>\n<p><strong>策略模式的缺点</strong><br>由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。<br>由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费</p>\n<p><strong>优化分支语句的模式</strong><br>工厂方法模式，状态模式与策略模式<br>工厂方法模式：一种创建型模式，最终目的是创建对象。<br>状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。<br>策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。</p>\n<h6 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h6><p>职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。</p>\n<p>示例<br><img src=\"/2022/09/07/26-about-design-model3/send-data.png\" alt=\"send-data\"><br><img src=\"/2022/09/07/26-about-design-model3/deal-data.png\" alt=\"deal-data\"><br><img src=\"/2022/09/07/26-about-design-model3/create-component.png\" alt=\"create-component\"></p>\n<p><strong>缺点</strong><br>职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费<br>多个对象参与请求的传递，在代码调试时增加了调试成本</p>\n<h6 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h6><p>命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。<br>命令模式常用于解耦<br><img src=\"/2022/09/07/26-about-design-model3/command-model-1.png\" alt=\"command-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-2.png\" alt=\"command-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/command-model-3.png\" alt=\"command-model-3\"></p>\n<p>命令模式的优点:<br>解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。<br>命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。</p>\n<p>命令模式的缺点:<br>命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。</p>\n<h6 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h6><p>访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/visitor-model.png\" alt=\"visitor-model\"></p>\n<h6 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h6><p>中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。</p>\n<p>(1)观察者模式与中介者模式的区别<br>相同点<br>都是通过消息的收发机制实现的<br>差异点<br>在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统<br>中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/mediator-model.png\" alt=\"mediator-model\"></p>\n<h6 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h6><p>备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/cache-model.png\" alt=\"cache-model\"></p>\n<h6 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h6><p>迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/iterator-model.png\" alt=\"iterator-model\"></p>\n<h6 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h6><p>解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>\n<p><img src=\"/2022/09/07/26-about-design-model3/explain-model-1.png\" alt=\"explain-model-1\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-2.png\" alt=\"explain-model-2\"><br><img src=\"/2022/09/07/26-about-design-model3/explain-model-3.png\" alt=\"explain-model-3\"></p>\n<p>解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是<strong>能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的</strong>。因为解释器要按照这套规则才能实现相应的功能。</p>\n"},{"title":"JavaScript设计模式读书笔记(5)","date":"2022-09-19T09:51:10.000Z","_content":"\n#### 技巧型设计模式\n技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。\n\n###### 链模式\n链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。\n\n![chain-model-1](chain-model-1.png)\n![chain-model-2](chain-model-2.png)\n![chain-model-3](chain-model-3.png)\n\njOuery获取的元素更像一个数组，上面框架返回的更像是一个对象\n原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了\n![chain-model-4](chain-model-4.png)\n\n![chain-model-5](chain-model-5.png)\n![chain-model-6](chain-model-6.png)\n\n###### 委托模式\n委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。\n\n委托模式可以优化页面中事件的数量。\n\n事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑\n\n![entrust-model-1](entrust-model-1.png)\n![entrust-model-2](entrust-model-2.png)\n\n###### 数据访问对象模式\n数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。\n\n![localstorage-model-1](localstorage-model-1.png)\n![localstorage-model-2](localstorage-model-2.png)\n![localstorage-model-3](localstorage-model-3.png)\n![localstorage-model-4](localstorage-model-4.png)\n![localstorage-model-5](localstorage-model-5.png)\n![localstorage-model-6](localstorage-model-6.png)\n\n###### 节流模式\n节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。\n\n![throttle-model-1](throttle-model-1.png)\n![throttle-model-2](throttle-model-2.png)\n![throttle-model-3](throttle-model-3.png)\n\n节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。\n\n节流模式优势\n(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行\n(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。\n\n###### 简单模板模式\n简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。\n\n![template-model-1](template-model-1.png)\n![template-model-2](template-model-2.png)\n![template-model-3](template-model-3.png)\n![template-model-4](template-model-4.png)\n![template-model-5](template-model-5.png)\n![template-model-6](template-model-6.png)\n\n###### 惰性模式\n惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。\n\n两种实现方式\n(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。\n(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗\n\n![lazy-model-1](lazy-model-1.png)\n![lazy-model-2](lazy-model-2.png)\n![lazy-model-3](lazy-model-3.png)\n![lazy-model-4](lazy-model-4.png)\n![lazy-model-5](lazy-model-5.png)\n![lazy-model-6](lazy-model-6.png)\n\n###### 参与者模式\n参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。\n\n![participate-model-1](participate-model-1.png)\n![participate-model-2](participate-model-2.png)\n\n函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能\n\n![participate-model-3](participate-model-3.png)\n![participate-model-4](participate-model-4.png)\n![participate-model-5](participate-model-5.png)\n\n参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化\n(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。\n(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。\n\n随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用\n![participate-model-6](participate-model-6.png)\n\n###### 等待者模式\n等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。\n\n![waiter-model-1](waiter-model-1.png)\n![waiter-model-2](waiter-model-2.png)\n![waiter-model-3](waiter-model-3.png)\n![waiter-model-4](waiter-model-4.png)\n![waiter-model-5](waiter-model-5.png)\n![waiter-model-6](waiter-model-6.png)\n![waiter-model-7](waiter-model-7.png)\n![waiter-model-8](waiter-model-8.png)\n\n","source":"_posts/27-about-design-model4.md","raw":"---\ntitle: JavaScript设计模式读书笔记(5)\ndate: 2022-09-19 17:51:10\ntags:\n---\n\n#### 技巧型设计模式\n技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。\n\n###### 链模式\n链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。\n\n![chain-model-1](chain-model-1.png)\n![chain-model-2](chain-model-2.png)\n![chain-model-3](chain-model-3.png)\n\njOuery获取的元素更像一个数组，上面框架返回的更像是一个对象\n原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了\n![chain-model-4](chain-model-4.png)\n\n![chain-model-5](chain-model-5.png)\n![chain-model-6](chain-model-6.png)\n\n###### 委托模式\n委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。\n\n委托模式可以优化页面中事件的数量。\n\n事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑\n\n![entrust-model-1](entrust-model-1.png)\n![entrust-model-2](entrust-model-2.png)\n\n###### 数据访问对象模式\n数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。\n\n![localstorage-model-1](localstorage-model-1.png)\n![localstorage-model-2](localstorage-model-2.png)\n![localstorage-model-3](localstorage-model-3.png)\n![localstorage-model-4](localstorage-model-4.png)\n![localstorage-model-5](localstorage-model-5.png)\n![localstorage-model-6](localstorage-model-6.png)\n\n###### 节流模式\n节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。\n\n![throttle-model-1](throttle-model-1.png)\n![throttle-model-2](throttle-model-2.png)\n![throttle-model-3](throttle-model-3.png)\n\n节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。\n\n节流模式优势\n(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行\n(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。\n\n###### 简单模板模式\n简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。\n\n![template-model-1](template-model-1.png)\n![template-model-2](template-model-2.png)\n![template-model-3](template-model-3.png)\n![template-model-4](template-model-4.png)\n![template-model-5](template-model-5.png)\n![template-model-6](template-model-6.png)\n\n###### 惰性模式\n惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。\n\n两种实现方式\n(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。\n(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗\n\n![lazy-model-1](lazy-model-1.png)\n![lazy-model-2](lazy-model-2.png)\n![lazy-model-3](lazy-model-3.png)\n![lazy-model-4](lazy-model-4.png)\n![lazy-model-5](lazy-model-5.png)\n![lazy-model-6](lazy-model-6.png)\n\n###### 参与者模式\n参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。\n\n![participate-model-1](participate-model-1.png)\n![participate-model-2](participate-model-2.png)\n\n函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能\n\n![participate-model-3](participate-model-3.png)\n![participate-model-4](participate-model-4.png)\n![participate-model-5](participate-model-5.png)\n\n参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化\n(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。\n(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。\n\n随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用\n![participate-model-6](participate-model-6.png)\n\n###### 等待者模式\n等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。\n\n![waiter-model-1](waiter-model-1.png)\n![waiter-model-2](waiter-model-2.png)\n![waiter-model-3](waiter-model-3.png)\n![waiter-model-4](waiter-model-4.png)\n![waiter-model-5](waiter-model-5.png)\n![waiter-model-6](waiter-model-6.png)\n![waiter-model-7](waiter-model-7.png)\n![waiter-model-8](waiter-model-8.png)\n\n","slug":"27-about-design-model4","published":1,"updated":"2022-09-23T06:51:25.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwx0013cktt7ij295mx","content":"<h4 id=\"技巧型设计模式\"><a href=\"#技巧型设计模式\" class=\"headerlink\" title=\"技巧型设计模式\"></a>技巧型设计模式</h4><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。</p>\n<h6 id=\"链模式\"><a href=\"#链模式\" class=\"headerlink\" title=\"链模式\"></a>链模式</h6><p>链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-1.png\" alt=\"chain-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-2.png\" alt=\"chain-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-3.png\" alt=\"chain-model-3\"></p>\n<p>jOuery获取的元素更像一个数组，上面框架返回的更像是一个对象<br>原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了<br><img src=\"/2022/09/19/27-about-design-model4/chain-model-4.png\" alt=\"chain-model-4\"></p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-5.png\" alt=\"chain-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-6.png\" alt=\"chain-model-6\"></p>\n<h6 id=\"委托模式\"><a href=\"#委托模式\" class=\"headerlink\" title=\"委托模式\"></a>委托模式</h6><p>委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。</p>\n<p>委托模式可以优化页面中事件的数量。</p>\n<p>事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/entrust-model-1.png\" alt=\"entrust-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/entrust-model-2.png\" alt=\"entrust-model-2\"></p>\n<h6 id=\"数据访问对象模式\"><a href=\"#数据访问对象模式\" class=\"headerlink\" title=\"数据访问对象模式\"></a>数据访问对象模式</h6><p>数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-1.png\" alt=\"localstorage-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-2.png\" alt=\"localstorage-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-3.png\" alt=\"localstorage-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-4.png\" alt=\"localstorage-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-5.png\" alt=\"localstorage-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-6.png\" alt=\"localstorage-model-6\"></p>\n<h6 id=\"节流模式\"><a href=\"#节流模式\" class=\"headerlink\" title=\"节流模式\"></a>节流模式</h6><p>节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/throttle-model-1.png\" alt=\"throttle-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-2.png\" alt=\"throttle-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-3.png\" alt=\"throttle-model-3\"></p>\n<p>节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。</p>\n<p>节流模式优势<br>(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行<br>(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。</p>\n<h6 id=\"简单模板模式\"><a href=\"#简单模板模式\" class=\"headerlink\" title=\"简单模板模式\"></a>简单模板模式</h6><p>简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/template-model-1.png\" alt=\"template-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-2.png\" alt=\"template-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-3.png\" alt=\"template-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-4.png\" alt=\"template-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-5.png\" alt=\"template-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-6.png\" alt=\"template-model-6\"></p>\n<h6 id=\"惰性模式\"><a href=\"#惰性模式\" class=\"headerlink\" title=\"惰性模式\"></a>惰性模式</h6><p>惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。</p>\n<p>两种实现方式<br>(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。<br>(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/lazy-model-1.png\" alt=\"lazy-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-2.png\" alt=\"lazy-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-3.png\" alt=\"lazy-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-4.png\" alt=\"lazy-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-5.png\" alt=\"lazy-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-6.png\" alt=\"lazy-model-6\"></p>\n<h6 id=\"参与者模式\"><a href=\"#参与者模式\" class=\"headerlink\" title=\"参与者模式\"></a>参与者模式</h6><p>参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-1.png\" alt=\"participate-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-2.png\" alt=\"participate-model-2\"></p>\n<p>函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-3.png\" alt=\"participate-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-4.png\" alt=\"participate-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-5.png\" alt=\"participate-model-5\"></p>\n<p>参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化<br>(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。<br>(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。</p>\n<p>随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用<br><img src=\"/2022/09/19/27-about-design-model4/participate-model-6.png\" alt=\"participate-model-6\"></p>\n<h6 id=\"等待者模式\"><a href=\"#等待者模式\" class=\"headerlink\" title=\"等待者模式\"></a>等待者模式</h6><p>等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/waiter-model-1.png\" alt=\"waiter-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-2.png\" alt=\"waiter-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-3.png\" alt=\"waiter-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-4.png\" alt=\"waiter-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-5.png\" alt=\"waiter-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-6.png\" alt=\"waiter-model-6\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-7.png\" alt=\"waiter-model-7\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-8.png\" alt=\"waiter-model-8\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"技巧型设计模式\"><a href=\"#技巧型设计模式\" class=\"headerlink\" title=\"技巧型设计模式\"></a>技巧型设计模式</h4><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。</p>\n<h6 id=\"链模式\"><a href=\"#链模式\" class=\"headerlink\" title=\"链模式\"></a>链模式</h6><p>链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-1.png\" alt=\"chain-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-2.png\" alt=\"chain-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-3.png\" alt=\"chain-model-3\"></p>\n<p>jOuery获取的元素更像一个数组，上面框架返回的更像是一个对象<br>原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了<br><img src=\"/2022/09/19/27-about-design-model4/chain-model-4.png\" alt=\"chain-model-4\"></p>\n<p><img src=\"/2022/09/19/27-about-design-model4/chain-model-5.png\" alt=\"chain-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/chain-model-6.png\" alt=\"chain-model-6\"></p>\n<h6 id=\"委托模式\"><a href=\"#委托模式\" class=\"headerlink\" title=\"委托模式\"></a>委托模式</h6><p>委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。</p>\n<p>委托模式可以优化页面中事件的数量。</p>\n<p>事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/entrust-model-1.png\" alt=\"entrust-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/entrust-model-2.png\" alt=\"entrust-model-2\"></p>\n<h6 id=\"数据访问对象模式\"><a href=\"#数据访问对象模式\" class=\"headerlink\" title=\"数据访问对象模式\"></a>数据访问对象模式</h6><p>数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-1.png\" alt=\"localstorage-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-2.png\" alt=\"localstorage-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-3.png\" alt=\"localstorage-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-4.png\" alt=\"localstorage-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-5.png\" alt=\"localstorage-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/localstorage-model-6.png\" alt=\"localstorage-model-6\"></p>\n<h6 id=\"节流模式\"><a href=\"#节流模式\" class=\"headerlink\" title=\"节流模式\"></a>节流模式</h6><p>节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/throttle-model-1.png\" alt=\"throttle-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-2.png\" alt=\"throttle-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/throttle-model-3.png\" alt=\"throttle-model-3\"></p>\n<p>节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。</p>\n<p>节流模式优势<br>(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行<br>(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。</p>\n<h6 id=\"简单模板模式\"><a href=\"#简单模板模式\" class=\"headerlink\" title=\"简单模板模式\"></a>简单模板模式</h6><p>简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/template-model-1.png\" alt=\"template-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-2.png\" alt=\"template-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-3.png\" alt=\"template-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-4.png\" alt=\"template-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-5.png\" alt=\"template-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/template-model-6.png\" alt=\"template-model-6\"></p>\n<h6 id=\"惰性模式\"><a href=\"#惰性模式\" class=\"headerlink\" title=\"惰性模式\"></a>惰性模式</h6><p>惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。</p>\n<p>两种实现方式<br>(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。<br>(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/lazy-model-1.png\" alt=\"lazy-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-2.png\" alt=\"lazy-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-3.png\" alt=\"lazy-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-4.png\" alt=\"lazy-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-5.png\" alt=\"lazy-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/lazy-model-6.png\" alt=\"lazy-model-6\"></p>\n<h6 id=\"参与者模式\"><a href=\"#参与者模式\" class=\"headerlink\" title=\"参与者模式\"></a>参与者模式</h6><p>参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-1.png\" alt=\"participate-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-2.png\" alt=\"participate-model-2\"></p>\n<p>函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/participate-model-3.png\" alt=\"participate-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-4.png\" alt=\"participate-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/participate-model-5.png\" alt=\"participate-model-5\"></p>\n<p>参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化<br>(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。<br>(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。</p>\n<p>随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用<br><img src=\"/2022/09/19/27-about-design-model4/participate-model-6.png\" alt=\"participate-model-6\"></p>\n<h6 id=\"等待者模式\"><a href=\"#等待者模式\" class=\"headerlink\" title=\"等待者模式\"></a>等待者模式</h6><p>等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。</p>\n<p><img src=\"/2022/09/19/27-about-design-model4/waiter-model-1.png\" alt=\"waiter-model-1\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-2.png\" alt=\"waiter-model-2\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-3.png\" alt=\"waiter-model-3\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-4.png\" alt=\"waiter-model-4\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-5.png\" alt=\"waiter-model-5\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-6.png\" alt=\"waiter-model-6\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-7.png\" alt=\"waiter-model-7\"><br><img src=\"/2022/09/19/27-about-design-model4/waiter-model-8.png\" alt=\"waiter-model-8\"></p>\n"},{"title":"JavaScript设计模式读书笔记(6)","date":"2022-09-20T07:22:12.000Z","_content":"\n#### 架构型设计模式\n架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。\n\n###### 同步模块模式\n模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。\n同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。\n\n(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。\n\n![module-model-1](module-model-1.png)\n![module-model-2](module-model-2.png)\n![module-model-3](module-model-3.png)\n![module-model-4](module-model-4.png)\n![module-model-5](module-model-5.png)\n\n###### 异步模块模式\n异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。\n\n![async-module-model-1](async-module-model-1.png)\n![async-module-model-2](async-module-model-2.png)\n![async-module-model-3](async-module-model-3.png)\n![async-module-model-4](async-module-model-4.png)\n![async-module-model-5](async-module-model-5.png)\n![async-module-model-6](async-module-model-6.png)\n![async-module-model-7](async-module-model-7.png)\n![async-module-model-8](async-module-model-8.png)\n![async-module-model-9](async-module-model-9.png)\n\n###### Widget模式\nWidget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。\n\n![widget-model-1](widget-model-1.png)\n![widget-model-2](widget-model-2.png)\n![widget-model-3](widget-model-3.png)\n![widget-model-4](widget-model-4.png)\n![widget-model-5](widget-model-5.png)\n![widget-model-6](widget-model-6.png)\n\n###### MVC模式\nMVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。\n\n![mvc-model-1](mvc-model-1.png)\n\n**每个对象是一个自动执行的函数**\n**3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法**\n\n![mvc-model-2](mvc-model-2.png)\n![mvc-model-3](mvc-model-3.png)\n视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口\n\n![mvc-model-4](mvc-model-4.png)\n\n###### MVP模式\nMVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。\n\n![mvp-model-1](mvp-model-1.png)\n![mvp-model-2](mvp-model-2.png)\n![mvp-model-3](mvp-model-3.png)\n![mvp-model-4](mvp-model-4.png)\n![mvp-model-5](mvp-model-5.png)\n![mvp-model-6](mvp-model-6.png)\n![mvp-model-7](mvp-model-7.png)\n\nMVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。\n\n###### MVVM模式\nMVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。\n\n![mvvm-model-1](mvvm-model-1.png)\n![mvvm-model-2](mvvm-model-2.png)\n![mvvm-model-3](mvvm-model-3.png)\n![mvvm-model-4](mvvm-model-4.png)\n![mvvm-model-5](mvvm-model-5.png)\n![mvvm-model-6](mvvm-model-6.png)\n![mvvm-model-7](mvvm-model-7.png)\n![mvvm-model-8](mvvm-model-8.png)\n\n###### 附录\n![appendix-1](appendix-1.png)\n![appendix-2](appendix-2.png)\n![appendix-3](appendix-3.png)\n![appendix-4](appendix-4.png)\n![appendix-5](appendix-5.png)\n![appendix-6](appendix-6.png)\n![appendix-7](appendix-7.png)\n![appendix-8](appendix-8.png)\n![appendix-9](appendix-9.png)\n![appendix-10](appendix-10.png)\n\n\n疑问点：\n(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice\n编程方式区分，不要糅合在一起\n对性能影响可以忽略不计\n\n(2)有一些模式很像，一定需要做区分吗？\n从实际场景触发，贴合场景选择设计模式\n设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题\n\n(3)柯理化\n函数；\n接受多个参数（一个参数没必要用柯理化）；\n将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果\n调用方式不一样。普通函数：函数名(参数1, 参数2, ...);   柯理化：函数名(参数1)(参数2)...\n\n对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决","source":"_posts/28-about-design-model5.md","raw":"---\ntitle: JavaScript设计模式读书笔记(6)\ndate: 2022-09-20 15:22:12\ntags:\n---\n\n#### 架构型设计模式\n架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。\n\n###### 同步模块模式\n模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。\n同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。\n\n(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。\n\n![module-model-1](module-model-1.png)\n![module-model-2](module-model-2.png)\n![module-model-3](module-model-3.png)\n![module-model-4](module-model-4.png)\n![module-model-5](module-model-5.png)\n\n###### 异步模块模式\n异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。\n\n![async-module-model-1](async-module-model-1.png)\n![async-module-model-2](async-module-model-2.png)\n![async-module-model-3](async-module-model-3.png)\n![async-module-model-4](async-module-model-4.png)\n![async-module-model-5](async-module-model-5.png)\n![async-module-model-6](async-module-model-6.png)\n![async-module-model-7](async-module-model-7.png)\n![async-module-model-8](async-module-model-8.png)\n![async-module-model-9](async-module-model-9.png)\n\n###### Widget模式\nWidget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。\n\n![widget-model-1](widget-model-1.png)\n![widget-model-2](widget-model-2.png)\n![widget-model-3](widget-model-3.png)\n![widget-model-4](widget-model-4.png)\n![widget-model-5](widget-model-5.png)\n![widget-model-6](widget-model-6.png)\n\n###### MVC模式\nMVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。\n\n![mvc-model-1](mvc-model-1.png)\n\n**每个对象是一个自动执行的函数**\n**3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法**\n\n![mvc-model-2](mvc-model-2.png)\n![mvc-model-3](mvc-model-3.png)\n视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口\n\n![mvc-model-4](mvc-model-4.png)\n\n###### MVP模式\nMVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。\n\n![mvp-model-1](mvp-model-1.png)\n![mvp-model-2](mvp-model-2.png)\n![mvp-model-3](mvp-model-3.png)\n![mvp-model-4](mvp-model-4.png)\n![mvp-model-5](mvp-model-5.png)\n![mvp-model-6](mvp-model-6.png)\n![mvp-model-7](mvp-model-7.png)\n\nMVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。\n\n###### MVVM模式\nMVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。\n\n![mvvm-model-1](mvvm-model-1.png)\n![mvvm-model-2](mvvm-model-2.png)\n![mvvm-model-3](mvvm-model-3.png)\n![mvvm-model-4](mvvm-model-4.png)\n![mvvm-model-5](mvvm-model-5.png)\n![mvvm-model-6](mvvm-model-6.png)\n![mvvm-model-7](mvvm-model-7.png)\n![mvvm-model-8](mvvm-model-8.png)\n\n###### 附录\n![appendix-1](appendix-1.png)\n![appendix-2](appendix-2.png)\n![appendix-3](appendix-3.png)\n![appendix-4](appendix-4.png)\n![appendix-5](appendix-5.png)\n![appendix-6](appendix-6.png)\n![appendix-7](appendix-7.png)\n![appendix-8](appendix-8.png)\n![appendix-9](appendix-9.png)\n![appendix-10](appendix-10.png)\n\n\n疑问点：\n(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice\n编程方式区分，不要糅合在一起\n对性能影响可以忽略不计\n\n(2)有一些模式很像，一定需要做区分吗？\n从实际场景触发，贴合场景选择设计模式\n设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题\n\n(3)柯理化\n函数；\n接受多个参数（一个参数没必要用柯理化）；\n将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果\n调用方式不一样。普通函数：函数名(参数1, 参数2, ...);   柯理化：函数名(参数1)(参数2)...\n\n对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决","slug":"28-about-design-model5","published":1,"updated":"2022-09-23T06:59:38.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwy0015cktt0yuydb6h","content":"<h4 id=\"架构型设计模式\"><a href=\"#架构型设计模式\" class=\"headerlink\" title=\"架构型设计模式\"></a>架构型设计模式</h4><p>架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。</p>\n<h6 id=\"同步模块模式\"><a href=\"#同步模块模式\" class=\"headerlink\" title=\"同步模块模式\"></a>同步模块模式</h6><p>模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。<br>同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。</p>\n<p>(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/module-model-1.png\" alt=\"module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-2.png\" alt=\"module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-3.png\" alt=\"module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-4.png\" alt=\"module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-5.png\" alt=\"module-model-5\"></p>\n<h6 id=\"异步模块模式\"><a href=\"#异步模块模式\" class=\"headerlink\" title=\"异步模块模式\"></a>异步模块模式</h6><p>异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/async-module-model-1.png\" alt=\"async-module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-2.png\" alt=\"async-module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-3.png\" alt=\"async-module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-4.png\" alt=\"async-module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-5.png\" alt=\"async-module-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-6.png\" alt=\"async-module-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-7.png\" alt=\"async-module-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-8.png\" alt=\"async-module-model-8\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-9.png\" alt=\"async-module-model-9\"></p>\n<h6 id=\"Widget模式\"><a href=\"#Widget模式\" class=\"headerlink\" title=\"Widget模式\"></a>Widget模式</h6><p>Widget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/widget-model-1.png\" alt=\"widget-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-2.png\" alt=\"widget-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-3.png\" alt=\"widget-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-4.png\" alt=\"widget-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-5.png\" alt=\"widget-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-6.png\" alt=\"widget-model-6\"></p>\n<h6 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h6><p>MVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-1.png\" alt=\"mvc-model-1\"></p>\n<p><strong>每个对象是一个自动执行的函数</strong><br><strong>3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法</strong></p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-2.png\" alt=\"mvc-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvc-model-3.png\" alt=\"mvc-model-3\"><br>视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-4.png\" alt=\"mvc-model-4\"></p>\n<h6 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h6><p>MVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvp-model-1.png\" alt=\"mvp-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-2.png\" alt=\"mvp-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-3.png\" alt=\"mvp-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-4.png\" alt=\"mvp-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-5.png\" alt=\"mvp-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-6.png\" alt=\"mvp-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-7.png\" alt=\"mvp-model-7\"></p>\n<p>MVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。</p>\n<h6 id=\"MVVM模式\"><a href=\"#MVVM模式\" class=\"headerlink\" title=\"MVVM模式\"></a>MVVM模式</h6><p>MVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-1.png\" alt=\"mvvm-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-2.png\" alt=\"mvvm-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-3.png\" alt=\"mvvm-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-4.png\" alt=\"mvvm-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-5.png\" alt=\"mvvm-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-6.png\" alt=\"mvvm-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-7.png\" alt=\"mvvm-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-8.png\" alt=\"mvvm-model-8\"></p>\n<h6 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h6><p><img src=\"/2022/09/20/28-about-design-model5/appendix-1.png\" alt=\"appendix-1\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-2.png\" alt=\"appendix-2\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-3.png\" alt=\"appendix-3\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-4.png\" alt=\"appendix-4\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-5.png\" alt=\"appendix-5\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-6.png\" alt=\"appendix-6\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-7.png\" alt=\"appendix-7\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-8.png\" alt=\"appendix-8\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-9.png\" alt=\"appendix-9\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-10.png\" alt=\"appendix-10\"></p>\n<p>疑问点：<br>(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice<br>编程方式区分，不要糅合在一起<br>对性能影响可以忽略不计</p>\n<p>(2)有一些模式很像，一定需要做区分吗？<br>从实际场景触发，贴合场景选择设计模式<br>设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题</p>\n<p>(3)柯理化<br>函数；<br>接受多个参数（一个参数没必要用柯理化）；<br>将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果<br>调用方式不一样。普通函数：函数名(参数1, 参数2, …);   柯理化：函数名(参数1)(参数2)…</p>\n<p>对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"架构型设计模式\"><a href=\"#架构型设计模式\" class=\"headerlink\" title=\"架构型设计模式\"></a>架构型设计模式</h4><p>架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。</p>\n<h6 id=\"同步模块模式\"><a href=\"#同步模块模式\" class=\"headerlink\" title=\"同步模块模式\"></a>同步模块模式</h6><p>模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。<br>同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。</p>\n<p>(1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/module-model-1.png\" alt=\"module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-2.png\" alt=\"module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-3.png\" alt=\"module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-4.png\" alt=\"module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/module-model-5.png\" alt=\"module-model-5\"></p>\n<h6 id=\"异步模块模式\"><a href=\"#异步模块模式\" class=\"headerlink\" title=\"异步模块模式\"></a>异步模块模式</h6><p>异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/async-module-model-1.png\" alt=\"async-module-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-2.png\" alt=\"async-module-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-3.png\" alt=\"async-module-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-4.png\" alt=\"async-module-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-5.png\" alt=\"async-module-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-6.png\" alt=\"async-module-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-7.png\" alt=\"async-module-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-8.png\" alt=\"async-module-model-8\"><br><img src=\"/2022/09/20/28-about-design-model5/async-module-model-9.png\" alt=\"async-module-model-9\"></p>\n<h6 id=\"Widget模式\"><a href=\"#Widget模式\" class=\"headerlink\" title=\"Widget模式\"></a>Widget模式</h6><p>Widget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/widget-model-1.png\" alt=\"widget-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-2.png\" alt=\"widget-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-3.png\" alt=\"widget-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-4.png\" alt=\"widget-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-5.png\" alt=\"widget-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/widget-model-6.png\" alt=\"widget-model-6\"></p>\n<h6 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h6><p>MVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-1.png\" alt=\"mvc-model-1\"></p>\n<p><strong>每个对象是一个自动执行的函数</strong><br><strong>3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法</strong></p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-2.png\" alt=\"mvc-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvc-model-3.png\" alt=\"mvc-model-3\"><br>视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvc-model-4.png\" alt=\"mvc-model-4\"></p>\n<h6 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h6><p>MVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvp-model-1.png\" alt=\"mvp-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-2.png\" alt=\"mvp-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-3.png\" alt=\"mvp-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-4.png\" alt=\"mvp-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-5.png\" alt=\"mvp-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-6.png\" alt=\"mvp-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvp-model-7.png\" alt=\"mvp-model-7\"></p>\n<p>MVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。</p>\n<h6 id=\"MVVM模式\"><a href=\"#MVVM模式\" class=\"headerlink\" title=\"MVVM模式\"></a>MVVM模式</h6><p>MVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。</p>\n<p><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-1.png\" alt=\"mvvm-model-1\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-2.png\" alt=\"mvvm-model-2\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-3.png\" alt=\"mvvm-model-3\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-4.png\" alt=\"mvvm-model-4\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-5.png\" alt=\"mvvm-model-5\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-6.png\" alt=\"mvvm-model-6\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-7.png\" alt=\"mvvm-model-7\"><br><img src=\"/2022/09/20/28-about-design-model5/mvvm-model-8.png\" alt=\"mvvm-model-8\"></p>\n<h6 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h6><p><img src=\"/2022/09/20/28-about-design-model5/appendix-1.png\" alt=\"appendix-1\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-2.png\" alt=\"appendix-2\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-3.png\" alt=\"appendix-3\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-4.png\" alt=\"appendix-4\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-5.png\" alt=\"appendix-5\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-6.png\" alt=\"appendix-6\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-7.png\" alt=\"appendix-7\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-8.png\" alt=\"appendix-8\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-9.png\" alt=\"appendix-9\"><br><img src=\"/2022/09/20/28-about-design-model5/appendix-10.png\" alt=\"appendix-10\"></p>\n<p>疑问点：<br>(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice<br>编程方式区分，不要糅合在一起<br>对性能影响可以忽略不计</p>\n<p>(2)有一些模式很像，一定需要做区分吗？<br>从实际场景触发，贴合场景选择设计模式<br>设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题</p>\n<p>(3)柯理化<br>函数；<br>接受多个参数（一个参数没必要用柯理化）；<br>将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果<br>调用方式不一样。普通函数：函数名(参数1, 参数2, …);   柯理化：函数名(参数1)(参数2)…</p>\n<p>对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决</p>\n"},{"title":"开发中使用的便捷代码","date":"2022-09-05T05:24:10.000Z","_content":"\n###### 基于条件设置对象属性\n```javascript\n// 空值\nconst name = '';\nconst obj = { ...name && {name}};\nconsole.log(obj); // {}\n// 非空值\nconst name = 'test_name';\nconst obj = { ...name && {name}};\nconsole.log(obj); // { name: 'test_name'}\n```\n\n###### 无中间变量交换变量值\n```javascript\nlet one = '12';\nlet two = '34';\n[one, two] = [two, one];\nconsole.log(one); // '34'\nconsole.log(two); // '12'\n```\n\n###### 过滤Boolean值为false的值\n```javascript\nconst array = [0, false, 12, true, '12', undefined, '', 8, null];\nconst result = array.filter(Boolean);\nconsole.log(result); // [12, true, '12', 8]\n```\n\n###### 转换元素类型\n```javascript\n// 将Number类型转换为String\nconst string = [1, 2, 3, 12].map(String);\nconsole.log(string); // ['1', '2', '3', '12']\n// 将String类型转换为Number\nconst string = ['1', '2', '3', '12'].map(Number);\nconsole.log(string); // [1, 2, 3, 12]\n```\n\n###### 数组去重\n```javascript\nconst repeatArray = [1,1,1,3,5,6,7,8,9,23,45,1,2,3,5,6];\nconst result = [...new Set(repeatArray)];\nconsole.log(result); // [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]\n```","source":"_posts/30-some-convenient-code.md","raw":"---\ntitle: 开发中使用的便捷代码\ndate: 2022-09-05 13:24:10\ntags:\n---\n\n###### 基于条件设置对象属性\n```javascript\n// 空值\nconst name = '';\nconst obj = { ...name && {name}};\nconsole.log(obj); // {}\n// 非空值\nconst name = 'test_name';\nconst obj = { ...name && {name}};\nconsole.log(obj); // { name: 'test_name'}\n```\n\n###### 无中间变量交换变量值\n```javascript\nlet one = '12';\nlet two = '34';\n[one, two] = [two, one];\nconsole.log(one); // '34'\nconsole.log(two); // '12'\n```\n\n###### 过滤Boolean值为false的值\n```javascript\nconst array = [0, false, 12, true, '12', undefined, '', 8, null];\nconst result = array.filter(Boolean);\nconsole.log(result); // [12, true, '12', 8]\n```\n\n###### 转换元素类型\n```javascript\n// 将Number类型转换为String\nconst string = [1, 2, 3, 12].map(String);\nconsole.log(string); // ['1', '2', '3', '12']\n// 将String类型转换为Number\nconst string = ['1', '2', '3', '12'].map(Number);\nconsole.log(string); // [1, 2, 3, 12]\n```\n\n###### 数组去重\n```javascript\nconst repeatArray = [1,1,1,3,5,6,7,8,9,23,45,1,2,3,5,6];\nconst result = [...new Set(repeatArray)];\nconsole.log(result); // [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]\n```","slug":"30-some-convenient-code","published":1,"updated":"2022-09-05T05:42:03.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwy0017cktt7tj472c9","content":"<h6 id=\"基于条件设置对象属性\"><a href=\"#基于条件设置对象属性\" class=\"headerlink\" title=\"基于条件设置对象属性\"></a>基于条件设置对象属性</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 非空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;test_name&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; name: &#x27;test_name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无中间变量交换变量值\"><a href=\"#无中间变量交换变量值\" class=\"headerlink\" title=\"无中间变量交换变量值\"></a>无中间变量交换变量值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"string\">&#x27;12&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"string\">&#x27;34&#x27;</span>;</span><br><span class=\"line\">[one, two] = [two, one];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one); <span class=\"comment\">// &#x27;34&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two); <span class=\"comment\">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"过滤Boolean值为false的值\"><a href=\"#过滤Boolean值为false的值\" class=\"headerlink\" title=\"过滤Boolean值为false的值\"></a>过滤Boolean值为false的值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">0</span>, <span class=\"literal\">false</span>, <span class=\"number\">12</span>, <span class=\"literal\">true</span>, <span class=\"string\">&#x27;12&#x27;</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = array.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [12, true, &#x27;12&#x27;, 8]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"转换元素类型\"><a href=\"#转换元素类型\" class=\"headerlink\" title=\"转换元素类型\"></a>转换元素类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Number类型转换为String</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>].map(<span class=\"built_in\">String</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 将String类型转换为Number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;12&#x27;</span>].map(<span class=\"built_in\">Number</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [1, 2, 3, 12]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeatArray = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = [...new <span class=\"built_in\">Set</span>(repeatArray)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"基于条件设置对象属性\"><a href=\"#基于条件设置对象属性\" class=\"headerlink\" title=\"基于条件设置对象属性\"></a>基于条件设置对象属性</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 非空值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;test_name&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; name: &#x27;test_name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无中间变量交换变量值\"><a href=\"#无中间变量交换变量值\" class=\"headerlink\" title=\"无中间变量交换变量值\"></a>无中间变量交换变量值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"string\">&#x27;12&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"string\">&#x27;34&#x27;</span>;</span><br><span class=\"line\">[one, two] = [two, one];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one); <span class=\"comment\">// &#x27;34&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two); <span class=\"comment\">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"过滤Boolean值为false的值\"><a href=\"#过滤Boolean值为false的值\" class=\"headerlink\" title=\"过滤Boolean值为false的值\"></a>过滤Boolean值为false的值</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">0</span>, <span class=\"literal\">false</span>, <span class=\"number\">12</span>, <span class=\"literal\">true</span>, <span class=\"string\">&#x27;12&#x27;</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>, <span class=\"literal\">null</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = array.filter(<span class=\"built_in\">Boolean</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [12, true, &#x27;12&#x27;, 8]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"转换元素类型\"><a href=\"#转换元素类型\" class=\"headerlink\" title=\"转换元素类型\"></a>转换元素类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Number类型转换为String</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>].map(<span class=\"built_in\">String</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 将String类型转换为Number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> string = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;12&#x27;</span>].map(<span class=\"built_in\">Number</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">// [1, 2, 3, 12]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeatArray = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = [...new <span class=\"built_in\">Set</span>(repeatArray)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]</span></span><br></pre></td></tr></table></figure>"},{"title":"使用hexo相关","date":"2022-03-26T13:14:29.000Z","_content":"\n## 一些使用hexo搭建博客时遇到的问题\n\n1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：'hexo' 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found\n解决办法：重新运行命令：npm install hexo-cli -g\n\n2、生成的图片路径不正确，有/.io//等一些奇怪的前缀\n原因：使用的hexo-asset-image插件存在bug\n解决办法：手动修改node_modules/hexo-asset-image中index.js文件的处理方式\n\n```javascript\n'use strict';\nvar cheerio = require('cheerio');\n\nfunction getPosition(str, m, i) {\nreturn str.split(m, i).join(m).length;\n}\n\nvar version = String(hexo.version).split('.');\nhexo.extend.filter.register('after_post_render', function(data){\nvar config = hexo.config;\nif(config.post_asset_folder){\n  var link = data.permalink;\n  if(version.length > 0 && Number(version[0]) == 3)\n     var beginPos = getPosition(link, '/', 1) + 1;\n  else\n     var beginPos = getPosition(link, '/', 3) + 1;\n  // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".\n  var endPos = link.lastIndexOf('/') + 1;\n  link = link.substring(beginPos, endPos);\n  \n  var toprocess = ['excerpt', 'more', 'content'];\n  for(var i = 0; i < toprocess.length; i++){\n    var key = toprocess[i];\n  \n    var $ = cheerio.load(data[key], {\n      ignoreWhitespace: false,\n      xmlMode: false,\n      lowerCaseTags: false,\n      decodeEntities: false\n    });\n  \n    $('img').each(function(){\n      if ($(this).attr('src')){\n          // For windows style path, we replace '\\' to '/'.\n          var src = $(this).attr('src').replace('\\\\', '/');\n          if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n             !/^\\s*\\//.test(src)) {\n            // For \"about\" page, the first part of \"src\" can't be removed.\n            // In addition, to support multi-level local directory.\n            var linkArray = link.split('/').filter(function(elem){\n              return elem != '';\n            });\n            var srcArray = src.split('/').filter(function(elem){\n              return elem != '' && elem != '.';\n            });\n            if(srcArray.length > 1)\n              srcArray.shift();\n            src = srcArray.join('/');\n            // 以下生成图片路径的处理可根据自身需要进行修改\n            if (link == 'nodejs/') {\n              src = `images/${src}`;\n            }\n            $(this).attr('src', config.root + link + src);\n            console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n          }\n      }else{\n          console.info&&console.info(\"no src attr, skipped...\");\n          console.info&&console.info($(this));\n      }\n    });\n    data[key] = $.html();\n      }\n    }\n  });\n  \n```","source":"_posts/3-about-use-hexo.md","raw":"---\ntitle: 使用hexo相关\ndate: 2022-03-26 21:14:29\ntags:\n---\n\n## 一些使用hexo搭建博客时遇到的问题\n\n1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：'hexo' 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found\n解决办法：重新运行命令：npm install hexo-cli -g\n\n2、生成的图片路径不正确，有/.io//等一些奇怪的前缀\n原因：使用的hexo-asset-image插件存在bug\n解决办法：手动修改node_modules/hexo-asset-image中index.js文件的处理方式\n\n```javascript\n'use strict';\nvar cheerio = require('cheerio');\n\nfunction getPosition(str, m, i) {\nreturn str.split(m, i).join(m).length;\n}\n\nvar version = String(hexo.version).split('.');\nhexo.extend.filter.register('after_post_render', function(data){\nvar config = hexo.config;\nif(config.post_asset_folder){\n  var link = data.permalink;\n  if(version.length > 0 && Number(version[0]) == 3)\n     var beginPos = getPosition(link, '/', 1) + 1;\n  else\n     var beginPos = getPosition(link, '/', 3) + 1;\n  // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".\n  var endPos = link.lastIndexOf('/') + 1;\n  link = link.substring(beginPos, endPos);\n  \n  var toprocess = ['excerpt', 'more', 'content'];\n  for(var i = 0; i < toprocess.length; i++){\n    var key = toprocess[i];\n  \n    var $ = cheerio.load(data[key], {\n      ignoreWhitespace: false,\n      xmlMode: false,\n      lowerCaseTags: false,\n      decodeEntities: false\n    });\n  \n    $('img').each(function(){\n      if ($(this).attr('src')){\n          // For windows style path, we replace '\\' to '/'.\n          var src = $(this).attr('src').replace('\\\\', '/');\n          if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n             !/^\\s*\\//.test(src)) {\n            // For \"about\" page, the first part of \"src\" can't be removed.\n            // In addition, to support multi-level local directory.\n            var linkArray = link.split('/').filter(function(elem){\n              return elem != '';\n            });\n            var srcArray = src.split('/').filter(function(elem){\n              return elem != '' && elem != '.';\n            });\n            if(srcArray.length > 1)\n              srcArray.shift();\n            src = srcArray.join('/');\n            // 以下生成图片路径的处理可根据自身需要进行修改\n            if (link == 'nodejs/') {\n              src = `images/${src}`;\n            }\n            $(this).attr('src', config.root + link + src);\n            console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n          }\n      }else{\n          console.info&&console.info(\"no src attr, skipped...\");\n          console.info&&console.info($(this));\n      }\n    });\n    data[key] = $.html();\n      }\n    }\n  });\n  \n```","slug":"3-about-use-hexo","published":1,"updated":"2022-12-16T07:44:02.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gwz0019cktth3cb5axq","content":"<h2 id=\"一些使用hexo搭建博客时遇到的问题\"><a href=\"#一些使用hexo搭建博客时遇到的问题\" class=\"headerlink\" title=\"一些使用hexo搭建博客时遇到的问题\"></a>一些使用hexo搭建博客时遇到的问题</h2><p>1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found<br>解决办法：重新运行命令：npm install hexo-cli -g</p>\n<p>2、生成的图片路径不正确，有/.io//等一些奇怪的前缀<br>原因：使用的hexo-asset-image插件存在bug<br>解决办法：手动修改node_modules/hexo-asset-image中index.js文件的处理方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cheerio&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPosition</span>(<span class=\"params\">str, m, i</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> str.split(m, i).join(m).length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> version = <span class=\"built_in\">String</span>(hexo.version).split(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">&#x27;after_post_render&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> config = hexo.config;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(config.post_asset_folder)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> link = data.permalink;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(version.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">Number</span>(version[<span class=\"number\">0</span>]) == <span class=\"number\">3</span>)</span><br><span class=\"line\">     <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">3</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> endPos = link.lastIndexOf(<span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  link = link.substring(beginPos, endPos);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> toprocess = [<span class=\"string\">&#x27;excerpt&#x27;</span>, <span class=\"string\">&#x27;more&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = toprocess[i];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class=\"line\">      <span class=\"attr\">ignoreWhitespace</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">xmlMode</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">lowerCaseTags</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">decodeEntities</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">    $(<span class=\"string\">&#x27;img&#x27;</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ($(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>))&#123;</span><br><span class=\"line\">          <span class=\"comment\">// For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;.</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> src = $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>).replace(<span class=\"string\">&#x27;\\\\&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!<span class=\"regexp\">/http[s]*.*|\\/\\/.*/</span>.test(src) &amp;&amp;</span><br><span class=\"line\">             !<span class=\"regexp\">/^\\s*\\//</span>.test(src)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class=\"line\">            <span class=\"comment\">// In addition, to support multi-level local directory.</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> linkArray = link.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> srcArray = src.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span> &amp;&amp; elem != <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(srcArray.length &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">              srcArray.shift();</span><br><span class=\"line\">            src = srcArray.join(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 以下生成图片路径的处理可根据自身需要进行修改</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (link == <span class=\"string\">&#x27;nodejs/&#x27;</span>) &#123;</span><br><span class=\"line\">              src = <span class=\"string\">`images/<span class=\"subst\">$&#123;src&#125;</span>`</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;no src attr, skipped...&quot;</span>);</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info($(<span class=\"built_in\">this</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    data[key] = $.html();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一些使用hexo搭建博客时遇到的问题\"><a href=\"#一些使用hexo搭建博客时遇到的问题\" class=\"headerlink\" title=\"一些使用hexo搭建博客时遇到的问题\"></a>一些使用hexo搭建博客时遇到的问题</h2><p>1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件  或 bash: hexo: command not found<br>解决办法：重新运行命令：npm install hexo-cli -g</p>\n<p>2、生成的图片路径不正确，有/.io//等一些奇怪的前缀<br>原因：使用的hexo-asset-image插件存在bug<br>解决办法：手动修改node_modules/hexo-asset-image中index.js文件的处理方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cheerio&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPosition</span>(<span class=\"params\">str, m, i</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> str.split(m, i).join(m).length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> version = <span class=\"built_in\">String</span>(hexo.version).split(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">&#x27;after_post_render&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> config = hexo.config;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(config.post_asset_folder)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> link = data.permalink;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(version.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">Number</span>(version[<span class=\"number\">0</span>]) == <span class=\"number\">3</span>)</span><br><span class=\"line\">     <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">3</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> endPos = link.lastIndexOf(<span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  link = link.substring(beginPos, endPos);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> toprocess = [<span class=\"string\">&#x27;excerpt&#x27;</span>, <span class=\"string\">&#x27;more&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = toprocess[i];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class=\"line\">      <span class=\"attr\">ignoreWhitespace</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">xmlMode</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">lowerCaseTags</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">decodeEntities</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">    $(<span class=\"string\">&#x27;img&#x27;</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ($(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>))&#123;</span><br><span class=\"line\">          <span class=\"comment\">// For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;.</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> src = $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>).replace(<span class=\"string\">&#x27;\\\\&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!<span class=\"regexp\">/http[s]*.*|\\/\\/.*/</span>.test(src) &amp;&amp;</span><br><span class=\"line\">             !<span class=\"regexp\">/^\\s*\\//</span>.test(src)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class=\"line\">            <span class=\"comment\">// In addition, to support multi-level local directory.</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> linkArray = link.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> srcArray = src.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span> &amp;&amp; elem != <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(srcArray.length &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">              srcArray.shift();</span><br><span class=\"line\">            src = srcArray.join(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 以下生成图片路径的处理可根据自身需要进行修改</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (link == <span class=\"string\">&#x27;nodejs/&#x27;</span>) &#123;</span><br><span class=\"line\">              src = <span class=\"string\">`images/<span class=\"subst\">$&#123;src&#125;</span>`</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;no src attr, skipped...&quot;</span>);</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info($(<span class=\"built_in\">this</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    data[key] = $.html();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>"},{"title":"es6对象增强","date":"2022-09-02T02:42:05.000Z","_content":"\n#### 对象字面量语法扩展\n\n(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。\n\n```javascript\nvar name = 'test';\nvar obj = {\n  name,\n};\nconsole.log(obj); // {name: 'test'}\n```\n\n(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法\n\n```javascript\n// ES5\nconst es5Obj = {\n  testFunction: function () {\n    console.log('es5');\n  },\n};\nconsole.log(es5Obj.testFunction()); // es5\n\n// es6\nconst es6Obj = {\n  testFunction() {\n    console.log('es6');\n  },\n};\nconsole.log(es6Obj.testFunction()); // es6\n\n// **注意：只有赋值的是匿名函数，才可以使用简介语法**\nconst es6Obj1 = {\n  testFunction: function Hello() {\n    console.log('hello');\n  },\n};\nconsole.log(es6Obj1.testFunction()); // hello\n```\n\n**常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位**\n\n(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来\n\n```javascript\nconst es6Obj = {\n  ['first' + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj['first' + 'second']); // hanmeimei\n\nconst first = 'first';\nconst es6Obj1 = {\n  [first + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj[first + 'second']); // hanmeimei\n```\n\n(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性\n\n```javascript\nconst es6Obj = {\n  name: 'first',\n  name: 'second',\n};\nconsole.log(es6Obj); // {name: 'second'}\n```\n\n#### 新方法\n\n(1)Object.is()\n作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN\n\n```javascript\nconsole.log(+0 == -0); // true\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n(2)Object.assign()\n作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象\n\n```javascript\n// Object.assign(target, ...sources);  target为目标对象  sources为源对象\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target); // Object { a: 1, b: 4, c: 5 }\nconsole.log(returnedTarget); // Object { a: 1, b: 4, c: 5 }\n```\n\n(3)Object.setPrototypeOf()\n作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象\n```javascript\n// Object.setPrototypeOf(object, prototypeObject);\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {};\n// obj 链接到person\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // hello\n// obj 链接到dog\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woof\n```\n当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // obj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // obj\n```\n在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: 'super' keyword unexpected here\n**为什么？？**\n```javascript\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下写法报错：Uncaught SyntaxError: 'super' keyword unexpected here\n greeting: function() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting());\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting());\n\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下方法可以正常运行\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n**在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。**","source":"_posts/29-es6-object-strong.md","raw":"---\ntitle: es6对象增强\ndate: 2022-09-02 10:42:05\ntags:\n---\n\n#### 对象字面量语法扩展\n\n(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。\n\n```javascript\nvar name = 'test';\nvar obj = {\n  name,\n};\nconsole.log(obj); // {name: 'test'}\n```\n\n(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法\n\n```javascript\n// ES5\nconst es5Obj = {\n  testFunction: function () {\n    console.log('es5');\n  },\n};\nconsole.log(es5Obj.testFunction()); // es5\n\n// es6\nconst es6Obj = {\n  testFunction() {\n    console.log('es6');\n  },\n};\nconsole.log(es6Obj.testFunction()); // es6\n\n// **注意：只有赋值的是匿名函数，才可以使用简介语法**\nconst es6Obj1 = {\n  testFunction: function Hello() {\n    console.log('hello');\n  },\n};\nconsole.log(es6Obj1.testFunction()); // hello\n```\n\n**常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位**\n\n(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来\n\n```javascript\nconst es6Obj = {\n  ['first' + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj['first' + 'second']); // hanmeimei\n\nconst first = 'first';\nconst es6Obj1 = {\n  [first + 'second']: 'hanmeimei',\n};\nconsole.log(es6Obj[first + 'second']); // hanmeimei\n```\n\n(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性\n\n```javascript\nconst es6Obj = {\n  name: 'first',\n  name: 'second',\n};\nconsole.log(es6Obj); // {name: 'second'}\n```\n\n#### 新方法\n\n(1)Object.is()\n作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN\n\n```javascript\nconsole.log(+0 == -0); // true\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n(2)Object.assign()\n作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象\n\n```javascript\n// Object.assign(target, ...sources);  target为目标对象  sources为源对象\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target); // Object { a: 1, b: 4, c: 5 }\nconsole.log(returnedTarget); // Object { a: 1, b: 4, c: 5 }\n```\n\n(3)Object.setPrototypeOf()\n作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象\n```javascript\n// Object.setPrototypeOf(object, prototypeObject);\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {};\n// obj 链接到person\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // hello\n// obj 链接到dog\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woof\n```\n当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // obj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // obj\n```\n在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象\n```javascript\nlet person = {\n  greeting() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting() {\n    return 'woof';\n  },\n};\nlet obj = {\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: 'super' keyword unexpected here\n**为什么？？**\n```javascript\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下写法报错：Uncaught SyntaxError: 'super' keyword unexpected here\n greeting: function() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting());\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting());\n\nlet person = {\n  greeting: function() {\n    return 'hello';\n  },\n};\nlet dog = {\n  greeting: function() {\n    return 'woof';\n  },\n};\nlet obj = {\n // 以下方法可以正常运行\n greeting() {\n    return super.greeting() + 'obj';\n  },\n};\nObject.setPrototypeOf(obj, person);\nconsole.log(obj.greeting()); // helloobj\nObject.setPrototypeOf(obj, dog);\nconsole.log(obj.greeting()); // woofobj\n```\n**在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。**","slug":"29-es6-object-strong","published":1,"updated":"2022-09-02T05:49:32.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx0001acktth4sm5pcu","content":"<h4 id=\"对象字面量语法扩展\"><a href=\"#对象字面量语法扩展\" class=\"headerlink\" title=\"对象字面量语法扩展\"></a>对象字面量语法扩展</h4><p>(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;test&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;name: &#x27;test&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es5Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es5&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es5Obj.testFunction()); <span class=\"comment\">// es5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">testFunction</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es6&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj.testFunction()); <span class=\"comment\">// es6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// **注意：只有赋值的是匿名函数，才可以使用简介语法**</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj1.testFunction()); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位</strong></p>\n<p>(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  [<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> first = <span class=\"string\">&#x27;first&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  [first + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[first + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;first&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;second&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj); <span class=\"comment\">// &#123;name: &#x27;second&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h4><p>(1)Object.is()<br>作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> == -<span class=\"number\">0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)Object.assign()<br>作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.assign(target, ...sources);  target为目标对象  sources为源对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source = &#123; <span class=\"attr\">b</span>: <span class=\"number\">4</span>, <span class=\"attr\">c</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> returnedTarget = <span class=\"built_in\">Object</span>.assign(target, source);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(returnedTarget); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)Object.setPrototypeOf()<br>作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.setPrototypeOf(object, prototypeObject);</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// obj 链接到person</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// obj 链接到dog</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woof</span></span><br></pre></td></tr></table></figure>\n<p>当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n<p>在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p>对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: ‘super’ keyword unexpected here<br><strong>为什么？？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下写法报错：Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class=\"line\"> <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下方法可以正常运行</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p><strong>在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"对象字面量语法扩展\"><a href=\"#对象字面量语法扩展\" class=\"headerlink\" title=\"对象字面量语法扩展\"></a>对象字面量语法扩展</h4><p>(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;test&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123;name: &#x27;test&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es5Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es5&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es5Obj.testFunction()); <span class=\"comment\">// es5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">testFunction</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;es6&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj.testFunction()); <span class=\"comment\">// es6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// **注意：只有赋值的是匿名函数，才可以使用简介语法**</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">testFunction</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj1.testFunction()); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位</strong></p>\n<p>(3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  [<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[<span class=\"string\">&#x27;first&#x27;</span> + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> first = <span class=\"string\">&#x27;first&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> es6Obj1 = &#123;</span><br><span class=\"line\">  [first + <span class=\"string\">&#x27;second&#x27;</span>]: <span class=\"string\">&#x27;hanmeimei&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj[first + <span class=\"string\">&#x27;second&#x27;</span>]); <span class=\"comment\">// hanmeimei</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> es6Obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;first&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;second&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es6Obj); <span class=\"comment\">// &#123;name: &#x27;second&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h4><p>(1)Object.is()<br>作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> == -<span class=\"number\">0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)Object.assign()<br>作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.assign(target, ...sources);  target为目标对象  sources为源对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source = &#123; <span class=\"attr\">b</span>: <span class=\"number\">4</span>, <span class=\"attr\">c</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> returnedTarget = <span class=\"built_in\">Object</span>.assign(target, source);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(returnedTarget); <span class=\"comment\">// Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)Object.setPrototypeOf()<br>作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object.setPrototypeOf(object, prototypeObject);</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// obj 链接到person</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// obj 链接到dog</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woof</span></span><br></pre></td></tr></table></figure>\n<p>当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n<p>在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p>对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: ‘super’ keyword unexpected here<br><strong>为什么？？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下写法报错：Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class=\"line\"> <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;woof&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 以下方法可以正常运行</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">greeting</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.greeting() + <span class=\"string\">&#x27;obj&#x27;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// helloobj</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.greeting()); <span class=\"comment\">// woofobj</span></span><br></pre></td></tr></table></figure>\n<p><strong>在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj.  那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this).  因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。</strong></p>\n"},{"title":"js中apply怎么把数组转化为参数？","date":"2022-09-21T09:07:53.000Z","_content":"\n###### apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(array);\n// [1, 10]\n// undefined\n\ntest.apply(null, array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(array);\n// [1, 10]\n// undefined\ntest.func.apply(test.func, array);\ntest.func.apply(null, array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(array);\n// NaN\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max.apply(null, array);\n// 8\n```\n\n###### ES6中的扩展符\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(...array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(...array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(...array);\n// 8\n```\n\n###### 使用arguments对象（不建议使用）\n函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。\n```javascript\nfunction test() {\n for (let i = 0; i < arguments.length; i++) {\n  console.log(arguments[i]);\n }\n}\ntest(1,12,5);\n// 1 12 5\ntest(1,12,3,4,5);\n// 1 12 3 4 5\n```","source":"_posts/32-apply-array-to-params.md","raw":"---\ntitle: js中apply怎么把数组转化为参数？\ndate: 2022-09-21 17:07:53\ntags:\n---\n\n###### apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(array);\n// [1, 10]\n// undefined\n\ntest.apply(null, array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(array);\n// [1, 10]\n// undefined\ntest.func.apply(test.func, array);\ntest.func.apply(null, array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(array);\n// NaN\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max.apply(null, array);\n// 8\n```\n\n###### ES6中的扩展符\n```javascript\nfunction test(a, b) {\n console.log(a);\n console.log(b);\n}\nconst array = [1, 10];\ntest(...array);\n// 1\n// 10\n\nvar test = {\n func: function (a, b) {\n  console.log(a);\n  console.log(b);\n }\n}\nconst array = [1, 10];\ntest.func(...array);\n// 1\n// 10\n\nconst array = [1, 2, 4, 6, 2, 8];\nMath.max(...array);\n// 8\n```\n\n###### 使用arguments对象（不建议使用）\n函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。\n```javascript\nfunction test() {\n for (let i = 0; i < arguments.length; i++) {\n  console.log(arguments[i]);\n }\n}\ntest(1,12,5);\n// 1 12 5\ntest(1,12,3,4,5);\n// 1 12 3 4 5\n```","slug":"32-apply-array-to-params","published":1,"updated":"2022-10-25T06:46:40.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx0001bckttcgv24tru","content":"<h6 id=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"><a href=\"#apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\" class=\"headerlink\" title=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"></a>apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">test.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\">test.func.apply(test.func, array);</span><br><span class=\"line\">test.func.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(array);</span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"ES6中的扩展符\"><a href=\"#ES6中的扩展符\" class=\"headerlink\" title=\"ES6中的扩展符\"></a>ES6中的扩展符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(...array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用arguments对象（不建议使用）\"><a href=\"#使用arguments对象（不建议使用）\" class=\"headerlink\" title=\"使用arguments对象（不建议使用）\"></a>使用arguments对象（不建议使用）</h6><p>函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 5</span></span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 3 4 5</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"><a href=\"#apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\" class=\"headerlink\" title=\"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组\"></a>apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">test.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(array);</span><br><span class=\"line\"><span class=\"comment\">// [1, 10]</span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\">test.func.apply(test.func, array);</span><br><span class=\"line\">test.func.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(array);</span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"ES6中的扩展符\"><a href=\"#ES6中的扩展符\" class=\"headerlink\" title=\"ES6中的扩展符\"></a>ES6中的扩展符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\"> <span class=\"attr\">func</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\">test.func(...array);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max(...array);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用arguments对象（不建议使用）\"><a href=\"#使用arguments对象（不建议使用）\" class=\"headerlink\" title=\"使用arguments对象（不建议使用）\"></a>使用arguments对象（不建议使用）</h6><p>函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 5</span></span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">12</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1 12 3 4 5</span></span><br></pre></td></tr></table></figure>"},{"title":"Object获取及设置原型对象","date":"2022-09-05T05:54:58.000Z","_content":"\n###### Object获取原型对象：Object.getPrototypeOf\nObject.getPrototypeOf用于获取指定对象的原型对象\n```javascript\nObject.getPrototypeOf(obj);\n```\n**参数**\nobj: 参数为要获取原型对象的对象\n**返回值**\n返回指定对象的原型对象或null\n注意：\nes5中，如果参数不是对象，会抛出TypeError错误\nes6中，如果参数不是对象，会强制类型转换为对象\n**示例**\n```javascript\nconsole.log(Object.getPrototypeOf('12') === String.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(12) === Number.prototype); // true\n//\nconsole.log(Object.getPrototypeOf({}) === Object.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(true) === Boolean.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(Symbol('test')) === Symbol.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(null)); // Uncaught TypeError: Cannot convert undefined or null to object\n// \nconsole.log(Object.getPrototypeOf(undefined)); // Uncaught TypeError: Cannot convert undefined or null to object\n\n// 对没有原型对象的对象进行操作\nconst obj = Object.create(null);\nconsole.log(Object.getPrototypeOf(obj)); // null\nconst obj = Object.create(undefined);\nconsole.log(Object.getPrototypeOf(obj)); // Uncaught TypeError: Object prototype may only be an Object or null: undefined\n```\n\n###### Object修改原型对象: Object.setPrototypeOf\nObject.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上\n```javascript\nObject.setPrototypeOf(obj, proto);\n```\n**参数**\nobj: 要设置原型对象的对象\nproto: 要设置的新原型对象或null，未设置时抛出TypeError错误\n\n**返回值**\n设置了新原型对象的对象\n\n注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象\n\n**示例**\n```javascript\nconst obj = { name: 'test' };\nconst newObj = Object.create(obj);\nObject.setPrototypeOf(newObj, obj);\nconsole.log(newObj.name); // 'test'\n\nconst otherObj = { age: 12};\nconsole.log(Object.getPrototypeOf(newObj) === obj); // true\nObject.setPrototypeOf(newObj, otherObj);\nconsole.log(Object.getPrototypeOf(newObj) === obj); // false\nconsole.log(Object.getPrototypeOf(newObj) === otherObj); // true\nconsole.log(newObj.name); // undefined\nconsole.log(newObj.age); // 12\n```","source":"_posts/31-get-and-set-prototypeof.md","raw":"---\ntitle: Object获取及设置原型对象\ndate: 2022-09-05 13:54:58\ntags:\n---\n\n###### Object获取原型对象：Object.getPrototypeOf\nObject.getPrototypeOf用于获取指定对象的原型对象\n```javascript\nObject.getPrototypeOf(obj);\n```\n**参数**\nobj: 参数为要获取原型对象的对象\n**返回值**\n返回指定对象的原型对象或null\n注意：\nes5中，如果参数不是对象，会抛出TypeError错误\nes6中，如果参数不是对象，会强制类型转换为对象\n**示例**\n```javascript\nconsole.log(Object.getPrototypeOf('12') === String.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(12) === Number.prototype); // true\n//\nconsole.log(Object.getPrototypeOf({}) === Object.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(true) === Boolean.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(Symbol('test')) === Symbol.prototype); // true\n// \nconsole.log(Object.getPrototypeOf(null)); // Uncaught TypeError: Cannot convert undefined or null to object\n// \nconsole.log(Object.getPrototypeOf(undefined)); // Uncaught TypeError: Cannot convert undefined or null to object\n\n// 对没有原型对象的对象进行操作\nconst obj = Object.create(null);\nconsole.log(Object.getPrototypeOf(obj)); // null\nconst obj = Object.create(undefined);\nconsole.log(Object.getPrototypeOf(obj)); // Uncaught TypeError: Object prototype may only be an Object or null: undefined\n```\n\n###### Object修改原型对象: Object.setPrototypeOf\nObject.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上\n```javascript\nObject.setPrototypeOf(obj, proto);\n```\n**参数**\nobj: 要设置原型对象的对象\nproto: 要设置的新原型对象或null，未设置时抛出TypeError错误\n\n**返回值**\n设置了新原型对象的对象\n\n注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象\n\n**示例**\n```javascript\nconst obj = { name: 'test' };\nconst newObj = Object.create(obj);\nObject.setPrototypeOf(newObj, obj);\nconsole.log(newObj.name); // 'test'\n\nconst otherObj = { age: 12};\nconsole.log(Object.getPrototypeOf(newObj) === obj); // true\nObject.setPrototypeOf(newObj, otherObj);\nconsole.log(Object.getPrototypeOf(newObj) === obj); // false\nconsole.log(Object.getPrototypeOf(newObj) === otherObj); // true\nconsole.log(newObj.name); // undefined\nconsole.log(newObj.age); // 12\n```","slug":"31-get-and-set-prototypeof","published":1,"updated":"2022-09-05T06:42:22.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx1001ccktt0byr5e3n","content":"<h6 id=\"Object获取原型对象：Object-getPrototypeOf\"><a href=\"#Object获取原型对象：Object-getPrototypeOf\" class=\"headerlink\" title=\"Object获取原型对象：Object.getPrototypeOf\"></a>Object获取原型对象：Object.getPrototypeOf</h6><p>Object.getPrototypeOf用于获取指定对象的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 参数为要获取原型对象的对象<br><strong>返回值</strong><br>返回指定对象的原型对象或null<br>注意：<br>es5中，如果参数不是对象，会抛出TypeError错误<br>es6中，如果参数不是对象，会强制类型转换为对象<br><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"string\">&#x27;12&#x27;</span>) === <span class=\"built_in\">String</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"number\">12</span>) === <span class=\"built_in\">Number</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(&#123;&#125;) === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">true</span>) === <span class=\"built_in\">Boolean</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;test&#x27;</span>)) === <span class=\"built_in\">Symbol</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">null</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">undefined</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对没有原型对象的对象进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// Uncaught TypeError: Object prototype may only be an Object or null: undefined</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Object修改原型对象-Object-setPrototypeOf\"><a href=\"#Object修改原型对象-Object-setPrototypeOf\" class=\"headerlink\" title=\"Object修改原型对象: Object.setPrototypeOf\"></a>Object修改原型对象: Object.setPrototypeOf</h6><p>Object.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 要设置原型对象的对象<br>proto: 要设置的新原型对象或null，未设置时抛出TypeError错误</p>\n<p><strong>返回值</strong><br>设置了新原型对象的对象</p>\n<p>注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">Object</span>.create(obj);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// &#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> otherObj = &#123; <span class=\"attr\">age</span>: <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, otherObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === otherObj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.age); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"Object获取原型对象：Object-getPrototypeOf\"><a href=\"#Object获取原型对象：Object-getPrototypeOf\" class=\"headerlink\" title=\"Object获取原型对象：Object.getPrototypeOf\"></a>Object获取原型对象：Object.getPrototypeOf</h6><p>Object.getPrototypeOf用于获取指定对象的原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 参数为要获取原型对象的对象<br><strong>返回值</strong><br>返回指定对象的原型对象或null<br>注意：<br>es5中，如果参数不是对象，会抛出TypeError错误<br>es6中，如果参数不是对象，会强制类型转换为对象<br><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"string\">&#x27;12&#x27;</span>) === <span class=\"built_in\">String</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"number\">12</span>) === <span class=\"built_in\">Number</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(&#123;&#125;) === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">true</span>) === <span class=\"built_in\">Boolean</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;test&#x27;</span>)) === <span class=\"built_in\">Symbol</span>.prototype); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">null</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"literal\">undefined</span>)); <span class=\"comment\">// Uncaught TypeError: Cannot convert undefined or null to object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对没有原型对象的对象进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(obj)); <span class=\"comment\">// Uncaught TypeError: Object prototype may only be an Object or null: undefined</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"Object修改原型对象-Object-setPrototypeOf\"><a href=\"#Object修改原型对象-Object-setPrototypeOf\" class=\"headerlink\" title=\"Object修改原型对象: Object.setPrototypeOf\"></a>Object修改原型对象: Object.setPrototypeOf</h6><p>Object.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong><br>obj: 要设置原型对象的对象<br>proto: 要设置的新原型对象或null，未设置时抛出TypeError错误</p>\n<p><strong>返回值</strong><br>设置了新原型对象的对象</p>\n<p>注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">Object</span>.create(obj);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// &#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> otherObj = &#123; <span class=\"attr\">age</span>: <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(newObj, otherObj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === obj); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(newObj) === otherObj); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.age); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>"},{"title":"数据结构与算法阅读笔记(4)","date":"2022-10-08T05:25:18.000Z","_content":"\n#### 递归\n\n递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。\n\n每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。\n\n```javascript\nfunction understandRecursion(doIunderstandRecursion) {\n  const recursionAnswer = confirm('Do you understand recursion?');\n  if (recursionAnswer === true) {\n    // 基线条件或停止点\n    return true;\n  }\n  understandRecursion(recursionAnswer); // 递归调用\n}\n```\n\n###### 计算一个数的阶乘\n\n数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。\n5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120\n(1)迭代阶乘\n(n) _ (n - 1) _ (n - 2) _ (n - 3) _ ... \\* 1\n\n```javascript\nfunction factorialIterative(number) {\n  if (number < 0) return undefined;\n  let total = 1;\n  for (let n = number; n > 1; n--) {\n    total = total * n;\n  }\n  return total;\n}\nconsole.log(factorialIterative(5)); // 120\n```\n\n(2)递归阶乘\n\n```javascript\nfunction factorial(n) {\n  if (n === 1 || n === 0) {\n    // 基线条件\n    return 1;\n  }\n  return n * factorial(n - 1); // 递归调用\n}\nconsole.log(factorial(5)); // 120\n```\n\n![factorial](factorial.png)\n\n如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）\n\n**测试浏览器最大调用栈大小**\n\n```javascript\nlet i = 0;\nfunction recursiveFn() {\n  i++;\n  recursiveFn();\n}\ntry {\n  recursiveFn();\n} catch (ex) {\n  console.log('i = ' + i + ' error: ' + ex);\n}\n```\n\n**ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。**\n有关尾调用优化的更多相关信息，请访问 https://www.chromestatus.com/feature/\n5516876633341952\n\n###### 斐波那契数列\n\n(1)位置 0 的斐波那契数是零\n(2)1 和 2 的斐波那契数是 1\n(3)n（此处 n > 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数\n\n**迭代求斐波那契数**\n\n```javascript\nfunction fibonacciIterative(n) {\n  if (n < 1) return 0;\n  if (n <= 2) return 1;\n  let fibNMinus2 = 0;\n  let fibNMinus1 = 1;\n  let fibN = n;\n  for (let i = 2; i <= n; i++) {\n    // n >= 2\n    fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2)\n    fibNMinus2 = fibNMinus1;\n    fibNMinus1 = fibN;\n  }\n  return fibN;\n}\nfibonacciIterative(9); // 34\n```\n\n**递归求斐波那契数**\n\n```javascript\nfunction fibonacci(n) {\n  if (n < 1) return 0; // {1}\n  if (n <= 2) return 1; // {2}\n  return fibonacci(n - 1) + fibonacci(n - 2); // {3}\n}\nfibonacci(9); // 34\n```\n\n**记忆化斐波那契数**\n\n```javascript\nfunction fibonacciMemoization(n) {\n  const memo = [0, 1]; // {1}\n  const fibonacci = (n) => {\n    if (memo[n] != null) return memo[n]; // {2}\n    return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // {3}\n  };\n  return fibonacci(n);\n}\nfibonacciMemoization(9); // 34\n```\n\n迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除\n\n#### 树数据结构\n\n###### 树的相关术语\n\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点\n\n位于树顶部的节点叫作根节点。它没有父节点。\n树中的每个元素都叫作节点，节点分为内部节点和外部节点。\n至少有一个子节点的节点称为内部节点。\n没有子元素的节点称为外部节点或叶节点。\n\n一个节点可以有祖先和后代。\n一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。\n一个节点的后代包括子节点、孙子节点、曾孙节点等。\n\n子树：子树由节点和它的后代构成。\n\n节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。\n\n树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。\n![tree](tree.png)\n\n###### 二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。\n\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。\n![binary-search-tree](binary-search-tree.png)\n\n通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）\n键是树相关的术语中对节点的称呼\n\n**中序遍历**\n![in-order-traverse](in-order-traverse.png)\n**先序遍历**\n![pre-order-traverse](pre-order-traverse.png)\n**后序遍历**\n![post-order-traverse](post-order-traverse.png)\n\n```javascript\nexport class Node {\n  constructor(key) {\n    this.key = key; // {1} 节点值\n    this.left = null; // 左侧子节点引用\n    this.right = null; // 右侧子节点引用\n  }\n}\n\nimport { Compare, defaultCompare } from '../util';\nimport { Node } from './models/node';\nexport default class BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // 用来比较节点值\n    this.root = null; // {1} Node 类型的根节点\n  }\n  // 向二叉搜索树中插入一个键\n  insert(key) {\n    if (this.root == null) {\n      // {1}\n      this.root = new Node(key); // {2}\n    } else {\n      this.insertNode(this.root, key); // {3}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {4}\n      if (node.left == null) {\n        // {5}\n        node.left = new Node(key); // {6}\n      } else {\n        this.insertNode(node.left, key); // {7}\n      }\n    } else {\n      if (node.right == null) {\n        // {8}\n        node.right = new Node(key); // {9}\n      } else {\n        this.insertNode(node.right, key); // {10}\n      }\n    }\n  }\n  // 中序遍历\n  // 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。\n  // 中序遍历的一种应用就是对树进行排序操作。\n  inOrderTraverse(callback) {\n    this.inOrderTraverseNode(this.root, callback); // {1}\n  }\n  inOrderTraverseNode(node, callback) {\n    if (node != null) {\n      // {2}\n      this.inOrderTraverseNode(node.left, callback); // {3}\n      callback(node.key); // {4}\n      this.inOrderTraverseNode(node.right, callback); // {5}\n    }\n  }\n  // 先序遍历\n  // 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档\n  preOrderTraverse(callback) {\n    this.preOrderTraverseNode(this.root, callback);\n  }\n  preOrderTraverseNode(node, callback) {\n    if (node != null) {\n      callback(node.key); // {1}\n      this.preOrderTraverseNode(node.left, callback); // {2}\n      this.preOrderTraverseNode(node.right, callback); // {3}\n    }\n  }\n  // 后序遍历\n  // 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小\n  postOrderTraverse(callback) {\n    this.postOrderTraverseNode(this.root, callback);\n  }\n  postOrderTraverseNode(node, callback) {\n    if (node != null) {\n      this.postOrderTraverseNode(node.left, callback); // {1}\n      this.postOrderTraverseNode(node.right, callback); // {2}\n      callback(node.key); // {3}\n    }\n  }\n  // 搜索最小值和最大值\n  min() {\n    return this.minNode(this.root); // {1}\n  }\n  minNode(node) {\n    let current = node;\n    while (current != null && current.left != null) {\n      // {2}\n      current = current.left; // {3}\n    }\n    return current; // {4}\n  }\n  max() {\n    return this.maxNode(this.root);\n  }\n  maxNode(node) {\n    let current = node;\n    while (current != null && current.right != null) {\n      // {5}\n      current = current.right;\n    }\n    return current;\n  }\n  // 搜索一个特定的值\n  search(key) {\n    return this.searchNode(this.root, key); // {1}\n  }\n  searchNode(node, key) {\n    if (node == null) {\n      // {2}\n      return false;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      return this.searchNode(node.left, key); // {4}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {5}\n      return this.searchNode(node.right, key); // {6}\n    } else {\n      return true; // {7}\n    }\n  }\n  // 移除一个节点\n  remove(key) {\n    this.root = this.removeNode(this.root, key); // {1}\n  }\n  removeNode(node, key) {\n    if (node == null) {\n      // {2}\n      return null;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      node.left = this.removeNode(node.left, key); // {4}\n      return node; // {5}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {6}\n      node.right = this.removeNode(node.right, key); // {7}\n      return node; // {8}\n    } else {\n      // 键等于 node.key\n      // 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点\n      if (node.left == null && node.right == null) {\n        // {9}\n        node = null; // {10}\n        return node; // {11}\n      }\n      // 第二种情况: 移除有一个左侧子节点或右侧子节点的节点\n      if (node.left == null) {\n        // {12}\n        node = node.right; // {13}\n        return node; // {14}\n      } else if (node.right == null) {\n        // {15}\n        node = node.left; // {16}\n        return node; // {17}\n      }\n      // 第三种情况: 具体流程可查看后续文章\n      const aux = this.minNode(node.right); // {18}\n      node.key = aux.key; // {19}\n      node.right = this.removeNode(node.right, aux.key); // {20}\n      return node; // {21}\n    }\n  }\n}\n```\n\n**移除有两个子节点的节点**\n要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。\n(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。\n(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们\n改变了这个节点的键，也就是说它被移除了。\n(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的\n最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。\n(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。\n![remove-left-right](remove-left-right.png)\n\n###### 自平衡树\n\nAdelson-Velskii-Landi 树（AVL 树）\nAVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。\n\n在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念\n\n```javascript\nconst BalanceFactor = {\n  UNBALANCED_RIGHT: 1,\n  SLIGHTLY_UNBALANCED_RIGHT: 2,\n  BALANCED: 3,\n  SLIGHTLY_UNBALANCED_LEFT: 4,\n  UNBALANCED_LEFT: 5,\n};\n\nclass AVLTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  // 节点的高度和平衡因子\n  getNodeHeight(node) {\n    if (node == null) {\n      return -1;\n    }\n    return (\n      Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) +\n      1\n    );\n  }\n  getBalanceFactor(node) {\n    const heightDifference =\n      this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\n    switch (heightDifference) {\n      case -2:\n        return BalanceFactor.UNBALANCED_RIGHT;\n      case -1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;\n      case 1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;\n      case 2:\n        return BalanceFactor.UNBALANCED_LEFT;\n      default:\n        return BalanceFactor.BALANCED;\n    }\n  }\n  rotationLL(node) {\n    const tmp = node.left; // {1}\n    node.left = tmp.right; // {2}\n    tmp.right = node; // {3}\n    return tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right; // {1}\n    node.right = tmp.left; // {2}\n    tmp.left = node; // {3}\n    return tmp;\n  }\n  rotationLR(node) {\n    node.left = this.rotationRR(node.left);\n    return this.rotationLL(node);\n  }\n  rotationRL(node) {\n    node.right = this.rotationLL(node.right);\n    return this.rotationRR(node);\n  }\n  //  向 AVL 树插入节点\n  insert(key) {\n    this.root = this.insertNode(this.root, key);\n  }\n  insertNode(node, key) {\n    // 像在 BST 树中一样插入节点\n    if (node == null) {\n      return new Node(key);\n    } else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      node.left = this.insertNode(node.left, key);\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      node.right = this.insertNode(node.right, key);\n    } else {\n      return node; // 重复的键\n    }\n    // 如果需要，将树进行平衡操作\n    const balanceFactor = this.getBalanceFactor(node); // {1}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {2}\n      if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {\n        // {3}\n        node = this.rotationLL(node); // {4}\n      } else {\n        return this.rotationLR(node); // {5}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {6}\n      if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {\n        // {7}\n        node = this.rotationRR(node); // {8}\n      } else {\n        return this.rotationRL(node); // {9}\n      }\n    }\n    return node;\n  }\n  // 从 AVL 树中移除节点\n  removeNode(node, key) {\n    node = super.removeNode(node, key); // {1}\n    if (node == null) {\n      return node; // null，不需要进行平衡\n    }\n    // 检测树是否平衡\n    const balanceFactor = this.getBalanceFactor(node); // {2}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {3}\n      const balanceFactorLeft = this.getBalanceFactor(node.left); // {4}\n      if (\n        balanceFactorLeft === BalanceFactor.BALANCED ||\n        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT\n      ) {\n        // {5}\n        return this.rotationLL(node); // {6}\n      }\n      if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\n        // {7}\n        return this.rotationLR(node.left); // {8}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {9}\n      const balanceFactorRight = this.getBalanceFactor(node.right); // {10}\n      if (\n        balanceFactorRight === BalanceFactor.BALANCED ||\n        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT\n      ) {\n        // {11}\n        return this.rotationRR(node); // {12}\n      }\n      if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\n        // {13}\n        return this.rotationRL(node.right); // {14}\n      }\n    }\n    return node;\n  }\n}\n```\n\n**平衡操作——AVL 旋转**\n(1)左-左（LL）：向右的单旋转\n这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的\n![left-left-1](left-left-1.png)\n![left-left-2](left-left-2.png)\n\nrotationLL 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；\n节点 X 的左子树保持不变；\n将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；\n将节点 X 的右子节点置为节点 Y（行{3}）\n\n(2)右-右（RR）：向左的单旋转\n右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的\n![right-right-1](right-right-1.png)\n![right-right-2](right-right-2.png)\n\nrotationRR 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；\n节点 X 的右子树保持不变；\n将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；\n将节点 X 的左子节点置为节点 Y（行{3}）\n\n(3)左-右（LR）：向右的双旋转\n这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复\n![left-right-1](left-right-1.png)\n![left-right-2](left-right-2.png)\n\nrotationLR 方法\n将节点 X 置于节点 Y（平衡因子为 2）所在的位置；\n将节点 Z 的左子节点置为节点 X 的右子节点；\n将节点 Y 的右子节点置为节点 X 的左子节点；\n将节点 X 的右子节点置为节点 Y；\n将节点 X 的左子节点置为节点 Z\n\n(4)右-左（RL）：向左的双旋转\n右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复\n![right-left-1](right-left-1.png)\n![right-left-2](right-left-2.png)\n\nrotationRL 方法\n将节点 X 置于节点 Y（平衡因子为+2）所在的位置；\n将节点 Y 的左子节点置为节点 X 的右子节点；\n将节点 Z 的右子节点置为节点 X 的左子节点；\n将节点 X 的左子节点置为节点 Y；\n将节点 X 的右子节点置为节点 Z\n\n###### 红黑树\n\n包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好\n\n在红黑树中，每个节点都遵循以下规则：\n(1) 顾名思义，每个节点不是红的就是黑的；\n(2) 树的根节点是黑的；\n(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；\n(4) 如果一个节点是红的，那么它的两个子节点都是黑的；\n(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；\n(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。\n\n```javascript\nclass RedBlackNode extends Node {\n  constructor(key) {\n    super(key);\n    this.key = key;\n    this.color = Colors.RED; // {6}\n    this.parent = null; // {7}\n  }\n  isRed() {\n    return this.color === Colors.RED;\n  }\n}\n\nclass RedBlackTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  insert(key: T) {\n    if (this.root == null) {\n      // {1}\n      this.root = new RedBlackNode(key); // {2}\n      this.root.color = Colors.BLACK; // {3}\n    } else {\n      const newNode = this.insertNode(this.root, key); // {4}\n      this.fixTreeProperties(newNode); // {5}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      if (node.left == null) {\n        node.left = new RedBlackNode(key);\n        node.left.parent = node; // {8}\n        return node.left; // {9}\n      } else {\n        return this.insertNode(node.left, key);\n      }\n    } else if (node.right == null) {\n      node.right = new RedBlackNode(key);\n      node.right.parent = node; // {10}\n      return node.right; // {11}\n    } else {\n      return this.insertNode(node.right, key);\n    }\n  }\n  fixTreeProperties(node) {\n    while (\n      node &&\n      node.parent &&\n      node.parent.color.isRed() && // {1}\n      node.color !== Colors.BLACK\n    ) {\n      // {2}\n      let parent = node.parent; // {3}\n      const grandParent = parent.parent; // {4}\n      // 情形 A：父节点是左侧子节点\n      if (grandParent && grandParent.left === parent) {\n        // {5}\n        const uncle = grandParent.right; // {6}\n        // 情形 1A：叔节点也是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {7}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent; // {8}\n        } else {\n          // 情形 2A：节点是右侧子节点——左旋转\n          if (node === parent.right) {\n            this.rotationRR(parent); // {12}\n            node = parent; // {13}\n            parent = node.parent; // {14}\n          }\n          // 情形 3A：节点是左侧子节点——右旋转\n          this.rotationLL(grandParent); // {15}\n          parent.color = Colors.BLACK; // {16}\n          grandParent.color = Colors.RED; // {17}\n          node = parent; // {18}\n        }\n      } else {\n        // 情形 B：父节点是右侧子节点\n        const uncle = grandParent.left; // {9}\n        // 情形 1B：叔节点是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {10}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent;\n        } else {\n          // 情形 2B：节点是左侧子节点——左旋转\n          if (node === parent.left) {\n            this.rotationLL(parent); // {19}\n            node = parent;\n            parent = node.parent;\n          }\n          // 情形 3B：节点是右侧子节点——左旋转\n          this.rotationRR(grandParent); // {20}\n          parent.color = Colors.BLACK;\n          grandParent.color = Colors.RED;\n          node = parent;\n        }\n      }\n    }\n    this.root.color = Colors.BLACK; // {11}\n  }\n  rotationLL(node) {\n    const tmp = node.left;\n    node.left = tmp.right;\n    if (tmp.right && tmp.right.key) {\n      tmp.right.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.right = node;\n    node.parent = tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right;\n    node.right = tmp.left;\n    if (tmp.left && tmp.left.key) {\n      tmp.left.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.left = node;\n    node.parent = tmp;\n  }\n}\n```\n\n左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。\n左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。\n![red-black-2a](red-black-2a.png)\n![red-black-3a](red-black-3a.png)\n![red-black-2b](red-black-2b.png)\n![red-black-3b](red-black-3b.png)\n","source":"_posts/36-data-structure4.md","raw":"---\ntitle: 数据结构与算法阅读笔记(4)\ndate: 2022-10-08 13:25:18\ntags:\n---\n\n#### 递归\n\n递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。\n\n每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。\n\n```javascript\nfunction understandRecursion(doIunderstandRecursion) {\n  const recursionAnswer = confirm('Do you understand recursion?');\n  if (recursionAnswer === true) {\n    // 基线条件或停止点\n    return true;\n  }\n  understandRecursion(recursionAnswer); // 递归调用\n}\n```\n\n###### 计算一个数的阶乘\n\n数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。\n5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120\n(1)迭代阶乘\n(n) _ (n - 1) _ (n - 2) _ (n - 3) _ ... \\* 1\n\n```javascript\nfunction factorialIterative(number) {\n  if (number < 0) return undefined;\n  let total = 1;\n  for (let n = number; n > 1; n--) {\n    total = total * n;\n  }\n  return total;\n}\nconsole.log(factorialIterative(5)); // 120\n```\n\n(2)递归阶乘\n\n```javascript\nfunction factorial(n) {\n  if (n === 1 || n === 0) {\n    // 基线条件\n    return 1;\n  }\n  return n * factorial(n - 1); // 递归调用\n}\nconsole.log(factorial(5)); // 120\n```\n\n![factorial](factorial.png)\n\n如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）\n\n**测试浏览器最大调用栈大小**\n\n```javascript\nlet i = 0;\nfunction recursiveFn() {\n  i++;\n  recursiveFn();\n}\ntry {\n  recursiveFn();\n} catch (ex) {\n  console.log('i = ' + i + ' error: ' + ex);\n}\n```\n\n**ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。**\n有关尾调用优化的更多相关信息，请访问 https://www.chromestatus.com/feature/\n5516876633341952\n\n###### 斐波那契数列\n\n(1)位置 0 的斐波那契数是零\n(2)1 和 2 的斐波那契数是 1\n(3)n（此处 n > 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数\n\n**迭代求斐波那契数**\n\n```javascript\nfunction fibonacciIterative(n) {\n  if (n < 1) return 0;\n  if (n <= 2) return 1;\n  let fibNMinus2 = 0;\n  let fibNMinus1 = 1;\n  let fibN = n;\n  for (let i = 2; i <= n; i++) {\n    // n >= 2\n    fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2)\n    fibNMinus2 = fibNMinus1;\n    fibNMinus1 = fibN;\n  }\n  return fibN;\n}\nfibonacciIterative(9); // 34\n```\n\n**递归求斐波那契数**\n\n```javascript\nfunction fibonacci(n) {\n  if (n < 1) return 0; // {1}\n  if (n <= 2) return 1; // {2}\n  return fibonacci(n - 1) + fibonacci(n - 2); // {3}\n}\nfibonacci(9); // 34\n```\n\n**记忆化斐波那契数**\n\n```javascript\nfunction fibonacciMemoization(n) {\n  const memo = [0, 1]; // {1}\n  const fibonacci = (n) => {\n    if (memo[n] != null) return memo[n]; // {2}\n    return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // {3}\n  };\n  return fibonacci(n);\n}\nfibonacciMemoization(9); // 34\n```\n\n迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除\n\n#### 树数据结构\n\n###### 树的相关术语\n\n一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点\n\n位于树顶部的节点叫作根节点。它没有父节点。\n树中的每个元素都叫作节点，节点分为内部节点和外部节点。\n至少有一个子节点的节点称为内部节点。\n没有子元素的节点称为外部节点或叶节点。\n\n一个节点可以有祖先和后代。\n一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。\n一个节点的后代包括子节点、孙子节点、曾孙节点等。\n\n子树：子树由节点和它的后代构成。\n\n节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。\n\n树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。\n![tree](tree.png)\n\n###### 二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。\n\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。\n![binary-search-tree](binary-search-tree.png)\n\n通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）\n键是树相关的术语中对节点的称呼\n\n**中序遍历**\n![in-order-traverse](in-order-traverse.png)\n**先序遍历**\n![pre-order-traverse](pre-order-traverse.png)\n**后序遍历**\n![post-order-traverse](post-order-traverse.png)\n\n```javascript\nexport class Node {\n  constructor(key) {\n    this.key = key; // {1} 节点值\n    this.left = null; // 左侧子节点引用\n    this.right = null; // 右侧子节点引用\n  }\n}\n\nimport { Compare, defaultCompare } from '../util';\nimport { Node } from './models/node';\nexport default class BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // 用来比较节点值\n    this.root = null; // {1} Node 类型的根节点\n  }\n  // 向二叉搜索树中插入一个键\n  insert(key) {\n    if (this.root == null) {\n      // {1}\n      this.root = new Node(key); // {2}\n    } else {\n      this.insertNode(this.root, key); // {3}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {4}\n      if (node.left == null) {\n        // {5}\n        node.left = new Node(key); // {6}\n      } else {\n        this.insertNode(node.left, key); // {7}\n      }\n    } else {\n      if (node.right == null) {\n        // {8}\n        node.right = new Node(key); // {9}\n      } else {\n        this.insertNode(node.right, key); // {10}\n      }\n    }\n  }\n  // 中序遍历\n  // 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。\n  // 中序遍历的一种应用就是对树进行排序操作。\n  inOrderTraverse(callback) {\n    this.inOrderTraverseNode(this.root, callback); // {1}\n  }\n  inOrderTraverseNode(node, callback) {\n    if (node != null) {\n      // {2}\n      this.inOrderTraverseNode(node.left, callback); // {3}\n      callback(node.key); // {4}\n      this.inOrderTraverseNode(node.right, callback); // {5}\n    }\n  }\n  // 先序遍历\n  // 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档\n  preOrderTraverse(callback) {\n    this.preOrderTraverseNode(this.root, callback);\n  }\n  preOrderTraverseNode(node, callback) {\n    if (node != null) {\n      callback(node.key); // {1}\n      this.preOrderTraverseNode(node.left, callback); // {2}\n      this.preOrderTraverseNode(node.right, callback); // {3}\n    }\n  }\n  // 后序遍历\n  // 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小\n  postOrderTraverse(callback) {\n    this.postOrderTraverseNode(this.root, callback);\n  }\n  postOrderTraverseNode(node, callback) {\n    if (node != null) {\n      this.postOrderTraverseNode(node.left, callback); // {1}\n      this.postOrderTraverseNode(node.right, callback); // {2}\n      callback(node.key); // {3}\n    }\n  }\n  // 搜索最小值和最大值\n  min() {\n    return this.minNode(this.root); // {1}\n  }\n  minNode(node) {\n    let current = node;\n    while (current != null && current.left != null) {\n      // {2}\n      current = current.left; // {3}\n    }\n    return current; // {4}\n  }\n  max() {\n    return this.maxNode(this.root);\n  }\n  maxNode(node) {\n    let current = node;\n    while (current != null && current.right != null) {\n      // {5}\n      current = current.right;\n    }\n    return current;\n  }\n  // 搜索一个特定的值\n  search(key) {\n    return this.searchNode(this.root, key); // {1}\n  }\n  searchNode(node, key) {\n    if (node == null) {\n      // {2}\n      return false;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      return this.searchNode(node.left, key); // {4}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {5}\n      return this.searchNode(node.right, key); // {6}\n    } else {\n      return true; // {7}\n    }\n  }\n  // 移除一个节点\n  remove(key) {\n    this.root = this.removeNode(this.root, key); // {1}\n  }\n  removeNode(node, key) {\n    if (node == null) {\n      // {2}\n      return null;\n    }\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      // {3}\n      node.left = this.removeNode(node.left, key); // {4}\n      return node; // {5}\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      // {6}\n      node.right = this.removeNode(node.right, key); // {7}\n      return node; // {8}\n    } else {\n      // 键等于 node.key\n      // 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点\n      if (node.left == null && node.right == null) {\n        // {9}\n        node = null; // {10}\n        return node; // {11}\n      }\n      // 第二种情况: 移除有一个左侧子节点或右侧子节点的节点\n      if (node.left == null) {\n        // {12}\n        node = node.right; // {13}\n        return node; // {14}\n      } else if (node.right == null) {\n        // {15}\n        node = node.left; // {16}\n        return node; // {17}\n      }\n      // 第三种情况: 具体流程可查看后续文章\n      const aux = this.minNode(node.right); // {18}\n      node.key = aux.key; // {19}\n      node.right = this.removeNode(node.right, aux.key); // {20}\n      return node; // {21}\n    }\n  }\n}\n```\n\n**移除有两个子节点的节点**\n要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。\n(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。\n(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们\n改变了这个节点的键，也就是说它被移除了。\n(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的\n最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。\n(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。\n![remove-left-right](remove-left-right.png)\n\n###### 自平衡树\n\nAdelson-Velskii-Landi 树（AVL 树）\nAVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。\n\n在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念\n\n```javascript\nconst BalanceFactor = {\n  UNBALANCED_RIGHT: 1,\n  SLIGHTLY_UNBALANCED_RIGHT: 2,\n  BALANCED: 3,\n  SLIGHTLY_UNBALANCED_LEFT: 4,\n  UNBALANCED_LEFT: 5,\n};\n\nclass AVLTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  // 节点的高度和平衡因子\n  getNodeHeight(node) {\n    if (node == null) {\n      return -1;\n    }\n    return (\n      Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) +\n      1\n    );\n  }\n  getBalanceFactor(node) {\n    const heightDifference =\n      this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\n    switch (heightDifference) {\n      case -2:\n        return BalanceFactor.UNBALANCED_RIGHT;\n      case -1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;\n      case 1:\n        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;\n      case 2:\n        return BalanceFactor.UNBALANCED_LEFT;\n      default:\n        return BalanceFactor.BALANCED;\n    }\n  }\n  rotationLL(node) {\n    const tmp = node.left; // {1}\n    node.left = tmp.right; // {2}\n    tmp.right = node; // {3}\n    return tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right; // {1}\n    node.right = tmp.left; // {2}\n    tmp.left = node; // {3}\n    return tmp;\n  }\n  rotationLR(node) {\n    node.left = this.rotationRR(node.left);\n    return this.rotationLL(node);\n  }\n  rotationRL(node) {\n    node.right = this.rotationLL(node.right);\n    return this.rotationRR(node);\n  }\n  //  向 AVL 树插入节点\n  insert(key) {\n    this.root = this.insertNode(this.root, key);\n  }\n  insertNode(node, key) {\n    // 像在 BST 树中一样插入节点\n    if (node == null) {\n      return new Node(key);\n    } else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      node.left = this.insertNode(node.left, key);\n    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\n      node.right = this.insertNode(node.right, key);\n    } else {\n      return node; // 重复的键\n    }\n    // 如果需要，将树进行平衡操作\n    const balanceFactor = this.getBalanceFactor(node); // {1}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {2}\n      if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {\n        // {3}\n        node = this.rotationLL(node); // {4}\n      } else {\n        return this.rotationLR(node); // {5}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {6}\n      if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {\n        // {7}\n        node = this.rotationRR(node); // {8}\n      } else {\n        return this.rotationRL(node); // {9}\n      }\n    }\n    return node;\n  }\n  // 从 AVL 树中移除节点\n  removeNode(node, key) {\n    node = super.removeNode(node, key); // {1}\n    if (node == null) {\n      return node; // null，不需要进行平衡\n    }\n    // 检测树是否平衡\n    const balanceFactor = this.getBalanceFactor(node); // {2}\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {\n      // {3}\n      const balanceFactorLeft = this.getBalanceFactor(node.left); // {4}\n      if (\n        balanceFactorLeft === BalanceFactor.BALANCED ||\n        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT\n      ) {\n        // {5}\n        return this.rotationLL(node); // {6}\n      }\n      if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\n        // {7}\n        return this.rotationLR(node.left); // {8}\n      }\n    }\n    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {\n      // {9}\n      const balanceFactorRight = this.getBalanceFactor(node.right); // {10}\n      if (\n        balanceFactorRight === BalanceFactor.BALANCED ||\n        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT\n      ) {\n        // {11}\n        return this.rotationRR(node); // {12}\n      }\n      if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\n        // {13}\n        return this.rotationRL(node.right); // {14}\n      }\n    }\n    return node;\n  }\n}\n```\n\n**平衡操作——AVL 旋转**\n(1)左-左（LL）：向右的单旋转\n这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的\n![left-left-1](left-left-1.png)\n![left-left-2](left-left-2.png)\n\nrotationLL 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；\n节点 X 的左子树保持不变；\n将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；\n将节点 X 的右子节点置为节点 Y（行{3}）\n\n(2)右-右（RR）：向左的单旋转\n右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的\n![right-right-1](right-right-1.png)\n![right-right-2](right-right-2.png)\n\nrotationRR 方法\n与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；\n节点 X 的右子树保持不变；\n将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；\n将节点 X 的左子节点置为节点 Y（行{3}）\n\n(3)左-右（LR）：向右的双旋转\n这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复\n![left-right-1](left-right-1.png)\n![left-right-2](left-right-2.png)\n\nrotationLR 方法\n将节点 X 置于节点 Y（平衡因子为 2）所在的位置；\n将节点 Z 的左子节点置为节点 X 的右子节点；\n将节点 Y 的右子节点置为节点 X 的左子节点；\n将节点 X 的右子节点置为节点 Y；\n将节点 X 的左子节点置为节点 Z\n\n(4)右-左（RL）：向左的双旋转\n右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复\n![right-left-1](right-left-1.png)\n![right-left-2](right-left-2.png)\n\nrotationRL 方法\n将节点 X 置于节点 Y（平衡因子为+2）所在的位置；\n将节点 Y 的左子节点置为节点 X 的右子节点；\n将节点 Z 的右子节点置为节点 X 的左子节点；\n将节点 X 的左子节点置为节点 Y；\n将节点 X 的右子节点置为节点 Z\n\n###### 红黑树\n\n包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好\n\n在红黑树中，每个节点都遵循以下规则：\n(1) 顾名思义，每个节点不是红的就是黑的；\n(2) 树的根节点是黑的；\n(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；\n(4) 如果一个节点是红的，那么它的两个子节点都是黑的；\n(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；\n(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。\n\n```javascript\nclass RedBlackNode extends Node {\n  constructor(key) {\n    super(key);\n    this.key = key;\n    this.color = Colors.RED; // {6}\n    this.parent = null; // {7}\n  }\n  isRed() {\n    return this.color === Colors.RED;\n  }\n}\n\nclass RedBlackTree extends BinarySearchTree {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = compareFn;\n    this.root = null;\n  }\n  insert(key: T) {\n    if (this.root == null) {\n      // {1}\n      this.root = new RedBlackNode(key); // {2}\n      this.root.color = Colors.BLACK; // {3}\n    } else {\n      const newNode = this.insertNode(this.root, key); // {4}\n      this.fixTreeProperties(newNode); // {5}\n    }\n  }\n  insertNode(node, key) {\n    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\n      if (node.left == null) {\n        node.left = new RedBlackNode(key);\n        node.left.parent = node; // {8}\n        return node.left; // {9}\n      } else {\n        return this.insertNode(node.left, key);\n      }\n    } else if (node.right == null) {\n      node.right = new RedBlackNode(key);\n      node.right.parent = node; // {10}\n      return node.right; // {11}\n    } else {\n      return this.insertNode(node.right, key);\n    }\n  }\n  fixTreeProperties(node) {\n    while (\n      node &&\n      node.parent &&\n      node.parent.color.isRed() && // {1}\n      node.color !== Colors.BLACK\n    ) {\n      // {2}\n      let parent = node.parent; // {3}\n      const grandParent = parent.parent; // {4}\n      // 情形 A：父节点是左侧子节点\n      if (grandParent && grandParent.left === parent) {\n        // {5}\n        const uncle = grandParent.right; // {6}\n        // 情形 1A：叔节点也是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {7}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent; // {8}\n        } else {\n          // 情形 2A：节点是右侧子节点——左旋转\n          if (node === parent.right) {\n            this.rotationRR(parent); // {12}\n            node = parent; // {13}\n            parent = node.parent; // {14}\n          }\n          // 情形 3A：节点是左侧子节点——右旋转\n          this.rotationLL(grandParent); // {15}\n          parent.color = Colors.BLACK; // {16}\n          grandParent.color = Colors.RED; // {17}\n          node = parent; // {18}\n        }\n      } else {\n        // 情形 B：父节点是右侧子节点\n        const uncle = grandParent.left; // {9}\n        // 情形 1B：叔节点是红色——只需要重新填色\n        if (uncle && uncle.color === Colors.RED) {\n          // {10}\n          grandParent.color = Colors.RED;\n          parent.color = Colors.BLACK;\n          uncle.color = Colors.BLACK;\n          node = grandParent;\n        } else {\n          // 情形 2B：节点是左侧子节点——左旋转\n          if (node === parent.left) {\n            this.rotationLL(parent); // {19}\n            node = parent;\n            parent = node.parent;\n          }\n          // 情形 3B：节点是右侧子节点——左旋转\n          this.rotationRR(grandParent); // {20}\n          parent.color = Colors.BLACK;\n          grandParent.color = Colors.RED;\n          node = parent;\n        }\n      }\n    }\n    this.root.color = Colors.BLACK; // {11}\n  }\n  rotationLL(node) {\n    const tmp = node.left;\n    node.left = tmp.right;\n    if (tmp.right && tmp.right.key) {\n      tmp.right.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.right = node;\n    node.parent = tmp;\n  }\n  rotationRR(node) {\n    const tmp = node.right;\n    node.right = tmp.left;\n    if (tmp.left && tmp.left.key) {\n      tmp.left.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.left = node;\n    node.parent = tmp;\n  }\n}\n```\n\n左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。\n左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。\n右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。\n![red-black-2a](red-black-2a.png)\n![red-black-3a](red-black-3a.png)\n![red-black-2b](red-black-2b.png)\n![red-black-3b](red-black-3b.png)\n","slug":"36-data-structure4","published":1,"updated":"2022-10-08T08:25:03.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx1001dckttcuiw12rz","content":"<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。</p>\n<p>每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">understandRecursion</span>(<span class=\"params\">doIunderstandRecursion</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> recursionAnswer = confirm(<span class=\"string\">&#x27;Do you understand recursion?&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (recursionAnswer === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件或停止点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  understandRecursion(recursionAnswer); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"计算一个数的阶乘\"><a href=\"#计算一个数的阶乘\" class=\"headerlink\" title=\"计算一个数的阶乘\"></a>计算一个数的阶乘</h6><p>数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。<br>5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120<br>(1)迭代阶乘<br>(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorialIterative</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (number &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n = number; n &gt; <span class=\"number\">1</span>; n--) &#123;</span><br><span class=\"line\">    total = total * n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorialIterative(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)递归阶乘</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorial(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/36-data-structure4/factorial.png\" alt=\"factorial\"></p>\n<p>如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）</p>\n<p><strong>测试浏览器最大调用栈大小</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursiveFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;i = &#x27;</span> + i + <span class=\"string\">&#x27; error: &#x27;</span> + ex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。</strong><br>有关尾调用优化的更多相关信息，请访问 <a href=\"https://www.chromestatus.com/feature/\">https://www.chromestatus.com/feature/</a><br>5516876633341952</p>\n<h6 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h6><p>(1)位置 0 的斐波那契数是零<br>(2)1 和 2 的斐波那契数是 1<br>(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数</p>\n<p><strong>迭代求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciIterative</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibN = n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n &gt;= 2</span></span><br><span class=\"line\">    fibN = fibNMinus1 + fibNMinus2; <span class=\"comment\">// f(n-1) + f(n-2)</span></span><br><span class=\"line\">    fibNMinus2 = fibNMinus1;</span><br><span class=\"line\">    fibNMinus1 = fibN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciIterative(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>递归求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacci(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>记忆化斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciMemoization</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> memo = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fibonacci = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[n] != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> memo[n]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (memo[n] = fibonacci(n - <span class=\"number\">1</span>, memo) + fibonacci(n - <span class=\"number\">2</span>, memo)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciMemoization(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除</p>\n<h4 id=\"树数据结构\"><a href=\"#树数据结构\" class=\"headerlink\" title=\"树数据结构\"></a>树数据结构</h4><h6 id=\"树的相关术语\"><a href=\"#树的相关术语\" class=\"headerlink\" title=\"树的相关术语\"></a>树的相关术语</h6><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点</p>\n<p>位于树顶部的节点叫作根节点。它没有父节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。</p>\n<p>一个节点可以有祖先和后代。<br>一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。<br>一个节点的后代包括子节点、孙子节点、曾孙节点等。</p>\n<p>子树：子树由节点和它的后代构成。</p>\n<p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p>\n<p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。<br><img src=\"/2022/10/08/36-data-structure4/tree.png\" alt=\"tree\"></p>\n<h6 id=\"二叉树和二叉搜索树\"><a href=\"#二叉树和二叉搜索树\" class=\"headerlink\" title=\"二叉树和二叉搜索树\"></a>二叉树和二叉搜索树</h6><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p>\n<p>二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。<br><img src=\"/2022/10/08/36-data-structure4/binary-search-tree.png\" alt=\"binary-search-tree\"></p>\n<p>通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）<br>键是树相关的术语中对节点的称呼</p>\n<p><strong>中序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/in-order-traverse.png\" alt=\"in-order-traverse\"><br><strong>先序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/pre-order-traverse.png\" alt=\"pre-order-traverse\"><br><strong>后序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/post-order-traverse.png\" alt=\"post-order-traverse\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key; <span class=\"comment\">// &#123;1&#125; 节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.left = <span class=\"literal\">null</span>; <span class=\"comment\">// 左侧子节点引用</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.right = <span class=\"literal\">null</span>; <span class=\"comment\">// 右侧子节点引用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Compare, defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/node&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// 用来比较节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;1&#125; Node 类型的根节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向二叉搜索树中插入一个键</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.left, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        node.right = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.right, key); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历的一种应用就是对树进行排序操作。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.inOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.preOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.postOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索最小值和最大值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">min</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.minNode(<span class=\"built_in\">this</span>.root); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">minNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      current = current.left; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">max</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.maxNode(<span class=\"built_in\">this</span>.root);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">maxNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      current = current.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索一个特定的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">search</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">searchNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.right, key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除一个节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.removeNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.removeNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 键等于 node.key</span></span><br><span class=\"line\">      <span class=\"comment\">// 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        node = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第二种情况: 移除有一个左侧子节点或右侧子节点的节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">        node = node.right; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">        node = node.left; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第三种情况: 具体流程可查看后续文章</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> aux = <span class=\"built_in\">this</span>.minNode(node.right); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">      node.key = aux.key; <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, aux.key); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;21&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>移除有两个子节点的节点</strong><br>要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。<br>(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们<br>改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的<br>最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。<br><img src=\"/2022/10/08/36-data-structure4/remove-left-right.png\" alt=\"remove-left-right\"></p>\n<h6 id=\"自平衡树\"><a href=\"#自平衡树\" class=\"headerlink\" title=\"自平衡树\"></a>自平衡树</h6><p>Adelson-Velskii-Landi 树（AVL 树）<br>AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。</p>\n<p>在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BalanceFactor = &#123;</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_RIGHT</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">BALANCED</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_LEFT</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_LEFT</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 节点的高度和平衡因子</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getNodeHeight</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">this</span>.getNodeHeight(node.left), <span class=\"built_in\">this</span>.getNodeHeight(node.right)) +</span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getBalanceFactor</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> heightDifference =</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.getNodeHeight(node.left) - <span class=\"built_in\">this</span>.getNodeHeight(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (heightDifference) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.BALANCED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.left = tmp.right; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.right = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.right = tmp.left; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.left = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.left = <span class=\"built_in\">this</span>.rotationRR(node.left);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.right = <span class=\"built_in\">this</span>.rotationLL(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  向 AVL 树插入节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 像在 BST 树中一样插入节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Node(key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// 重复的键</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果需要，将树进行平衡操作</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从 AVL 树中移除节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    node = <span class=\"built_in\">super</span>.removeNode(node, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// null，不需要进行平衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检测树是否平衡</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorLeft = <span class=\"built_in\">this</span>.getBalanceFactor(node.left); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node.left); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorRight = <span class=\"built_in\">this</span>.getBalanceFactor(node.right); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node.right); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>平衡操作——AVL 旋转</strong><br>(1)左-左（LL）：向右的单旋转<br>这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的<br><img src=\"/2022/10/08/36-data-structure4/left-left-1.png\" alt=\"left-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-left-2.png\" alt=\"left-left-2\"></p>\n<p>rotationLL 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；<br>节点 X 的左子树保持不变；<br>将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；<br>将节点 X 的右子节点置为节点 Y（行{3}）</p>\n<p>(2)右-右（RR）：向左的单旋转<br>右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的<br><img src=\"/2022/10/08/36-data-structure4/right-right-1.png\" alt=\"right-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-right-2.png\" alt=\"right-right-2\"></p>\n<p>rotationRR 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；<br>节点 X 的右子树保持不变；<br>将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；<br>将节点 X 的左子节点置为节点 Y（行{3}）</p>\n<p>(3)左-右（LR）：向右的双旋转<br>这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/left-right-1.png\" alt=\"left-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-right-2.png\" alt=\"left-right-2\"></p>\n<p>rotationLR 方法<br>将节点 X 置于节点 Y（平衡因子为 2）所在的位置；<br>将节点 Z 的左子节点置为节点 X 的右子节点；<br>将节点 Y 的右子节点置为节点 X 的左子节点；<br>将节点 X 的右子节点置为节点 Y；<br>将节点 X 的左子节点置为节点 Z</p>\n<p>(4)右-左（RL）：向左的双旋转<br>右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/right-left-1.png\" alt=\"right-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-left-2.png\" alt=\"right-left-2\"></p>\n<p>rotationRL 方法<br>将节点 X 置于节点 Y（平衡因子为+2）所在的位置；<br>将节点 Y 的左子节点置为节点 X 的右子节点；<br>将节点 Z 的右子节点置为节点 X 的左子节点；<br>将节点 X 的左子节点置为节点 Y；<br>将节点 X 的右子节点置为节点 Z</p>\n<h6 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h6><p>包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好</p>\n<p>在红黑树中，每个节点都遵循以下规则：<br>(1) 顾名思义，每个节点不是红的就是黑的；<br>(2) 树的根节点是黑的；<br>(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；<br>(4) 如果一个节点是红的，那么它的两个子节点都是黑的；<br>(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；<br>(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(key);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = Colors.RED; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.parent = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isRed</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.color === Colors.RED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key: T</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> RedBlackNode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newNode = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.fixTreeProperties(newNode); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">        node.left.parent = node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.right = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">      node.right.parent = node; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node.right; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">fixTreeProperties</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      node &amp;&amp;</span><br><span class=\"line\">      node.parent &amp;&amp;</span><br><span class=\"line\">      node.parent.color.isRed() &amp;&amp; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      node.color !== Colors.BLACK</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> parent = node.parent; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> grandParent = parent.parent; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 情形 A：父节点是左侧子节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1A：叔节点也是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2A：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationRR(parent); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">            node = parent; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">            parent = node.parent; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3A：节点是左侧子节点——右旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationLL(grandParent); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">          node = parent; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情形 B：父节点是右侧子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1B：叔节点是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2B：节点是左侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.left) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationLL(parent); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">            node = parent;</span><br><span class=\"line\">            parent = node.parent;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3B：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationRR(grandParent); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          node = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left;</span><br><span class=\"line\">    node.left = tmp.right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class=\"line\">      tmp.right.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.right = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right;</span><br><span class=\"line\">    node.right = tmp.left;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class=\"line\">      tmp.left.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.left = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。<br>左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。<br><img src=\"/2022/10/08/36-data-structure4/red-black-2a.png\" alt=\"red-black-2a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3a.png\" alt=\"red-black-3a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-2b.png\" alt=\"red-black-2b\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3b.png\" alt=\"red-black-3b\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><p>递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。</p>\n<p>每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">understandRecursion</span>(<span class=\"params\">doIunderstandRecursion</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> recursionAnswer = confirm(<span class=\"string\">&#x27;Do you understand recursion?&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (recursionAnswer === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件或停止点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  understandRecursion(recursionAnswer); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"计算一个数的阶乘\"><a href=\"#计算一个数的阶乘\" class=\"headerlink\" title=\"计算一个数的阶乘\"></a>计算一个数的阶乘</h6><p>数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。<br>5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120<br>(1)迭代阶乘<br>(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorialIterative</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (number &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n = number; n &gt; <span class=\"number\">1</span>; n--) &#123;</span><br><span class=\"line\">    total = total * n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorialIterative(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)递归阶乘</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基线条件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorial(<span class=\"number\">5</span>)); <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/36-data-structure4/factorial.png\" alt=\"factorial\"></p>\n<p>如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）</p>\n<p><strong>测试浏览器最大调用栈大小</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursiveFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  recursiveFn();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ex) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;i = &#x27;</span> + i + <span class=\"string\">&#x27; error: &#x27;</span> + ex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。</strong><br>有关尾调用优化的更多相关信息，请访问 <a href=\"https://www.chromestatus.com/feature/\">https://www.chromestatus.com/feature/</a><br>5516876633341952</p>\n<h6 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h6><p>(1)位置 0 的斐波那契数是零<br>(2)1 和 2 的斐波那契数是 1<br>(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数</p>\n<p><strong>迭代求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciIterative</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibNMinus1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fibN = n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n &gt;= 2</span></span><br><span class=\"line\">    fibN = fibNMinus1 + fibNMinus2; <span class=\"comment\">// f(n-1) + f(n-2)</span></span><br><span class=\"line\">    fibNMinus2 = fibNMinus1;</span><br><span class=\"line\">    fibNMinus1 = fibN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciIterative(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>递归求斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacci(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>记忆化斐波那契数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacciMemoization</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> memo = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fibonacci = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[n] != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> memo[n]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (memo[n] = fibonacci(n - <span class=\"number\">1</span>, memo) + fibonacci(n - <span class=\"number\">2</span>, memo)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fibonacciMemoization(<span class=\"number\">9</span>); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除</p>\n<h4 id=\"树数据结构\"><a href=\"#树数据结构\" class=\"headerlink\" title=\"树数据结构\"></a>树数据结构</h4><h6 id=\"树的相关术语\"><a href=\"#树的相关术语\" class=\"headerlink\" title=\"树的相关术语\"></a>树的相关术语</h6><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点</p>\n<p>位于树顶部的节点叫作根节点。它没有父节点。<br>树中的每个元素都叫作节点，节点分为内部节点和外部节点。<br>至少有一个子节点的节点称为内部节点。<br>没有子元素的节点称为外部节点或叶节点。</p>\n<p>一个节点可以有祖先和后代。<br>一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。<br>一个节点的后代包括子节点、孙子节点、曾孙节点等。</p>\n<p>子树：子树由节点和它的后代构成。</p>\n<p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p>\n<p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。<br><img src=\"/2022/10/08/36-data-structure4/tree.png\" alt=\"tree\"></p>\n<h6 id=\"二叉树和二叉搜索树\"><a href=\"#二叉树和二叉搜索树\" class=\"headerlink\" title=\"二叉树和二叉搜索树\"></a>二叉树和二叉搜索树</h6><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p>\n<p>二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。<br><img src=\"/2022/10/08/36-data-structure4/binary-search-tree.png\" alt=\"binary-search-tree\"></p>\n<p>通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）<br>键是树相关的术语中对节点的称呼</p>\n<p><strong>中序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/in-order-traverse.png\" alt=\"in-order-traverse\"><br><strong>先序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/pre-order-traverse.png\" alt=\"pre-order-traverse\"><br><strong>后序遍历</strong><br><img src=\"/2022/10/08/36-data-structure4/post-order-traverse.png\" alt=\"post-order-traverse\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key; <span class=\"comment\">// &#123;1&#125; 节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.left = <span class=\"literal\">null</span>; <span class=\"comment\">// 左侧子节点引用</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.right = <span class=\"literal\">null</span>; <span class=\"comment\">// 右侧子节点引用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Compare, defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/node&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// 用来比较节点值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;1&#125; Node 类型的根节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向二叉搜索树中插入一个键</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.left, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        node.right = <span class=\"keyword\">new</span> Node(key); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.insertNode(node.right, key); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。</span></span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历的一种应用就是对树进行排序操作。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.inOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">inOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.inOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.preOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">preOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.preOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历</span></span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverse</span>(<span class=\"params\">callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.postOrderTraverseNode(<span class=\"built_in\">this</span>.root, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">postOrderTraverseNode</span>(<span class=\"params\">node, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.left, callback); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.postOrderTraverseNode(node.right, callback); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      callback(node.key); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索最小值和最大值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">min</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.minNode(<span class=\"built_in\">this</span>.root); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">minNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      current = current.left; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">max</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.maxNode(<span class=\"built_in\">this</span>.root);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">maxNode</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = node;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span> &amp;&amp; current.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      current = current.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 搜索一个特定的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">search</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">searchNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.searchNode(node.right, key); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除一个节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.removeNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.removeNode(node.left, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, key); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 键等于 node.key</span></span><br><span class=\"line\">      <span class=\"comment\">// 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        node = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第二种情况: 移除有一个左侧子节点或右侧子节点的节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">        node = node.right; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">        node = node.left; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 第三种情况: 具体流程可查看后续文章</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> aux = <span class=\"built_in\">this</span>.minNode(node.right); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">      node.key = aux.key; <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.removeNode(node.right, aux.key); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;21&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>移除有两个子节点的节点</strong><br>要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。<br>(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们<br>改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的<br>最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。<br><img src=\"/2022/10/08/36-data-structure4/remove-left-right.png\" alt=\"remove-left-right\"></p>\n<h6 id=\"自平衡树\"><a href=\"#自平衡树\" class=\"headerlink\" title=\"自平衡树\"></a>自平衡树</h6><p>Adelson-Velskii-Landi 树（AVL 树）<br>AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。</p>\n<p>在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BalanceFactor = &#123;</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_RIGHT</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">BALANCED</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">SLIGHTLY_UNBALANCED_LEFT</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">  <span class=\"attr\">UNBALANCED_LEFT</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 节点的高度和平衡因子</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getNodeHeight</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">this</span>.getNodeHeight(node.left), <span class=\"built_in\">this</span>.getNodeHeight(node.right)) +</span><br><span class=\"line\">      <span class=\"number\">1</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getBalanceFactor</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> heightDifference =</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.getNodeHeight(node.left) - <span class=\"built_in\">this</span>.getNodeHeight(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (heightDifference) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> -<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BalanceFactor.BALANCED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.left = tmp.right; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.right = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    node.right = tmp.left; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    tmp.left = node; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.left = <span class=\"built_in\">this</span>.rotationRR(node.left);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    node.right = <span class=\"built_in\">this</span>.rotationLL(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  向 AVL 树插入节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 像在 BST 树中一样插入节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Node(key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      node.left = <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      node.right = <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// 重复的键</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果需要，将树进行平衡操作</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        node = <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从 AVL 树中移除节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    node = <span class=\"built_in\">super</span>.removeNode(node, key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// null，不需要进行平衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检测树是否平衡</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> balanceFactor = <span class=\"built_in\">this</span>.getBalanceFactor(node); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorLeft = <span class=\"built_in\">this</span>.getBalanceFactor(node.left); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLL(node); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationLR(node.left); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> balanceFactorRight = <span class=\"built_in\">this</span>.getBalanceFactor(node.right); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.BALANCED ||</span><br><span class=\"line\">        balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRR(node); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.rotationRL(node.right); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>平衡操作——AVL 旋转</strong><br>(1)左-左（LL）：向右的单旋转<br>这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的<br><img src=\"/2022/10/08/36-data-structure4/left-left-1.png\" alt=\"left-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-left-2.png\" alt=\"left-left-2\"></p>\n<p>rotationLL 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；<br>节点 X 的左子树保持不变；<br>将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；<br>将节点 X 的右子节点置为节点 Y（行{3}）</p>\n<p>(2)右-右（RR）：向左的单旋转<br>右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的<br><img src=\"/2022/10/08/36-data-structure4/right-right-1.png\" alt=\"right-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-right-2.png\" alt=\"right-right-2\"></p>\n<p>rotationRR 方法<br>与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；<br>节点 X 的右子树保持不变；<br>将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；<br>将节点 X 的左子节点置为节点 Y（行{3}）</p>\n<p>(3)左-右（LR）：向右的双旋转<br>这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/left-right-1.png\" alt=\"left-right-1\"><br><img src=\"/2022/10/08/36-data-structure4/left-right-2.png\" alt=\"left-right-2\"></p>\n<p>rotationLR 方法<br>将节点 X 置于节点 Y（平衡因子为 2）所在的位置；<br>将节点 Z 的左子节点置为节点 X 的右子节点；<br>将节点 Y 的右子节点置为节点 X 的左子节点；<br>将节点 X 的右子节点置为节点 Y；<br>将节点 X 的左子节点置为节点 Z</p>\n<p>(4)右-左（RL）：向左的双旋转<br>右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复<br><img src=\"/2022/10/08/36-data-structure4/right-left-1.png\" alt=\"right-left-1\"><br><img src=\"/2022/10/08/36-data-structure4/right-left-2.png\" alt=\"right-left-2\"></p>\n<p>rotationRL 方法<br>将节点 X 置于节点 Y（平衡因子为+2）所在的位置；<br>将节点 Y 的左子节点置为节点 X 的右子节点；<br>将节点 Z 的右子节点置为节点 X 的左子节点；<br>将节点 X 的左子节点置为节点 Y；<br>将节点 X 的右子节点置为节点 Z</p>\n<h6 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h6><p>包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好</p>\n<p>在红黑树中，每个节点都遵循以下规则：<br>(1) 顾名思义，每个节点不是红的就是黑的；<br>(2) 树的根节点是黑的；<br>(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；<br>(4) 如果一个节点是红的，那么它的两个子节点都是黑的；<br>(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；<br>(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(key);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = Colors.RED; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.parent = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isRed</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.color === Colors.RED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedBlackTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">BinarySearchTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">key: T</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = <span class=\"keyword\">new</span> RedBlackNode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newNode = <span class=\"built_in\">this</span>.insertNode(<span class=\"built_in\">this</span>.root, key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.fixTreeProperties(newNode); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insertNode</span>(<span class=\"params\">node, key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        node.left = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">        node.left.parent = node; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.left, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.right = <span class=\"keyword\">new</span> RedBlackNode(key);</span><br><span class=\"line\">      node.right.parent = node; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> node.right; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.insertNode(node.right, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">fixTreeProperties</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      node &amp;&amp;</span><br><span class=\"line\">      node.parent &amp;&amp;</span><br><span class=\"line\">      node.parent.color.isRed() &amp;&amp; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      node.color !== Colors.BLACK</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> parent = node.parent; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> grandParent = parent.parent; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 情形 A：父节点是左侧子节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1A：叔节点也是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2A：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationRR(parent); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">            node = parent; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">            parent = node.parent; <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3A：节点是左侧子节点——右旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationLL(grandParent); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED; <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">          node = parent; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情形 B：父节点是右侧子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> uncle = grandParent.left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 情形 1B：叔节点是红色——只需要重新填色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uncle &amp;&amp; uncle.color === Colors.RED) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          uncle.color = Colors.BLACK;</span><br><span class=\"line\">          node = grandParent;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 2B：节点是左侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node === parent.left) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.rotationLL(parent); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">            node = parent;</span><br><span class=\"line\">            parent = node.parent;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 情形 3B：节点是右侧子节点——左旋转</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.rotationRR(grandParent); <span class=\"comment\">// &#123;20&#125;</span></span><br><span class=\"line\">          parent.color = Colors.BLACK;</span><br><span class=\"line\">          grandParent.color = Colors.RED;</span><br><span class=\"line\">          node = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.root.color = Colors.BLACK; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationLL</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.left;</span><br><span class=\"line\">    node.left = tmp.right;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class=\"line\">      tmp.right.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.right = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">rotationRR</span>(<span class=\"params\">node</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tmp = node.right;</span><br><span class=\"line\">    node.right = tmp.left;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class=\"line\">      tmp.left.parent = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.parent = node.parent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.parent) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.root = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === node.parent.left) &#123;</span><br><span class=\"line\">        node.parent.left = tmp;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.parent.right = tmp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tmp.left = node;</span><br><span class=\"line\">    node.parent = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。<br>左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。<br>右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。<br><img src=\"/2022/10/08/36-data-structure4/red-black-2a.png\" alt=\"red-black-2a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3a.png\" alt=\"red-black-3a\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-2b.png\" alt=\"red-black-2b\"><br><img src=\"/2022/10/08/36-data-structure4/red-black-3b.png\" alt=\"red-black-3b\"></p>\n"},{"title":"数据结构与算法阅读笔记(2)","date":"2022-09-23T07:52:54.000Z","_content":"\n#### 队列\n\n队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾\n\n```javascript\nclass Queue {\n  constructor() {\n    this.count = 0; // {1}\n    this.lowestCount = 0; // {2}\n    this.items = {}; // {3}\n  }\n  // 向队列添加元素\n  enqueue(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 从队列移除元素\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  // 查看队列头元素\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  // 获取队列的长度\n  size() {\n    return this.count - this.lowestCount;\n  }\n  // 清空队列\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n```\n\n###### 双端队列\n\n双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列\n\n由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构\n\n```javascript\nclass Deque {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n // 向双端队列的前端添加元素\n  addFront(element) {\n    if (this.isEmpty()) { // {1}\n      this.addBack(element);\n    } else if (this.lowestCount > 0) { // {2}\n      this.lowestCount--;\n      this.items[this.lowestCount] = element;\n    } else {\n      for (let i = this.count; i > 0; i--) { // {3}\n        this.items[i] = this.items[i - 1];\n      }\n      this.count++;\n      this.lowestCount = 0;\n      this.items[0] = element; // {4}\n    }\n  }\n  addBack(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  removeFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  removeBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  peekFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  peekBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  clear() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n}\n```\n\n###### 循环队列 - 击鼓传花\n场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）\n```javascript\nfunction hotPotato(elementsList, num) { \n  const queue = new Queue(); // {1} \n  const elimitatedList = [];\n  // 把名单的名字全都加入队列\n  for (let i = 0; i < elementsList.length; i++) { \n    queue.enqueue(elementsList[i]); // {2} \n  }\n  // 迭代队列\n  while (queue.size() > 1) { \n    for (let i = 0; i < num; i++) { \n      // 将队列开头一项移除，添加到队列末尾\n      queue.enqueue(queue.dequeue()); // {3} \n    } \n    // 将超出限制的队列开头一项移除，作为淘汰项\n    elimitatedList.push(queue.dequeue()); // {4} \n  } \n  return { \n    eliminated: elimitatedList, \n    winner: queue.dequeue() // {5} \n  };\n}\n\nconst names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; \nconst result = hotPotato(names, 7);\nresult.eliminated.forEach(name => { \n console.log(`${name}在击鼓传花游戏中被淘汰。`); \n}); \nconsole.log(`胜利者： ${result.winner}`);\n```\n\n###### 回文检查器\n回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。\n```javascript\nfunction palindromeChecker(aString) {\n  // 检查传入的字符串参数是否合法\n  if (aString === undefined || aString === null || (aString !== null && aString.length === 0)) { // {1} \n    return false;\n  } \n  const deque = new Deque(); // {2}\n  // 将所有字母转化为小写，同时移除所有的空格\n  const lowerString = aString.toLocaleLowerCase().split(' ').join(''); // {3} \n  let isEqual = true; \n  let firstChar, lastChar;\n  // 将所有字符串加入队列中\n  for (let i = 0; i < lowerString.length; i++) { // {4} \n    deque.addBack(lowerString.charAt(i)); \n  }\n\n  while (deque.size() > 1 && isEqual) { // {5} \n    firstChar = deque.removeFront(); // {6} \n    lastChar = deque.removeBack(); // {7}\n\n    if (firstChar !== lastChar) { \n      isEqual = false; // {8} \n    }\n  } \n  return isEqual;\n}\n```\n\n[javascript事件循环](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n\n#### 链表\n\n###### 链表数据结构\n![链表](chain-table-1.png)\n链表的好处：添加或移除元素的时候不需要移动其他元素\n要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素\n```javascript\n// util.js\nexport function defaultEquals(a, b) { \n  return a === b; \n}\n// models/linked-list-models\nexport class Node {\n  constructor(element) {\n    this.element = element; \n    this.next = undefined; \n  }\n} \n\nimport { defaultEquals } from '../util'; \nimport { Node } from './models/linked-list-models'; // {1} \nexport default class LinkedList { \n  constructor(equalsFn = defaultEquals) { \n    this.count = 0; // {2} \n    this.head = undefined; // {3}\n    this.equalsFn = equalsFn; // {4} \n  }\n  // 向链表尾部添加元素\n  push(element) { \n    const node = new Node(element); // {1} \n    let current; // {2} \n\n    if (this.head == null) { // {3} \n      this.head = node;\n    } else {\n      current = this.head; // {4} \n      while (current.next != null) { // {5} 获得最后一项\n        current = current.next; \n      }\n      // 将其 next 赋为新元素，建立链接\n      current.next = node; // {6} \n    } \n    this.count++; // {7} \n  }\n  // 从链表中移除元素\n  removeAt(index) { \n    // 检查越界值\n    if (index >= 0 && index < this.count) { // {1} \n      let current = this.head; // {2} \n      // 移除第一项\n      if (index === 0) { // {3} \n        this.head = current.next; \n      } else {\n        // 获取当前index的前一个节点\n        const previous = this.getElementAt(index - 1);\n        current = previous.next;\n        // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它\n        previous.next = current.next; // {8} \n      }\n      this.count--; // {9} \n      return current.element; \n    } \n    return undefined; // {10} \n  }\n  // 循环迭代链表直到目标位置\n  getElementAt(index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      let node = this.head; // {2} \n      for (let i = 0; i < index && node != null; i++) { // {3} \n        node = node.next;\n      } \n      return node; // {4} \n    } \n    return undefined; // {5} \n  }\n  // 在任意位置插入元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      const node = new Node(element);\n\n      if (index === 0) { // 在第一个位置添加\n        const current = this.head; \n        node.next = current; // {2} \n        this.head = node; \n      } else { \n        const previous = this.getElementAt(index - 1); // {3} \n        const current = previous.next; // {4} \n        node.next = current; // {5} \n        previous.next = node; // {6} \n      } \n      this.count++; // 更新链表的长度\n      return true; \n    } \n    return false; // {7} \n  }\n  //  indexOf 方法：返回一个元素的位置\n  indexOf(element) { \n    let current = this.head; // {1} \n    for (let i = 0; i < this.count && current != null; i++) { // {2} \n      if (this.equalsFn(element, current.element)) { // {3} \n        return i; // {4} \n      }\n      current = current.next; // {5} \n    } \n    return -1; // {6} \n  }\n  // 从链表中移除元素\n  remove(element) { \n    const index = this.indexOf(element); \n    return this.removeAt(index); \n  }\n  size() { \n    return this.count; \n  }\n  isEmpty() { \n    return this.count === 0; \n  }\n  getHead() {\n    return this.head; \n  }\n  toString() { \n    if (this.head == null) { // {1} \n      return ''; \n    } \n    let objString = `${this.head.element}`; // {2} \n    let current = this.head.next; // {3} \n\n    for (let i = 1; i < this.size() && current != null; i++) { // {4} \n      objString = `${objString},${current.element}`; \n      current = current.next;\n    } \n    return objString; // {5} \n  }\n}\n```\n[javascript垃圾回收器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)\n\n###### 双向链表\n在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素\n![双向链表](chain-table-2.png)\n```javascript\nclass DoublyNode extends Node { // {1} \n constructor(element, next, prev) { \n  super(element, next); // {2} \n  this.prev = prev; // {3} 新增的\n } \n}\n\nclass DoublyLinkedList extends LinkedList { // {4} \n  constructor(equalsFn = defaultEquals) { \n    super(equalsFn); // {5} \n    this.tail = undefined; // {6} 新增的\n  }\n  //  在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new DoublyNode(element); \n      let current = this.head;\n\n      if (index === 0) { \n          if (this.head == null) { // {1} 新增的\n            this.head = node; \n            this.tail = node; \n          } else { \n            node.next = this.head; // {2} \n            current.prev = node; // {3} 新增的\n            this.head = node; // {4} \n          } \n      } else if (index === this.count) { // 最后一项 // 新增的\n        current = this.tail; // {5} \n        current.next = node; // {6} \n        node.prev = current; // {7} \n        this.tail = node; // {8} \n      } else { \n        const previous = this.getElementAt(index - 1); // {9} \n        current = previous.next; // {10} \n        node.next = current; // {11} \n        previous.next = node; // {12} \n        current.prev = node; // {13} 新增的\n        node.prev = previous; // {14} 新增的\n      }\n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        this.head = current.next; // {1} \n        // 如果只有一项，更新 tail // 新增的\n        if (this.count === 1) { // {2} \n          this.tail = undefined; \n        } else { \n          this.head.prev = undefined; // {3} \n        } \n      } else if (index === this.count - 1) { // 最后一项 //新增的\n        current = this.tail; // {4} \n        this.tail = current.prev; // {5} \n        this.tail.next = undefined; // {6} \n      } else { \n        current = this.getElementAt(index); // {7} \n        const previous = current.prev; // {8} \n        // 将 previous 与 current 的下一项链接起来——跳过 current \n        previous.next = current.next; // {9} \n        current.next.prev = previous; // {10} 新增的\n      }\n      this.count--; \n      return current.element; \n    } \n    return undefined; \n  }\n}\n// 源码：https://github.com/loiane/javascript-datastructures-algorithms\n```\n\n###### 循环链表\n循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）\n双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev\n![循环链表](chain-table-3.png)\n![双向循环链表](chain-table-4.png)\n\n```javascript\nclass CircularLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals) {\n    super(equalsFn); \n  }\n  // 在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new Node(element); \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.head == null) { \n          this.head = node; // {1} \n          node.next = this.head; // {2} 新增的\n        } else { \n          node.next = current; // {3} \n          current = this.getElementAt(this.size()); // {4} \n          // 更新最后一个元素\n          this.head = node; // {5} \n          current.next = this.head; // {6} 新增的\n        }\n      } else { // 这种场景没有变化\n        const previous = this.getElementAt(index - 1); \n        node.next = previous.next; \n        previous.next = node; \n      } \n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.size() === 1) { \n          this.head = undefined; \n        } else { \n          const removed = this.head; // {1} \n          current = this.getElementAt(this.size()); // {2} 新增的\n          this.head = this.head.next; // {3} \n          current.next = this.head; // {4} \n          current = removed; // {5}\n        }\n      } else { \n        // 不需要修改循环链表最后一个元素\n        const previous = this.getElementAt(index - 1); \n        current = previous.next; \n        previous.next = current.next; \n      }\n      this.count--; \n      return current.element; // {6} \n    } \n    return undefined; \n  }\n}\n```\n\n###### 有序链表\n有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。\n```javascript\nconst Compare = { \n  LESS_THAN: -1, \n  BIGGER_THAN: 1 \n}; \nfunction defaultCompare(a, b) { \n  if (a === b) { // {1} \n    return 0; \n  } \n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN; // {2} \n} \nclass SortedLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals, compareFn = defaultCompare) { \n    super(equalsFn); \n    this.compareFn = compareFn; // {3} \n  }\n  // 有序插入元素\n  insert(element, index = 0) { // {1} \n    if (this.isEmpty()) { \n      return super.insert(element, 0); // {2} \n    } \n    const pos = this.getIndexNextSortedElement(element); // {3} \n    return super.insert(element, pos); // {4} \n  } \n  getIndexNextSortedElement(element) { \n    let current = this.head; \n    let i = 0; \n    for (; i < this.size() && current; i++) { \n      const comp = this.compareFn(element, current.element); // {5} \n      if (comp === Compare.LESS_THAN) { // {6} \n        return i; \n      } \n      current = current.next; \n    } \n    return i; // {7} \n  }\n}\n```\n\n###### 创建 StackLinkedList 类\n```javascript\nclass StackLinkedList { \n  constructor() { \n    this.items = new DoublyLinkedList(); // {1} \n  } \n  push(element) { \n    this.items.push(element); // {2} \n  } \n  pop() { \n    if (this.isEmpty()) { \n      return undefined; \n    } \n    return this.items.removeAt(this.size() - 1); // {3} \n  } \n}\n```","source":"_posts/34-data-structure2.md","raw":"---\ntitle: 数据结构与算法阅读笔记(2)\ndate: 2022-09-23 15:52:54\ntags:\n---\n\n#### 队列\n\n队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾\n\n```javascript\nclass Queue {\n  constructor() {\n    this.count = 0; // {1}\n    this.lowestCount = 0; // {2}\n    this.items = {}; // {3}\n  }\n  // 向队列添加元素\n  enqueue(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 从队列移除元素\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  // 查看队列头元素\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  // 获取队列的长度\n  size() {\n    return this.count - this.lowestCount;\n  }\n  // 清空队列\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[this.lowestCount]}`;\n    for (let i = this.lowestCount + 1; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n```\n\n###### 双端队列\n\n双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列\n\n由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构\n\n```javascript\nclass Deque {\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n // 向双端队列的前端添加元素\n  addFront(element) {\n    if (this.isEmpty()) { // {1}\n      this.addBack(element);\n    } else if (this.lowestCount > 0) { // {2}\n      this.lowestCount--;\n      this.items[this.lowestCount] = element;\n    } else {\n      for (let i = this.count; i > 0; i--) { // {3}\n        this.items[i] = this.items[i - 1];\n      }\n      this.count++;\n      this.lowestCount = 0;\n      this.items[0] = element; // {4}\n    }\n  }\n  addBack(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  removeFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const result = this.items[this.lowestCount]; // {1}\n    delete this.items[this.lowestCount]; // {2}\n    this.lowestCount++; // {3}\n    return result; // {4}\n  }\n  removeBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  peekFront() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  peekBack() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  isEmpty() {\n    return this.count - this.lowestCount === 0;\n  }\n  clear() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n}\n```\n\n###### 循环队列 - 击鼓传花\n场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）\n```javascript\nfunction hotPotato(elementsList, num) { \n  const queue = new Queue(); // {1} \n  const elimitatedList = [];\n  // 把名单的名字全都加入队列\n  for (let i = 0; i < elementsList.length; i++) { \n    queue.enqueue(elementsList[i]); // {2} \n  }\n  // 迭代队列\n  while (queue.size() > 1) { \n    for (let i = 0; i < num; i++) { \n      // 将队列开头一项移除，添加到队列末尾\n      queue.enqueue(queue.dequeue()); // {3} \n    } \n    // 将超出限制的队列开头一项移除，作为淘汰项\n    elimitatedList.push(queue.dequeue()); // {4} \n  } \n  return { \n    eliminated: elimitatedList, \n    winner: queue.dequeue() // {5} \n  };\n}\n\nconst names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; \nconst result = hotPotato(names, 7);\nresult.eliminated.forEach(name => { \n console.log(`${name}在击鼓传花游戏中被淘汰。`); \n}); \nconsole.log(`胜利者： ${result.winner}`);\n```\n\n###### 回文检查器\n回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。\n```javascript\nfunction palindromeChecker(aString) {\n  // 检查传入的字符串参数是否合法\n  if (aString === undefined || aString === null || (aString !== null && aString.length === 0)) { // {1} \n    return false;\n  } \n  const deque = new Deque(); // {2}\n  // 将所有字母转化为小写，同时移除所有的空格\n  const lowerString = aString.toLocaleLowerCase().split(' ').join(''); // {3} \n  let isEqual = true; \n  let firstChar, lastChar;\n  // 将所有字符串加入队列中\n  for (let i = 0; i < lowerString.length; i++) { // {4} \n    deque.addBack(lowerString.charAt(i)); \n  }\n\n  while (deque.size() > 1 && isEqual) { // {5} \n    firstChar = deque.removeFront(); // {6} \n    lastChar = deque.removeBack(); // {7}\n\n    if (firstChar !== lastChar) { \n      isEqual = false; // {8} \n    }\n  } \n  return isEqual;\n}\n```\n\n[javascript事件循环](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n\n#### 链表\n\n###### 链表数据结构\n![链表](chain-table-1.png)\n链表的好处：添加或移除元素的时候不需要移动其他元素\n要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素\n```javascript\n// util.js\nexport function defaultEquals(a, b) { \n  return a === b; \n}\n// models/linked-list-models\nexport class Node {\n  constructor(element) {\n    this.element = element; \n    this.next = undefined; \n  }\n} \n\nimport { defaultEquals } from '../util'; \nimport { Node } from './models/linked-list-models'; // {1} \nexport default class LinkedList { \n  constructor(equalsFn = defaultEquals) { \n    this.count = 0; // {2} \n    this.head = undefined; // {3}\n    this.equalsFn = equalsFn; // {4} \n  }\n  // 向链表尾部添加元素\n  push(element) { \n    const node = new Node(element); // {1} \n    let current; // {2} \n\n    if (this.head == null) { // {3} \n      this.head = node;\n    } else {\n      current = this.head; // {4} \n      while (current.next != null) { // {5} 获得最后一项\n        current = current.next; \n      }\n      // 将其 next 赋为新元素，建立链接\n      current.next = node; // {6} \n    } \n    this.count++; // {7} \n  }\n  // 从链表中移除元素\n  removeAt(index) { \n    // 检查越界值\n    if (index >= 0 && index < this.count) { // {1} \n      let current = this.head; // {2} \n      // 移除第一项\n      if (index === 0) { // {3} \n        this.head = current.next; \n      } else {\n        // 获取当前index的前一个节点\n        const previous = this.getElementAt(index - 1);\n        current = previous.next;\n        // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它\n        previous.next = current.next; // {8} \n      }\n      this.count--; // {9} \n      return current.element; \n    } \n    return undefined; // {10} \n  }\n  // 循环迭代链表直到目标位置\n  getElementAt(index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      let node = this.head; // {2} \n      for (let i = 0; i < index && node != null; i++) { // {3} \n        node = node.next;\n      } \n      return node; // {4} \n    } \n    return undefined; // {5} \n  }\n  // 在任意位置插入元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { // {1} \n      const node = new Node(element);\n\n      if (index === 0) { // 在第一个位置添加\n        const current = this.head; \n        node.next = current; // {2} \n        this.head = node; \n      } else { \n        const previous = this.getElementAt(index - 1); // {3} \n        const current = previous.next; // {4} \n        node.next = current; // {5} \n        previous.next = node; // {6} \n      } \n      this.count++; // 更新链表的长度\n      return true; \n    } \n    return false; // {7} \n  }\n  //  indexOf 方法：返回一个元素的位置\n  indexOf(element) { \n    let current = this.head; // {1} \n    for (let i = 0; i < this.count && current != null; i++) { // {2} \n      if (this.equalsFn(element, current.element)) { // {3} \n        return i; // {4} \n      }\n      current = current.next; // {5} \n    } \n    return -1; // {6} \n  }\n  // 从链表中移除元素\n  remove(element) { \n    const index = this.indexOf(element); \n    return this.removeAt(index); \n  }\n  size() { \n    return this.count; \n  }\n  isEmpty() { \n    return this.count === 0; \n  }\n  getHead() {\n    return this.head; \n  }\n  toString() { \n    if (this.head == null) { // {1} \n      return ''; \n    } \n    let objString = `${this.head.element}`; // {2} \n    let current = this.head.next; // {3} \n\n    for (let i = 1; i < this.size() && current != null; i++) { // {4} \n      objString = `${objString},${current.element}`; \n      current = current.next;\n    } \n    return objString; // {5} \n  }\n}\n```\n[javascript垃圾回收器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)\n\n###### 双向链表\n在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素\n![双向链表](chain-table-2.png)\n```javascript\nclass DoublyNode extends Node { // {1} \n constructor(element, next, prev) { \n  super(element, next); // {2} \n  this.prev = prev; // {3} 新增的\n } \n}\n\nclass DoublyLinkedList extends LinkedList { // {4} \n  constructor(equalsFn = defaultEquals) { \n    super(equalsFn); // {5} \n    this.tail = undefined; // {6} 新增的\n  }\n  //  在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new DoublyNode(element); \n      let current = this.head;\n\n      if (index === 0) { \n          if (this.head == null) { // {1} 新增的\n            this.head = node; \n            this.tail = node; \n          } else { \n            node.next = this.head; // {2} \n            current.prev = node; // {3} 新增的\n            this.head = node; // {4} \n          } \n      } else if (index === this.count) { // 最后一项 // 新增的\n        current = this.tail; // {5} \n        current.next = node; // {6} \n        node.prev = current; // {7} \n        this.tail = node; // {8} \n      } else { \n        const previous = this.getElementAt(index - 1); // {9} \n        current = previous.next; // {10} \n        node.next = current; // {11} \n        previous.next = node; // {12} \n        current.prev = node; // {13} 新增的\n        node.prev = previous; // {14} 新增的\n      }\n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        this.head = current.next; // {1} \n        // 如果只有一项，更新 tail // 新增的\n        if (this.count === 1) { // {2} \n          this.tail = undefined; \n        } else { \n          this.head.prev = undefined; // {3} \n        } \n      } else if (index === this.count - 1) { // 最后一项 //新增的\n        current = this.tail; // {4} \n        this.tail = current.prev; // {5} \n        this.tail.next = undefined; // {6} \n      } else { \n        current = this.getElementAt(index); // {7} \n        const previous = current.prev; // {8} \n        // 将 previous 与 current 的下一项链接起来——跳过 current \n        previous.next = current.next; // {9} \n        current.next.prev = previous; // {10} 新增的\n      }\n      this.count--; \n      return current.element; \n    } \n    return undefined; \n  }\n}\n// 源码：https://github.com/loiane/javascript-datastructures-algorithms\n```\n\n###### 循环链表\n循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）\n双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev\n![循环链表](chain-table-3.png)\n![双向循环链表](chain-table-4.png)\n\n```javascript\nclass CircularLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals) {\n    super(equalsFn); \n  }\n  // 在任意位置插入新元素\n  insert(element, index) { \n    if (index >= 0 && index <= this.count) { \n      const node = new Node(element); \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.head == null) { \n          this.head = node; // {1} \n          node.next = this.head; // {2} 新增的\n        } else { \n          node.next = current; // {3} \n          current = this.getElementAt(this.size()); // {4} \n          // 更新最后一个元素\n          this.head = node; // {5} \n          current.next = this.head; // {6} 新增的\n        }\n      } else { // 这种场景没有变化\n        const previous = this.getElementAt(index - 1); \n        node.next = previous.next; \n        previous.next = node; \n      } \n      this.count++; \n      return true;\n    } \n    return false; \n  }\n  // 从任意位置移除元素\n  removeAt(index) { \n    if (index >= 0 && index < this.count) { \n      let current = this.head;\n\n      if (index === 0) { \n        if (this.size() === 1) { \n          this.head = undefined; \n        } else { \n          const removed = this.head; // {1} \n          current = this.getElementAt(this.size()); // {2} 新增的\n          this.head = this.head.next; // {3} \n          current.next = this.head; // {4} \n          current = removed; // {5}\n        }\n      } else { \n        // 不需要修改循环链表最后一个元素\n        const previous = this.getElementAt(index - 1); \n        current = previous.next; \n        previous.next = current.next; \n      }\n      this.count--; \n      return current.element; // {6} \n    } \n    return undefined; \n  }\n}\n```\n\n###### 有序链表\n有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。\n```javascript\nconst Compare = { \n  LESS_THAN: -1, \n  BIGGER_THAN: 1 \n}; \nfunction defaultCompare(a, b) { \n  if (a === b) { // {1} \n    return 0; \n  } \n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN; // {2} \n} \nclass SortedLinkedList extends LinkedList { \n  constructor(equalsFn = defaultEquals, compareFn = defaultCompare) { \n    super(equalsFn); \n    this.compareFn = compareFn; // {3} \n  }\n  // 有序插入元素\n  insert(element, index = 0) { // {1} \n    if (this.isEmpty()) { \n      return super.insert(element, 0); // {2} \n    } \n    const pos = this.getIndexNextSortedElement(element); // {3} \n    return super.insert(element, pos); // {4} \n  } \n  getIndexNextSortedElement(element) { \n    let current = this.head; \n    let i = 0; \n    for (; i < this.size() && current; i++) { \n      const comp = this.compareFn(element, current.element); // {5} \n      if (comp === Compare.LESS_THAN) { // {6} \n        return i; \n      } \n      current = current.next; \n    } \n    return i; // {7} \n  }\n}\n```\n\n###### 创建 StackLinkedList 类\n```javascript\nclass StackLinkedList { \n  constructor() { \n    this.items = new DoublyLinkedList(); // {1} \n  } \n  push(element) { \n    this.items.push(element); // {2} \n  } \n  pop() { \n    if (this.isEmpty()) { \n      return undefined; \n    } \n    return this.items.removeAt(this.size() - 1); // {3} \n  } \n}\n```","slug":"34-data-structure2","published":1,"updated":"2022-09-27T09:21:29.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx2001ecktthr53h1pe","content":"<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向队列添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">enqueue</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从队列移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dequeue</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列头元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检查队列是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取队列的长度</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空队列</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.lowestCount + <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h6><p>双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列</p>\n<p>由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deque</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 向双端队列的前端添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addFront</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addBack(element);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.lowestCount &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount--;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount] = element;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.count; i &gt; <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.items[i] = <span class=\"built_in\">this</span>.items[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>] = element; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addBack</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环队列-击鼓传花\"><a href=\"#循环队列-击鼓传花\" class=\"headerlink\" title=\"循环队列 - 击鼓传花\"></a>循环队列 - 击鼓传花</h6><p>场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">elementsList, num</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elimitatedList = [];</span><br><span class=\"line\">  <span class=\"comment\">// 把名单的名字全都加入队列</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; elementsList.length; i++) &#123; </span><br><span class=\"line\">    queue.enqueue(elementsList[i]); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代队列</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (queue.size() &gt; <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 将队列开头一项移除，添加到队列末尾</span></span><br><span class=\"line\">      queue.enqueue(queue.dequeue()); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 将超出限制的队列开头一项移除，作为淘汰项</span></span><br><span class=\"line\">    elimitatedList.push(queue.dequeue()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; </span><br><span class=\"line\">    <span class=\"attr\">eliminated</span>: elimitatedList, </span><br><span class=\"line\">    <span class=\"attr\">winner</span>: queue.dequeue() <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Camila&#x27;</span>, <span class=\"string\">&#x27;Ingrid&#x27;</span>, <span class=\"string\">&#x27;Carl&#x27;</span>]; </span><br><span class=\"line\"><span class=\"keyword\">const</span> result = hotPotato(names, <span class=\"number\">7</span>);</span><br><span class=\"line\">result.eliminated.forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`胜利者： <span class=\"subst\">$&#123;result.winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回文检查器\"><a href=\"#回文检查器\" class=\"headerlink\" title=\"回文检查器\"></a>回文检查器</h6><p>回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">palindromeChecker</span>(<span class=\"params\">aString</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 检查传入的字符串参数是否合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (aString === <span class=\"literal\">undefined</span> || aString === <span class=\"literal\">null</span> || (aString !== <span class=\"literal\">null</span> &amp;&amp; aString.length === <span class=\"number\">0</span>)) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> deque = <span class=\"keyword\">new</span> Deque(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> lowerString = aString.toLocaleLowerCase().split(<span class=\"string\">&#x27; &#x27;</span>).join(<span class=\"string\">&#x27;&#x27;</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isEqual = <span class=\"literal\">true</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstChar, lastChar;</span><br><span class=\"line\">  <span class=\"comment\">// 将所有字符串加入队列中</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; lowerString.length; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    deque.addBack(lowerString.charAt(i)); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deque.size() &gt; <span class=\"number\">1</span> &amp;&amp; isEqual) &#123; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    firstChar = deque.removeFront(); <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    lastChar = deque.removeBack(); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (firstChar !== lastChar) &#123; </span><br><span class=\"line\">      isEqual = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> isEqual;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">javascript事件循环</a></p>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><h6 id=\"链表数据结构\"><a href=\"#链表数据结构\" class=\"headerlink\" title=\"链表数据结构\"></a>链表数据结构</h6><p><img src=\"/2022/09/23/34-data-structure2/chain-table-1.png\" alt=\"链表\"><br>链表的好处：添加或移除元素的时候不需要移动其他元素<br>要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultEquals</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// models/linked-list-models</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.element = element; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.next = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultEquals &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>; </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/linked-list-models&#x27;</span>; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.equalsFn = equalsFn; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向链表尾部添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current.next != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;5&#125; 获得最后一项</span></span><br><span class=\"line\">        current = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 将其 next 赋为新元素，建立链接</span></span><br><span class=\"line\">      current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 检查越界值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"comment\">// 移除第一项</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前index的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        current = previous.next;</span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环迭代链表直到目标位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getElementAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> node = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; index &amp;&amp; node != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        node = node.next;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 在第一个位置添加</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = previous.next; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// 更新链表的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  indexOf 方法：返回一个元素的位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">indexOf</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.count &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.equalsFn(element, current.element)) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"built_in\">this</span>.indexOf(element); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.removeAt(index); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getHead</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.head.element&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;current.element&#125;</span>`</span>; </span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management\">javascript垃圾回收器</a></p>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素<br><img src=\"/2022/09/23/34-data-structure2/chain-table-2.png\" alt=\"双向链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element, next, prev</span>)</span> &#123; </span><br><span class=\"line\">  <span class=\"built_in\">super</span>(element, next); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.prev = prev; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> DoublyNode(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.tail = node; </span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">            current.prev = node; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// 最后一项 // 新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        node.prev = current; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = node; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current = previous.next; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;11&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;12&#125; </span></span><br><span class=\"line\">        current.prev = node; <span class=\"comment\">// &#123;13&#125; 新增的</span></span><br><span class=\"line\">        node.prev = previous; <span class=\"comment\">// &#123;14&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 如果只有一项，更新 tail // 新增的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.count === <span class=\"number\">1</span>) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head.prev = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 最后一项 //新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = current.prev; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail.next = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.getElementAt(index); <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = current.prev; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来——跳过 current </span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current.next.prev = previous; <span class=\"comment\">// &#123;10&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 源码：https://github.com/loiane/javascript-datastructures-algorithms</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h6><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）<br>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev<br><img src=\"/2022/09/23/34-data-structure2/chain-table-3.png\" alt=\"循环链表\"><br><img src=\"/2022/09/23/34-data-structure2/chain-table-4.png\" alt=\"双向循环链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircularLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          node.next = current; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          <span class=\"comment\">// 更新最后一个元素</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 这种场景没有变化</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        node.next = previous.next; </span><br><span class=\"line\">        previous.next = node; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"keyword\">const</span> removed = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          current = removed; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 不需要修改循环链表最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        current = previous.next; </span><br><span class=\"line\">        previous.next = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h6><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Compare = &#123; </span><br><span class=\"line\">  <span class=\"attr\">LESS_THAN</span>: -<span class=\"number\">1</span>, </span><br><span class=\"line\">  <span class=\"attr\">BIGGER_THAN</span>: <span class=\"number\">1</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a === b) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals, compareFn = defaultCompare</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 有序插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index = <span class=\"number\">0</span></span>)</span> &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, <span class=\"number\">0</span>); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> pos = <span class=\"built_in\">this</span>.getIndexNextSortedElement(element); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, pos); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getIndexNextSortedElement</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current; i++) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> comp = <span class=\"built_in\">this</span>.compareFn(element, current.element); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (comp === Compare.LESS_THAN) &#123; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      current = current.next; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"创建-StackLinkedList-类\"><a href=\"#创建-StackLinkedList-类\" class=\"headerlink\" title=\"创建 StackLinkedList 类\"></a>创建 StackLinkedList 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackLinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = <span class=\"keyword\">new</span> DoublyLinkedList(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.removeAt(<span class=\"built_in\">this</span>.size() - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向队列添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">enqueue</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从队列移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dequeue</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列头元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检查队列是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取队列的长度</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空队列</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.lowestCount + <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h6><p>双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列</p>\n<p>由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deque</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 向双端队列的前端添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addFront</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addBack(element);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.lowestCount &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount--;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount] = element;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">this</span>.count; i &gt; <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.items[i] = <span class=\"built_in\">this</span>.items[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>] = element; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addBack</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount++; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekFront</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.lowestCount];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peekBack</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count - <span class=\"built_in\">this</span>.lowestCount === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lowestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环队列-击鼓传花\"><a href=\"#循环队列-击鼓传花\" class=\"headerlink\" title=\"循环队列 - 击鼓传花\"></a>循环队列 - 击鼓传花</h6><p>场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hotPotato</span>(<span class=\"params\">elementsList, num</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elimitatedList = [];</span><br><span class=\"line\">  <span class=\"comment\">// 把名单的名字全都加入队列</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; elementsList.length; i++) &#123; </span><br><span class=\"line\">    queue.enqueue(elementsList[i]); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代队列</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (queue.size() &gt; <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123; </span><br><span class=\"line\">      <span class=\"comment\">// 将队列开头一项移除，添加到队列末尾</span></span><br><span class=\"line\">      queue.enqueue(queue.dequeue()); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 将超出限制的队列开头一项移除，作为淘汰项</span></span><br><span class=\"line\">    elimitatedList.push(queue.dequeue()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; </span><br><span class=\"line\">    <span class=\"attr\">eliminated</span>: elimitatedList, </span><br><span class=\"line\">    <span class=\"attr\">winner</span>: queue.dequeue() <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Camila&#x27;</span>, <span class=\"string\">&#x27;Ingrid&#x27;</span>, <span class=\"string\">&#x27;Carl&#x27;</span>]; </span><br><span class=\"line\"><span class=\"keyword\">const</span> result = hotPotato(names, <span class=\"number\">7</span>);</span><br><span class=\"line\">result.eliminated.forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`胜利者： <span class=\"subst\">$&#123;result.winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回文检查器\"><a href=\"#回文检查器\" class=\"headerlink\" title=\"回文检查器\"></a>回文检查器</h6><p>回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">palindromeChecker</span>(<span class=\"params\">aString</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 检查传入的字符串参数是否合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (aString === <span class=\"literal\">undefined</span> || aString === <span class=\"literal\">null</span> || (aString !== <span class=\"literal\">null</span> &amp;&amp; aString.length === <span class=\"number\">0</span>)) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">const</span> deque = <span class=\"keyword\">new</span> Deque(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> lowerString = aString.toLocaleLowerCase().split(<span class=\"string\">&#x27; &#x27;</span>).join(<span class=\"string\">&#x27;&#x27;</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isEqual = <span class=\"literal\">true</span>; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstChar, lastChar;</span><br><span class=\"line\">  <span class=\"comment\">// 将所有字符串加入队列中</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; lowerString.length; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    deque.addBack(lowerString.charAt(i)); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deque.size() &gt; <span class=\"number\">1</span> &amp;&amp; isEqual) &#123; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    firstChar = deque.removeFront(); <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    lastChar = deque.removeBack(); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (firstChar !== lastChar) &#123; </span><br><span class=\"line\">      isEqual = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> isEqual;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">javascript事件循环</a></p>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><h6 id=\"链表数据结构\"><a href=\"#链表数据结构\" class=\"headerlink\" title=\"链表数据结构\"></a>链表数据结构</h6><p><img src=\"/2022/09/23/34-data-structure2/chain-table-1.png\" alt=\"链表\"><br>链表的好处：添加或移除元素的时候不需要移动其他元素<br>要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultEquals</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// models/linked-list-models</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.element = element; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.next = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultEquals &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>; </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Node &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./models/linked-list-models&#x27;</span>; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.equalsFn = equalsFn; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向链表尾部添加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current.next != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;5&#125; 获得最后一项</span></span><br><span class=\"line\">        current = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 将其 next 赋为新元素，建立链接</span></span><br><span class=\"line\">      current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 检查越界值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"comment\">// 移除第一项</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前index的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        current = previous.next;</span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环迭代链表直到目标位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getElementAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> node = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; index &amp;&amp; node != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        node = node.next;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 在第一个位置添加</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = previous.next; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; <span class=\"comment\">// 更新链表的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  indexOf 方法：返回一个元素的位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">indexOf</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.count &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.equalsFn(element, current.element)) &#123; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从链表中移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"built_in\">this</span>.indexOf(element); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.removeAt(index); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getHead</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.head.element&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current != <span class=\"literal\">null</span>; i++) &#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;current.element&#125;</span>`</span>; </span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management\">javascript垃圾回收器</a></p>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素<br><img src=\"/2022/09/23/34-data-structure2/chain-table-2.png\" alt=\"双向链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyNode</span> <span class=\"keyword\">extends</span> <span class=\"title\">Node</span> </span>&#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">element, next, prev</span>)</span> &#123; </span><br><span class=\"line\">  <span class=\"built_in\">super</span>(element, next); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.prev = prev; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoublyLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> DoublyNode(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// &#123;1&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.tail = node; </span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">            current.prev = node; <span class=\"comment\">// &#123;3&#125; 新增的</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count) &#123; <span class=\"comment\">// 最后一项 // 新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        current.next = node; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        node.prev = current; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = node; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current = previous.next; <span class=\"comment\">// &#123;10&#125; </span></span><br><span class=\"line\">        node.next = current; <span class=\"comment\">// &#123;11&#125; </span></span><br><span class=\"line\">        previous.next = node; <span class=\"comment\">// &#123;12&#125; </span></span><br><span class=\"line\">        current.prev = node; <span class=\"comment\">// &#123;13&#125; 新增的</span></span><br><span class=\"line\">        node.prev = previous; <span class=\"comment\">// &#123;14&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.head = current.next; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 如果只有一项，更新 tail // 新增的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.count === <span class=\"number\">1</span>) &#123; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.tail = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head.prev = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index === <span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 最后一项 //新增的</span></span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.tail; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail = current.prev; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tail.next = <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        current = <span class=\"built_in\">this</span>.getElementAt(index); <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = current.prev; <span class=\"comment\">// &#123;8&#125; </span></span><br><span class=\"line\">        <span class=\"comment\">// 将 previous 与 current 的下一项链接起来——跳过 current </span></span><br><span class=\"line\">        previous.next = current.next; <span class=\"comment\">// &#123;9&#125; </span></span><br><span class=\"line\">        current.next.prev = previous; <span class=\"comment\">// &#123;10&#125; 新增的</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 源码：https://github.com/loiane/javascript-datastructures-algorithms</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h6><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）<br>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev<br><img src=\"/2022/09/23/34-data-structure2/chain-table-3.png\" alt=\"循环链表\"><br><img src=\"/2022/09/23/34-data-structure2/chain-table-4.png\" alt=\"双向循环链表\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircularLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在任意位置插入新元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(element); </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.head == <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          node.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          node.next = current; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          <span class=\"comment\">// 更新最后一个元素</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = node; <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;6&#125; 新增的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 这种场景没有变化</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        node.next = previous.next; </span><br><span class=\"line\">        previous.next = node; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count++; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从任意位置移除元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">removeAt</span>(<span class=\"params\">index</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">this</span>.count) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          <span class=\"keyword\">const</span> removed = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">          current = <span class=\"built_in\">this</span>.getElementAt(<span class=\"built_in\">this</span>.size()); <span class=\"comment\">// &#123;2&#125; 新增的</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.head = <span class=\"built_in\">this</span>.head.next; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">          current.next = <span class=\"built_in\">this</span>.head; <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">          current = removed; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 不需要修改循环链表最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> previous = <span class=\"built_in\">this</span>.getElementAt(index - <span class=\"number\">1</span>); </span><br><span class=\"line\">        current = previous.next; </span><br><span class=\"line\">        previous.next = current.next; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.count--; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h6><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Compare = &#123; </span><br><span class=\"line\">  <span class=\"attr\">LESS_THAN</span>: -<span class=\"number\">1</span>, </span><br><span class=\"line\">  <span class=\"attr\">BIGGER_THAN</span>: <span class=\"number\">1</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a === b) &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedLinkedList</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">equalsFn = defaultEquals, compareFn = defaultCompare</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(equalsFn); </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 有序插入元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">element, index = <span class=\"number\">0</span></span>)</span> &#123; <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, <span class=\"number\">0</span>); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">const</span> pos = <span class=\"built_in\">this</span>.getIndexNextSortedElement(element); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.insert(element, pos); <span class=\"comment\">// &#123;4&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getIndexNextSortedElement</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"built_in\">this</span>.head; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"built_in\">this</span>.size() &amp;&amp; current; i++) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">const</span> comp = <span class=\"built_in\">this</span>.compareFn(element, current.element); <span class=\"comment\">// &#123;5&#125; </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (comp === Compare.LESS_THAN) &#123; <span class=\"comment\">// &#123;6&#125; </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      current = current.next; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;7&#125; </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"创建-StackLinkedList-类\"><a href=\"#创建-StackLinkedList-类\" class=\"headerlink\" title=\"创建 StackLinkedList 类\"></a>创建 StackLinkedList 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackLinkedList</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = <span class=\"keyword\">new</span> DoublyLinkedList(); <span class=\"comment\">// &#123;1&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element); <span class=\"comment\">// &#123;2&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.removeAt(<span class=\"built_in\">this</span>.size() - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125; </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数据结构与算法阅读笔记(1)","date":"2022-09-20T09:41:00.000Z","_content":"\nECMAScript 和 javascript 的关系\nECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。\n\nES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别\n\n(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)\n\n(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性\n一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)\n\n(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)\n\n(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)\n\n(5)ES.Next 用来指代下一个版本的 ECMAScript\n\nES6 兼容性：http://kangax.github.io/compat-table/es6/\nES7 兼容性：http://kangax.github.io/compat-table/es2016plus/\n\nES5 中 class 类，使用属性存取器\n(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字\n(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的\n\n```javascript\nclass Person {\n  constructor(name) {\n    this._name = name; // {1}\n  }\n  get name() {\n    // {2}\n    return this._name;\n  }\n  set name(value) {\n    // {3}\n    this._name = value;\n  }\n}\nlet lotrChar = new Person('Frodo');\nconsole.log(lotrChar.name); // {4} // Frodo\nlotrChar.name = 'Gandalf'; // {5}\nconsole.log(lotrChar.name); // Gandalf\nlotrChar._name = 'Sam'; // {6}\nconsole.log(lotrChar.name); // Sam\n```\n\n乘方运算符\n\n```javascript\nconst area = 3.14 * r * r;\nconst area = 3.14 * Math.pow(r, 2);\n// ES2016 中引入了**运算符，用来进行指数运算\nconst area = 3.14 * r ** 2;\n```\n\n[JavaScript 和 ECMAScript 的完整功能列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n###### TypeScript\n\nTypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.\n(1)接口\n\n```javascript\n// 第一种定义接口的方式\ninterface Person {\n  name: string;\n  age: number;\n}\nfunction printName(person: Person) {\n  console.log(person.name);\n}\n/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，\n并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/\ninterface Comparable {\n  compareTo(b): number;\n}\nclass MyObject implements Comparable {\n  age: number;\n  compareTo(b): number {\n    if (this.age === b.age) {\n      return 0;\n    }\n    return this.age > b.age ? 1 : -1;\n  }\n}\n```\n\n**JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check**\n\n###### 数组\n\n数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组\n\n(1)使用@@iterator 对象\nES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet iterator = numbers[Symbol.iterator]();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\nconsole.log(iterator.next().value); // 4\nconsole.log(iterator.next().value); // 5\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\niterator = numbers[Symbol.iterator]();\nfor (const n of iterator) {\n  console.log(n);\n}\n\n// 复制已有数组\nlet numbers2 = Array.from(numbers);\nlet numbers3 = Array.of(...numbers);\n```\n\n(2)copyWithin\ncopyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置\n\n```javascript\ncopyArray = [1, 2, 3, 4, 5, 6];\ncopyArray.copyWithin(1, 3, 5);\n// copyWithin(起始位置，开始位置，结束位置)\n// [1, 4, 5, 4, 5, 6]\n```\n\n(3)排序\n\n```javascript\n// 自定义排序\nconst friends = [\n  { name: 'John', age: 30 },\n  { name: 'Ana', age: 20 },\n  { name: 'Chris', age: 25 }, // ES2017 允许存在尾逗号\n];\nfunction comparePerson(a, b) {\n  if (a.age < b.age) {\n    return -1;\n  }\n  if (a.age > b.age) {\n    return 1;\n  }\n  return 0;\n}\nconsole.log(friends.sort(comparePerson));\n/**\n[ \n { name: 'Ana', age: 20 }, \n { name: 'Chris', age: 25 },\n { name: 'John', age: 30 }, \n]\n*/\n// 忽略大小写的比较\nconst names = ['Ana', 'ana', 'john', 'John']; // 重置数组的初始状态\nconsole.log(\n  names.sort((a, b) => {\n    if (a.toLowerCase() < b.toLowerCase()) {\n      return -1;\n    }\n    if (a.toLowerCase() > b.toLowerCase()) {\n      return 1;\n    }\n    return 0;\n  })\n);\n// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法\nconst names = ['Ana', 'ana', 'john', 'John'];\nnames.sort((a, b) => a.localeCompare(b));\n// ['ana', 'Ana', 'john', 'John']\n\nconst names2 = ['Maève', 'Maeve'];\nconsole.log(names2.sort((a, b) => a.localeCompare(b)));\n// [\"Maeve\", \"Maève\"]\n```\n\n###### 类型数组\n\n| 类型数组          | 数据类型            |\n| ----------------- | ------------------- |\n| Int8Array         | 8 位二进制补码整数  |\n| Uint8Array        | 8 位无符号整数      |\n| Uint8ClampedArray | 8 位无符号整数      |\n| Int16Array        | 16 位二进制补码整数 |\n| Uint16Array       | 16 位无符号整数     |\n| Int32Array        | 32 位二进制补码整数 |\n| Uint32Array       | 32 位无符号整数     |\n| Float32Array      | 32 位 IEEE 浮点数   |\n| Float64Array      | 64 位 IEEE 浮点数   |\n\n```javascript\nlet length = 5;\nlet int16 = new Int16Array(length);\nlet array16 = [];\narray16.length = length;\nfor (let i = 0; i < length; i++) {\n  int16[i] = i + 1;\n}\nconsole.log(int16);\n```\n\n类型数组作用：WebGL API、位操作、处理文件和图像\n\n[类型数组文档](https://web.dev/webgl-typed-arrays/)\n\n###### 栈\n\n栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底\n\n栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）\n\n(1)创建一个基于数组的栈\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  // 添加一个（或几个）新元素到栈顶\n  push(element) {\n    this.items.push(element);\n  }\n  // 移除栈顶的元素，同时返回被移除的元素\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  // 如果栈里没有任何元素就返回 true，否则返回 false\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 返回栈里的元素个数。该方法和数组的 length 属性很类似\n  size() {\n    return this.items.length;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = [];\n  }\n}\n```\n\n**在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。**\n(2)创建一个基于 JavaScript 对象的 Stack 类\n\n```javascript\nclass Stack {\n  constructor() {\n    this.count = 0; // count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素\n    this.items = {};\n  }\n  // 向栈中插入元素,只允许一次插入一个元素\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 验证一个栈的大小\n  size() {\n    return this.count;\n  }\n  // 获取栈是否为空\n  isEmpty() {\n    return this.count === 0;\n  }\n  // 从栈中弹出元素\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  // 查看栈顶的值\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  // 清空栈\n  clear() {\n    this.items = {};\n    this.count = 0;\n    //  while (!this.isEmpty()) {\n    //  this.pop();\n    // }\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[0]}`; // {1}\n    for (let i = 1; i < this.count; i++) {\n      // {2}\n      objString = `${objString},${this.items[i]}`; // {3}\n    }\n    return objString;\n  }\n}\n```\n\n**javascript 实现私有属性的方法**\n下划线命名约定\n\n```javascript\n// 中使用下划线命名约定来标记一个属性为私有属性\nclass Stack {\n  constructor() {\n    this._count = 0;\n    this._items = {};\n  }\n}\n```\n\n_下划线命名约定就是在属性名称之前加上一个下划线（\\_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识_\n\n**用 ES2015 的限定作用域 Symbol 实现类**\n\n```javascript\nconst _items = Symbol('stackItems');\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n  // 栈的方法\n}\n\nconst stack = new Stack();\nstack.push(5);\nstack.push(8);\nlet objectSymbols = Object.getOwnPropertySymbols(stack);\nconsole.log(objectSymbols.length); // 输出 1\nconsole.log(objectSymbols); // [Symbol()]\nconsole.log(objectSymbols[0]); // Symbol()\nstack[objectSymbols[0]].push(1);\nstack.print(); // 输出 5, 8, 1\n```\n\n_访问 stack[objectSymbols[0]]得到\\_items,并且，\\_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求_\n\n**用 ES2015 的 WeakMap 实现类**\nWeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型\n\n```javascript\nconst items = new WeakMap(); // {1}\nclass Stack {\n  constructor() {\n    items.set(this, []); // {2}\n  }\n  push(element) {\n    const s = items.get(this); // {3}\n    s.push(element);\n  }\n  pop() {\n    const s = items.get(this);\n    const r = s.pop();\n    return r;\n  }\n  // 其他方法\n}\n```\n\n_代码的可读性不强，而且在扩展该类时无法继承私有属性_\n\n**ECMAScript 类属性提案**\n\n```javascript\nclass Stack {\n  #count = 0;\n  #items = 0;\n  // 栈的方法\n}\n```\n\n**从十进制转二进制**\n\n```javascript\nfunction decimalToBinary(decNumber) {\n  const remStack = new Stack();\n  let number = decNumber;\n  let rem;\n  let binaryString = '';\n  while (number > 0) {\n    rem = Math.floor(number % 2);\n    remStack.push(rem);\n    number = Math.floor(number / 2);\n  }\n  while (!remStack.isEmpty()) {\n    binaryString += remStack.pop().toString();\n  }\n  return binaryString;\n}\n```\n\n**进制转换算法**\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const remStack = new Stack();\n  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6}\n  let number = decNumber;\n  let rem;\n  let baseString = '';\n  if (!(base >= 2 && base <= 36)) {\n    return '';\n  }\n  while (number > 0) {\n    rem = Math.floor(number % base);\n    remStack.push(rem);\n    number = Math.floor(number / base);\n  }\n  while (!remStack.isEmpty()) {\n    baseString += digits[remStack.pop()]; // {7}\n  }\n  return baseString;\n}\n```\n","source":"_posts/33-data-structure1.md","raw":"---\ntitle: 数据结构与算法阅读笔记(1)\ndate: 2022-09-20 17:41:00\ntags:\n---\n\nECMAScript 和 javascript 的关系\nECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。\n\nES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别\n\n(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)\n\n(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性\n一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)\n\n(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)\n\n(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)\n\n(5)ES.Next 用来指代下一个版本的 ECMAScript\n\nES6 兼容性：http://kangax.github.io/compat-table/es6/\nES7 兼容性：http://kangax.github.io/compat-table/es2016plus/\n\nES5 中 class 类，使用属性存取器\n(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字\n(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的\n\n```javascript\nclass Person {\n  constructor(name) {\n    this._name = name; // {1}\n  }\n  get name() {\n    // {2}\n    return this._name;\n  }\n  set name(value) {\n    // {3}\n    this._name = value;\n  }\n}\nlet lotrChar = new Person('Frodo');\nconsole.log(lotrChar.name); // {4} // Frodo\nlotrChar.name = 'Gandalf'; // {5}\nconsole.log(lotrChar.name); // Gandalf\nlotrChar._name = 'Sam'; // {6}\nconsole.log(lotrChar.name); // Sam\n```\n\n乘方运算符\n\n```javascript\nconst area = 3.14 * r * r;\nconst area = 3.14 * Math.pow(r, 2);\n// ES2016 中引入了**运算符，用来进行指数运算\nconst area = 3.14 * r ** 2;\n```\n\n[JavaScript 和 ECMAScript 的完整功能列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n###### TypeScript\n\nTypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.\n(1)接口\n\n```javascript\n// 第一种定义接口的方式\ninterface Person {\n  name: string;\n  age: number;\n}\nfunction printName(person: Person) {\n  console.log(person.name);\n}\n/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，\n并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/\ninterface Comparable {\n  compareTo(b): number;\n}\nclass MyObject implements Comparable {\n  age: number;\n  compareTo(b): number {\n    if (this.age === b.age) {\n      return 0;\n    }\n    return this.age > b.age ? 1 : -1;\n  }\n}\n```\n\n**JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check**\n\n###### 数组\n\n数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组\n\n(1)使用@@iterator 对象\nES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet iterator = numbers[Symbol.iterator]();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\nconsole.log(iterator.next().value); // 4\nconsole.log(iterator.next().value); // 5\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\niterator = numbers[Symbol.iterator]();\nfor (const n of iterator) {\n  console.log(n);\n}\n\n// 复制已有数组\nlet numbers2 = Array.from(numbers);\nlet numbers3 = Array.of(...numbers);\n```\n\n(2)copyWithin\ncopyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置\n\n```javascript\ncopyArray = [1, 2, 3, 4, 5, 6];\ncopyArray.copyWithin(1, 3, 5);\n// copyWithin(起始位置，开始位置，结束位置)\n// [1, 4, 5, 4, 5, 6]\n```\n\n(3)排序\n\n```javascript\n// 自定义排序\nconst friends = [\n  { name: 'John', age: 30 },\n  { name: 'Ana', age: 20 },\n  { name: 'Chris', age: 25 }, // ES2017 允许存在尾逗号\n];\nfunction comparePerson(a, b) {\n  if (a.age < b.age) {\n    return -1;\n  }\n  if (a.age > b.age) {\n    return 1;\n  }\n  return 0;\n}\nconsole.log(friends.sort(comparePerson));\n/**\n[ \n { name: 'Ana', age: 20 }, \n { name: 'Chris', age: 25 },\n { name: 'John', age: 30 }, \n]\n*/\n// 忽略大小写的比较\nconst names = ['Ana', 'ana', 'john', 'John']; // 重置数组的初始状态\nconsole.log(\n  names.sort((a, b) => {\n    if (a.toLowerCase() < b.toLowerCase()) {\n      return -1;\n    }\n    if (a.toLowerCase() > b.toLowerCase()) {\n      return 1;\n    }\n    return 0;\n  })\n);\n// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法\nconst names = ['Ana', 'ana', 'john', 'John'];\nnames.sort((a, b) => a.localeCompare(b));\n// ['ana', 'Ana', 'john', 'John']\n\nconst names2 = ['Maève', 'Maeve'];\nconsole.log(names2.sort((a, b) => a.localeCompare(b)));\n// [\"Maeve\", \"Maève\"]\n```\n\n###### 类型数组\n\n| 类型数组          | 数据类型            |\n| ----------------- | ------------------- |\n| Int8Array         | 8 位二进制补码整数  |\n| Uint8Array        | 8 位无符号整数      |\n| Uint8ClampedArray | 8 位无符号整数      |\n| Int16Array        | 16 位二进制补码整数 |\n| Uint16Array       | 16 位无符号整数     |\n| Int32Array        | 32 位二进制补码整数 |\n| Uint32Array       | 32 位无符号整数     |\n| Float32Array      | 32 位 IEEE 浮点数   |\n| Float64Array      | 64 位 IEEE 浮点数   |\n\n```javascript\nlet length = 5;\nlet int16 = new Int16Array(length);\nlet array16 = [];\narray16.length = length;\nfor (let i = 0; i < length; i++) {\n  int16[i] = i + 1;\n}\nconsole.log(int16);\n```\n\n类型数组作用：WebGL API、位操作、处理文件和图像\n\n[类型数组文档](https://web.dev/webgl-typed-arrays/)\n\n###### 栈\n\n栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底\n\n栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）\n\n(1)创建一个基于数组的栈\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  // 添加一个（或几个）新元素到栈顶\n  push(element) {\n    this.items.push(element);\n  }\n  // 移除栈顶的元素，同时返回被移除的元素\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  // 如果栈里没有任何元素就返回 true，否则返回 false\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 返回栈里的元素个数。该方法和数组的 length 属性很类似\n  size() {\n    return this.items.length;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = [];\n  }\n}\n```\n\n**在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。**\n(2)创建一个基于 JavaScript 对象的 Stack 类\n\n```javascript\nclass Stack {\n  constructor() {\n    this.count = 0; // count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素\n    this.items = {};\n  }\n  // 向栈中插入元素,只允许一次插入一个元素\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n  // 验证一个栈的大小\n  size() {\n    return this.count;\n  }\n  // 获取栈是否为空\n  isEmpty() {\n    return this.count === 0;\n  }\n  // 从栈中弹出元素\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n  // 查看栈顶的值\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n  // 清空栈\n  clear() {\n    this.items = {};\n    this.count = 0;\n    //  while (!this.isEmpty()) {\n    //  this.pop();\n    // }\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString = `${this.items[0]}`; // {1}\n    for (let i = 1; i < this.count; i++) {\n      // {2}\n      objString = `${objString},${this.items[i]}`; // {3}\n    }\n    return objString;\n  }\n}\n```\n\n**javascript 实现私有属性的方法**\n下划线命名约定\n\n```javascript\n// 中使用下划线命名约定来标记一个属性为私有属性\nclass Stack {\n  constructor() {\n    this._count = 0;\n    this._items = {};\n  }\n}\n```\n\n_下划线命名约定就是在属性名称之前加上一个下划线（\\_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识_\n\n**用 ES2015 的限定作用域 Symbol 实现类**\n\n```javascript\nconst _items = Symbol('stackItems');\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n  // 栈的方法\n}\n\nconst stack = new Stack();\nstack.push(5);\nstack.push(8);\nlet objectSymbols = Object.getOwnPropertySymbols(stack);\nconsole.log(objectSymbols.length); // 输出 1\nconsole.log(objectSymbols); // [Symbol()]\nconsole.log(objectSymbols[0]); // Symbol()\nstack[objectSymbols[0]].push(1);\nstack.print(); // 输出 5, 8, 1\n```\n\n_访问 stack[objectSymbols[0]]得到\\_items,并且，\\_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求_\n\n**用 ES2015 的 WeakMap 实现类**\nWeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型\n\n```javascript\nconst items = new WeakMap(); // {1}\nclass Stack {\n  constructor() {\n    items.set(this, []); // {2}\n  }\n  push(element) {\n    const s = items.get(this); // {3}\n    s.push(element);\n  }\n  pop() {\n    const s = items.get(this);\n    const r = s.pop();\n    return r;\n  }\n  // 其他方法\n}\n```\n\n_代码的可读性不强，而且在扩展该类时无法继承私有属性_\n\n**ECMAScript 类属性提案**\n\n```javascript\nclass Stack {\n  #count = 0;\n  #items = 0;\n  // 栈的方法\n}\n```\n\n**从十进制转二进制**\n\n```javascript\nfunction decimalToBinary(decNumber) {\n  const remStack = new Stack();\n  let number = decNumber;\n  let rem;\n  let binaryString = '';\n  while (number > 0) {\n    rem = Math.floor(number % 2);\n    remStack.push(rem);\n    number = Math.floor(number / 2);\n  }\n  while (!remStack.isEmpty()) {\n    binaryString += remStack.pop().toString();\n  }\n  return binaryString;\n}\n```\n\n**进制转换算法**\n\n```javascript\nfunction baseConverter(decNumber, base) {\n  const remStack = new Stack();\n  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6}\n  let number = decNumber;\n  let rem;\n  let baseString = '';\n  if (!(base >= 2 && base <= 36)) {\n    return '';\n  }\n  while (number > 0) {\n    rem = Math.floor(number % base);\n    remStack.push(rem);\n    number = Math.floor(number / base);\n  }\n  while (!remStack.isEmpty()) {\n    baseString += digits[remStack.pop()]; // {7}\n  }\n  return baseString;\n}\n```\n","slug":"33-data-structure1","published":1,"updated":"2022-09-23T07:51:52.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx2001fcktt6xzveimz","content":"<p>ECMAScript 和 javascript 的关系<br>ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。</p>\n<p>ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别</p>\n<p>(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)</p>\n<p>(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性<br>一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)</p>\n<p>(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)</p>\n<p>(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)</p>\n<p>(5)ES.Next 用来指代下一个版本的 ECMAScript</p>\n<p>ES6 兼容性：<a href=\"http://kangax.github.io/compat-table/es6/\">http://kangax.github.io/compat-table/es6/</a><br>ES7 兼容性：<a href=\"http://kangax.github.io/compat-table/es2016plus/\">http://kangax.github.io/compat-table/es2016plus/</a></p>\n<p>ES5 中 class 类，使用属性存取器<br>(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字<br>(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = name; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">name</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">name</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lotrChar = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Frodo&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// &#123;4&#125; // Frodo</span></span><br><span class=\"line\">lotrChar.name = <span class=\"string\">&#x27;Gandalf&#x27;</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Gandalf</span></span><br><span class=\"line\">lotrChar._name = <span class=\"string\">&#x27;Sam&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Sam</span></span><br></pre></td></tr></table></figure>\n\n<p>乘方运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r * r;</span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * <span class=\"built_in\">Math</span>.pow(r, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// ES2016 中引入了**运算符，用来进行指数运算</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r ** <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript 和 ECMAScript 的完整功能列表</a></p>\n<h6 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h6><p>TypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.<br>(1)接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种定义接口的方式</span></span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(person.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，</span></span><br><span class=\"line\"><span class=\"comment\">并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/</span></span><br><span class=\"line\">interface Comparable &#123;</span><br><span class=\"line\">  compareTo(b): number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> <span class=\"title\">implements</span> <span class=\"title\">Comparable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">  compareTo(b): number &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.age === b.age) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age &gt; b.age ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check</strong></p>\n<h6 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h6><p>数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组</p>\n<p>(1)使用@@iterator 对象<br>ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\">iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> iterator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制已有数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers2 = <span class=\"built_in\">Array</span>.from(numbers);</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers3 = <span class=\"built_in\">Array</span>.of(...numbers);</span><br></pre></td></tr></table></figure>\n\n<p>(2)copyWithin<br>copyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">copyArray.copyWithin(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// copyWithin(起始位置，开始位置，结束位置)</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 4, 5, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义排序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> friends = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">20</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Chris&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;, <span class=\"comment\">// ES2017 允许存在尾逗号</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">comparePerson</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &lt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &gt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friends.sort(comparePerson));</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">[ </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Chris&#x27;, age: 25 &#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;John&#x27;, age: 30 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 忽略大小写的比较</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>]; <span class=\"comment\">// 重置数组的初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &lt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &gt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>];</span><br><span class=\"line\">names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class=\"line\"><span class=\"comment\">// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names2 = [<span class=\"string\">&#x27;Maève&#x27;</span>, <span class=\"string\">&#x27;Maeve&#x27;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names2.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b)));</span><br><span class=\"line\"><span class=\"comment\">// [&quot;Maeve&quot;, &quot;Maève&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"类型数组\"><a href=\"#类型数组\" class=\"headerlink\" title=\"类型数组\"></a>类型数组</h6><table>\n<thead>\n<tr>\n<th>类型数组</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>8 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint8Array</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Uint8ClampedArray</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>16 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>16 位无符号整数</td>\n</tr>\n<tr>\n<td>Int32Array</td>\n<td>32 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint32Array</td>\n<td>32 位无符号整数</td>\n</tr>\n<tr>\n<td>Float32Array</td>\n<td>32 位 IEEE 浮点数</td>\n</tr>\n<tr>\n<td>Float64Array</td>\n<td>64 位 IEEE 浮点数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> length = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> int16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(length);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array16 = [];</span><br><span class=\"line\">array16.length = length;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">  int16[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int16);</span><br></pre></td></tr></table></figure>\n\n<p>类型数组作用：WebGL API、位操作、处理文件和图像</p>\n<p><a href=\"https://web.dev/webgl-typed-arrays/\">类型数组文档</a></p>\n<h6 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h6><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底</p>\n<p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）</p>\n<p>(1)创建一个基于数组的栈</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个（或几个）新元素到栈顶</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.items.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈里的元素个数。该方法和数组的 length 属性很类似</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈里的所有元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。</strong><br>(2)创建一个基于 JavaScript 对象的 Stack 类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向栈中插入元素,只允许一次插入一个元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 验证一个栈的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取栈是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从栈中弹出元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看栈顶的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空栈</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  while (!this.isEmpty()) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//  this.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>]&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>javascript 实现私有属性的方法</strong><br>下划线命名约定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中使用下划线命名约定来标记一个属性为私有属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识</em></p>\n<p><strong>用 ES2015 的限定作用域 Symbol 实现类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _items = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;stackItems&#x27;</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(stack);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols.length); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols); <span class=\"comment\">// [Symbol()]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols[<span class=\"number\">0</span>]); <span class=\"comment\">// Symbol()</span></span><br><span class=\"line\">stack[objectSymbols[<span class=\"number\">0</span>]].push(<span class=\"number\">1</span>);</span><br><span class=\"line\">stack.print(); <span class=\"comment\">// 输出 5, 8, 1</span></span><br></pre></td></tr></table></figure>\n\n<p><em>访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求</em></p>\n<p><strong>用 ES2015 的 WeakMap 实现类</strong><br>WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    items.set(<span class=\"built_in\">this</span>, []); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    s.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = s.pop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>代码的可读性不强，而且在扩展该类时无法继承私有属性</em></p>\n<p><strong>ECMAScript 类属性提案</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  #count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  #items = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>从十进制转二进制</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decimalToBinary</span>(<span class=\"params\">decNumber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> binaryString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % <span class=\"number\">2</span>);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    binaryString += remStack.pop().toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binaryString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进制转换算法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> baseString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(base &gt;= <span class=\"number\">2</span> &amp;&amp; base &lt;= <span class=\"number\">36</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % base);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    baseString += digits[remStack.pop()]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>ECMAScript 和 javascript 的关系<br>ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。</p>\n<p>ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别</p>\n<p>(1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称)</p>\n<p>(2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性<br>一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)</p>\n<p>(3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7)</p>\n<p>(4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8)</p>\n<p>(5)ES.Next 用来指代下一个版本的 ECMAScript</p>\n<p>ES6 兼容性：<a href=\"http://kangax.github.io/compat-table/es6/\">http://kangax.github.io/compat-table/es6/</a><br>ES7 兼容性：<a href=\"http://kangax.github.io/compat-table/es2016plus/\">http://kangax.github.io/compat-table/es2016plus/</a></p>\n<p>ES5 中 class 类，使用属性存取器<br>(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字<br>(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = name; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">name</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">name</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>._name = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lotrChar = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Frodo&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// &#123;4&#125; // Frodo</span></span><br><span class=\"line\">lotrChar.name = <span class=\"string\">&#x27;Gandalf&#x27;</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Gandalf</span></span><br><span class=\"line\">lotrChar._name = <span class=\"string\">&#x27;Sam&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lotrChar.name); <span class=\"comment\">// Sam</span></span><br></pre></td></tr></table></figure>\n\n<p>乘方运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r * r;</span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * <span class=\"built_in\">Math</span>.pow(r, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// ES2016 中引入了**运算符，用来进行指数运算</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> area = <span class=\"number\">3.14</span> * r ** <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript 和 ECMAScript 的完整功能列表</a></p>\n<h6 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h6><p>TypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.<br>(1)接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种定义接口的方式</span></span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(person.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，</span></span><br><span class=\"line\"><span class=\"comment\">并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/</span></span><br><span class=\"line\">interface Comparable &#123;</span><br><span class=\"line\">  compareTo(b): number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> <span class=\"title\">implements</span> <span class=\"title\">Comparable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: number;</span><br><span class=\"line\">  compareTo(b): number &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.age === b.age) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age &gt; b.age ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check</strong></p>\n<h6 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h6><p>数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组</p>\n<p>(1)使用@@iterator 对象<br>ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next().value); <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</span><br><span class=\"line\">iterator = numbers[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> iterator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制已有数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers2 = <span class=\"built_in\">Array</span>.from(numbers);</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers3 = <span class=\"built_in\">Array</span>.of(...numbers);</span><br></pre></td></tr></table></figure>\n\n<p>(2)copyWithin<br>copyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">copyArray.copyWithin(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// copyWithin(起始位置，开始位置，结束位置)</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 4, 5, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(3)排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义排序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> friends = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">20</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Chris&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;, <span class=\"comment\">// ES2017 允许存在尾逗号</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">comparePerson</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &lt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.age &gt; b.age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friends.sort(comparePerson));</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">[ </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;Chris&#x27;, age: 25 &#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> &#123; name: &#x27;John&#x27;, age: 30 &#125;, </span></span><br><span class=\"line\"><span class=\"comment\">]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 忽略大小写的比较</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>]; <span class=\"comment\">// 重置数组的初始状态</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &lt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.toLowerCase() &gt; b.toLowerCase()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&#x27;Ana&#x27;</span>, <span class=\"string\">&#x27;ana&#x27;</span>, <span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;John&#x27;</span>];</span><br><span class=\"line\">names.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b));</span><br><span class=\"line\"><span class=\"comment\">// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> names2 = [<span class=\"string\">&#x27;Maève&#x27;</span>, <span class=\"string\">&#x27;Maeve&#x27;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names2.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.localeCompare(b)));</span><br><span class=\"line\"><span class=\"comment\">// [&quot;Maeve&quot;, &quot;Maève&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"类型数组\"><a href=\"#类型数组\" class=\"headerlink\" title=\"类型数组\"></a>类型数组</h6><table>\n<thead>\n<tr>\n<th>类型数组</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>8 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint8Array</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Uint8ClampedArray</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>16 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>16 位无符号整数</td>\n</tr>\n<tr>\n<td>Int32Array</td>\n<td>32 位二进制补码整数</td>\n</tr>\n<tr>\n<td>Uint32Array</td>\n<td>32 位无符号整数</td>\n</tr>\n<tr>\n<td>Float32Array</td>\n<td>32 位 IEEE 浮点数</td>\n</tr>\n<tr>\n<td>Float64Array</td>\n<td>64 位 IEEE 浮点数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> length = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> int16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(length);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array16 = [];</span><br><span class=\"line\">array16.length = length;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">  int16[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int16);</span><br></pre></td></tr></table></figure>\n\n<p>类型数组作用：WebGL API、位操作、处理文件和图像</p>\n<p><a href=\"https://web.dev/webgl-typed-arrays/\">类型数组文档</a></p>\n<h6 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h6><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底</p>\n<p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）</p>\n<p>(1)创建一个基于数组的栈</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个（或几个）新元素到栈顶</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.items.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回栈里的元素个数。该方法和数组的 length 属性很类似</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除栈里的所有元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。</strong><br>(2)创建一个基于 JavaScript 对象的 Stack 类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>; <span class=\"comment\">// count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向栈中插入元素,只允许一次插入一个元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count] = element;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 验证一个栈的大小</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取栈是否为空</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.count === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从栈中弹出元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count--;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 查看栈顶的值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">peek</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.items[<span class=\"built_in\">this</span>.count - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清空栈</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//  while (!this.isEmpty()) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//  this.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[<span class=\"number\">0</span>]&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.count; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.items[i]&#125;</span>`</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>javascript 实现私有属性的方法</strong><br>下划线命名约定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中使用下划线命名约定来标记一个属性为私有属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识</em></p>\n<p><strong>用 ES2015 的限定作用域 Symbol 实现类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _items = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;stackItems&#x27;</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>[_items] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(stack);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols.length); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols); <span class=\"comment\">// [Symbol()]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols[<span class=\"number\">0</span>]); <span class=\"comment\">// Symbol()</span></span><br><span class=\"line\">stack[objectSymbols[<span class=\"number\">0</span>]].push(<span class=\"number\">1</span>);</span><br><span class=\"line\">stack.print(); <span class=\"comment\">// 输出 5, 8, 1</span></span><br></pre></td></tr></table></figure>\n\n<p><em>访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求</em></p>\n<p><strong>用 ES2015 的 WeakMap 实现类</strong><br>WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    items.set(<span class=\"built_in\">this</span>, []); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">push</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    s.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">pop</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> s = items.get(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = s.pop();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>代码的可读性不强，而且在扩展该类时无法继承私有属性</em></p>\n<p><strong>ECMAScript 类属性提案</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</span><br><span class=\"line\">  #count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  #items = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 栈的方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>从十进制转二进制</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decimalToBinary</span>(<span class=\"params\">decNumber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> binaryString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % <span class=\"number\">2</span>);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    binaryString += remStack.pop().toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binaryString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进制转换算法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseConverter</span>(<span class=\"params\">decNumber, base</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> remStack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> digits = <span class=\"string\">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> number = decNumber;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rem;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> baseString = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(base &gt;= <span class=\"number\">2</span> &amp;&amp; base &lt;= <span class=\"number\">36</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    rem = <span class=\"built_in\">Math</span>.floor(number % base);</span><br><span class=\"line\">    remStack.push(rem);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.floor(number / base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!remStack.isEmpty()) &#123;</span><br><span class=\"line\">    baseString += digits[remStack.pop()]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构与算法阅读笔记(3)","date":"2022-09-29T02:49:51.000Z","_content":"\n#### 集合\n\n集合是由一组无序且唯一（即不能重复）的项组成的\n\n###### 创建集合类\n\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n  has(element) {\n    return element in items;\n  }\n  // Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。\n  // in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。\n  // has(element) {\n  //   return Object.prototype.hasOwnProperty.call(this.items, element);\n  // }\n  add(element) {\n    if (!this.has(element)) {\n      this.items[element] = element; // {1}\n      return true;\n    }\n    return false;\n  }\n  delete(element) {\n    if (this.has(element)) {\n      delete this.items[element]; // {1}\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    this.items = {}; // {2}\n  }\n  size() {\n    return Object.keys(this.items).length; // {1}\n  }\n  // sizeLegacy() {\n  //  let count = 0;\n  //  for(let key in this.items) { // {2}\n  // 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量\n  // 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原\n  // 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对\n  // 象自身、未用于数据结构的）\n  //  if(this.items.hasOwnProperty(key)) { // {3}\n  //  count++; // {4}\n  //  }\n  //  return count;\n  // }\n  values() {\n    return Object.values(this.items);\n  }\n  // valuesLegacy() {\n  //  let values = [];\n  //  for(let key in this.items) { // {1}\n  //    if(this.items.hasOwnProperty(key)) {\n  //       values.push(key); // {2}\n  //    }\n  //  }\n  //  return values;\n  // }\n}\n```\n\n###### 集合运算\n\n(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n\n```javascript\n// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果\nunion(otherSet) {\n  const unionSet = new Set(); // {1}\n  // 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中\n  this.values().forEach(value => unionSet.add(value)); // {2}\n  otherSet.values().forEach(value => unionSet.add(value)); // {3}\n  return unionSet;\n}\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(3);\nsetB.add(4);\nsetB.add(5);\nsetB.add(6);\nconst unionAB = setA.union(setB);\nconsole.log(unionAB.values());\n// [1,2,3,4,5,6]\n```\n\n(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n\n```javascript\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values();\n for (let i = 0; i < values.length; i++) { // {2}\n   if (otherSet.has(values[i])) { // {3}\n     intersectionSet.add(values[i]); // {4}\n   }\n }\n return intersectionSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst intersectionAB = setA.intersection(setB);\nconsole.log(intersectionAB.values());\n// [2,3]\n\n// 优化\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values(); // {2}\n const otherValues = otherSet.values(); // {3}\n let biggerSet = values; // {4}\n let smallerSet = otherValues; // {5}\n\n if (otherValues.length - values.length > 0) { // {6}\n   biggerSet = otherValues;\n   smallerSet = values;\n }\n smallerSet.forEach(value => { // {7}\n   if (biggerSet.includes(value)) {\n     intersectionSet.add(value);\n   }\n });\n return intersectionSet;\n}\n```\n\n(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n\n```javascript\ndifference(otherSet) {\n  const differenceSet = new Set(); // {1}\n  this.values().forEach(value => { // {2}\n    if (!otherSet.has(value)) { // {3}\n      differenceSet.add(value); // {4}\n    }\n  });\n  return differenceSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst differenceAB = setA.difference(setB);\nconsole.log(differenceAB.values());\n// [1]\n```\n\n(4)子集：验证一个给定集合是否是另一集合的子集\n\n```javascript\nisSubsetOf(otherSet) {\n  if (this.size() > otherSet.size()) { // {1}\n    return false;\n  }\n  let isSubset = true; // {2}\n  // 只要回调函数返回 true，every 方法就会被调用（行{6}）。如果回调函数返回 false，循环会停止\n  this.values().every(value => { // {3}\n    if (!otherSet.has(value)) { // {4}\n      isSubset = false; // {5}\n      return false;\n    }\n    return true; // {6}\n  });\n  return isSubset; // {7}\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nconst setB = new Set();\nsetB.add(1);\nsetB.add(2);\nsetB.add(3);\nconst setC = new Set();\nsetC.add(2);\nsetC.add(3);\nsetC.add(4);\nconsole.log(setA.isSubsetOf(setB));\n// true\nconsole.log(setA.isSubsetOf(setC));\n// false\n```\n\n###### 使用扩展运算符\n\n```javascript\n// 并集\nconsole.log(new Set([...setA, ...setB]));\n\n// 交集\nconsole.log(new Set([...setA].filter((x) => setB.has(x))));\n\n// 差集\nconsole.log(new Set([...setA].filter((x) => !setB.has(x))));\n```\n\n#### 字典和散列表\n\n###### 字典\n\n在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。\n字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。\n字典也称作映射、符号表或关联数组\n\n```javascript\n// util.js\nexport function defaultToString(item) {\n  if (item === null) {\n    return 'NULL';\n  } else if (item === undefined) {\n    return 'UNDEFINED';\n  } else if (typeof item === 'string' || item instanceof String) {\n    return `${item}`;\n  }\n  return item.toString(); // {1}\n}\n\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  toString() {\n    return `[#${this.key}: ${this.value}]`;\n  }\n}\n\nimport { defaultToString } from '../util';\nexport default class Dictionary {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn; // {1}\n    this.table = {}; // {2}\n  }\n  // 检测一个键是否存在于字典中\n  hasKey(key) {\n    return this.table[this.toStrFn(key)] != null;\n  }\n  // 在字典和 ValuePair 类中设置键和值\n  set(key, value) {\n    if (key != null && value != null) {\n      const tableKey = this.toStrFn(key); // {1}\n      this.table[tableKey] = new ValuePair(key, value); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 从字典中移除一个值\n  remove(key) {\n    if (this.hasKey(key)) {\n      delete this.table[this.toStrFn(key)];\n      return true;\n    }\n    return false;\n  }\n  // 从字典中检索一个值\n  get(key) {\n    const valuePair = this.table[this.toStrFn(key)]; // {1}\n    return valuePair == null ? undefined : valuePair.value; // {2}\n  }\n  keyValues() {\n    return Object.values(this.table);\n  }\n  keys() {\n    return this.keyValues().map((valuePair) => valuePair.key);\n  }\n  values() {\n    return this.keyValues().map((valuePair) => valuePair.value);\n  }\n  forEach(callbackFn) {\n    const valuePairs = this.keyValues(); // {1}\n    for (let i = 0; i < valuePairs.length; i++) {\n      // {2}\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value); // {3}\n      if (result === false) {\n        break; // {4}\n      }\n    }\n  }\n  size() {\n    return Object.keys(this.table).length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  clear() {\n    this.table = {};\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const valuePairs = this.keyValues();\n    let objString = `${valuePairs[0].toString()}`; // {1}\n    for (let i = 1; i < valuePairs.length; i++) {\n      objString = `${objString},${valuePairs[i].toString()}`; // {2}\n    }\n    return objString; // {3}\n  }\n}\n```\n\n###### 散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值\n\n散列函数的作用是给定一个键值，然后返回值在表中的地址\n\n散列表有一些在计算机科学中应用的例子:\n(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用\n(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。\n\n散列函数 ---- lose lose 散列函数\n![lose-lose](lose-lose.png)\n\nHashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我\n们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而\n在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存\n在 hash 位置（或属性）\n\n```javascript\nclass HashTable {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  // 创建散列函数\n  loseloseHashCode(key) {\n    if (typeof key === 'number') {\n      // {1}\n      return key;\n    }\n    const tableKey = this.toStrFn(key); // {2}\n    // 根据组成 key 的每个字符的 ASCII 码值的和得到一个数\n    let hash = 0; // {3}\n    for (let i = 0; i < tableKey.length; i++) {\n      hash += tableKey.charCodeAt(i); // {4}\n    }\n    // 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行{5}）\n    // 这可以规避操作数超过数值变量最大表示范围的风险\n    return hash % 37; // {5}\n  }\n  hashCode(key) {\n    return this.loseloseHashCode(key);\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      // {1}\n      const position = this.hashCode(key); // {2}\n      this.table[position] = new ValuePair(key, value); // {3}\n      return true;\n    }\n    return false;\n  }\n  get(key) {\n    const valuePair = this.table[this.hashCode(key)];\n    return valuePair == null ? undefined : valuePair.value;\n  }\n  remove(key) {\n    const hash = this.hashCode(key); // {1}\n    const valuePair = this.table[hash]; // {2}\n    if (valuePair != null) {\n      delete this.table[hash]; // {3}\n      return true;\n    }\n    return false;\n  }\n}\n\nconst hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\nconsole.log(hash.hashCode('Gandalf') + ' - Gandalf');\nconsole.log(hash.hashCode('John') + ' - John');\nconsole.log(hash.hashCode('Tyrion') + ' - Tyrion');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion\n```\n\n**散列集合**\n散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数\n散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。\n\n**散列表中的冲突**\n有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n(1)分离链接\n分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。\n它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间\n![sperate-chain](sperate-chain.png)\n\n```javascript\nclass HashTableSeparateChaining {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      //  将验证要加入新元素的位置是否已经被占据\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new LinkedList(); // {2}\n      }\n      this.table[position].push(new ValuePair(key, value)); // {3}\n      return true;\n    }\n    return false;\n  }\n  // 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化\n  // LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key\n  // 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较\n  // 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要\n  // 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。\n  // 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。\n  get(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position]; // {1}\n    if (linkedList != null && !linkedList.isEmpty()) {\n      // {2}\n      let current = linkedList.getHead(); // {3}\n      while (current != null) {\n        // {4}\n        if (current.element.key === key) {\n          // {5}\n          return current.element.value; // {6}\n        }\n        current = current.next; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position];\n    if (linkedList != null && !linkedList.isEmpty()) {\n      let current = linkedList.getHead();\n      while (current != null) {\n        if (current.element.key === key) {\n          // {1}\n          linkedList.remove(current.element); // {2}\n          if (linkedList.isEmpty()) {\n            // {3}\n            delete this.table[position]; // {4}\n          }\n          return true; // {5}\n        }\n        current = current.next; // {6}\n      }\n    }\n    return false; // {7}\n  }\n}\n```\n\n(2)线性探查\n它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中\n当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置\n![linear-probing](linear-probing.png)\n\n线性探查技术分为两种。\n\n第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因\n![soft-delete](soft-delete.png)\n[源代码](http://github.com/loiane/javascript-datastructures-algorithms)\n\n第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。\n![move-key](move-key.png)\n\n```javascript\n// move-key\nclass HashTableSeparateChainingMoveKey {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new ValuePair(key, value); // {2}\n      } else {\n        let index = position + 1; // {3}\n        while (this.table[index] != null) {\n          // {4}\n          index++; // {5}\n        }\n        this.table[index] = new ValuePair(key, value); // {6}\n      }\n      return true;\n    }\n    return false;\n  }\n  // 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注\n  // 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需\n  // 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数\n  // 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需\n  // 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一\n  // 个功能\n  get(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      // {1}\n      if (this.table[position].key === key) {\n        // {2}\n        return this.table[position].value; // {3}\n      }\n      let index = position + 1; // {4}\n      while (this.table[index] != null && this.table[index].key !== key) {\n        // {5}\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        // {6}\n        return this.table[position].value; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      if (this.table[position].key === key) {\n        delete this.table[position]; // {1}\n        this.verifyRemoveSideEffect(key, position); // {2}\n        return true;\n      }\n      let index = position + 1;\n      while (this.table[index] != null && this.table[index].key !== key) {\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        delete this.table[index]; // {3}\n        this.verifyRemoveSideEffect(key, index); // {4}\n        return true;\n      }\n    }\n    return false;\n  }\n  verifyRemoveSideEffect(key, removedPosition) {\n    const hash = this.hashCode(key); // {1}\n    let index = removedPosition + 1; // {2}\n    while (this.table[index] != null) {\n      // {3}\n      const posHash = this.hashCode(this.table[index].key); // {4}\n      if (posHash <= hash || posHash <= removedPosition) {\n        // {5}\n        this.table[removedPosition] = this.table[index]; // {6}\n        delete this.table[index];\n        removedPosition = index;\n      }\n      index++;\n    }\n  }\n}\n```\n\n**更好的散列函数**\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。\n\n```javascript\ndjb2HashCode(key) {\n const tableKey = this.toStrFn(key); // {1}\n//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381\n let hash = 5381; // {2}\n for (let i = 0; i < tableKey.length; i++) { // {3}\n//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加\n hash = (hash * 33) + tableKey.charCodeAt(i); // {4}\n }\n//  将使用相加的和与另一个随机质数相除的余数\n return hash % 1013; // {5}\n}\n// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0\n```\n\n**ES2015 Map 类**\n\n```javascript\nconst map = new Map();\nmap.set('Gandalf', 'gandalf@email.com');\nmap.set('John', 'johnsnow@email.com');\nmap.set('Tyrion', 'tyrion@email.com');\nconsole.log(map.has('Gandalf')); // true\nconsole.log(map.size); // 3\nconsole.log(map.keys()); // 输出{\"Gandalf\", \"John\", \"Tyrion\"}\nconsole.log(map.values()); // 输出{\"gandalf@email.com\", \"johnsnow@email.com\",\n\"tyrion@email.com\"}\nconsole.log(map.get('Tyrion')); // tyrion@email.com\nmap.delete('John');\n```\n\n**ES2105 WeakMap 类和 WeakSet 类**\nMap 和 Set 与其弱化版本之间仅有的区别是:\n(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法\n(2)WeakSet 和 WeakMap 只能用对象作为键\n\n```javascript\nconst map = new WeakMap();\nconst ob1 = { name: 'Gandalf' }; // {1}\nconst ob2 = { name: 'John' };\nconst ob3 = { name: 'Tyrion' };\nmap.set(ob1, 'gandalf@email.com'); // {2}\nmap.set(ob2, 'johnsnow@email.com');\nmap.set(ob3, 'tyrion@email.com');\nconsole.log(map.has(ob1)); // true {3}\nconsole.log(map.get(ob3)); // tyrion@email.com {4}\nmap.delete(ob2); // {5}\n```\n\n注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象\n","source":"_posts/35-data-structure3.md","raw":"---\ntitle: 数据结构与算法阅读笔记(3)\ndate: 2022-09-29 10:49:51\ntags:\n---\n\n#### 集合\n\n集合是由一组无序且唯一（即不能重复）的项组成的\n\n###### 创建集合类\n\n```javascript\nclass Set {\n  constructor() {\n    this.items = {};\n  }\n  has(element) {\n    return element in items;\n  }\n  // Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。\n  // in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。\n  // has(element) {\n  //   return Object.prototype.hasOwnProperty.call(this.items, element);\n  // }\n  add(element) {\n    if (!this.has(element)) {\n      this.items[element] = element; // {1}\n      return true;\n    }\n    return false;\n  }\n  delete(element) {\n    if (this.has(element)) {\n      delete this.items[element]; // {1}\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    this.items = {}; // {2}\n  }\n  size() {\n    return Object.keys(this.items).length; // {1}\n  }\n  // sizeLegacy() {\n  //  let count = 0;\n  //  for(let key in this.items) { // {2}\n  // 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量\n  // 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原\n  // 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对\n  // 象自身、未用于数据结构的）\n  //  if(this.items.hasOwnProperty(key)) { // {3}\n  //  count++; // {4}\n  //  }\n  //  return count;\n  // }\n  values() {\n    return Object.values(this.items);\n  }\n  // valuesLegacy() {\n  //  let values = [];\n  //  for(let key in this.items) { // {1}\n  //    if(this.items.hasOwnProperty(key)) {\n  //       values.push(key); // {2}\n  //    }\n  //  }\n  //  return values;\n  // }\n}\n```\n\n###### 集合运算\n\n(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n\n```javascript\n// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果\nunion(otherSet) {\n  const unionSet = new Set(); // {1}\n  // 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中\n  this.values().forEach(value => unionSet.add(value)); // {2}\n  otherSet.values().forEach(value => unionSet.add(value)); // {3}\n  return unionSet;\n}\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(3);\nsetB.add(4);\nsetB.add(5);\nsetB.add(6);\nconst unionAB = setA.union(setB);\nconsole.log(unionAB.values());\n// [1,2,3,4,5,6]\n```\n\n(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n\n```javascript\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values();\n for (let i = 0; i < values.length; i++) { // {2}\n   if (otherSet.has(values[i])) { // {3}\n     intersectionSet.add(values[i]); // {4}\n   }\n }\n return intersectionSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst intersectionAB = setA.intersection(setB);\nconsole.log(intersectionAB.values());\n// [2,3]\n\n// 优化\nintersection(otherSet) {\n const intersectionSet = new Set(); // {1}\n const values = this.values(); // {2}\n const otherValues = otherSet.values(); // {3}\n let biggerSet = values; // {4}\n let smallerSet = otherValues; // {5}\n\n if (otherValues.length - values.length > 0) { // {6}\n   biggerSet = otherValues;\n   smallerSet = values;\n }\n smallerSet.forEach(value => { // {7}\n   if (biggerSet.includes(value)) {\n     intersectionSet.add(value);\n   }\n });\n return intersectionSet;\n}\n```\n\n(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n\n```javascript\ndifference(otherSet) {\n  const differenceSet = new Set(); // {1}\n  this.values().forEach(value => { // {2}\n    if (!otherSet.has(value)) { // {3}\n      differenceSet.add(value); // {4}\n    }\n  });\n  return differenceSet;\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nsetA.add(3);\nconst setB = new Set();\nsetB.add(2);\nsetB.add(3);\nsetB.add(4);\nconst differenceAB = setA.difference(setB);\nconsole.log(differenceAB.values());\n// [1]\n```\n\n(4)子集：验证一个给定集合是否是另一集合的子集\n\n```javascript\nisSubsetOf(otherSet) {\n  if (this.size() > otherSet.size()) { // {1}\n    return false;\n  }\n  let isSubset = true; // {2}\n  // 只要回调函数返回 true，every 方法就会被调用（行{6}）。如果回调函数返回 false，循环会停止\n  this.values().every(value => { // {3}\n    if (!otherSet.has(value)) { // {4}\n      isSubset = false; // {5}\n      return false;\n    }\n    return true; // {6}\n  });\n  return isSubset; // {7}\n}\n\nconst setA = new Set();\nsetA.add(1);\nsetA.add(2);\nconst setB = new Set();\nsetB.add(1);\nsetB.add(2);\nsetB.add(3);\nconst setC = new Set();\nsetC.add(2);\nsetC.add(3);\nsetC.add(4);\nconsole.log(setA.isSubsetOf(setB));\n// true\nconsole.log(setA.isSubsetOf(setC));\n// false\n```\n\n###### 使用扩展运算符\n\n```javascript\n// 并集\nconsole.log(new Set([...setA, ...setB]));\n\n// 交集\nconsole.log(new Set([...setA].filter((x) => setB.has(x))));\n\n// 差集\nconsole.log(new Set([...setA].filter((x) => !setB.has(x))));\n```\n\n#### 字典和散列表\n\n###### 字典\n\n在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。\n字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。\n字典也称作映射、符号表或关联数组\n\n```javascript\n// util.js\nexport function defaultToString(item) {\n  if (item === null) {\n    return 'NULL';\n  } else if (item === undefined) {\n    return 'UNDEFINED';\n  } else if (typeof item === 'string' || item instanceof String) {\n    return `${item}`;\n  }\n  return item.toString(); // {1}\n}\n\nclass ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  toString() {\n    return `[#${this.key}: ${this.value}]`;\n  }\n}\n\nimport { defaultToString } from '../util';\nexport default class Dictionary {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn; // {1}\n    this.table = {}; // {2}\n  }\n  // 检测一个键是否存在于字典中\n  hasKey(key) {\n    return this.table[this.toStrFn(key)] != null;\n  }\n  // 在字典和 ValuePair 类中设置键和值\n  set(key, value) {\n    if (key != null && value != null) {\n      const tableKey = this.toStrFn(key); // {1}\n      this.table[tableKey] = new ValuePair(key, value); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 从字典中移除一个值\n  remove(key) {\n    if (this.hasKey(key)) {\n      delete this.table[this.toStrFn(key)];\n      return true;\n    }\n    return false;\n  }\n  // 从字典中检索一个值\n  get(key) {\n    const valuePair = this.table[this.toStrFn(key)]; // {1}\n    return valuePair == null ? undefined : valuePair.value; // {2}\n  }\n  keyValues() {\n    return Object.values(this.table);\n  }\n  keys() {\n    return this.keyValues().map((valuePair) => valuePair.key);\n  }\n  values() {\n    return this.keyValues().map((valuePair) => valuePair.value);\n  }\n  forEach(callbackFn) {\n    const valuePairs = this.keyValues(); // {1}\n    for (let i = 0; i < valuePairs.length; i++) {\n      // {2}\n      const result = callbackFn(valuePairs[i].key, valuePairs[i].value); // {3}\n      if (result === false) {\n        break; // {4}\n      }\n    }\n  }\n  size() {\n    return Object.keys(this.table).length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  clear() {\n    this.table = {};\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    const valuePairs = this.keyValues();\n    let objString = `${valuePairs[0].toString()}`; // {1}\n    for (let i = 1; i < valuePairs.length; i++) {\n      objString = `${objString},${valuePairs[i].toString()}`; // {2}\n    }\n    return objString; // {3}\n  }\n}\n```\n\n###### 散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值\n\n散列函数的作用是给定一个键值，然后返回值在表中的地址\n\n散列表有一些在计算机科学中应用的例子:\n(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用\n(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。\n\n散列函数 ---- lose lose 散列函数\n![lose-lose](lose-lose.png)\n\nHashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我\n们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而\n在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存\n在 hash 位置（或属性）\n\n```javascript\nclass HashTable {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  // 创建散列函数\n  loseloseHashCode(key) {\n    if (typeof key === 'number') {\n      // {1}\n      return key;\n    }\n    const tableKey = this.toStrFn(key); // {2}\n    // 根据组成 key 的每个字符的 ASCII 码值的和得到一个数\n    let hash = 0; // {3}\n    for (let i = 0; i < tableKey.length; i++) {\n      hash += tableKey.charCodeAt(i); // {4}\n    }\n    // 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行{5}）\n    // 这可以规避操作数超过数值变量最大表示范围的风险\n    return hash % 37; // {5}\n  }\n  hashCode(key) {\n    return this.loseloseHashCode(key);\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      // {1}\n      const position = this.hashCode(key); // {2}\n      this.table[position] = new ValuePair(key, value); // {3}\n      return true;\n    }\n    return false;\n  }\n  get(key) {\n    const valuePair = this.table[this.hashCode(key)];\n    return valuePair == null ? undefined : valuePair.value;\n  }\n  remove(key) {\n    const hash = this.hashCode(key); // {1}\n    const valuePair = this.table[hash]; // {2}\n    if (valuePair != null) {\n      delete this.table[hash]; // {3}\n      return true;\n    }\n    return false;\n  }\n}\n\nconst hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\nconsole.log(hash.hashCode('Gandalf') + ' - Gandalf');\nconsole.log(hash.hashCode('John') + ' - John');\nconsole.log(hash.hashCode('Tyrion') + ' - Tyrion');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion\n```\n\n**散列集合**\n散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数\n散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。\n\n**散列表中的冲突**\n有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突\n\n处理冲突有几种方法：分离链接、线性探查和双散列法。\n\n(1)分离链接\n分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。\n它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间\n![sperate-chain](sperate-chain.png)\n\n```javascript\nclass HashTableSeparateChaining {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      //  将验证要加入新元素的位置是否已经被占据\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new LinkedList(); // {2}\n      }\n      this.table[position].push(new ValuePair(key, value)); // {3}\n      return true;\n    }\n    return false;\n  }\n  // 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化\n  // LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key\n  // 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较\n  // 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要\n  // 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。\n  // 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。\n  get(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position]; // {1}\n    if (linkedList != null && !linkedList.isEmpty()) {\n      // {2}\n      let current = linkedList.getHead(); // {3}\n      while (current != null) {\n        // {4}\n        if (current.element.key === key) {\n          // {5}\n          return current.element.value; // {6}\n        }\n        current = current.next; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    const linkedList = this.table[position];\n    if (linkedList != null && !linkedList.isEmpty()) {\n      let current = linkedList.getHead();\n      while (current != null) {\n        if (current.element.key === key) {\n          // {1}\n          linkedList.remove(current.element); // {2}\n          if (linkedList.isEmpty()) {\n            // {3}\n            delete this.table[position]; // {4}\n          }\n          return true; // {5}\n        }\n        current = current.next; // {6}\n      }\n    }\n    return false; // {7}\n  }\n}\n```\n\n(2)线性探查\n它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中\n当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置\n![linear-probing](linear-probing.png)\n\n线性探查技术分为两种。\n\n第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因\n![soft-delete](soft-delete.png)\n[源代码](http://github.com/loiane/javascript-datastructures-algorithms)\n\n第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。\n![move-key](move-key.png)\n\n```javascript\n// move-key\nclass HashTableSeparateChainingMoveKey {\n  constructor(toStrFn = defaultToString) {\n    this.toStrFn = toStrFn;\n    this.table = {};\n  }\n  put(key, value) {\n    if (key != null && value != null) {\n      const position = this.hashCode(key);\n      if (this.table[position] == null) {\n        // {1}\n        this.table[position] = new ValuePair(key, value); // {2}\n      } else {\n        let index = position + 1; // {3}\n        while (this.table[index] != null) {\n          // {4}\n          index++; // {5}\n        }\n        this.table[index] = new ValuePair(key, value); // {6}\n      }\n      return true;\n    }\n    return false;\n  }\n  // 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注\n  // 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需\n  // 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数\n  // 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需\n  // 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一\n  // 个功能\n  get(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      // {1}\n      if (this.table[position].key === key) {\n        // {2}\n        return this.table[position].value; // {3}\n      }\n      let index = position + 1; // {4}\n      while (this.table[index] != null && this.table[index].key !== key) {\n        // {5}\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        // {6}\n        return this.table[position].value; // {7}\n      }\n    }\n    return undefined; // {8}\n  }\n  remove(key) {\n    const position = this.hashCode(key);\n    if (this.table[position] != null) {\n      if (this.table[position].key === key) {\n        delete this.table[position]; // {1}\n        this.verifyRemoveSideEffect(key, position); // {2}\n        return true;\n      }\n      let index = position + 1;\n      while (this.table[index] != null && this.table[index].key !== key) {\n        index++;\n      }\n      if (this.table[index] != null && this.table[index].key === key) {\n        delete this.table[index]; // {3}\n        this.verifyRemoveSideEffect(key, index); // {4}\n        return true;\n      }\n    }\n    return false;\n  }\n  verifyRemoveSideEffect(key, removedPosition) {\n    const hash = this.hashCode(key); // {1}\n    let index = removedPosition + 1; // {2}\n    while (this.table[index] != null) {\n      // {3}\n      const posHash = this.hashCode(this.table[index].key); // {4}\n      if (posHash <= hash || posHash <= removedPosition) {\n        // {5}\n        this.table[removedPosition] = this.table[index]; // {6}\n        delete this.table[index];\n        removedPosition = index;\n      }\n      index++;\n    }\n  }\n}\n```\n\n**更好的散列函数**\n一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。\n\n```javascript\ndjb2HashCode(key) {\n const tableKey = this.toStrFn(key); // {1}\n//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381\n let hash = 5381; // {2}\n for (let i = 0; i < tableKey.length; i++) { // {3}\n//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加\n hash = (hash * 33) + tableKey.charCodeAt(i); // {4}\n }\n//  将使用相加的和与另一个随机质数相除的余数\n return hash % 1013; // {5}\n}\n// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0\n```\n\n**ES2015 Map 类**\n\n```javascript\nconst map = new Map();\nmap.set('Gandalf', 'gandalf@email.com');\nmap.set('John', 'johnsnow@email.com');\nmap.set('Tyrion', 'tyrion@email.com');\nconsole.log(map.has('Gandalf')); // true\nconsole.log(map.size); // 3\nconsole.log(map.keys()); // 输出{\"Gandalf\", \"John\", \"Tyrion\"}\nconsole.log(map.values()); // 输出{\"gandalf@email.com\", \"johnsnow@email.com\",\n\"tyrion@email.com\"}\nconsole.log(map.get('Tyrion')); // tyrion@email.com\nmap.delete('John');\n```\n\n**ES2105 WeakMap 类和 WeakSet 类**\nMap 和 Set 与其弱化版本之间仅有的区别是:\n(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法\n(2)WeakSet 和 WeakMap 只能用对象作为键\n\n```javascript\nconst map = new WeakMap();\nconst ob1 = { name: 'Gandalf' }; // {1}\nconst ob2 = { name: 'John' };\nconst ob3 = { name: 'Tyrion' };\nmap.set(ob1, 'gandalf@email.com'); // {2}\nmap.set(ob2, 'johnsnow@email.com');\nmap.set(ob3, 'tyrion@email.com');\nconsole.log(map.has(ob1)); // true {3}\nconsole.log(map.get(ob3)); // tyrion@email.com {4}\nmap.delete(ob2); // {5}\n```\n\n注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象\n","slug":"35-data-structure3","published":1,"updated":"2022-10-08T05:24:51.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx3001gckttebru30l9","content":"<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>集合是由一组无序且唯一（即不能重复）的项组成的</p>\n<h6 id=\"创建集合类\"><a href=\"#创建集合类\" class=\"headerlink\" title=\"创建集合类\"></a>创建集合类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// has(element) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   return Object.prototype.hasOwnProperty.call(this.items, element);</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[element] = element; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[element]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.items).length; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// sizeLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let count = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原</span></span><br><span class=\"line\">  <span class=\"comment\">// 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对</span></span><br><span class=\"line\">  <span class=\"comment\">// 象自身、未用于数据结构的）</span></span><br><span class=\"line\">  <span class=\"comment\">//  if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  count++; // &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return count;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.items);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// valuesLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let values = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if(this.items.hasOwnProperty(key)) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       values.push(key); // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return values;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h6><p>(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">union</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> unionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  otherSet.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> unionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> unionAB = setA.union(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values();</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (otherSet.has(values[i])) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">     intersectionSet.add(values[i]); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> intersectionAB = setA.intersection(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(intersectionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> otherValues = otherSet.values(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> biggerSet = values; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> smallerSet = otherValues; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (otherValues.length - values.length &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">   biggerSet = otherValues;</span><br><span class=\"line\">   smallerSet = values;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> smallerSet.forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (biggerSet.includes(value)) &#123;</span><br><span class=\"line\">     intersectionSet.add(value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">difference</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> differenceSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      differenceSet.add(value); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> differenceSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> differenceAB = setA.difference(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(differenceAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)子集：验证一个给定集合是否是另一集合的子集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">isSubsetOf</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() &gt; otherSet.size()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isSubset = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().every(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      isSubset = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isSubset; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setC = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setC.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setB));</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setC));</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用扩展运算符\"><a href=\"#使用扩展运算符\" class=\"headerlink\" title=\"使用扩展运算符\"></a>使用扩展运算符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA, ...setB]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> setB.has(x))));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> !setB.has(x))));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字典和散列表\"><a href=\"#字典和散列表\" class=\"headerlink\" title=\"字典和散列表\"></a>字典和散列表</h4><h6 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h6><p>在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。<br>字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。<br>字典也称作映射、符号表或关联数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultToString</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NULL&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;UNDEFINED&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item === <span class=\"string\">&#x27;string&#x27;</span> || item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;item&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item.toString(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`[#<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.key&#125;</span>: <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.value&#125;</span>]`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultToString &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检测一个键是否存在于字典中</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hasKey</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)] != <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在字典和 ValuePair 类中设置键和值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[tableKey] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中移除一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.hasKey(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中检索一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keyValues</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.table);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keys</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">forEach</span>(<span class=\"params\">callbackFn</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.table).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;valuePairs[<span class=\"number\">0</span>].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h6><p>散列算法的作用是尽可能快地在数据结构中找到一个值</p>\n<p>散列函数的作用是给定一个键值，然后返回值在表中的地址</p>\n<p>散列表有一些在计算机科学中应用的例子:<br>(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用<br>(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。</p>\n<p>散列函数 —- lose lose 散列函数<br><img src=\"/2022/09/29/35-data-structure3/lose-lose.png\" alt=\"lose-lose\"></p>\n<p>HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我<br>们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而<br>在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存<br>在 hash 位置（或属性）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建散列函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">loseloseHashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> key === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据组成 key 的每个字符的 ASCII 码值的和得到一个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class=\"line\">      hash += tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;）</span></span><br><span class=\"line\">    <span class=\"comment\">// 这可以规避操作数超过数值变量最大表示范围的风险</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash % <span class=\"number\">37</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.loseloseHashCode(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.hashCode(key)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valuePair != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hash = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Gandalf&#x27;</span>) + <span class=\"string\">&#x27; - Gandalf&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;John&#x27;</span>) + <span class=\"string\">&#x27; - John&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Tyrion&#x27;</span>) + <span class=\"string\">&#x27; - Tyrion&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 19 - Gandalf</span></span><br><span class=\"line\"><span class=\"comment\">// 29 - John</span></span><br><span class=\"line\"><span class=\"comment\">// 16 - Tyrion</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>散列集合</strong><br>散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数<br>散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。</p>\n<p><strong>散列表中的冲突</strong><br>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<p>(1)分离链接<br>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间<br><img src=\"/2022/09/29/35-data-structure3/sperate-chain.png\" alt=\"sperate-chain\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChaining</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"comment\">//  将验证要加入新元素的位置是否已经被占据</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> LinkedList(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position].push(<span class=\"keyword\">new</span> ValuePair(key, value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化</span></span><br><span class=\"line\">  <span class=\"comment\">// LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key</span></span><br><span class=\"line\">  <span class=\"comment\">// 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较</span></span><br><span class=\"line\">  <span class=\"comment\">// 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。</span></span><br><span class=\"line\">  <span class=\"comment\">// 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> current.element.value; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">          linkedList.remove(current.element); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (linkedList.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(2)线性探查<br>它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中<br>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置<br><img src=\"/2022/09/29/35-data-structure3/linear-probing.png\" alt=\"linear-probing\"></p>\n<p>线性探查技术分为两种。</p>\n<p>第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因<br><img src=\"/2022/09/29/35-data-structure3/soft-delete.png\" alt=\"soft-delete\"><br><a href=\"http://github.com/loiane/javascript-datastructures-algorithms\">源代码</a></p>\n<p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。<br><img src=\"/2022/09/29/35-data-structure3/move-key.png\" alt=\"move-key\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move-key</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChainingMoveKey</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          index++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[index] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注</span></span><br><span class=\"line\">  <span class=\"comment\">// 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数</span></span><br><span class=\"line\">  <span class=\"comment\">// 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一</span></span><br><span class=\"line\">  <span class=\"comment\">// 个功能</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, position); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">verifyRemoveSideEffect</span>(<span class=\"params\">key, removedPosition</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = removedPosition + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> posHash = <span class=\"built_in\">this</span>.hashCode(<span class=\"built_in\">this</span>.table[index].key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[removedPosition] = <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index];</span><br><span class=\"line\">        removedPosition = index;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更好的散列函数</strong><br>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加</span></span><br><span class=\"line\"> hash = (hash * <span class=\"number\">33</span>) + tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//  将使用相加的和与另一个随机质数相除的余数</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2015 Map 类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(<span class=\"string\">&#x27;Gandalf&#x27;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.size); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.keys()); <span class=\"comment\">// 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.values()); <span class=\"comment\">// 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tyrion@email.com&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">&#x27;Tyrion&#x27;</span>)); <span class=\"comment\">// tyrion@email.com</span></span><br><span class=\"line\">map.delete(<span class=\"string\">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2105 WeakMap 类和 WeakSet 类</strong><br>Map 和 Set 与其弱化版本之间仅有的区别是:<br>(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法<br>(2)WeakSet 和 WeakMap 只能用对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Gandalf&#x27;</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ob2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tyrion&#x27;</span> &#125;;</span><br><span class=\"line\">map.set(ob1, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">map.set(ob2, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(ob3, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(ob1)); <span class=\"comment\">// true &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(ob3)); <span class=\"comment\">// tyrion@email.com &#123;4&#125;</span></span><br><span class=\"line\">map.delete(ob2); <span class=\"comment\">// &#123;5&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>集合是由一组无序且唯一（即不能重复）的项组成的</p>\n<h6 id=\"创建集合类\"><a href=\"#创建集合类\" class=\"headerlink\" title=\"创建集合类\"></a>创建集合类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。</span></span><br><span class=\"line\">  <span class=\"comment\">// has(element) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   return Object.prototype.hasOwnProperty.call(this.items, element);</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.items[element] = element; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">element</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.has(element)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.items[element]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.items = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.items).length; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// sizeLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let count = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原</span></span><br><span class=\"line\">  <span class=\"comment\">// 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对</span></span><br><span class=\"line\">  <span class=\"comment\">// 象自身、未用于数据结构的）</span></span><br><span class=\"line\">  <span class=\"comment\">//  if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  count++; // &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return count;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.items);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// valuesLegacy() &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  let values = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for(let key in this.items) &#123; // &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if(this.items.hasOwnProperty(key)) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       values.push(key); // &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//  return values;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h6><p>(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">union</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> unionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  otherSet.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> unionSet.add(value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> unionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> unionAB = setA.union(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values();</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (otherSet.has(values[i])) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">     intersectionSet.add(values[i]); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> intersectionAB = setA.intersection(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(intersectionAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">intersection</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> values = <span class=\"built_in\">this</span>.values(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> otherValues = otherSet.values(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> biggerSet = values; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> smallerSet = otherValues; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (otherValues.length - values.length &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">   biggerSet = otherValues;</span><br><span class=\"line\">   smallerSet = values;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> smallerSet.forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (biggerSet.includes(value)) &#123;</span><br><span class=\"line\">     intersectionSet.add(value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">difference</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> differenceSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      differenceSet.add(value); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> differenceSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> differenceAB = setA.difference(setB);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(differenceAB.values());</span><br><span class=\"line\"><span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<p>(4)子集：验证一个给定集合是否是另一集合的子集</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">isSubsetOf</span>(<span class=\"params\">otherSet</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() &gt; otherSet.size()) &#123; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isSubset = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.values().every(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(value)) &#123; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      isSubset = <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isSubset; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> setA = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setA.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setA.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setB = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setB.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setB.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> setC = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">setC.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">setC.add(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setB));</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(setA.isSubsetOf(setC));</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用扩展运算符\"><a href=\"#使用扩展运算符\" class=\"headerlink\" title=\"使用扩展运算符\"></a>使用扩展运算符</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA, ...setB]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> setB.has(x))));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...setA].filter(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> !setB.has(x))));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字典和散列表\"><a href=\"#字典和散列表\" class=\"headerlink\" title=\"字典和散列表\"></a>字典和散列表</h4><h6 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h6><p>在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。<br>字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。<br>字典也称作映射、符号表或关联数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// util.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultToString</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NULL&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;UNDEFINED&#x27;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item === <span class=\"string\">&#x27;string&#x27;</span> || item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;item&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item.toString(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValuePair</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`[#<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.key&#125;</span>: <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.value&#125;</span>]`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultToString &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 检测一个键是否存在于字典中</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hasKey</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)] != <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在字典和 ValuePair 类中设置键和值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[tableKey] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中移除一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.hasKey(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 从字典中检索一个值</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.toStrFn(key)]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keyValues</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(<span class=\"built_in\">this</span>.table);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">keys</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">values</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.keyValues().map(<span class=\"function\">(<span class=\"params\">valuePair</span>) =&gt;</span> valuePair.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">forEach</span>(<span class=\"params\">callbackFn</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues(); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>.table).length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePairs = <span class=\"built_in\">this</span>.keyValues();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objString = <span class=\"string\">`<span class=\"subst\">$&#123;valuePairs[<span class=\"number\">0</span>].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class=\"line\">      objString = <span class=\"string\">`<span class=\"subst\">$&#123;objString&#125;</span>,<span class=\"subst\">$&#123;valuePairs[i].toString()&#125;</span>`</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objString; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h6><p>散列算法的作用是尽可能快地在数据结构中找到一个值</p>\n<p>散列函数的作用是给定一个键值，然后返回值在表中的地址</p>\n<p>散列表有一些在计算机科学中应用的例子:<br>(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用<br>(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。</p>\n<p>散列函数 —- lose lose 散列函数<br><img src=\"/2022/09/29/35-data-structure3/lose-lose.png\" alt=\"lose-lose\"></p>\n<p>HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我<br>们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而<br>在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存<br>在 hash 位置（或属性）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建散列函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">loseloseHashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> key === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据组成 key 的每个字符的 ASCII 码值的和得到一个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class=\"line\">      hash += tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;）</span></span><br><span class=\"line\">    <span class=\"comment\">// 这可以规避操作数超过数值变量最大表示范围的风险</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash % <span class=\"number\">37</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">hashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.loseloseHashCode(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[<span class=\"built_in\">this</span>.hashCode(key)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> valuePair == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : valuePair.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> valuePair = <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valuePair != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[hash]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hash = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">hash.put(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Gandalf&#x27;</span>) + <span class=\"string\">&#x27; - Gandalf&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;John&#x27;</span>) + <span class=\"string\">&#x27; - John&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hash.hashCode(<span class=\"string\">&#x27;Tyrion&#x27;</span>) + <span class=\"string\">&#x27; - Tyrion&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 19 - Gandalf</span></span><br><span class=\"line\"><span class=\"comment\">// 29 - John</span></span><br><span class=\"line\"><span class=\"comment\">// 16 - Tyrion</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>散列集合</strong><br>散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数<br>散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。</p>\n<p><strong>散列表中的冲突</strong><br>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突</p>\n<p>处理冲突有几种方法：分离链接、线性探查和双散列法。</p>\n<p>(1)分离链接<br>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。<br>它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间<br><img src=\"/2022/09/29/35-data-structure3/sperate-chain.png\" alt=\"sperate-chain\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChaining</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"comment\">//  将验证要加入新元素的位置是否已经被占据</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> LinkedList(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.table[position].push(<span class=\"keyword\">new</span> ValuePair(key, value)); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化</span></span><br><span class=\"line\">  <span class=\"comment\">// LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key</span></span><br><span class=\"line\">  <span class=\"comment\">// 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较</span></span><br><span class=\"line\">  <span class=\"comment\">// 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。</span></span><br><span class=\"line\">  <span class=\"comment\">// 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> current.element.value; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkedList = <span class=\"built_in\">this</span>.table[position];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedList != <span class=\"literal\">null</span> &amp;&amp; !linkedList.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = linkedList.getHead();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">          linkedList.remove(current.element); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (linkedList.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = current.next; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(2)线性探查<br>它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中<br>当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置<br><img src=\"/2022/09/29/35-data-structure3/linear-probing.png\" alt=\"linear-probing\"></p>\n<p>线性探查技术分为两种。</p>\n<p>第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因<br><img src=\"/2022/09/29/35-data-structure3/soft-delete.png\" alt=\"soft-delete\"><br><a href=\"http://github.com/loiane/javascript-datastructures-algorithms\">源代码</a></p>\n<p>第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。<br><img src=\"/2022/09/29/35-data-structure3/move-key.png\" alt=\"move-key\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move-key</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTableSeparateChainingMoveKey</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">toStrFn = defaultToString</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.toStrFn = toStrFn;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.table = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">put</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">          index++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[index] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注</span></span><br><span class=\"line\">  <span class=\"comment\">// 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数</span></span><br><span class=\"line\">  <span class=\"comment\">// 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需</span></span><br><span class=\"line\">  <span class=\"comment\">// 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一</span></span><br><span class=\"line\">  <span class=\"comment\">// 个功能</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.table[position].value; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">remove</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> position = <span class=\"built_in\">this</span>.hashCode(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[position].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[position]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, position); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key !== key) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span> &amp;&amp; <span class=\"built_in\">this</span>.table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.verifyRemoveSideEffect(key, index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">verifyRemoveSideEffect</span>(<span class=\"params\">key, removedPosition</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> hash = <span class=\"built_in\">this</span>.hashCode(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = removedPosition + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>.table[index] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> posHash = <span class=\"built_in\">this</span>.hashCode(<span class=\"built_in\">this</span>.table[index].key); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.table[removedPosition] = <span class=\"built_in\">this</span>.table[index]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.table[index];</span><br><span class=\"line\">        removedPosition = index;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更好的散列函数</strong><br>一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">djb2HashCode</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> tableKey = <span class=\"built_in\">this</span>.toStrFn(key); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> hash = <span class=\"number\">5381</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tableKey.length; i++) &#123; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加</span></span><br><span class=\"line\"> hash = (hash * <span class=\"number\">33</span>) + tableKey.charCodeAt(i); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//  将使用相加的和与另一个随机质数相除的余数</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> hash % <span class=\"number\">1013</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2015 Map 类</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Gandalf&#x27;</span>, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;John&#x27;</span>, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&#x27;Tyrion&#x27;</span>, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(<span class=\"string\">&#x27;Gandalf&#x27;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.size); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.keys()); <span class=\"comment\">// 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.values()); <span class=\"comment\">// 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&quot;tyrion@email.com&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">&#x27;Tyrion&#x27;</span>)); <span class=\"comment\">// tyrion@email.com</span></span><br><span class=\"line\">map.delete(<span class=\"string\">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES2105 WeakMap 类和 WeakSet 类</strong><br>Map 和 Set 与其弱化版本之间仅有的区别是:<br>(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法<br>(2)WeakSet 和 WeakMap 只能用对象作为键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Gandalf&#x27;</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ob2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ob3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tyrion&#x27;</span> &#125;;</span><br><span class=\"line\">map.set(ob1, <span class=\"string\">&#x27;gandalf@email.com&#x27;</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">map.set(ob2, <span class=\"string\">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class=\"line\">map.set(ob3, <span class=\"string\">&#x27;tyrion@email.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(ob1)); <span class=\"comment\">// true &#123;3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(ob3)); <span class=\"comment\">// tyrion@email.com &#123;4&#125;</span></span><br><span class=\"line\">map.delete(ob2); <span class=\"comment\">// &#123;5&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象</p>\n"},{"title":"浏览器渲染","date":"2022-05-23T06:13:56.000Z","_content":"\n## 渲染流程\n(1)深度遍历解析HTML建立DOM树\n(2)解析CSS建立CSSOM树\n(3)依据DOM树和CSSOM树构造Render树\n(4)计算各元素尺寸、位置\n(5)绘制页面像素信息\n(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上\n(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)\n## GUI渲染线程\n(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等\n(2)重排/重绘\n--1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。\n--2、任何页面布局和几何属性的改变都会触发重排，比如：\n页面渲染初始化；(无法避免)\n添加或删除可见的DOM元素；\n元素位置的改变；\n改变元素尺寸（宽、高、内外边距、边框等）；\n浏览器窗口尺寸的变化（resize事件发生时）；\n填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；\n读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)\n--3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。\n--4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。\n## JS引擎线程\n(1)解析Javascript脚本，单线程执行\n(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞\n## 事件触发线程\n(1)归属于浏览器而不是JS引擎，用来控制事件循环\n(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理\n## 定时触发器线程\n(1)setInterval与setTimeout所在线程\n(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确\n(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行\n## 异步http请求线程\n(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n## 实现hover等鼠标操作\n![hover](hover.png)\n\n## 使用performance分析页面性能\n![performance](performance.png)\n\n## 使用network调试\n![network](network.png)\n- preserve log 保留之前的请求\n","source":"_posts/4-browser-render.md","raw":"---\ntitle: 浏览器渲染\ndate: 2022-05-23 14:13:56\ntags:\n---\n\n## 渲染流程\n(1)深度遍历解析HTML建立DOM树\n(2)解析CSS建立CSSOM树\n(3)依据DOM树和CSSOM树构造Render树\n(4)计算各元素尺寸、位置\n(5)绘制页面像素信息\n(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上\n(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)\n## GUI渲染线程\n(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等\n(2)重排/重绘\n--1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。\n--2、任何页面布局和几何属性的改变都会触发重排，比如：\n页面渲染初始化；(无法避免)\n添加或删除可见的DOM元素；\n元素位置的改变；\n改变元素尺寸（宽、高、内外边距、边框等）；\n浏览器窗口尺寸的变化（resize事件发生时）；\n填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；\n读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)\n--3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。\n--4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。\n## JS引擎线程\n(1)解析Javascript脚本，单线程执行\n(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞\n## 事件触发线程\n(1)归属于浏览器而不是JS引擎，用来控制事件循环\n(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理\n## 定时触发器线程\n(1)setInterval与setTimeout所在线程\n(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确\n(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行\n## 异步http请求线程\n(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n## 实现hover等鼠标操作\n![hover](hover.png)\n\n## 使用performance分析页面性能\n![performance](performance.png)\n\n## 使用network调试\n![network](network.png)\n- preserve log 保留之前的请求\n","slug":"4-browser-render","published":1,"updated":"2022-10-25T03:20:16.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx3001hcktt12699h3i","content":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p>(1)深度遍历解析HTML建立DOM树<br>(2)解析CSS建立CSSOM树<br>(3)依据DOM树和CSSOM树构造Render树<br>(4)计算各元素尺寸、位置<br>(5)绘制页面像素信息<br>(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)</p>\n<h2 id=\"GUI渲染线程\"><a href=\"#GUI渲染线程\" class=\"headerlink\" title=\"GUI渲染线程\"></a>GUI渲染线程</h2><p>(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等<br>(2)重排/重绘<br>–1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。<br>–2、任何页面布局和几何属性的改变都会触发重排，比如：<br>页面渲染初始化；(无法避免)<br>添加或删除可见的DOM元素；<br>元素位置的改变；<br>改变元素尺寸（宽、高、内外边距、边框等）；<br>浏览器窗口尺寸的变化（resize事件发生时）；<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)<br>–3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。<br>–4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。</p>\n<h2 id=\"JS引擎线程\"><a href=\"#JS引擎线程\" class=\"headerlink\" title=\"JS引擎线程\"></a>JS引擎线程</h2><p>(1)解析Javascript脚本，单线程执行<br>(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞</p>\n<h2 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h2><p>(1)归属于浏览器而不是JS引擎，用来控制事件循环<br>(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理</p>\n<h2 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h2><p>(1)setInterval与setTimeout所在线程<br>(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确<br>(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行</p>\n<h2 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步http请求线程</h2><p>(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n<h2 id=\"实现hover等鼠标操作\"><a href=\"#实现hover等鼠标操作\" class=\"headerlink\" title=\"实现hover等鼠标操作\"></a>实现hover等鼠标操作</h2><p><img src=\"/2022/05/23/4-browser-render/hover.png\" alt=\"hover\"></p>\n<h2 id=\"使用performance分析页面性能\"><a href=\"#使用performance分析页面性能\" class=\"headerlink\" title=\"使用performance分析页面性能\"></a>使用performance分析页面性能</h2><p><img src=\"/2022/05/23/4-browser-render/performance.png\" alt=\"performance\"></p>\n<h2 id=\"使用network调试\"><a href=\"#使用network调试\" class=\"headerlink\" title=\"使用network调试\"></a>使用network调试</h2><p><img src=\"/2022/05/23/4-browser-render/network.png\" alt=\"network\"></p>\n<ul>\n<li>preserve log 保留之前的请求</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p>(1)深度遍历解析HTML建立DOM树<br>(2)解析CSS建立CSSOM树<br>(3)依据DOM树和CSSOM树构造Render树<br>(4)计算各元素尺寸、位置<br>(5)绘制页面像素信息<br>(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)</p>\n<h2 id=\"GUI渲染线程\"><a href=\"#GUI渲染线程\" class=\"headerlink\" title=\"GUI渲染线程\"></a>GUI渲染线程</h2><p>(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等<br>(2)重排/重绘<br>–1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。<br>–2、任何页面布局和几何属性的改变都会触发重排，比如：<br>页面渲染初始化；(无法避免)<br>添加或删除可见的DOM元素；<br>元素位置的改变；<br>改变元素尺寸（宽、高、内外边距、边框等）；<br>浏览器窗口尺寸的变化（resize事件发生时）；<br>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)<br>–3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。<br>–4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。</p>\n<h2 id=\"JS引擎线程\"><a href=\"#JS引擎线程\" class=\"headerlink\" title=\"JS引擎线程\"></a>JS引擎线程</h2><p>(1)解析Javascript脚本，单线程执行<br>(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞</p>\n<h2 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h2><p>(1)归属于浏览器而不是JS引擎，用来控制事件循环<br>(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理</p>\n<h2 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h2><p>(1)setInterval与setTimeout所在线程<br>(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确<br>(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行</p>\n<h2 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步http请求线程</h2><p>(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n<h2 id=\"实现hover等鼠标操作\"><a href=\"#实现hover等鼠标操作\" class=\"headerlink\" title=\"实现hover等鼠标操作\"></a>实现hover等鼠标操作</h2><p><img src=\"/2022/05/23/4-browser-render/hover.png\" alt=\"hover\"></p>\n<h2 id=\"使用performance分析页面性能\"><a href=\"#使用performance分析页面性能\" class=\"headerlink\" title=\"使用performance分析页面性能\"></a>使用performance分析页面性能</h2><p><img src=\"/2022/05/23/4-browser-render/performance.png\" alt=\"performance\"></p>\n<h2 id=\"使用network调试\"><a href=\"#使用network调试\" class=\"headerlink\" title=\"使用network调试\"></a>使用network调试</h2><p><img src=\"/2022/05/23/4-browser-render/network.png\" alt=\"network\"></p>\n<ul>\n<li>preserve log 保留之前的请求</li>\n</ul>\n"},{"title":"数据结构与算法阅读笔记(6)","date":"2022-10-13T06:15:28.000Z","_content":"\n#### 排序和搜索算法\n\n###### 排序算法\n\n**冒泡排序**\n冒泡排序(_复杂度是 O(n2)_)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。\n\n```javascript\nfunction defaultCompare(a, b) {\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  for (let i = 0; i < length; i++) {\n    // {2}\n    for (let j = 0; j < length - 1; j++) {\n      // {3}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        // {4}\n        swap(array, j, j + 1); // {5}\n      }\n    }\n  }\n  return array;\n}\n\nfunction swap(array, a, b) {\n  /* const temp = array[a]; \n array[a] = array[b]; \n array[b] = temp; */ // 经典方式\n  [array[a], array[b]] = [array[b], array[a]]; // ES2015 的方式\n}\n```\n\n![sort-1](sort-1.png)\n_改进后的冒泡排序_\n\n```javascript\nfunction modifiedBubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1 - i; j++) {\n      // {1}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n```\n\n![sort-2](sort-2.png)\n\n**选择排序**\n选择排序算法(_复杂度为 O(n2)_)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.\n\n```javascript\nfunction selectionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let indexMin;\n  for (let i = 0; i < length - 1; i++) {\n    // {2}\n    indexMin = i; // {3}\n    for (let j = i; j < length; j++) {\n      // {4}\n      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {\n        // {5}\n        indexMin = j; // {6}\n      }\n    }\n    if (i !== indexMin) {\n      // {7}\n      swap(array, i, indexMin);\n    }\n  }\n  return array;\n}\n```\n\n![sort-3](sort-3.png)\n\n**插入排序**\n插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.\n\n```javascript\nfunction insertionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let temp;\n  for (let i = 1; i < length; i++) {\n    // {2}\n    let j = i; // {3}\n    temp = array[i]; // {4}\n    while (j > 0 && compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) {\n      // {5}\n      array[j] = array[j - 1]; // {6}\n      j--;\n    }\n    array[j] = temp; // {7}\n  }\n  return array;\n}\n```\n\n![sort-4](sort-4.png)\n_排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。_\n\n**归并排序**\n归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。\n\n_JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。_\n\n归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。\n\n由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。\n\n```javascript\nfunction mergeSort(array, compareFn = defaultCompare) {\n  if (array.length > 1) {\n    // {1}\n    const { length } = array;\n    const middle = Math.floor(length / 2); // {2}\n    const left = mergeSort(array.slice(0, middle), compareFn); // {3}\n    const right = mergeSort(array.slice(middle, length), compareFn); // {4}\n    array = merge(left, right, compareFn); // {5}\n  }\n  return array;\n}\n\nfunction merge(left, right, compareFn) {\n  let i = 0; // {6}\n  let j = 0;\n  const result = [];\n  while (i < left.length && j < right.length) {\n    // {7}\n    result.push(\n      compareFn(left[i], right[j]) === Compare.LESS_THAN\n        ? left[i++]\n        : right[j++]\n    ); // {8}\n  }\n  return result.concat(i < left.length ? left.slice(i) : right.slice(j)); // {9}\n}\n```\n\n![sort-5](sort-5.png)\n\n**快速排序**\n快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）\n\n(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。\n(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。\n(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。\n\n```javascript\nfunction quickSort(array, compareFn = defaultCompare) {\n  return quick(array, 0, array.length - 1, compareFn);\n}\n\nfunction quick(array, left, right, compareFn) {\n  let index; // {1}\n  if (array.length > 1) {\n    // {2}\n    index = partition(array, left, right, compareFn); // {3}\n    if (left < index - 1) {\n      // {4}\n      quick(array, left, index - 1, compareFn); // {5}\n    }\n    if (index < right) {\n      // {6}\n      quick(array, index, right, compareFn); // {7}\n    }\n  }\n  return array;\n}\n\nfunction partition(array, left, right, compareFn) {\n  // 选择中间值作为主元\n  const pivot = array[Math.floor((right + left) / 2)]; // {8}\n  let i = left; // {9}\n  let j = right; // {10}\n  while (i <= j) {\n    // {11}\n    while (compareFn(array[i], pivot) === Compare.LESS_THAN) {\n      // {12}\n      i++;\n    }\n    while (compareFn(array[j], pivot) === Compare.BIGGER_THAN) {\n      // {13}\n      j--;\n    }\n    if (i <= j) {\n      // {14}\n      swap(array, i, j); // {15}\n      i++;\n      j--;\n    }\n  }\n  return i; // {16}\n}\n```\n\n划分操作的第一次执行\n![sort-6](sort-6.png)\n对有较小值的子数组执行的划分操作\n![sort-7](sort-7.png)\n针对有较大值的子数组\n![sort-8](sort-8.png)\n![sort-9](sort-9.png)\n![sort-10](sort-10.png)\n\n**计数排序**\n计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组\n\n它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。\n\n```javascript\nfunction countingSort(array) {\n  if (array.length < 2) {\n    // {1}\n    return array;\n  }\n  const maxValue = findMaxValue(array); // {2}\n  const counts = new Array(maxValue + 1); // {3}\n  array.forEach((element) => {\n    if (!counts[element]) {\n      // {4}\n      counts[element] = 0;\n    }\n    counts[element]++; // {5}\n  });\n  let sortedIndex = 0;\n  counts.forEach((count, i) => {\n    while (count > 0) {\n      // {6}\n      array[sortedIndex++] = i; // {7}\n      count--; // {8}\n    }\n  });\n  return array;\n}\n\nfunction findMaxValue(array) {\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}\n```\n\n**桶排序**\n桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。\n\n_默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。_\n\n```javascript\nfunction bucketSort(array, bucketSize = 5) {\n  // {1}\n  if (array.length < 2) {\n    return array;\n  }\n  // 创建桶并将元素分布到不同的桶中\n  const buckets = createBuckets(array, bucketSize); // {2}\n  // 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组\n  return sortBuckets(buckets); // {3}\n}\n\nfunction createBuckets(array, bucketSize) {\n  let minValue = array[0];\n  let maxValue = array[0];\n  for (let i = 1; i < array.length; i++) {\n    // {4}\n    if (array[i] < minValue) {\n      minValue = array[i];\n    } else if (array[i] > maxValue) {\n      maxValue = array[i];\n    }\n  }\n  // 计算每个桶中需要分布的元素个数\n  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // {5}\n  const buckets = [];\n  for (let i = 0; i < bucketCount; i++) {\n    // 初始化每个桶\n    buckets[i] = [];\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {7}\n    const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); // {8}\n    buckets[bucketIndex].push(array[i]);\n  }\n  return buckets;\n}\n\nfunction sortBuckets(buckets) {\n  const sortedArray = []; // {9}\n  for (let i = 0; i < buckets.length; i++) {\n    // {10}\n    if (buckets[i] != null) {\n      insertionSort(buckets[i]); // {11}\n      sortedArray.push(...buckets[i]); // {12}\n    }\n  }\n  return sortedArray;\n}\n```\n\n![sort-11](sort-11.png)\n\n**基数排序**\n基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。\n\n```javascript\nfunction radixSort(array, radixBase = 10) {\n  if (array.length < 2) {\n    return array;\n  }\n  const minValue = findMinValue(array);\n  const maxValue = findMaxValue(array);\n  let significantDigit = 1; // {1}\n  while ((maxValue - minValue) / significantDigit >= 1) {\n    // {2}\n    array = countingSortForRadix(array, radixBase, significantDigit, minValue); // {3}\n    significantDigit *= radixBase; // {4}\n  }\n  return array;\n}\n\nfunction countingSortForRadix(array, radixBase, significantDigit, minValue) {\n  let bucketsIndex;\n  const buckets = [];\n  const aux = [];\n  for (let i = 0; i < radixBase; i++) {\n    // {5}\n    buckets[i] = 0;\n  }\n  for (let i = 0; i < array.length; i++) {\n    // 基于数组中数的有效位（行{7}）进行计数排序\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {7}\n    buckets[bucketsIndex]++; // {8}\n  }\n  for (let i = 1; i < radixBase; i++) {\n    // 计算累积结果来得到正确的计数值\n    buckets[i] += buckets[i - 1];\n  }\n  for (let i = array.length - 1; i >= 0; i--) {\n    // {10}\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {11}\n    aux[--buckets[bucketsIndex]] = array[i]; // {12}\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {13}\n    array[i] = aux[i];\n  }\n  return array;\n}\n```\n\n![sort-12](sort-12.png)\n\n###### 搜索算法\n\n**顺序搜索**\n顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法\n\n```javascript\nconst DOES_NOT_EXIST = -1;\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    // {1}\n    if (equalsFn(value, array[i])) {\n      // {2}\n      return i; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\n```\n\n![search-1](search-1.png)\n\n**二分搜索**\n个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。\n(1) 选择数组的中间值。\n(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array); // {1}\n  let low = 0; // {2}\n  let high = sortedArray.length - 1; // {3}\n  while (lesserOrEquals(low, high, compareFn)) {\n    // {4}\n    const mid = Math.floor((low + high) / 2); // {5}\n    const element = sortedArray[mid]; // {6}\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {7}\n      low = mid + 1; // {8}\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {9}\n      high = mid - 1; // {10}\n    } else {\n      return mid; // {11}\n    }\n  }\n  return DOES_NOT_EXIST; // {12}\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-2](search-2.png)\n\n**内插搜索**\n内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。\n\n算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤\n\n(1) 使用 position 公式选中一个值；\n(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction interpolationSearch(\n  array,\n  value,\n  compareFn = defaultCompare,\n  equalsFn = defaultEquals,\n  diffFn = defaultDiff\n) {\n  const { length } = array;\n  let low = 0;\n  let high = length - 1;\n  let position = -1;\n  let delta = -1;\n  while (\n    low <= high &&\n    biggerOrEquals(value, array[low], compareFn) &&\n    lesserOrEquals(value, array[high], compareFn)\n  ) {\n    /** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */\n    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);\n    position = low + Math.floor((high - low) * delta); // {2}\n    if (equalsFn(array[position], value)) {\n      // {3}\n      return position;\n    }\n    if (compareFn(array[position], value) === Compare.LESS_THAN) {\n      // {4}\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n  }\n  return DOES_NOT_EXIST;\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\nfunction biggerOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-3](search-3.png)\n\n###### 随机算法\n\n**Fisher-Yates 随机**\n它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）\n\n```javascript\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n    swap(array, i, randomIndex);\n  }\n  return array;\n}\n```\n\n![search-4](search-4.png)\n","source":"_posts/38-data-structure6.md","raw":"---\ntitle: 数据结构与算法阅读笔记(6)\ndate: 2022-10-13 14:15:28\ntags:\n---\n\n#### 排序和搜索算法\n\n###### 排序算法\n\n**冒泡排序**\n冒泡排序(_复杂度是 O(n2)_)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。\n\n```javascript\nfunction defaultCompare(a, b) {\n  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;\n}\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  for (let i = 0; i < length; i++) {\n    // {2}\n    for (let j = 0; j < length - 1; j++) {\n      // {3}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        // {4}\n        swap(array, j, j + 1); // {5}\n      }\n    }\n  }\n  return array;\n}\n\nfunction swap(array, a, b) {\n  /* const temp = array[a]; \n array[a] = array[b]; \n array[b] = temp; */ // 经典方式\n  [array[a], array[b]] = [array[b], array[a]]; // ES2015 的方式\n}\n```\n\n![sort-1](sort-1.png)\n_改进后的冒泡排序_\n\n```javascript\nfunction modifiedBubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1 - i; j++) {\n      // {1}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n```\n\n![sort-2](sort-2.png)\n\n**选择排序**\n选择排序算法(_复杂度为 O(n2)_)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.\n\n```javascript\nfunction selectionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let indexMin;\n  for (let i = 0; i < length - 1; i++) {\n    // {2}\n    indexMin = i; // {3}\n    for (let j = i; j < length; j++) {\n      // {4}\n      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {\n        // {5}\n        indexMin = j; // {6}\n      }\n    }\n    if (i !== indexMin) {\n      // {7}\n      swap(array, i, indexMin);\n    }\n  }\n  return array;\n}\n```\n\n![sort-3](sort-3.png)\n\n**插入排序**\n插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.\n\n```javascript\nfunction insertionSort(array, compareFn = defaultCompare) {\n  const { length } = array; // {1}\n  let temp;\n  for (let i = 1; i < length; i++) {\n    // {2}\n    let j = i; // {3}\n    temp = array[i]; // {4}\n    while (j > 0 && compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) {\n      // {5}\n      array[j] = array[j - 1]; // {6}\n      j--;\n    }\n    array[j] = temp; // {7}\n  }\n  return array;\n}\n```\n\n![sort-4](sort-4.png)\n_排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。_\n\n**归并排序**\n归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。\n\n_JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。_\n\n归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。\n\n由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。\n\n```javascript\nfunction mergeSort(array, compareFn = defaultCompare) {\n  if (array.length > 1) {\n    // {1}\n    const { length } = array;\n    const middle = Math.floor(length / 2); // {2}\n    const left = mergeSort(array.slice(0, middle), compareFn); // {3}\n    const right = mergeSort(array.slice(middle, length), compareFn); // {4}\n    array = merge(left, right, compareFn); // {5}\n  }\n  return array;\n}\n\nfunction merge(left, right, compareFn) {\n  let i = 0; // {6}\n  let j = 0;\n  const result = [];\n  while (i < left.length && j < right.length) {\n    // {7}\n    result.push(\n      compareFn(left[i], right[j]) === Compare.LESS_THAN\n        ? left[i++]\n        : right[j++]\n    ); // {8}\n  }\n  return result.concat(i < left.length ? left.slice(i) : right.slice(j)); // {9}\n}\n```\n\n![sort-5](sort-5.png)\n\n**快速排序**\n快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）\n\n(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。\n(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。\n(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。\n\n```javascript\nfunction quickSort(array, compareFn = defaultCompare) {\n  return quick(array, 0, array.length - 1, compareFn);\n}\n\nfunction quick(array, left, right, compareFn) {\n  let index; // {1}\n  if (array.length > 1) {\n    // {2}\n    index = partition(array, left, right, compareFn); // {3}\n    if (left < index - 1) {\n      // {4}\n      quick(array, left, index - 1, compareFn); // {5}\n    }\n    if (index < right) {\n      // {6}\n      quick(array, index, right, compareFn); // {7}\n    }\n  }\n  return array;\n}\n\nfunction partition(array, left, right, compareFn) {\n  // 选择中间值作为主元\n  const pivot = array[Math.floor((right + left) / 2)]; // {8}\n  let i = left; // {9}\n  let j = right; // {10}\n  while (i <= j) {\n    // {11}\n    while (compareFn(array[i], pivot) === Compare.LESS_THAN) {\n      // {12}\n      i++;\n    }\n    while (compareFn(array[j], pivot) === Compare.BIGGER_THAN) {\n      // {13}\n      j--;\n    }\n    if (i <= j) {\n      // {14}\n      swap(array, i, j); // {15}\n      i++;\n      j--;\n    }\n  }\n  return i; // {16}\n}\n```\n\n划分操作的第一次执行\n![sort-6](sort-6.png)\n对有较小值的子数组执行的划分操作\n![sort-7](sort-7.png)\n针对有较大值的子数组\n![sort-8](sort-8.png)\n![sort-9](sort-9.png)\n![sort-10](sort-10.png)\n\n**计数排序**\n计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组\n\n它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。\n\n```javascript\nfunction countingSort(array) {\n  if (array.length < 2) {\n    // {1}\n    return array;\n  }\n  const maxValue = findMaxValue(array); // {2}\n  const counts = new Array(maxValue + 1); // {3}\n  array.forEach((element) => {\n    if (!counts[element]) {\n      // {4}\n      counts[element] = 0;\n    }\n    counts[element]++; // {5}\n  });\n  let sortedIndex = 0;\n  counts.forEach((count, i) => {\n    while (count > 0) {\n      // {6}\n      array[sortedIndex++] = i; // {7}\n      count--; // {8}\n    }\n  });\n  return array;\n}\n\nfunction findMaxValue(array) {\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}\n```\n\n**桶排序**\n桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。\n\n_默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。_\n\n```javascript\nfunction bucketSort(array, bucketSize = 5) {\n  // {1}\n  if (array.length < 2) {\n    return array;\n  }\n  // 创建桶并将元素分布到不同的桶中\n  const buckets = createBuckets(array, bucketSize); // {2}\n  // 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组\n  return sortBuckets(buckets); // {3}\n}\n\nfunction createBuckets(array, bucketSize) {\n  let minValue = array[0];\n  let maxValue = array[0];\n  for (let i = 1; i < array.length; i++) {\n    // {4}\n    if (array[i] < minValue) {\n      minValue = array[i];\n    } else if (array[i] > maxValue) {\n      maxValue = array[i];\n    }\n  }\n  // 计算每个桶中需要分布的元素个数\n  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // {5}\n  const buckets = [];\n  for (let i = 0; i < bucketCount; i++) {\n    // 初始化每个桶\n    buckets[i] = [];\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {7}\n    const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); // {8}\n    buckets[bucketIndex].push(array[i]);\n  }\n  return buckets;\n}\n\nfunction sortBuckets(buckets) {\n  const sortedArray = []; // {9}\n  for (let i = 0; i < buckets.length; i++) {\n    // {10}\n    if (buckets[i] != null) {\n      insertionSort(buckets[i]); // {11}\n      sortedArray.push(...buckets[i]); // {12}\n    }\n  }\n  return sortedArray;\n}\n```\n\n![sort-11](sort-11.png)\n\n**基数排序**\n基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。\n\n```javascript\nfunction radixSort(array, radixBase = 10) {\n  if (array.length < 2) {\n    return array;\n  }\n  const minValue = findMinValue(array);\n  const maxValue = findMaxValue(array);\n  let significantDigit = 1; // {1}\n  while ((maxValue - minValue) / significantDigit >= 1) {\n    // {2}\n    array = countingSortForRadix(array, radixBase, significantDigit, minValue); // {3}\n    significantDigit *= radixBase; // {4}\n  }\n  return array;\n}\n\nfunction countingSortForRadix(array, radixBase, significantDigit, minValue) {\n  let bucketsIndex;\n  const buckets = [];\n  const aux = [];\n  for (let i = 0; i < radixBase; i++) {\n    // {5}\n    buckets[i] = 0;\n  }\n  for (let i = 0; i < array.length; i++) {\n    // 基于数组中数的有效位（行{7}）进行计数排序\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {7}\n    buckets[bucketsIndex]++; // {8}\n  }\n  for (let i = 1; i < radixBase; i++) {\n    // 计算累积结果来得到正确的计数值\n    buckets[i] += buckets[i - 1];\n  }\n  for (let i = array.length - 1; i >= 0; i--) {\n    // {10}\n    bucketsIndex = Math.floor(\n      ((array[i] - minValue) / significantDigit) % radixBase\n    ); // {11}\n    aux[--buckets[bucketsIndex]] = array[i]; // {12}\n  }\n  for (let i = 0; i < array.length; i++) {\n    // {13}\n    array[i] = aux[i];\n  }\n  return array;\n}\n```\n\n![sort-12](sort-12.png)\n\n###### 搜索算法\n\n**顺序搜索**\n顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法\n\n```javascript\nconst DOES_NOT_EXIST = -1;\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    // {1}\n    if (equalsFn(value, array[i])) {\n      // {2}\n      return i; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\n```\n\n![search-1](search-1.png)\n\n**二分搜索**\n个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。\n(1) 选择数组的中间值。\n(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array); // {1}\n  let low = 0; // {2}\n  let high = sortedArray.length - 1; // {3}\n  while (lesserOrEquals(low, high, compareFn)) {\n    // {4}\n    const mid = Math.floor((low + high) / 2); // {5}\n    const element = sortedArray[mid]; // {6}\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {7}\n      low = mid + 1; // {8}\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {9}\n      high = mid - 1; // {10}\n    } else {\n      return mid; // {11}\n    }\n  }\n  return DOES_NOT_EXIST; // {12}\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-2](search-2.png)\n\n**内插搜索**\n内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。\n\n算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤\n\n(1) 使用 position 公式选中一个值；\n(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；\n(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；\n(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。\n\n```javascript\nfunction interpolationSearch(\n  array,\n  value,\n  compareFn = defaultCompare,\n  equalsFn = defaultEquals,\n  diffFn = defaultDiff\n) {\n  const { length } = array;\n  let low = 0;\n  let high = length - 1;\n  let position = -1;\n  let delta = -1;\n  while (\n    low <= high &&\n    biggerOrEquals(value, array[low], compareFn) &&\n    lesserOrEquals(value, array[high], compareFn)\n  ) {\n    /** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */\n    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);\n    position = low + Math.floor((high - low) * delta); // {2}\n    if (equalsFn(array[position], value)) {\n      // {3}\n      return position;\n    }\n    if (compareFn(array[position], value) === Compare.LESS_THAN) {\n      // {4}\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n  }\n  return DOES_NOT_EXIST;\n}\n\nfunction lesserOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.LESS_THAN || comp === Compare.EQUALS;\n}\nfunction biggerOrEquals(a, b, compareFn) {\n  const comp = compareFn(a, b);\n  return comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;\n}\n```\n\n![search-3](search-3.png)\n\n###### 随机算法\n\n**Fisher-Yates 随机**\n它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）\n\n```javascript\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n    swap(array, i, randomIndex);\n  }\n  return array;\n}\n```\n\n![search-4](search-4.png)\n","slug":"38-data-structure6","published":1,"updated":"2022-10-13T08:12:54.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx4001icktt1le40upq","content":"<h4 id=\"排序和搜索算法\"><a href=\"#排序和搜索算法\" class=\"headerlink\" title=\"排序和搜索算法\"></a>排序和搜索算法</h4><h6 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h6><p><strong>冒泡排序</strong><br>冒泡排序(<em>复杂度是 O(n2)</em>)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* const temp = array[a]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[a] = array[b]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[b] = temp; */</span> <span class=\"comment\">// 经典方式</span></span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]]; <span class=\"comment\">// ES2015 的方式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-1.png\" alt=\"sort-1\"><br><em>改进后的冒泡排序</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">modifiedBubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-2.png\" alt=\"sort-2\"></p>\n<p><strong>选择排序</strong><br>选择排序算法(<em>复杂度为 O(n2)</em>)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> indexMin;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    indexMin = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        indexMin = j; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== indexMin) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(array, i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-3.png\" alt=\"sort-3\"></p>\n<p><strong>插入排序</strong><br>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    temp = array[i]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; compareFn(array[j - <span class=\"number\">1</span>], temp) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[j] = array[j - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[j] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-4.png\" alt=\"sort-4\"><br><em>排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。</em></p>\n<p><strong>归并排序</strong><br>归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。</p>\n<p><em>JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。</em></p>\n<p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>\n<p>由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> middle = <span class=\"built_in\">Math</span>.floor(length / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = mergeSort(array.slice(<span class=\"number\">0</span>, middle), compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = mergeSort(array.slice(middle, length), compareFn); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    array = merge(left, right, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    result.push(</span><br><span class=\"line\">      compareFn(left[i], right[j]) === Compare.LESS_THAN</span><br><span class=\"line\">        ? left[i++]</span><br><span class=\"line\">        : right[j++]</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(i &lt; left.length ? left.slice(i) : right.slice(j)); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-5.png\" alt=\"sort-5\"></p>\n<p><strong>快速排序</strong><br>快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）</p>\n<p>(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。<br>(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。<br>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quick</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    index = partition(array, left, right, compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; index - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      quick(array, left, index - <span class=\"number\">1</span>, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      quick(array, index, right, compareFn); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 选择中间值作为主元</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> pivot = array[<span class=\"built_in\">Math</span>.floor((right + left) / <span class=\"number\">2</span>)]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = right; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      swap(array, i, j); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>划分操作的第一次执行<br><img src=\"/2022/10/13/38-data-structure6/sort-6.png\" alt=\"sort-6\"><br>对有较小值的子数组执行的划分操作<br><img src=\"/2022/10/13/38-data-structure6/sort-7.png\" alt=\"sort-7\"><br>针对有较大值的子数组<br><img src=\"/2022/10/13/38-data-structure6/sort-8.png\" alt=\"sort-8\"><br><img src=\"/2022/10/13/38-data-structure6/sort-9.png\" alt=\"sort-9\"><br><img src=\"/2022/10/13/38-data-structure6/sort-10.png\" alt=\"sort-10\"></p>\n<p><strong>计数排序</strong><br>计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组</p>\n<p>它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counts = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxValue + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  array.forEach(<span class=\"function\">(<span class=\"params\">element</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!counts[element]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      counts[element] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    counts[element]++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  counts.forEach(<span class=\"function\">(<span class=\"params\">count, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[sortedIndex++] = i; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      count--; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxValue</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &gt; max) &#123;</span><br><span class=\"line\">      max = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>桶排序</strong><br>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。</p>\n<p><em>默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, bucketSize = <span class=\"number\">5</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建桶并将元素分布到不同的桶中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = createBuckets(array, bucketSize); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortBuckets(buckets); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createBuckets</span>(<span class=\"params\">array, bucketSize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; minValue) &#123;</span><br><span class=\"line\">      minValue = array[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[i] &gt; maxValue) &#123;</span><br><span class=\"line\">      maxValue = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 计算每个桶中需要分布的元素个数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> bucketCount = <span class=\"built_in\">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化每个桶</span></span><br><span class=\"line\">    buckets[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> bucketIndex = <span class=\"built_in\">Math</span>.floor((array[i] - minValue) / bucketSize); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    buckets[bucketIndex].push(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buckets;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortBuckets</span>(<span class=\"params\">buckets</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = []; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buckets[i] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      insertionSort(buckets[i]); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      sortedArray.push(...buckets[i]); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-11.png\" alt=\"sort-11\"></p>\n<p><strong>基数排序</strong><br>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">array, radixBase = <span class=\"number\">10</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> minValue = findMinValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> significantDigit = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((maxValue - minValue) / significantDigit &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    array = countingSortForRadix(array, radixBase, significantDigit, minValue); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    significantDigit *= radixBase; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSortForRadix</span>(<span class=\"params\">array, radixBase, significantDigit, minValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bucketsIndex;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> aux = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    buckets[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于数组中数的有效位（行&#123;7&#125;）进行计数排序</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    buckets[bucketsIndex]++; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算累积结果来得到正确的计数值</span></span><br><span class=\"line\">    buckets[i] += buckets[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    aux[--buckets[bucketsIndex]] = array[i]; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    array[i] = aux[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-12.png\" alt=\"sort-12\"></p>\n<h6 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h6><p><strong>顺序搜索</strong><br>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DOES_NOT_EXIST = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-1.png\" alt=\"search-1\"></p>\n<p><strong>二分搜索</strong><br>个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。<br>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = sortedArray.length - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lesserOrEquals(low, high, compareFn)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = sortedArray[mid]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      low = mid + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      high = mid - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-2.png\" alt=\"search-2\"></p>\n<p><strong>内插搜索</strong><br>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。</p>\n<p>算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤</p>\n<p>(1) 使用 position 公式选中一个值；<br>(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interpolationSearch</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  equalsFn = defaultEquals,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  diffFn = defaultDiff</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> position = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> delta = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    low &lt;= high &amp;&amp;</span><br><span class=\"line\">    biggerOrEquals(value, array[low], compareFn) &amp;&amp;</span><br><span class=\"line\">    lesserOrEquals(value, array[high], compareFn)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */</span></span><br><span class=\"line\">    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);</span><br><span class=\"line\">    position = low + <span class=\"built_in\">Math</span>.floor((high - low) * delta); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(array[position], value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(array[position], value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      low = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      high = position - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">biggerOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-3.png\" alt=\"search-3\"></p>\n<h6 id=\"随机算法\"><a href=\"#随机算法\" class=\"headerlink\" title=\"随机算法\"></a>随机算法</h6><p><strong>Fisher-Yates 随机</strong><br>它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> randomIndex = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">    swap(array, i, randomIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-4.png\" alt=\"search-4\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"排序和搜索算法\"><a href=\"#排序和搜索算法\" class=\"headerlink\" title=\"排序和搜索算法\"></a>排序和搜索算法</h4><h6 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h6><p><strong>冒泡排序</strong><br>冒泡排序(<em>复杂度是 O(n2)</em>)比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defaultCompare</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* const temp = array[a]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[a] = array[b]; </span></span><br><span class=\"line\"><span class=\"comment\"> array[b] = temp; */</span> <span class=\"comment\">// 经典方式</span></span><br><span class=\"line\">  [array[a], array[b]] = [array[b], array[a]]; <span class=\"comment\">// ES2015 的方式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-1.png\" alt=\"sort-1\"><br><em>改进后的冒泡排序</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">modifiedBubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-2.png\" alt=\"sort-2\"></p>\n<p><strong>选择排序</strong><br>选择排序算法(<em>复杂度为 O(n2)</em>)是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> indexMin;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    indexMin = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">        indexMin = j; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== indexMin) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(array, i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-3.png\" alt=\"sort-3\"></p>\n<p><strong>插入排序</strong><br>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    temp = array[i]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; compareFn(array[j - <span class=\"number\">1</span>], temp) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[j] = array[j - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[j] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-4.png\" alt=\"sort-4\"><br><em>排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。</em></p>\n<p><strong>归并排序</strong><br>归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。</p>\n<p><em>JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。</em></p>\n<p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>\n<p>由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> middle = <span class=\"built_in\">Math</span>.floor(length / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = mergeSort(array.slice(<span class=\"number\">0</span>, middle), compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = mergeSort(array.slice(middle, length), compareFn); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    array = merge(left, right, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    result.push(</span><br><span class=\"line\">      compareFn(left[i], right[j]) === Compare.LESS_THAN</span><br><span class=\"line\">        ? left[i++]</span><br><span class=\"line\">        : right[j++]</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(i &lt; left.length ? left.slice(i) : right.slice(j)); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-5.png\" alt=\"sort-5\"></p>\n<p><strong>快速排序</strong><br>快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）</p>\n<p>(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。<br>(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。<br>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quick</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    index = partition(array, left, right, compareFn); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; index - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      quick(array, left, index - <span class=\"number\">1</span>, compareFn); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; right) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      quick(array, index, right, compareFn); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partition</span>(<span class=\"params\">array, left, right, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 选择中间值作为主元</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> pivot = array[<span class=\"built_in\">Math</span>.floor((right + left) / <span class=\"number\">2</span>)]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = left; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = right; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      swap(array, i, j); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      i++;</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>划分操作的第一次执行<br><img src=\"/2022/10/13/38-data-structure6/sort-6.png\" alt=\"sort-6\"><br>对有较小值的子数组执行的划分操作<br><img src=\"/2022/10/13/38-data-structure6/sort-7.png\" alt=\"sort-7\"><br>针对有较大值的子数组<br><img src=\"/2022/10/13/38-data-structure6/sort-8.png\" alt=\"sort-8\"><br><img src=\"/2022/10/13/38-data-structure6/sort-9.png\" alt=\"sort-9\"><br><img src=\"/2022/10/13/38-data-structure6/sort-10.png\" alt=\"sort-10\"></p>\n<p><strong>计数排序</strong><br>计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组</p>\n<p>它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counts = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxValue + <span class=\"number\">1</span>); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  array.forEach(<span class=\"function\">(<span class=\"params\">element</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!counts[element]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      counts[element] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    counts[element]++; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  counts.forEach(<span class=\"function\">(<span class=\"params\">count, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[sortedIndex++] = i; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      count--; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMaxValue</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &gt; max) &#123;</span><br><span class=\"line\">      max = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>桶排序</strong><br>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。</p>\n<p><em>默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bucketSort</span>(<span class=\"params\">array, bucketSize = <span class=\"number\">5</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建桶并将元素分布到不同的桶中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = createBuckets(array, bucketSize); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortBuckets(buckets); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createBuckets</span>(<span class=\"params\">array, bucketSize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxValue = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; minValue) &#123;</span><br><span class=\"line\">      minValue = array[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[i] &gt; maxValue) &#123;</span><br><span class=\"line\">      maxValue = array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 计算每个桶中需要分布的元素个数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> bucketCount = <span class=\"built_in\">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化每个桶</span></span><br><span class=\"line\">    buckets[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> bucketIndex = <span class=\"built_in\">Math</span>.floor((array[i] - minValue) / bucketSize); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    buckets[bucketIndex].push(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buckets;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortBuckets</span>(<span class=\"params\">buckets</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = []; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buckets[i] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      insertionSort(buckets[i]); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">      sortedArray.push(...buckets[i]); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-11.png\" alt=\"sort-11\"></p>\n<p><strong>基数排序</strong><br>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">array, radixBase = <span class=\"number\">10</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> minValue = findMinValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> maxValue = findMaxValue(array);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> significantDigit = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((maxValue - minValue) / significantDigit &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    array = countingSortForRadix(array, radixBase, significantDigit, minValue); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    significantDigit *= radixBase; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countingSortForRadix</span>(<span class=\"params\">array, radixBase, significantDigit, minValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bucketsIndex;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> buckets = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> aux = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    buckets[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于数组中数的有效位（行&#123;7&#125;）进行计数排序</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    buckets[bucketsIndex]++; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; radixBase; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算累积结果来得到正确的计数值</span></span><br><span class=\"line\">    buckets[i] += buckets[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    bucketsIndex = <span class=\"built_in\">Math</span>.floor(</span><br><span class=\"line\">      ((array[i] - minValue) / significantDigit) % radixBase</span><br><span class=\"line\">    ); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    aux[--buckets[bucketsIndex]] = array[i]; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    array[i] = aux[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/sort-12.png\" alt=\"sort-12\"></p>\n<h6 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h6><p><strong>顺序搜索</strong><br>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DOES_NOT_EXIST = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-1.png\" alt=\"search-1\"></p>\n<p><strong>二分搜索</strong><br>个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。<br>(1) 选择数组的中间值。<br>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = sortedArray.length - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lesserOrEquals(low, high, compareFn)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = sortedArray[mid]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      low = mid + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      high = mid - <span class=\"number\">1</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-2.png\" alt=\"search-2\"></p>\n<p><strong>内插搜索</strong><br>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。</p>\n<p>算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤</p>\n<p>(1) 使用 position 公式选中一个值；<br>(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；<br>(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；<br>(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interpolationSearch</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  equalsFn = defaultEquals,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  diffFn = defaultDiff</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> high = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> position = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> delta = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    low &lt;= high &amp;&amp;</span><br><span class=\"line\">    biggerOrEquals(value, array[low], compareFn) &amp;&amp;</span><br><span class=\"line\">    lesserOrEquals(value, array[high], compareFn)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */</span></span><br><span class=\"line\">    delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);</span><br><span class=\"line\">    position = low + <span class=\"built_in\">Math</span>.floor((high - low) * delta); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(array[position], value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(array[position], value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      low = position + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      high = position - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lesserOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.LESS_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">biggerOrEquals</span>(<span class=\"params\">a, b, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> comp = compareFn(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-3.png\" alt=\"search-3\"></p>\n<h6 id=\"随机算法\"><a href=\"#随机算法\" class=\"headerlink\" title=\"随机算法\"></a>随机算法</h6><p><strong>Fisher-Yates 随机</strong><br>它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shuffle</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> randomIndex = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">    swap(array, i, randomIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/38-data-structure6/search-4.png\" alt=\"search-4\"></p>\n"},{"title":"数据结构与算法阅读笔记(5)","date":"2022-10-08T08:33:37.000Z","_content":"\n#### 二叉堆和堆排序\n\n###### 二叉堆数据结构\n\n(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。\n(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性\n![heat](heat.png)\n\n二叉树有两种表示方式\n第一种是使用一个动态的表示方式，也就是指针（用节点表示）\n第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。\n![min-heat](min-heat.png)\n\n访问使用普通数组的二叉树节点:\n它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；\n它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；\n它的父节点位置是 index / 2（如果位置可用）\n\n```javascript\nimport { defaultCompare } from '../util';\n\nexport class MinHeap {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // {1}\n    this.heap = []; // {2}\n  }\n  getLeftIndex(index) {\n    return 2 * index + 1;\n  }\n  getRightIndex(index) {\n    return 2 * index + 2;\n  }\n  getParentIndex(index) {\n    if (index === 0) {\n      return undefined;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n  insert(value) {\n    if (value != null) {\n      this.heap.push(value); // {1}\n      this.siftUp(this.heap.length - 1); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 上移操作\n  siftUp(index) {\n    let parent = this.getParentIndex(index); // {1}\n    while (\n      index > 0 &&\n      this.compareFn(this.heap[parent], this.heap[index]) > Compare.BIGGER_THAN\n    ) {\n      // {2}\n      swap(this.heap, parent, index); // {3}\n      index = parent;\n      parent = this.getParentIndex(index); // {4}\n    }\n    function swap(array, a, b) {\n      const temp = array[a]; // {5}\n      array[a] = array[b]; // {6}\n      array[b] = temp; // {7}\n    }\n  }\n  size() {\n    return this.heap.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  findMinimum() {\n    return this.isEmpty() ? undefined : this.heap[0]; // {1}\n  }\n  extract() {\n    if (this.isEmpty()) {\n      return undefined; // {1}\n    }\n    if (this.size() === 1) {\n      return this.heap.shift(); // {2}\n    }\n    const removedValue = this.heap.shift(); // {3}\n    this.siftDown(0); // {4}\n    return removedValue; // {5}\n  }\n  siftDown(index) {\n    let element = index;\n    const left = this.getLeftIndex(index); // {1}\n    const right = this.getRightIndex(index); // {2}\n    const size = this.size();\n    if (\n      left < size &&\n      this.compareFn(this.heap[element], this.heap[left]) > Compare.BIGGER_THAN\n    ) {\n      // {3}\n      element = left; // {4}\n    }\n    if (\n      right < size &&\n      this.compareFn(this.heap[element], this.heap[right]) > Compare.BIGGER_THAN\n    ) {\n      // {5}\n      element = right; // {6}\n    }\n    if (index !== element) {\n      // {7}\n      swap(this.heap, index, element); // {8}\n      this.siftDown(element); // {9}\n    }\n  }\n}\n```\n\n![min-heat-pic](min-heat-pic.png)\n\n**创建最大堆类**\nMaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有>（大于）的比较换成<（小于）的比较。\n\n```javascript\nfunction reverseCompare(compareFn) {\n  return (a, b) => compareFn(b, a);\n}\n\nexport class MaxHeap extends MinHeap {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = reverseCompare(compareFn); // {1}\n  }\n}\n```\n\n**堆排序算法**\n(1) 用数组创建一个最大堆用作源数据。\n(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。\n(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1\n\n```javascript\nfunction heapSort(array, compareFn = defaultCompare) {\n  let heapSize = array.length;\n  buildMaxHeap(array, compareFn); // 步骤 1\n  while (heapSize > 1) {\n    swap(array, 0, --heapSize); // 步骤 2\n    heapify(array, 0, heapSize, compareFn); // 步骤 3\n  }\n  return array;\n}\nfunction buildMaxHeap(array, compareFn) {\n  for (let i = Math.floor(array.length / 2); i >= 0; i -= 1) {\n    heapify(array, i, array.length, compareFn);\n  }\n  return array;\n}\n```\n\nheapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法\n![heap-sort](heap-sort.png)\n\n**堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。**\n\n#### 图\n\n###### 图的相关术语\n\n图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）\nG = (V, E)\nV: 一组顶点\nE: 一组边，连接 V 中的顶点\n![graph-1](graph-1.png)\n\n由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。\n一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。\n路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。\n简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。\n如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。\n\n**有向图和无向图**\n图可以是无向的（边没有方向）或是有向的（有向图）。\n如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。\n![graph-2](graph-2.png)\n图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。\n![graph-3](graph-3.png)\n\n###### 图的表示\n\n**邻接矩阵**\n每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0\n![graph-4](graph-4.png)\n_缺点：_\n(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。\n(2)顶点的数量可能会改变，而二维数组不太灵活\n\n**邻接表**\n邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。\n可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表\n![graph-5](graph-5.png)\n\n**关联矩阵**\n在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0\n![graph-6](graph-6.png)\n_关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存_\n\n###### 创建 Graph 类\n\n```javascript\nclass Graph {\n  constructor(isDirected = false) {\n    // 表示图是否有向\n    this.isDirected = isDirected; // {1}\n    //  所有顶点的名字\n    this.vertices = []; // {2}\n    //  字典将会使用顶点的名字作为键，邻接顶点列表作为值\n    this.adjList = new Dictionary(); // {3}\n  }\n  //  一个用来向图中添加一个新的顶点\n  addVertex(v) {\n    if (!this.vertices.includes(v)) {\n      // {5}\n      this.vertices.push(v); // {6}\n      this.adjList.set(v, []); // {7}\n    }\n  }\n  // 来添加顶点之间的边\n  addEdge(v, w) {\n    if (!this.adjList.get(v)) {\n      this.addVertex(v); // {8}\n    }\n    if (!this.adjList.get(w)) {\n      this.addVertex(w); // {9}\n    }\n    this.adjList.get(v).push(w); // {10}\n    if (!this.isDirected) {\n      this.adjList.get(w).push(v); // {11}\n    }\n  }\n  // 获取顶点列表\n  getVertices() {\n    return this.vertices;\n  }\n  // 获取邻接表\n  getAdjList() {\n    return this.adjList;\n  }\n  toString() {\n    let s = '';\n    for (let i = 0; i < this.vertices.length; i++) {\n      // {15}\n      s += `${this.vertices[i]} -> `;\n      const neighbors = this.adjList.get(this.vertices[i]); // {16}\n      for (let j = 0; j < neighbors.length; j++) {\n        // {17}\n        s += `${neighbors[j]} `;\n      }\n      s += '\\n'; // {18}\n    }\n    return s;\n  }\n}\n```\n\n###### 图的遍历\n\n*作用：*图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等\n图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。\n完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。\n为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。\n\n**广度优先搜索（breadth-first search，BFS）**\n**深度优先搜索（depth-first search，DFS）**\n*不同点：*待访问顶点列表的数据结构\n| 算 法        | 数据结构 | 描 述                                                          |\n| ------------ | -------- | -------------------------------------------------------------- |\n| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |\n| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |\n\n```javascript\n// 白色：表示该顶点还没有被访问。\n// 灰色：表示该顶点被访问过，但并未被探索过。\n// 黑色：表示该顶点被访问过且被完全探索过\nconst Colors = {\n  WHITE: 0,\n  GREY: 1,\n  BLACK: 2,\n};\n// 初始化每个顶点的颜色\nconst initializeColor = (vertices) => {\n  const color = {};\n  for (let i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = Colors.WHITE;\n  }\n  return color;\n};\n```\n\n**广度优先搜索**\n从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点\n![graph-7](graph-7.png)\n_步骤_\n(1) 创建一个队列 Q。\n(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。\n(3) 如果 Q 非空，则运行以下步骤：\n\n- (a) 将 u 从 Q 中出队列；\n- (b) 标注 u 为被发现的（灰色）；\n- (c) 将 u 所有未被访问过的邻点（白色）入队列；\n- (d) 标注 u 为已被探索的（黑色）\n\n```javascript\nexport const breadthFirstSearch = (graph, startVertex, callback) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices); // {1}\n  const queue = new Queue(); // {2}\n  queue.enqueue(startVertex); // {3}\n  while (!queue.isEmpty()) {\n    // {4}\n    const u = queue.dequeue(); // {5}\n    const neighbors = adjList.get(u); // {6}\n    // 发现了节点，但尚未完成探索\n    color[u] = Colors.GREY; // {7}\n    for (let i = 0; i < neighbors.length; i++) {\n      // {8}\n      const w = neighbors[i]; // {9}\n      if (color[w] === Colors.WHITE) {\n        // {10}\n        color[w] = Colors.GREY; // {11}\n        queue.enqueue(w); // {12}\n      }\n    }\n    color[u] = Colors.BLACK; // {13}\n    // 可选回调函数\n    if (callback) {\n      // {14}\n      callback(u);\n    }\n  }\n};\n\nconst printVertex = (value) => console.log('Visited vertex: ' + value); // {15}\nbreadthFirstSearch(graph, myVertices[0], printVertex);\n```\n\n_使用 BFS 寻找最短路径_\n给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）\n\n```javascript\nconst BFS = (graph, startVertex) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  // 创建一个队列\n  const queue = new Queue();\n  const distances = {}; // {1}\n  const predecessors = {}; // {2}\n  queue.enqueue(startVertex);\n  for (let i = 0; i < vertices.length; i++) {\n    // {3}\n    distances[vertices[i]] = 0; // {4}\n    predecessors[vertices[i]] = null; // {5}\n  }\n  while (!queue.isEmpty()) {\n    const u = queue.dequeue();\n    const neighbors = adjList.get(u);\n    color[u] = Colors.GREY;\n    for (let i = 0; i < neighbors.length; i++) {\n      const w = neighbors[i];\n      if (color[w] === Colors.WHITE) {\n        color[w] = Colors.GREY;\n        distances[w] = distances[u] + 1; // {6}\n        predecessors[w] = u; // {7}\n        queue.enqueue(w);\n      }\n    }\n    color[u] = Colors.BLACK;\n  }\n  return {\n    // {8}\n    distances, // 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]\n    predecessors, // 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径\n  };\n};\n\nconst shortestPathA = BFS(graph, myVertices[0]);\nconsole.log(shortestPathA);\n// distances: {A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3},\n// predecessors: {A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"}\n\nconst fromVertex = myVertices[0]; // {9}\n\nfor (i = 1; i < myVertices.length; i++) {\n  // {10}\n  const toVertex = myVertices[i]; // {11}\n  // 创建一个栈\n  const path = new Stack(); // {12}\n  // 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点\n  for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) {\n    // {13}\n    path.push(v); // {14}\n  }\n  path.push(fromVertex); // {15}\n  let s = path.pop(); // {16}\n  while (!path.isEmpty()) {\n    // {17}\n    s += ' - ' + path.pop(); // {18}\n  }\n  console.log(s); // {19}\n}\n// A - B\n// A - C\n// A - D\n// A - B - E\n// A - B - F\n// A - C - G\n// A - D - H\n// A - B - E - I\n```\n\n_深入学习最短路径算法_\nDijkstra 算法解决了单源最短路径问题。\nBellman-Ford 算法解决了边权值为负的单源最短路径问题。\nA\\*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。\nFloyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题\n\n**深度优先搜索**\n深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点\n![graph-8](graph-8.png)\n\n深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。\n_步骤_\n(1) 标注 v 为被发现的（灰色）；\n(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；\n(3) 标注 v 为已被探索的（黑色）。\n\n深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）\n\n```javascript\nconst depthFirstSearch = (graph, callback) => {\n  // {1}\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    if (color[vertices[i]] === Colors.WHITE) {\n      // {3}\n      depthFirstSearchVisit(vertices[i], color, adjList, callback); // {4}\n    }\n  }\n};\nconst depthFirstSearchVisit = (u, color, adjList, callback) => {\n  color[u] = Colors.GREY; // {5}\n  if (callback) {\n    // {6}\n    callback(u);\n  }\n  const neighbors = adjList.get(u); // {7}\n  for (let i = 0; i < neighbors.length; i++) {\n    // {8}\n    const w = neighbors[i]; // {9}\n    if (color[w] === Colors.WHITE) {\n      // {10}\n      depthFirstSearchVisit(w, color, adjList, callback); // {11}\n    }\n  }\n  color[u] = Colors.BLACK; // {12}\n};\n\ndepthFirstSearch(graph, printVertex);\n// Visited vertex: A\n// Visited vertex: B\n// Visited vertex: E\n// Visited vertex: I\n// Visited vertex: F\n// Visited vertex: C\n// Visited vertex: D\n// Visited vertex: G\n// Visited vertex: H\n```\n\n![graph-9](graph-9.png)\n\n_Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。_\n\n_探索深度优先算法_\n对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。\n\n```javascript\nexport const DFS = (graph) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  const d = {};\n  const f = {};\n  const p = {};\n  const time = { count: 0 }; // {1}\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    f[vertices[i]] = 0;\n    d[vertices[i]] = 0;\n    p[vertices[i]] = null;\n  }\n  for (let i = 0; i < vertices.length; i++) {\n    if (color[vertices[i]] === Colors.WHITE) {\n      DFSVisit(vertices[i], color, d, f, p, time, adjList);\n    }\n  }\n  return {\n    // {3}\n    discovery: d, // 顶点 u 的发现时间 d[u]；\n    finished: f, // 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；\n    predecessors: p, // 顶点 u 的前溯点 p[u]\n  };\n};\nconst DFSVisit = (u, color, d, f, p, time, adjList) => {\n  color[u] = Colors.GREY;\n  d[u] = ++time.count; // {4}\n  const neighbors = adjList.get(u);\n  for (let i = 0; i < neighbors.length; i++) {\n    const w = neighbors[i];\n    if (color[w] === Colors.WHITE) {\n      p[w] = u; // {5}\n      DFSVisit(w, color, d, f, p, time, adjList);\n    }\n  }\n  color[u] = Colors.BLACK;\n  f[u] = ++time.count; // {6}\n};\n```\n\n(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；\n(2)对于所有的顶点 u，d[u] < f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。\n在这两个假设下，我们有如下的规则。\n_1 <= d [u] < f [u] <= 2|V|_\n如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间\n![graph-10](graph-10.png)\n\n**拓扑排序——使用深度优先搜索**\n![graph-11](graph-11.png)\n有向无环图（DAG）\n\n需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）\n\n_拓扑排序只能应用于 DAG_\n\n```javascript\ngraph = new Graph(true); // 有向图\nmyVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\nfor (i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('B', 'D');\ngraph.addEdge('B', 'E');\ngraph.addEdge('C', 'F');\ngraph.addEdge('F', 'E');\nconst result = DFS(graph);\n```\n\n![graph-12](graph-12.png)\n\n```javascript\nconst fTimes = result.finished;\ns = '';\nfor (let count = 0; count < myVertices.length; count++) {\n  let max = 0;\n  let maxName = null;\n  for (i = 0; i < myVertices.length; i++) {\n    if (fTimes[myVertices[i]] > max) {\n      max = fTimes[myVertices[i]];\n      maxName = myVertices[i];\n    }\n  }\n  s += ' - ' + maxName;\n  delete fTimes[maxName];\n}\nconsole.log(s);\n// B - A - D - C - F - E\n```\n\n###### 最短路径算法\n\n_Dijkstra 算法_\nDijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。\n\n![graph-13](graph-13.png)\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [0, 0, 1, 4, 2, 0],\n  [0, 0, 0, 0, 3, 0],\n  [0, 0, 0, 0, 0, 2],\n  [0, 0, 0, 3, 0, 2],\n  [0, 0, 0, 0, 0, 0],\n];\n// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER\nconst INF = Number.MAX_SAFE_INTEGER;\nconst dijkstra = (graph, src) => {\n  const dist = [];\n  const visited = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = INF; // 把所有的距离（dist）初始化为无限大\n    visited[i] = false;\n  }\n  dist[src] = 0; // {2} 把源顶点到自己的距离设为 0\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    const u = minDistance(dist, visited); // {4} 从尚未处理的顶点中选出距离最近的顶点\n    visited[u] = true; // {5} 把选出的顶点标为 visited，以免重复计算\n    for (let v = 0; v < length; v++) {\n      if (\n        !visited[v] &&\n        graph[u][v] !== 0 &&\n        dist[u] !== INF &&\n        dist[u] + graph[u][v] < dist[v]\n      ) {\n        // 如果找到更短的路径，则更新最短路径的值\n        // {6}\n        dist[v] = dist[u] + graph[u][v]; // {7}\n      }\n    }\n  }\n  return dist; // {8}\n};\n\nconst minDistance = (dist, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist.length; v++) {\n    if (visited[v] === false && dist[v] <= min) {\n      min = dist[v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// 0 0\n// 1 2\n// 2 4\n// 3 6\n// 4 4\n// 5 6\n```\n\n**Floyd-Warshall 算法**\nFloyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。\n\n```javascript\nconst floydWarshall = (graph) => {\n  const dist = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = [];\n    for (let j = 0; j < length; j++) {\n      if (i === j) {\n        dist[i][j] = 0; // {2}\n      } else if (!isFinite(graph[i][j])) {\n        // 如果两个顶点之间没有边，就将其表示为 Infinity\n        dist[i][j] = Infinity; // {3}\n      } else {\n        // 为 i 到 j 可能的最短距离就是这些顶点间的权值\n        dist[i][j] = graph[i][j]; // {4}\n      }\n    }\n  }\n  // 将顶点 0 到 k 作为中间点（行{5}），从 i 到 j 的最短路径经过 k。\n  for (let k = 0; k < length; k++) {\n    // {5}\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length; j++) {\n        // 计算通过顶点 k 的 i 和 j 之间的最短路径\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          // {6}\n          dist[i][j] = dist[i][k] + dist[k][j]; // {7}\n        }\n      }\n    }\n  }\n  return dist;\n};\n// 0 2 4 6 4 6\n// INF 0 2 4 2 4\n// INF INF 0 6 3 5\n// INF INF INF 0 INF 2\n// INF INF INF 3 0 2\n// INF INF INF INF INF 0\n```\n\n###### 最小生成树(MST)\n\n**Prim 算法**\nPrim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [2, 0, 2, 4, 2, 0],\n  [4, 2, 0, 0, 3, 0],\n  [0, 4, 0, 0, 3, 2],\n  [0, 2, 3, 3, 0, 2],\n  [0, 0, 0, 2, 2, 0],\n];\n\nconst INF = Number.MAX_SAFE_INTEGER;\nconst prim = (graph) => {\n  const parent = [];\n  const key = [];\n  const visited = [];\n  const { length } = graph;\n  // 把所有顶点（key）初始化为无限大\n  for (let i = 0; i < length; i++) {\n    // {1}\n    key[i] = INF;\n    visited[i] = false;\n  }\n  // 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1\n  key[0] = 0; // {2}\n  parent[0] = -1;\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    // 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）\n    const u = minKey(graph, key, visited); // {4}\n    visited[u] = true; // {5}\n    for (let v = 0; v < length; v++) {\n      // 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值\n      if (graph[u][v] && !visited[v] && graph[u][v] < key[v]) {\n        // {6}\n        parent[v] = u; // {7}\n        key[v] = graph[u][v]; // {8}\n      }\n    }\n  }\n  return parent; // {9}\n};\n\nconst minDistance = (dist, key, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist[key].length; v++) {\n    if (visited[v] === false && dist[key][v] <= min) {\n      min = dist[key][v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// Edge Weight\n// 0 - 1 2\n// 1 - 2 2\n// 5 - 3 2\n// 1 - 4 2\n// 4 - 5 2\n```\n\n**Kruskal 算法**\n是一种求加权无向连通图的 MST 的贪心算法\n\n```javascript\nconst kruskal = (graph) => {\n  const { length } = graph;\n  const parent = [];\n  let ne = 0;\n  let a;\n  let b;\n  let u;\n  let v;\n  // 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值\n  const cost = initializeCost(graph); // {1}\n  // 当 MST 的边数小于顶点总数减 1 时\n  while (ne < length - 1) {\n    // 找出权值最小的边\n    for (let i = 0, min = INF; i < length; i++) {\n      // {3}\n      for (let j = 0; j < length; j++) {\n        if (cost[i][j] < min) {\n          min = cost[i][j];\n          a = u = i;\n          b = v = j;\n        }\n      }\n    }\n    // 检查 MST 中是否已存在这条边，以避免环路\n    u = find(u, parent); // {4}\n    v = find(v, parent); // {5}\n    // 如果 u 和 v 是不同的边，则将其加入 MST\n    if (union(u, v, parent)) {\n      // {6}\n      ne++;\n    }\n    // ：从列表中移除这些边，以免重复计算\n    cost[a][b] = cost[b][a] = INF; // {7}\n  }\n  return parent;\n};\n\nconst find = (i, parent) => {\n  while (parent[i]) {\n    i = parent[i];\n  }\n  return i;\n};\nconst union = (i, j, parent) => {\n  if (i !== j) {\n    parent[j] = i;\n    return true;\n  }\n  return false;\n};\n```\n","source":"_posts/37-data-structure5.md","raw":"---\ntitle: 数据结构与算法阅读笔记(5)\ndate: 2022-10-08 16:33:37\ntags:\n---\n\n#### 二叉堆和堆排序\n\n###### 二叉堆数据结构\n\n(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。\n(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性\n![heat](heat.png)\n\n二叉树有两种表示方式\n第一种是使用一个动态的表示方式，也就是指针（用节点表示）\n第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。\n![min-heat](min-heat.png)\n\n访问使用普通数组的二叉树节点:\n它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；\n它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；\n它的父节点位置是 index / 2（如果位置可用）\n\n```javascript\nimport { defaultCompare } from '../util';\n\nexport class MinHeap {\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn; // {1}\n    this.heap = []; // {2}\n  }\n  getLeftIndex(index) {\n    return 2 * index + 1;\n  }\n  getRightIndex(index) {\n    return 2 * index + 2;\n  }\n  getParentIndex(index) {\n    if (index === 0) {\n      return undefined;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n  insert(value) {\n    if (value != null) {\n      this.heap.push(value); // {1}\n      this.siftUp(this.heap.length - 1); // {2}\n      return true;\n    }\n    return false;\n  }\n  // 上移操作\n  siftUp(index) {\n    let parent = this.getParentIndex(index); // {1}\n    while (\n      index > 0 &&\n      this.compareFn(this.heap[parent], this.heap[index]) > Compare.BIGGER_THAN\n    ) {\n      // {2}\n      swap(this.heap, parent, index); // {3}\n      index = parent;\n      parent = this.getParentIndex(index); // {4}\n    }\n    function swap(array, a, b) {\n      const temp = array[a]; // {5}\n      array[a] = array[b]; // {6}\n      array[b] = temp; // {7}\n    }\n  }\n  size() {\n    return this.heap.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  findMinimum() {\n    return this.isEmpty() ? undefined : this.heap[0]; // {1}\n  }\n  extract() {\n    if (this.isEmpty()) {\n      return undefined; // {1}\n    }\n    if (this.size() === 1) {\n      return this.heap.shift(); // {2}\n    }\n    const removedValue = this.heap.shift(); // {3}\n    this.siftDown(0); // {4}\n    return removedValue; // {5}\n  }\n  siftDown(index) {\n    let element = index;\n    const left = this.getLeftIndex(index); // {1}\n    const right = this.getRightIndex(index); // {2}\n    const size = this.size();\n    if (\n      left < size &&\n      this.compareFn(this.heap[element], this.heap[left]) > Compare.BIGGER_THAN\n    ) {\n      // {3}\n      element = left; // {4}\n    }\n    if (\n      right < size &&\n      this.compareFn(this.heap[element], this.heap[right]) > Compare.BIGGER_THAN\n    ) {\n      // {5}\n      element = right; // {6}\n    }\n    if (index !== element) {\n      // {7}\n      swap(this.heap, index, element); // {8}\n      this.siftDown(element); // {9}\n    }\n  }\n}\n```\n\n![min-heat-pic](min-heat-pic.png)\n\n**创建最大堆类**\nMaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有>（大于）的比较换成<（小于）的比较。\n\n```javascript\nfunction reverseCompare(compareFn) {\n  return (a, b) => compareFn(b, a);\n}\n\nexport class MaxHeap extends MinHeap {\n  constructor(compareFn = defaultCompare) {\n    super(compareFn);\n    this.compareFn = reverseCompare(compareFn); // {1}\n  }\n}\n```\n\n**堆排序算法**\n(1) 用数组创建一个最大堆用作源数据。\n(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。\n(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1\n\n```javascript\nfunction heapSort(array, compareFn = defaultCompare) {\n  let heapSize = array.length;\n  buildMaxHeap(array, compareFn); // 步骤 1\n  while (heapSize > 1) {\n    swap(array, 0, --heapSize); // 步骤 2\n    heapify(array, 0, heapSize, compareFn); // 步骤 3\n  }\n  return array;\n}\nfunction buildMaxHeap(array, compareFn) {\n  for (let i = Math.floor(array.length / 2); i >= 0; i -= 1) {\n    heapify(array, i, array.length, compareFn);\n  }\n  return array;\n}\n```\n\nheapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法\n![heap-sort](heap-sort.png)\n\n**堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。**\n\n#### 图\n\n###### 图的相关术语\n\n图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）\nG = (V, E)\nV: 一组顶点\nE: 一组边，连接 V 中的顶点\n![graph-1](graph-1.png)\n\n由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。\n一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。\n路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。\n简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。\n如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。\n\n**有向图和无向图**\n图可以是无向的（边没有方向）或是有向的（有向图）。\n如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。\n![graph-2](graph-2.png)\n图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。\n![graph-3](graph-3.png)\n\n###### 图的表示\n\n**邻接矩阵**\n每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0\n![graph-4](graph-4.png)\n_缺点：_\n(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。\n(2)顶点的数量可能会改变，而二维数组不太灵活\n\n**邻接表**\n邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。\n可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表\n![graph-5](graph-5.png)\n\n**关联矩阵**\n在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0\n![graph-6](graph-6.png)\n_关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存_\n\n###### 创建 Graph 类\n\n```javascript\nclass Graph {\n  constructor(isDirected = false) {\n    // 表示图是否有向\n    this.isDirected = isDirected; // {1}\n    //  所有顶点的名字\n    this.vertices = []; // {2}\n    //  字典将会使用顶点的名字作为键，邻接顶点列表作为值\n    this.adjList = new Dictionary(); // {3}\n  }\n  //  一个用来向图中添加一个新的顶点\n  addVertex(v) {\n    if (!this.vertices.includes(v)) {\n      // {5}\n      this.vertices.push(v); // {6}\n      this.adjList.set(v, []); // {7}\n    }\n  }\n  // 来添加顶点之间的边\n  addEdge(v, w) {\n    if (!this.adjList.get(v)) {\n      this.addVertex(v); // {8}\n    }\n    if (!this.adjList.get(w)) {\n      this.addVertex(w); // {9}\n    }\n    this.adjList.get(v).push(w); // {10}\n    if (!this.isDirected) {\n      this.adjList.get(w).push(v); // {11}\n    }\n  }\n  // 获取顶点列表\n  getVertices() {\n    return this.vertices;\n  }\n  // 获取邻接表\n  getAdjList() {\n    return this.adjList;\n  }\n  toString() {\n    let s = '';\n    for (let i = 0; i < this.vertices.length; i++) {\n      // {15}\n      s += `${this.vertices[i]} -> `;\n      const neighbors = this.adjList.get(this.vertices[i]); // {16}\n      for (let j = 0; j < neighbors.length; j++) {\n        // {17}\n        s += `${neighbors[j]} `;\n      }\n      s += '\\n'; // {18}\n    }\n    return s;\n  }\n}\n```\n\n###### 图的遍历\n\n*作用：*图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等\n图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。\n完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。\n为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。\n\n**广度优先搜索（breadth-first search，BFS）**\n**深度优先搜索（depth-first search，DFS）**\n*不同点：*待访问顶点列表的数据结构\n| 算 法        | 数据结构 | 描 述                                                          |\n| ------------ | -------- | -------------------------------------------------------------- |\n| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |\n| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |\n\n```javascript\n// 白色：表示该顶点还没有被访问。\n// 灰色：表示该顶点被访问过，但并未被探索过。\n// 黑色：表示该顶点被访问过且被完全探索过\nconst Colors = {\n  WHITE: 0,\n  GREY: 1,\n  BLACK: 2,\n};\n// 初始化每个顶点的颜色\nconst initializeColor = (vertices) => {\n  const color = {};\n  for (let i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = Colors.WHITE;\n  }\n  return color;\n};\n```\n\n**广度优先搜索**\n从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点\n![graph-7](graph-7.png)\n_步骤_\n(1) 创建一个队列 Q。\n(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。\n(3) 如果 Q 非空，则运行以下步骤：\n\n- (a) 将 u 从 Q 中出队列；\n- (b) 标注 u 为被发现的（灰色）；\n- (c) 将 u 所有未被访问过的邻点（白色）入队列；\n- (d) 标注 u 为已被探索的（黑色）\n\n```javascript\nexport const breadthFirstSearch = (graph, startVertex, callback) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices); // {1}\n  const queue = new Queue(); // {2}\n  queue.enqueue(startVertex); // {3}\n  while (!queue.isEmpty()) {\n    // {4}\n    const u = queue.dequeue(); // {5}\n    const neighbors = adjList.get(u); // {6}\n    // 发现了节点，但尚未完成探索\n    color[u] = Colors.GREY; // {7}\n    for (let i = 0; i < neighbors.length; i++) {\n      // {8}\n      const w = neighbors[i]; // {9}\n      if (color[w] === Colors.WHITE) {\n        // {10}\n        color[w] = Colors.GREY; // {11}\n        queue.enqueue(w); // {12}\n      }\n    }\n    color[u] = Colors.BLACK; // {13}\n    // 可选回调函数\n    if (callback) {\n      // {14}\n      callback(u);\n    }\n  }\n};\n\nconst printVertex = (value) => console.log('Visited vertex: ' + value); // {15}\nbreadthFirstSearch(graph, myVertices[0], printVertex);\n```\n\n_使用 BFS 寻找最短路径_\n给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）\n\n```javascript\nconst BFS = (graph, startVertex) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  // 创建一个队列\n  const queue = new Queue();\n  const distances = {}; // {1}\n  const predecessors = {}; // {2}\n  queue.enqueue(startVertex);\n  for (let i = 0; i < vertices.length; i++) {\n    // {3}\n    distances[vertices[i]] = 0; // {4}\n    predecessors[vertices[i]] = null; // {5}\n  }\n  while (!queue.isEmpty()) {\n    const u = queue.dequeue();\n    const neighbors = adjList.get(u);\n    color[u] = Colors.GREY;\n    for (let i = 0; i < neighbors.length; i++) {\n      const w = neighbors[i];\n      if (color[w] === Colors.WHITE) {\n        color[w] = Colors.GREY;\n        distances[w] = distances[u] + 1; // {6}\n        predecessors[w] = u; // {7}\n        queue.enqueue(w);\n      }\n    }\n    color[u] = Colors.BLACK;\n  }\n  return {\n    // {8}\n    distances, // 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]\n    predecessors, // 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径\n  };\n};\n\nconst shortestPathA = BFS(graph, myVertices[0]);\nconsole.log(shortestPathA);\n// distances: {A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3},\n// predecessors: {A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"}\n\nconst fromVertex = myVertices[0]; // {9}\n\nfor (i = 1; i < myVertices.length; i++) {\n  // {10}\n  const toVertex = myVertices[i]; // {11}\n  // 创建一个栈\n  const path = new Stack(); // {12}\n  // 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点\n  for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) {\n    // {13}\n    path.push(v); // {14}\n  }\n  path.push(fromVertex); // {15}\n  let s = path.pop(); // {16}\n  while (!path.isEmpty()) {\n    // {17}\n    s += ' - ' + path.pop(); // {18}\n  }\n  console.log(s); // {19}\n}\n// A - B\n// A - C\n// A - D\n// A - B - E\n// A - B - F\n// A - C - G\n// A - D - H\n// A - B - E - I\n```\n\n_深入学习最短路径算法_\nDijkstra 算法解决了单源最短路径问题。\nBellman-Ford 算法解决了边权值为负的单源最短路径问题。\nA\\*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。\nFloyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题\n\n**深度优先搜索**\n深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点\n![graph-8](graph-8.png)\n\n深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。\n_步骤_\n(1) 标注 v 为被发现的（灰色）；\n(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；\n(3) 标注 v 为已被探索的（黑色）。\n\n深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）\n\n```javascript\nconst depthFirstSearch = (graph, callback) => {\n  // {1}\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    if (color[vertices[i]] === Colors.WHITE) {\n      // {3}\n      depthFirstSearchVisit(vertices[i], color, adjList, callback); // {4}\n    }\n  }\n};\nconst depthFirstSearchVisit = (u, color, adjList, callback) => {\n  color[u] = Colors.GREY; // {5}\n  if (callback) {\n    // {6}\n    callback(u);\n  }\n  const neighbors = adjList.get(u); // {7}\n  for (let i = 0; i < neighbors.length; i++) {\n    // {8}\n    const w = neighbors[i]; // {9}\n    if (color[w] === Colors.WHITE) {\n      // {10}\n      depthFirstSearchVisit(w, color, adjList, callback); // {11}\n    }\n  }\n  color[u] = Colors.BLACK; // {12}\n};\n\ndepthFirstSearch(graph, printVertex);\n// Visited vertex: A\n// Visited vertex: B\n// Visited vertex: E\n// Visited vertex: I\n// Visited vertex: F\n// Visited vertex: C\n// Visited vertex: D\n// Visited vertex: G\n// Visited vertex: H\n```\n\n![graph-9](graph-9.png)\n\n_Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。_\n\n_探索深度优先算法_\n对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。\n\n```javascript\nexport const DFS = (graph) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n  const d = {};\n  const f = {};\n  const p = {};\n  const time = { count: 0 }; // {1}\n  for (let i = 0; i < vertices.length; i++) {\n    // {2}\n    f[vertices[i]] = 0;\n    d[vertices[i]] = 0;\n    p[vertices[i]] = null;\n  }\n  for (let i = 0; i < vertices.length; i++) {\n    if (color[vertices[i]] === Colors.WHITE) {\n      DFSVisit(vertices[i], color, d, f, p, time, adjList);\n    }\n  }\n  return {\n    // {3}\n    discovery: d, // 顶点 u 的发现时间 d[u]；\n    finished: f, // 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；\n    predecessors: p, // 顶点 u 的前溯点 p[u]\n  };\n};\nconst DFSVisit = (u, color, d, f, p, time, adjList) => {\n  color[u] = Colors.GREY;\n  d[u] = ++time.count; // {4}\n  const neighbors = adjList.get(u);\n  for (let i = 0; i < neighbors.length; i++) {\n    const w = neighbors[i];\n    if (color[w] === Colors.WHITE) {\n      p[w] = u; // {5}\n      DFSVisit(w, color, d, f, p, time, adjList);\n    }\n  }\n  color[u] = Colors.BLACK;\n  f[u] = ++time.count; // {6}\n};\n```\n\n(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；\n(2)对于所有的顶点 u，d[u] < f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。\n在这两个假设下，我们有如下的规则。\n_1 <= d [u] < f [u] <= 2|V|_\n如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间\n![graph-10](graph-10.png)\n\n**拓扑排序——使用深度优先搜索**\n![graph-11](graph-11.png)\n有向无环图（DAG）\n\n需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）\n\n_拓扑排序只能应用于 DAG_\n\n```javascript\ngraph = new Graph(true); // 有向图\nmyVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\nfor (i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('B', 'D');\ngraph.addEdge('B', 'E');\ngraph.addEdge('C', 'F');\ngraph.addEdge('F', 'E');\nconst result = DFS(graph);\n```\n\n![graph-12](graph-12.png)\n\n```javascript\nconst fTimes = result.finished;\ns = '';\nfor (let count = 0; count < myVertices.length; count++) {\n  let max = 0;\n  let maxName = null;\n  for (i = 0; i < myVertices.length; i++) {\n    if (fTimes[myVertices[i]] > max) {\n      max = fTimes[myVertices[i]];\n      maxName = myVertices[i];\n    }\n  }\n  s += ' - ' + maxName;\n  delete fTimes[maxName];\n}\nconsole.log(s);\n// B - A - D - C - F - E\n```\n\n###### 最短路径算法\n\n_Dijkstra 算法_\nDijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。\n\n![graph-13](graph-13.png)\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [0, 0, 1, 4, 2, 0],\n  [0, 0, 0, 0, 3, 0],\n  [0, 0, 0, 0, 0, 2],\n  [0, 0, 0, 3, 0, 2],\n  [0, 0, 0, 0, 0, 0],\n];\n// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER\nconst INF = Number.MAX_SAFE_INTEGER;\nconst dijkstra = (graph, src) => {\n  const dist = [];\n  const visited = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = INF; // 把所有的距离（dist）初始化为无限大\n    visited[i] = false;\n  }\n  dist[src] = 0; // {2} 把源顶点到自己的距离设为 0\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    const u = minDistance(dist, visited); // {4} 从尚未处理的顶点中选出距离最近的顶点\n    visited[u] = true; // {5} 把选出的顶点标为 visited，以免重复计算\n    for (let v = 0; v < length; v++) {\n      if (\n        !visited[v] &&\n        graph[u][v] !== 0 &&\n        dist[u] !== INF &&\n        dist[u] + graph[u][v] < dist[v]\n      ) {\n        // 如果找到更短的路径，则更新最短路径的值\n        // {6}\n        dist[v] = dist[u] + graph[u][v]; // {7}\n      }\n    }\n  }\n  return dist; // {8}\n};\n\nconst minDistance = (dist, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist.length; v++) {\n    if (visited[v] === false && dist[v] <= min) {\n      min = dist[v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// 0 0\n// 1 2\n// 2 4\n// 3 6\n// 4 4\n// 5 6\n```\n\n**Floyd-Warshall 算法**\nFloyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。\n\n```javascript\nconst floydWarshall = (graph) => {\n  const dist = [];\n  const { length } = graph;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    dist[i] = [];\n    for (let j = 0; j < length; j++) {\n      if (i === j) {\n        dist[i][j] = 0; // {2}\n      } else if (!isFinite(graph[i][j])) {\n        // 如果两个顶点之间没有边，就将其表示为 Infinity\n        dist[i][j] = Infinity; // {3}\n      } else {\n        // 为 i 到 j 可能的最短距离就是这些顶点间的权值\n        dist[i][j] = graph[i][j]; // {4}\n      }\n    }\n  }\n  // 将顶点 0 到 k 作为中间点（行{5}），从 i 到 j 的最短路径经过 k。\n  for (let k = 0; k < length; k++) {\n    // {5}\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length; j++) {\n        // 计算通过顶点 k 的 i 和 j 之间的最短路径\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          // {6}\n          dist[i][j] = dist[i][k] + dist[k][j]; // {7}\n        }\n      }\n    }\n  }\n  return dist;\n};\n// 0 2 4 6 4 6\n// INF 0 2 4 2 4\n// INF INF 0 6 3 5\n// INF INF INF 0 INF 2\n// INF INF INF 3 0 2\n// INF INF INF INF INF 0\n```\n\n###### 最小生成树(MST)\n\n**Prim 算法**\nPrim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。\n\n```javascript\nvar graph = [\n  [0, 2, 4, 0, 0, 0],\n  [2, 0, 2, 4, 2, 0],\n  [4, 2, 0, 0, 3, 0],\n  [0, 4, 0, 0, 3, 2],\n  [0, 2, 3, 3, 0, 2],\n  [0, 0, 0, 2, 2, 0],\n];\n\nconst INF = Number.MAX_SAFE_INTEGER;\nconst prim = (graph) => {\n  const parent = [];\n  const key = [];\n  const visited = [];\n  const { length } = graph;\n  // 把所有顶点（key）初始化为无限大\n  for (let i = 0; i < length; i++) {\n    // {1}\n    key[i] = INF;\n    visited[i] = false;\n  }\n  // 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1\n  key[0] = 0; // {2}\n  parent[0] = -1;\n  for (let i = 0; i < length - 1; i++) {\n    // {3}\n    // 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）\n    const u = minKey(graph, key, visited); // {4}\n    visited[u] = true; // {5}\n    for (let v = 0; v < length; v++) {\n      // 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值\n      if (graph[u][v] && !visited[v] && graph[u][v] < key[v]) {\n        // {6}\n        parent[v] = u; // {7}\n        key[v] = graph[u][v]; // {8}\n      }\n    }\n  }\n  return parent; // {9}\n};\n\nconst minDistance = (dist, key, visited) => {\n  let min = INF;\n  let minIndex = -1;\n  for (let v = 0; v < dist[key].length; v++) {\n    if (visited[v] === false && dist[key][v] <= min) {\n      min = dist[key][v];\n      minIndex = v;\n    }\n  }\n  return minIndex;\n};\n\n// Edge Weight\n// 0 - 1 2\n// 1 - 2 2\n// 5 - 3 2\n// 1 - 4 2\n// 4 - 5 2\n```\n\n**Kruskal 算法**\n是一种求加权无向连通图的 MST 的贪心算法\n\n```javascript\nconst kruskal = (graph) => {\n  const { length } = graph;\n  const parent = [];\n  let ne = 0;\n  let a;\n  let b;\n  let u;\n  let v;\n  // 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值\n  const cost = initializeCost(graph); // {1}\n  // 当 MST 的边数小于顶点总数减 1 时\n  while (ne < length - 1) {\n    // 找出权值最小的边\n    for (let i = 0, min = INF; i < length; i++) {\n      // {3}\n      for (let j = 0; j < length; j++) {\n        if (cost[i][j] < min) {\n          min = cost[i][j];\n          a = u = i;\n          b = v = j;\n        }\n      }\n    }\n    // 检查 MST 中是否已存在这条边，以避免环路\n    u = find(u, parent); // {4}\n    v = find(v, parent); // {5}\n    // 如果 u 和 v 是不同的边，则将其加入 MST\n    if (union(u, v, parent)) {\n      // {6}\n      ne++;\n    }\n    // ：从列表中移除这些边，以免重复计算\n    cost[a][b] = cost[b][a] = INF; // {7}\n  }\n  return parent;\n};\n\nconst find = (i, parent) => {\n  while (parent[i]) {\n    i = parent[i];\n  }\n  return i;\n};\nconst union = (i, j, parent) => {\n  if (i !== j) {\n    parent[j] = i;\n    return true;\n  }\n  return false;\n};\n```\n","slug":"37-data-structure5","published":1,"updated":"2022-10-13T06:14:03.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx4001jcktta6jo57f0","content":"<h4 id=\"二叉堆和堆排序\"><a href=\"#二叉堆和堆排序\" class=\"headerlink\" title=\"二叉堆和堆排序\"></a>二叉堆和堆排序</h4><h6 id=\"二叉堆数据结构\"><a href=\"#二叉堆数据结构\" class=\"headerlink\" title=\"二叉堆数据结构\"></a>二叉堆数据结构</h6><p>(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。<br>(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性<br><img src=\"/2022/10/08/37-data-structure5/heat.png\" alt=\"heat\"></p>\n<p>二叉树有两种表示方式<br>第一种是使用一个动态的表示方式，也就是指针（用节点表示）<br>第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。<br><img src=\"/2022/10/08/37-data-structure5/min-heat.png\" alt=\"min-heat\"></p>\n<p>访问使用普通数组的二叉树节点:<br>它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；<br>它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；<br>它的父节点位置是 index / 2（如果位置可用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.heap = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getLeftIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getRightIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getParentIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor((index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.heap.push(value); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftUp(<span class=\"built_in\">this</span>.heap.length - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 上移操作</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftUp</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      index &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[parent], <span class=\"built_in\">this</span>.heap[index]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, parent, index); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      index = parent;</span><br><span class=\"line\">      parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> temp = array[a]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[a] = array[b]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[b] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">findMinimum</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.isEmpty() ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">this</span>.heap[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">extract</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> removedValue = <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.siftDown(<span class=\"number\">0</span>); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> removedValue; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftDown</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = index;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = <span class=\"built_in\">this</span>.getLeftIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = <span class=\"built_in\">this</span>.getRightIndex(index); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> size = <span class=\"built_in\">this</span>.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      left &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[left]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      element = left; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      right &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[right]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      element = right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== element) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, index, element); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftDown(element); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/min-heat-pic.png\" alt=\"min-heat-pic\"></p>\n<p><strong>创建最大堆类</strong><br>MaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有&gt;（大于）的比较换成&lt;（小于）的比较。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverseCompare</span>(<span class=\"params\">compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> compareFn(b, a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxHeap</span> <span class=\"keyword\">extends</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = reverseCompare(compareFn); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆排序算法</strong><br>(1) 用数组创建一个最大堆用作源数据。<br>(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。<br>(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> heapSize = array.length;</span><br><span class=\"line\">  buildMaxHeap(array, compareFn); <span class=\"comment\">// 步骤 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (heapSize &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    swap(array, <span class=\"number\">0</span>, --heapSize); <span class=\"comment\">// 步骤 2</span></span><br><span class=\"line\">    heapify(array, <span class=\"number\">0</span>, heapSize, compareFn); <span class=\"comment\">// 步骤 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildMaxHeap</span>(<span class=\"params\">array, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(array.length / <span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i -= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    heapify(array, i, array.length, compareFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>heapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法<br><img src=\"/2022/10/08/37-data-structure5/heap-sort.png\" alt=\"heap-sort\"></p>\n<p><strong>堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。</strong></p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><h6 id=\"图的相关术语\"><a href=\"#图的相关术语\" class=\"headerlink\" title=\"图的相关术语\"></a>图的相关术语</h6><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）<br>G = (V, E)<br>V: 一组顶点<br>E: 一组边，连接 V 中的顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-1.png\" alt=\"graph-1\"></p>\n<p>由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。<br>一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。<br>路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。<br>简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。<br>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p>\n<p><strong>有向图和无向图</strong><br>图可以是无向的（边没有方向）或是有向的（有向图）。<br>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。<br><img src=\"/2022/10/08/37-data-structure5/graph-2.png\" alt=\"graph-2\"><br>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。<br><img src=\"/2022/10/08/37-data-structure5/graph-3.png\" alt=\"graph-3\"></p>\n<h6 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h6><p><strong>邻接矩阵</strong><br>每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-4.png\" alt=\"graph-4\"><br><em>缺点：</em><br>(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。<br>(2)顶点的数量可能会改变，而二维数组不太灵活</p>\n<p><strong>邻接表</strong><br>邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。<br>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表<br><img src=\"/2022/10/08/37-data-structure5/graph-5.png\" alt=\"graph-5\"></p>\n<p><strong>关联矩阵</strong><br>在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-6.png\" alt=\"graph-6\"><br><em>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存</em></p>\n<h6 id=\"创建-Graph-类\"><a href=\"#创建-Graph-类\" class=\"headerlink\" title=\"创建 Graph 类\"></a>创建 Graph 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">isDirected = <span class=\"literal\">false</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示图是否有向</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDirected = isDirected; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  所有顶点的名字</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.vertices = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  字典将会使用顶点的名字作为键，邻接顶点列表作为值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  一个用来向图中添加一个新的顶点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addVertex</span>(<span class=\"params\">v</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.vertices.includes(v)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.vertices.push(v); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.set(v, []); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 来添加顶点之间的边</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addEdge</span>(<span class=\"params\">v, w</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(v)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(v); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(w)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(w); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList.get(v).push(w); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isDirected) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.get(w).push(v); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取顶点列表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getVertices</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.vertices;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取邻接表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getAdjList</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.adjList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.vertices.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      s += <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.vertices[i]&#125;</span> -&gt; `</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> neighbors = <span class=\"built_in\">this</span>.adjList.get(<span class=\"built_in\">this</span>.vertices[i]); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">        s += <span class=\"string\">`<span class=\"subst\">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      s += <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h6><p><em>作用：</em>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。<br>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>\n<p><strong>广度优先搜索（breadth-first search，BFS）</strong><br><strong>深度优先搜索（depth-first search，DFS）</strong><br><em>不同点：</em>待访问顶点列表的数据结构<br>| 算 法        | 数据结构 | 描 述                                                          |<br>| ———— | ——– | ————————————————————– |<br>| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |<br>| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 白色：表示该顶点还没有被访问。</span></span><br><span class=\"line\"><span class=\"comment\">// 灰色：表示该顶点被访问过，但并未被探索过。</span></span><br><span class=\"line\"><span class=\"comment\">// 黑色：表示该顶点被访问过且被完全探索过</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Colors = &#123;</span><br><span class=\"line\">  <span class=\"attr\">WHITE</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">GREY</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">BLACK</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化每个顶点的颜色</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initializeColor = <span class=\"function\">(<span class=\"params\">vertices</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    color[vertices[i]] = Colors.WHITE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>广度优先搜索</strong><br>从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-7.png\" alt=\"graph-7\"><br><em>步骤</em><br>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：</p>\n<ul>\n<li>(a) 将 u 从 Q 中出队列；</li>\n<li>(b) 标注 u 为被发现的（灰色）；</li>\n<li>(c) 将 u 所有未被访问过的邻点（白色）入队列；</li>\n<li>(d) 标注 u 为已被探索的（黑色）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> breadthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue(); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 发现了节点，但尚未完成探索</span></span><br><span class=\"line\">    color[u] = Colors.GREY; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        color[w] = Colors.GREY; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        queue.enqueue(w); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 可选回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      callback(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> printVertex = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Visited vertex: &#x27;</span> + value); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">breadthFirstSearch(graph, myVertices[<span class=\"number\">0</span>], printVertex);</span><br></pre></td></tr></table></figure>\n\n<p><em>使用 BFS 寻找最短路径</em><br>给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BFS = <span class=\"function\">(<span class=\"params\">graph, startVertex</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> distances = &#123;&#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> predecessors = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    distances[vertices[i]] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    predecessors[vertices[i]] = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">    color[u] = Colors.GREY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        color[w] = Colors.GREY;</span><br><span class=\"line\">        distances[w] = distances[u] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        predecessors[w] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        queue.enqueue(w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    distances, <span class=\"comment\">// 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]</span></span><br><span class=\"line\">    predecessors, <span class=\"comment\">// 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shortestPathA = BFS(graph, myVertices[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shortestPathA);</span><br><span class=\"line\"><span class=\"comment\">// distances: &#123;A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// predecessors: &#123;A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G: &quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fromVertex = myVertices[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> toVertex = myVertices[i]; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 创建一个栈</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"keyword\">new</span> Stack(); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    path.push(v); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  path.push(fromVertex); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> s = path.pop(); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!path.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">    s += <span class=\"string\">&#x27; - &#x27;</span> + path.pop(); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// A - B</span></span><br><span class=\"line\"><span class=\"comment\">// A - C</span></span><br><span class=\"line\"><span class=\"comment\">// A - D</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - F</span></span><br><span class=\"line\"><span class=\"comment\">// A - C - G</span></span><br><span class=\"line\"><span class=\"comment\">// A - D - H</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E - I</span></span><br></pre></td></tr></table></figure>\n\n<p><em>深入学习最短路径算法</em><br>Dijkstra 算法解决了单源最短路径问题。<br>Bellman-Ford 算法解决了边权值为负的单源最短路径问题。<br>A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。<br>Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题</p>\n<p><strong>深度优先搜索</strong><br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-8.png\" alt=\"graph-8\"></p>\n<p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。<br><em>步骤</em><br>(1) 标注 v 为被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）。</p>\n<p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(vertices[i], color, adjList, callback); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearchVisit = <span class=\"function\">(<span class=\"params\">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    callback(u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(w, color, adjList, callback); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">depthFirstSearch(graph, printVertex);</span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: A</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: B</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: E</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: I</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: F</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: C</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: D</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: G</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: H</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-9.png\" alt=\"graph-9\"></p>\n<p><em>Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。</em></p>\n<p><em>探索深度优先算法</em><br>对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DFS = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> d = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    f[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    d[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    p[vertices[i]] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      DFSVisit(vertices[i], color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">discovery</span>: d, <span class=\"comment\">// 顶点 u 的发现时间 d[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">finished</span>: f, <span class=\"comment\">// 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">predecessors</span>: p, <span class=\"comment\">// 顶点 u 的前溯点 p[u]</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DFSVisit = <span class=\"function\">(<span class=\"params\">u, color, d, f, p, time, adjList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY;</span><br><span class=\"line\">  d[u] = ++time.count; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      p[w] = u; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      DFSVisit(w, color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK;</span><br><span class=\"line\">  f[u] = ++time.count; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；<br>(2)对于所有的顶点 u，d[u] &lt; f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。<br>在这两个假设下，我们有如下的规则。<br><em>1 &lt;= d [u] &lt; f [u] &lt;= 2|V|</em><br>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间<br><img src=\"/2022/10/08/37-data-structure5/graph-10.png\" alt=\"graph-10\"></p>\n<p><strong>拓扑排序——使用深度优先搜索</strong><br><img src=\"/2022/10/08/37-data-structure5/graph-11.png\" alt=\"graph-11\"><br>有向无环图（DAG）</p>\n<p>需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）</p>\n<p><em>拓扑排序只能应用于 DAG</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = <span class=\"keyword\">new</span> Graph(<span class=\"literal\">true</span>); <span class=\"comment\">// 有向图</span></span><br><span class=\"line\">myVertices = [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  graph.addVertex(myVertices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = DFS(graph);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-12.png\" alt=\"graph-12\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fTimes = result.finished;</span><br><span class=\"line\">s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> count = <span class=\"number\">0</span>; count &lt; myVertices.length; count++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxName = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fTimes[myVertices[i]] &gt; max) &#123;</span><br><span class=\"line\">      max = fTimes[myVertices[i]];</span><br><span class=\"line\">      maxName = myVertices[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s += <span class=\"string\">&#x27; - &#x27;</span> + maxName;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> fTimes[maxName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\"><span class=\"comment\">// B - A - D - C - F - E</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h6><p><em>Dijkstra 算法</em><br>Dijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p>\n<p><img src=\"/2022/10/08/37-data-structure5/graph-13.png\" alt=\"graph-13\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dijkstra = <span class=\"function\">(<span class=\"params\">graph, src</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = INF; <span class=\"comment\">// 把所有的距离（dist）初始化为无限大</span></span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dist[src] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; 把源顶点到自己的距离设为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minDistance(dist, visited); <span class=\"comment\">// &#123;4&#125; 从尚未处理的顶点中选出距离最近的顶点</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125; 把选出的顶点标为 visited，以免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !visited[v] &amp;&amp;</span><br><span class=\"line\">        graph[u][v] !== <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        dist[u] !== INF &amp;&amp;</span><br><span class=\"line\">        dist[u] + graph[u][v] &lt; dist[v]</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到更短的路径，则更新最短路径的值</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        dist[v] = dist[u] + graph[u][v]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// 3 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4 4</span></span><br><span class=\"line\"><span class=\"comment\">// 5 6</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Floyd-Warshall 算法</strong><br>Floyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floydWarshall = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">        dist[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">isFinite</span>(graph[i][j])) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果两个顶点之间没有边，就将其表示为 Infinity</span></span><br><span class=\"line\">        dist[i][j] = <span class=\"literal\">Infinity</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为 i 到 j 可能的最短距离就是这些顶点间的权值</span></span><br><span class=\"line\">        dist[i][j] = graph[i][j]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将顶点 0 到 k 作为中间点（行&#123;5&#125;），从 i 到 j 的最短路径经过 k。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; length; k++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算通过顶点 k 的 i 和 j 之间的最短路径</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">          dist[i][j] = dist[i][k] + dist[k][j]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 0 2 4 6 4 6</span></span><br><span class=\"line\"><span class=\"comment\">// INF 0 2 4 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF 0 6 3 5</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 0 INF 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 3 0 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树(MST)\"></a>最小生成树(MST)</h6><p><strong>Prim 算法</strong><br>Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> prim = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> key = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"comment\">// 把所有顶点（key）初始化为无限大</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    key[i] = INF;</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1</span></span><br><span class=\"line\">  key[<span class=\"number\">0</span>] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  parent[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minKey(graph, key, visited); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        parent[v] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        key[v] = graph[u][v]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, key, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist[key].length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[key][v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[key][v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Edge Weight</span></span><br><span class=\"line\"><span class=\"comment\">// 0 - 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 2 2</span></span><br><span class=\"line\"><span class=\"comment\">// 5 - 3 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 4 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4 - 5 2</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Kruskal 算法</strong><br>是一种求加权无向连通图的 MST 的贪心算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> kruskal = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> u;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> v;</span><br><span class=\"line\">  <span class=\"comment\">// 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> cost = initializeCost(graph); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 当 MST 的边数小于顶点总数减 1 时</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ne &lt; length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出权值最小的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class=\"line\">          min = cost[i][j];</span><br><span class=\"line\">          a = u = i;</span><br><span class=\"line\">          b = v = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查 MST 中是否已存在这条边，以避免环路</span></span><br><span class=\"line\">    u = find(u, parent); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    v = find(v, parent); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 u 和 v 是不同的边，则将其加入 MST</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (union(u, v, parent)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      ne++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ：从列表中移除这些边，以免重复计算</span></span><br><span class=\"line\">    cost[a][b] = cost[b][a] = INF; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> find = <span class=\"function\">(<span class=\"params\">i, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (parent[i]) &#123;</span><br><span class=\"line\">    i = parent[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> union = <span class=\"function\">(<span class=\"params\">i, j, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i !== j) &#123;</span><br><span class=\"line\">    parent[j] = i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"二叉堆和堆排序\"><a href=\"#二叉堆和堆排序\" class=\"headerlink\" title=\"二叉堆和堆排序\"></a>二叉堆和堆排序</h4><h6 id=\"二叉堆数据结构\"><a href=\"#二叉堆数据结构\" class=\"headerlink\" title=\"二叉堆数据结构\"></a>二叉堆数据结构</h6><p>(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。<br>(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性<br><img src=\"/2022/10/08/37-data-structure5/heat.png\" alt=\"heat\"></p>\n<p>二叉树有两种表示方式<br>第一种是使用一个动态的表示方式，也就是指针（用节点表示）<br>第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。<br><img src=\"/2022/10/08/37-data-structure5/min-heat.png\" alt=\"min-heat\"></p>\n<p>访问使用普通数组的二叉树节点:<br>它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；<br>它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；<br>它的父节点位置是 index / 2（如果位置可用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defaultCompare &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = compareFn; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.heap = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getLeftIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getRightIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * index + <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getParentIndex</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor((index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.heap.push(value); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftUp(<span class=\"built_in\">this</span>.heap.length - <span class=\"number\">1</span>); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 上移操作</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftUp</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">      index &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[parent], <span class=\"built_in\">this</span>.heap[index]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, parent, index); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      index = parent;</span><br><span class=\"line\">      parent = <span class=\"built_in\">this</span>.getParentIndex(index); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">array, a, b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> temp = array[a]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      array[a] = array[b]; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      array[b] = temp; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">size</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isEmpty</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size() === <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">findMinimum</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.isEmpty() ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">this</span>.heap[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">extract</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size() === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> removedValue = <span class=\"built_in\">this</span>.heap.shift(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.siftDown(<span class=\"number\">0</span>); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> removedValue; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">siftDown</span>(<span class=\"params\">index</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = index;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = <span class=\"built_in\">this</span>.getLeftIndex(index); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = <span class=\"built_in\">this</span>.getRightIndex(index); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> size = <span class=\"built_in\">this</span>.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      left &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[left]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      element = left; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      right &lt; size &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.compareFn(<span class=\"built_in\">this</span>.heap[element], <span class=\"built_in\">this</span>.heap[right]) &gt; Compare.BIGGER_THAN</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      element = right; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== element) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      swap(<span class=\"built_in\">this</span>.heap, index, element); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.siftDown(element); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/min-heat-pic.png\" alt=\"min-heat-pic\"></p>\n<p><strong>创建最大堆类</strong><br>MaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有&gt;（大于）的比较换成&lt;（小于）的比较。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reverseCompare</span>(<span class=\"params\">compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> compareFn(b, a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MaxHeap</span> <span class=\"keyword\">extends</span> <span class=\"title\">MinHeap</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">compareFn = defaultCompare</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(compareFn);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compareFn = reverseCompare(compareFn); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆排序算法</strong><br>(1) 用数组创建一个最大堆用作源数据。<br>(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。<br>(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> heapSize = array.length;</span><br><span class=\"line\">  buildMaxHeap(array, compareFn); <span class=\"comment\">// 步骤 1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (heapSize &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    swap(array, <span class=\"number\">0</span>, --heapSize); <span class=\"comment\">// 步骤 2</span></span><br><span class=\"line\">    heapify(array, <span class=\"number\">0</span>, heapSize, compareFn); <span class=\"comment\">// 步骤 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildMaxHeap</span>(<span class=\"params\">array, compareFn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(array.length / <span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i -= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    heapify(array, i, array.length, compareFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>heapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法<br><img src=\"/2022/10/08/37-data-structure5/heap-sort.png\" alt=\"heap-sort\"></p>\n<p><strong>堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。</strong></p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><h6 id=\"图的相关术语\"><a href=\"#图的相关术语\" class=\"headerlink\" title=\"图的相关术语\"></a>图的相关术语</h6><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）<br>G = (V, E)<br>V: 一组顶点<br>E: 一组边，连接 V 中的顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-1.png\" alt=\"graph-1\"></p>\n<p>由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。<br>一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。<br>路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。<br>简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。<br>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p>\n<p><strong>有向图和无向图</strong><br>图可以是无向的（边没有方向）或是有向的（有向图）。<br>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。<br><img src=\"/2022/10/08/37-data-structure5/graph-2.png\" alt=\"graph-2\"><br>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。<br><img src=\"/2022/10/08/37-data-structure5/graph-3.png\" alt=\"graph-3\"></p>\n<h6 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h6><p><strong>邻接矩阵</strong><br>每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-4.png\" alt=\"graph-4\"><br><em>缺点：</em><br>(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。<br>(2)顶点的数量可能会改变，而二维数组不太灵活</p>\n<p><strong>邻接表</strong><br>邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。<br>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表<br><img src=\"/2022/10/08/37-data-structure5/graph-5.png\" alt=\"graph-5\"></p>\n<p><strong>关联矩阵</strong><br>在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0<br><img src=\"/2022/10/08/37-data-structure5/graph-6.png\" alt=\"graph-6\"><br><em>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存</em></p>\n<h6 id=\"创建-Graph-类\"><a href=\"#创建-Graph-类\" class=\"headerlink\" title=\"创建 Graph 类\"></a>创建 Graph 类</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">isDirected = <span class=\"literal\">false</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示图是否有向</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDirected = isDirected; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  所有顶点的名字</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.vertices = []; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  字典将会使用顶点的名字作为键，邻接顶点列表作为值</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList = <span class=\"keyword\">new</span> Dictionary(); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//  一个用来向图中添加一个新的顶点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addVertex</span>(<span class=\"params\">v</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.vertices.includes(v)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.vertices.push(v); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.set(v, []); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 来添加顶点之间的边</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">addEdge</span>(<span class=\"params\">v, w</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(v)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(v); <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.adjList.get(w)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.addVertex(w); <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.adjList.get(v).push(w); <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isDirected) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.adjList.get(w).push(v); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取顶点列表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getVertices</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.vertices;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取邻接表</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getAdjList</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.adjList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.vertices.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">      s += <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.vertices[i]&#125;</span> -&gt; `</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> neighbors = <span class=\"built_in\">this</span>.adjList.get(<span class=\"built_in\">this</span>.vertices[i]); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">        s += <span class=\"string\">`<span class=\"subst\">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      s += <span class=\"string\">&#x27;\\n&#x27;</span>; <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h6><p><em>作用：</em>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。<br>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>\n<p><strong>广度优先搜索（breadth-first search，BFS）</strong><br><strong>深度优先搜索（depth-first search，DFS）</strong><br><em>不同点：</em>待访问顶点列表的数据结构<br>| 算 法        | 数据结构 | 描 述                                                          |<br>| ———— | ——– | ————————————————————– |<br>| 深度优先搜索 | 栈       | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |<br>| 广度优先搜索 | 队列     | 将顶点存入队列，最先入队列的顶点先被探索                       |</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 白色：表示该顶点还没有被访问。</span></span><br><span class=\"line\"><span class=\"comment\">// 灰色：表示该顶点被访问过，但并未被探索过。</span></span><br><span class=\"line\"><span class=\"comment\">// 黑色：表示该顶点被访问过且被完全探索过</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Colors = &#123;</span><br><span class=\"line\">  <span class=\"attr\">WHITE</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">GREY</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">BLACK</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化每个顶点的颜色</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initializeColor = <span class=\"function\">(<span class=\"params\">vertices</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    color[vertices[i]] = Colors.WHITE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>广度优先搜索</strong><br>从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-7.png\" alt=\"graph-7\"><br><em>步骤</em><br>(1) 创建一个队列 Q。<br>(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。<br>(3) 如果 Q 非空，则运行以下步骤：</p>\n<ul>\n<li>(a) 将 u 从 Q 中出队列；</li>\n<li>(b) 标注 u 为被发现的（灰色）；</li>\n<li>(c) 将 u 所有未被访问过的邻点（白色）入队列；</li>\n<li>(d) 标注 u 为已被探索的（黑色）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> breadthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue(); <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue(); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 发现了节点，但尚未完成探索</span></span><br><span class=\"line\">    color[u] = Colors.GREY; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">        color[w] = Colors.GREY; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        queue.enqueue(w); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK; <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 可选回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">      callback(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> printVertex = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Visited vertex: &#x27;</span> + value); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">breadthFirstSearch(graph, myVertices[<span class=\"number\">0</span>], printVertex);</span><br></pre></td></tr></table></figure>\n\n<p><em>使用 BFS 寻找最短路径</em><br>给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BFS = <span class=\"function\">(<span class=\"params\">graph, startVertex</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> distances = &#123;&#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> predecessors = &#123;&#125;; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  queue.enqueue(startVertex);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    distances[vertices[i]] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    predecessors[vertices[i]] = <span class=\"literal\">null</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = queue.dequeue();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">    color[u] = Colors.GREY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">        color[w] = Colors.GREY;</span><br><span class=\"line\">        distances[w] = distances[u] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        predecessors[w] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        queue.enqueue(w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    color[u] = Colors.BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    distances, <span class=\"comment\">// 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u]</span></span><br><span class=\"line\">    predecessors, <span class=\"comment\">// 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shortestPathA = BFS(graph, myVertices[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shortestPathA);</span><br><span class=\"line\"><span class=\"comment\">// distances: &#123;A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// predecessors: &#123;A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G: &quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fromVertex = myVertices[<span class=\"number\">0</span>]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> toVertex = myVertices[i]; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 创建一个栈</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"keyword\">new</span> Stack(); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">    path.push(v); <span class=\"comment\">// &#123;14&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  path.push(fromVertex); <span class=\"comment\">// &#123;15&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> s = path.pop(); <span class=\"comment\">// &#123;16&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!path.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;17&#125;</span></span><br><span class=\"line\">    s += <span class=\"string\">&#x27; - &#x27;</span> + path.pop(); <span class=\"comment\">// &#123;18&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s); <span class=\"comment\">// &#123;19&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// A - B</span></span><br><span class=\"line\"><span class=\"comment\">// A - C</span></span><br><span class=\"line\"><span class=\"comment\">// A - D</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - F</span></span><br><span class=\"line\"><span class=\"comment\">// A - C - G</span></span><br><span class=\"line\"><span class=\"comment\">// A - D - H</span></span><br><span class=\"line\"><span class=\"comment\">// A - B - E - I</span></span><br></pre></td></tr></table></figure>\n\n<p><em>深入学习最短路径算法</em><br>Dijkstra 算法解决了单源最短路径问题。<br>Bellman-Ford 算法解决了边权值为负的单源最短路径问题。<br>A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。<br>Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题</p>\n<p><strong>深度优先搜索</strong><br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点<br><img src=\"/2022/10/08/37-data-structure5/graph-8.png\" alt=\"graph-8\"></p>\n<p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。<br><em>步骤</em><br>(1) 标注 v 为被发现的（灰色）；<br>(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；<br>(3) 标注 v 为已被探索的（黑色）。</p>\n<p>深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearch = <span class=\"function\">(<span class=\"params\">graph, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(vertices[i], color, adjList, callback); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> depthFirstSearchVisit = <span class=\"function\">(<span class=\"params\">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    callback(u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i]; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      depthFirstSearchVisit(w, color, adjList, callback); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK; <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">depthFirstSearch(graph, printVertex);</span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: A</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: B</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: E</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: I</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: F</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: C</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: D</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: G</span></span><br><span class=\"line\"><span class=\"comment\">// Visited vertex: H</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-9.png\" alt=\"graph-9\"></p>\n<p><em>Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。</em></p>\n<p><em>探索深度优先算法</em><br>对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DFS = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vertices = graph.getVertices();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> adjList = graph.getAdjList();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> color = initializeColor(vertices);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> d = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    f[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    d[vertices[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    p[vertices[i]] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[vertices[i]] === Colors.WHITE) &#123;</span><br><span class=\"line\">      DFSVisit(vertices[i], color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">discovery</span>: d, <span class=\"comment\">// 顶点 u 的发现时间 d[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">finished</span>: f, <span class=\"comment\">// 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]；</span></span><br><span class=\"line\">    <span class=\"attr\">predecessors</span>: p, <span class=\"comment\">// 顶点 u 的前溯点 p[u]</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DFSVisit = <span class=\"function\">(<span class=\"params\">u, color, d, f, p, time, adjList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  color[u] = Colors.GREY;</span><br><span class=\"line\">  d[u] = ++time.count; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> neighbors = adjList.get(u);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> w = neighbors[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class=\"line\">      p[w] = u; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      DFSVisit(w, color, d, f, p, time, adjList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  color[u] = Colors.BLACK;</span><br><span class=\"line\">  f[u] = ++time.count; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>(1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；<br>(2)对于所有的顶点 u，d[u] &lt; f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。<br>在这两个假设下，我们有如下的规则。<br><em>1 &lt;= d [u] &lt; f [u] &lt;= 2|V|</em><br>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间<br><img src=\"/2022/10/08/37-data-structure5/graph-10.png\" alt=\"graph-10\"></p>\n<p><strong>拓扑排序——使用深度优先搜索</strong><br><img src=\"/2022/10/08/37-data-structure5/graph-11.png\" alt=\"graph-11\"><br>有向无环图（DAG）</p>\n<p>需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort）</p>\n<p><em>拓扑排序只能应用于 DAG</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = <span class=\"keyword\">new</span> Graph(<span class=\"literal\">true</span>); <span class=\"comment\">// 有向图</span></span><br><span class=\"line\">myVertices = [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  graph.addVertex(myVertices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = DFS(graph);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/08/37-data-structure5/graph-12.png\" alt=\"graph-12\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fTimes = result.finished;</span><br><span class=\"line\">s = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> count = <span class=\"number\">0</span>; count &lt; myVertices.length; count++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxName = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fTimes[myVertices[i]] &gt; max) &#123;</span><br><span class=\"line\">      max = fTimes[myVertices[i]];</span><br><span class=\"line\">      maxName = myVertices[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  s += <span class=\"string\">&#x27; - &#x27;</span> + maxName;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> fTimes[maxName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\"><span class=\"comment\">// B - A - D - C - F - E</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h6><p><em>Dijkstra 算法</em><br>Dijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p>\n<p><img src=\"/2022/10/08/37-data-structure5/graph-13.png\" alt=\"graph-13\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGER</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dijkstra = <span class=\"function\">(<span class=\"params\">graph, src</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = INF; <span class=\"comment\">// 把所有的距离（dist）初始化为无限大</span></span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dist[src] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125; 把源顶点到自己的距离设为 0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minDistance(dist, visited); <span class=\"comment\">// &#123;4&#125; 从尚未处理的顶点中选出距离最近的顶点</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125; 把选出的顶点标为 visited，以免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !visited[v] &amp;&amp;</span><br><span class=\"line\">        graph[u][v] !== <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        dist[u] !== INF &amp;&amp;</span><br><span class=\"line\">        dist[u] + graph[u][v] &lt; dist[v]</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到更短的路径，则更新最短路径的值</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        dist[v] = dist[u] + graph[u][v]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// 3 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4 4</span></span><br><span class=\"line\"><span class=\"comment\">// 5 6</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Floyd-Warshall 算法</strong><br>Floyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floydWarshall = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dist = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    dist[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">        dist[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"built_in\">isFinite</span>(graph[i][j])) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果两个顶点之间没有边，就将其表示为 Infinity</span></span><br><span class=\"line\">        dist[i][j] = <span class=\"literal\">Infinity</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为 i 到 j 可能的最短距离就是这些顶点间的权值</span></span><br><span class=\"line\">        dist[i][j] = graph[i][j]; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将顶点 0 到 k 作为中间点（行&#123;5&#125;），从 i 到 j 的最短路径经过 k。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; length; k++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算通过顶点 k 的 i 和 j 之间的最短路径</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">          dist[i][j] = dist[i][k] + dist[k][j]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 0 2 4 6 4 6</span></span><br><span class=\"line\"><span class=\"comment\">// INF 0 2 4 2 4</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF 0 6 3 5</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 0 INF 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF 3 0 2</span></span><br><span class=\"line\"><span class=\"comment\">// INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树(MST)\"></a>最小生成树(MST)</h6><p><strong>Prim 算法</strong><br>Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> INF = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\"><span class=\"keyword\">const</span> prim = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> key = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> visited = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"comment\">// 把所有顶点（key）初始化为无限大</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    key[i] = INF;</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1</span></span><br><span class=\"line\">  key[<span class=\"number\">0</span>] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">  parent[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> u = minKey(graph, key, visited); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; length; v++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">        parent[v] = u; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">        key[v] = graph[u][v]; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minDistance = <span class=\"function\">(<span class=\"params\">dist, key, visited</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = INF;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v = <span class=\"number\">0</span>; v &lt; dist[key].length; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (visited[v] === <span class=\"literal\">false</span> &amp;&amp; dist[key][v] &lt;= min) &#123;</span><br><span class=\"line\">      min = dist[key][v];</span><br><span class=\"line\">      minIndex = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minIndex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Edge Weight</span></span><br><span class=\"line\"><span class=\"comment\">// 0 - 1 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 2 2</span></span><br><span class=\"line\"><span class=\"comment\">// 5 - 3 2</span></span><br><span class=\"line\"><span class=\"comment\">// 1 - 4 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4 - 5 2</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Kruskal 算法</strong><br>是一种求加权无向连通图的 MST 的贪心算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> kruskal = <span class=\"function\">(<span class=\"params\">graph</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = graph;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> u;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> v;</span><br><span class=\"line\">  <span class=\"comment\">// 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> cost = initializeCost(graph); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 当 MST 的边数小于顶点总数减 1 时</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ne &lt; length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出权值最小的边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class=\"line\">          min = cost[i][j];</span><br><span class=\"line\">          a = u = i;</span><br><span class=\"line\">          b = v = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查 MST 中是否已存在这条边，以避免环路</span></span><br><span class=\"line\">    u = find(u, parent); <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    v = find(v, parent); <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 u 和 v 是不同的边，则将其加入 MST</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (union(u, v, parent)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      ne++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ：从列表中移除这些边，以免重复计算</span></span><br><span class=\"line\">    cost[a][b] = cost[b][a] = INF; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> find = <span class=\"function\">(<span class=\"params\">i, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (parent[i]) &#123;</span><br><span class=\"line\">    i = parent[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> union = <span class=\"function\">(<span class=\"params\">i, j, parent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i !== j) &#123;</span><br><span class=\"line\">    parent[j] = i;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"42-js-equal-type","date":"2022-10-26T06:24:02.000Z","_content":"\n#### javascript中的相等比较算法\n\n","source":"_posts/41-js-equal-type.md","raw":"---\ntitle: 42-js-equal-type\ndate: 2022-10-26 14:24:02\ntags:\n---\n\n#### javascript中的相等比较算法\n\n","slug":"41-js-equal-type","published":1,"updated":"2022-10-26T09:26:49.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx5001kcktt4st45hhz","content":"<h4 id=\"javascript中的相等比较算法\"><a href=\"#javascript中的相等比较算法\" class=\"headerlink\" title=\"javascript中的相等比较算法\"></a>javascript中的相等比较算法</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"javascript中的相等比较算法\"><a href=\"#javascript中的相等比较算法\" class=\"headerlink\" title=\"javascript中的相等比较算法\"></a>javascript中的相等比较算法</h4>"},{"title":"数据结构与算法阅读笔记(7)","date":"2022-10-13T08:13:40.000Z","_content":"\n#### 算法设计与技巧\n\n###### 分而治之\n\n将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题\n\n分而治之算法可以分成三个部分。\n(1) 分解原问题为多个子问题（原问题的多个小实例）。\n(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。\n(3) 组合这些子问题的解决方式，得到原问题的解。\n\n**二分搜索**\n分解：计算 mid 并搜索数组较小或较大的一半。\n解决：在较小或较大的一半中搜索值。\n合并：这步不需要，因为我们直接返回了索引值。\n\n```javascript\nfunction binarySearchRecursive(\n  array,\n  value,\n  low,\n  high,\n  compareFn = defaultCompare\n) {\n  if (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const element = array[mid];\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {1}\n      return binarySearchRecursive(array, value, mid + 1, high, compareFn);\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {2}\n      return binarySearchRecursive(array, value, low, mid - 1, compareFn);\n    } else {\n      return mid; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\nexport function binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array);\n  const low = 0;\n  const high = sortedArray.length - 1;\n  return binarySearchRecursive(array, value, low, high, compareFn);\n}\n```\n\n![technology-1](technology-1.png)\n\n**动态规划**\n动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。\n\n_注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。_\n\n步骤：\n(1) 定义子问题；\n(2) 实现要反复执行来解决子问题的部分；\n(3) 识别并求解出基线条件。\n\n_能用动态规划解决的一些著名问题如下。_\n(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。\n(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。\n(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。\n(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。\n(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)\n\n_最少硬币找零问题_\n最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。\n\n```javascript\n// coins 硬币面额的数组\nfunction minCoinChange(coins, amount) {\n  const cache = []; // {1}\n  const makeChange = (value) => {\n    // {2}\n    if (!value) {\n      // {3}\n      return [];\n    }\n    if (cache[value]) {\n      // {4}\n      return cache[value];\n    }\n    let min = [];\n    let newMin;\n    let newAmount;\n    for (let i = 0; i < coins.length; i++) {\n      // {5}\n      const coin = coins[i];\n      newAmount = value - coin; // {6}\n      if (newAmount >= 0) {\n        newMin = makeChange(newAmount); // {7}\n      }\n      if (\n        newAmount >= 0 && // {8}\n        (newMin.length < min.length - 1 || !min.length) && // {9}\n        (newMin.length || !newAmount) // {10}\n      ) {\n        min = [coin].concat(newMin); // {11}\n        console.log('new Min ' + min + ' for ' + amount);\n      }\n    }\n    return (cache[value] = min); // {12}\n  };\n  return makeChange(amount); // {13}\n}\n```\n\n_背包问题_\n背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。\n\n```javascript\nfunction knapSack(capacity, weights, values, n) {\n  const kS = [];\n  // 初始化将用于寻找解决方案的矩阵\n  for (let i = 0; i <= n; i++) {\n    kS[i] = [];\n  }\n  for (let i = 0; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (i === 0 || w === 0) {\n        // {2}\n        kS[i][w] = 0;\n      } else if (weights[i - 1] <= w) {\n        // 。物品 i 的重量必须小于约束\n        const a = values[i - 1] + kS[i - 1][w - weights[i - 1]];\n        const b = kS[i - 1][w];\n        // 当找到可以构成解决方案的物品时，选择价值最大的那个\n        kS[i][w] = a > b ? a : b; // {4} max(a,b)\n      } else {\n        kS[i][w] = kS[i - 1][w]; // {5}\n      }\n    }\n  }\n  findValues(n, capacity, kS, weights, values); // {6} 增加的代码\n  return kS[n][capacity]; // {7}\n}\n\nfunction findValues(n, capacity, kS, weights, values) {\n  let i = n;\n  let k = capacity;\n  console.log('构成解的物品：');\n  while (i > 0 && k > 0) {\n    if (kS[i][k] !== kS[i - 1][k]) {\n      console.log(\n        `物品 ${i} 可以是解的一部分 w,v: ${weights[i - 1]}, ${values[i - 1]}`\n      );\n      i--;\n      k -= kS[i][k];\n    } else {\n      i--;\n    }\n  }\n}\n```\n\n![technology-2](technology-2.png)\n\n_最长公共子序列(LCS)_\n找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。\n![technology-3](technology-3.png)\n\n```javascript\nfunction lcs(wordX, wordY) {\n  const m = wordX.length;\n  const n = wordY.length;\n  const l = [];\n  for (let i = 0; i <= m; i++) {\n    l[i] = []; // {1}\n    // solution[i] = [];\n    for (let j = 0; j <= n; j++) {\n      l[i][j] = 0; // {2}\n      // solution[i][j] = '0';\n    }\n  }\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      if (i === 0 || j === 0) {\n        l[i][j] = 0;\n      } else if (wordX[i - 1] === wordY[j - 1]) {\n        l[i][j] = l[i - 1][j - 1] + 1; // {3}\n        // solution[i][j] = 'diagonal';\n      } else {\n        const a = l[i - 1][j];\n        const b = l[i][j - 1];\n        l[i][j] = a > b ? a : b; // {4} max(a,b)\n        // solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';\n      }\n    }\n  }\n  return l[m][n]; // {5}\n  // printSolution(solution, wordX, m, n);\n}\n\nfunction printSolution(solution, wordX, m, n) {\n  let a = m;\n  let b = n;\n  let x = solution[a][b];\n  let answer = '';\n  while (x !== '0') {\n    if (solution[a][b] === 'diagonal') {\n      answer = wordX[a - 1] + answer;\n      a--;\n      b--;\n    } else if (solution[a][b] === 'left') {\n      b--;\n    } else if (solution[a][b] === 'top') {\n      a--;\n    }\n    x = solution[a][b];\n  }\n  console.log('lcs: ' + answer);\n}\n```\n\n![technology-4](technology-4.png)\n\n_矩阵链相乘_\n要找出一组矩阵相乘的最佳方式（顺序）\n\nA*B*C\\*D 的乘法\n\nA 是一个 10 行 100 列的矩阵；\nB 是一个 100 行 5 列的矩阵；\nC 是一个 5 行 50 列的矩阵；\nD 是一个 50 行 1 列的矩阵；\nA*B*C\\*D 的结果是一个 10 行 1 列的矩阵\n\n(1) (A(B(CD)))：乘法运算的次数是 1750 次。\n(2) ((AB)(CD))：乘法运算的次数是 5300 次。\n(3) (((AB)C)D)：乘法运算的次数是 8000 次。\n(4) ((A(BC))D)：乘法运算的次数是 75 500 次。\n(5) (A((BC)D))：乘法运算的次数是 31 000 次。\n\n```javascript\nfunction matrixChainOrder(p) {\n  const n = p.length;\n  const m = [];\n  const s = [];\n  for (let i = 1; i <= n; i++) {\n    m[i] = [];\n    m[i][i] = 0;\n  }\n\n  //   const s = [];\n  // for (let i = 0; i <= n; i++){\n  //  s[i] = [];\n  //  for (let j=0; j <= n; j++){\n  //  s[i][j] = 0;\n  //  }\n  // }\n\n  for (let l = 2; l < n; l++) {\n    for (let i = 1; i <= n - l + 1; i++) {\n      const j = i + l - 1;\n      m[i][j] = Number.MAX_SAFE_INTEGER;\n      for (let k = i; k <= j - 1; k++) {\n        const q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // {1}\n        if (q < m[i][j]) {\n          m[i][j] = q; // {2}\n          // s[i][j] = k;\n        }\n      }\n    }\n  }\n  return m[1][n - 1]; // {3}\n  // printOptimalParenthesis(s, 1, n-1);\n}\n\nfunction printOptimalParenthesis(s, i, j) {\n  if (i === j) {\n    console.log('A[' + i + ']');\n  } else {\n    console.log('(');\n    printOptimalParenthesis(s, i, s[i][j]);\n    printOptimalParenthesis(s, s[i][j] + 1, j);\n    console.log(')');\n  }\n}\n// (A[1](A[2](A[3]A[4]))) => (A(B(CD)))\n```\n\n###### 贪心算法\n\n贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。\n\n**最少硬币找零问题**\n\n```javascript\nfunction minCoinChange(coins, amount) {\n  const change = [];\n  let total = 0;\n  for (let i = coins.length; i >= 0; i--) {\n    // {1}\n    const coin = coins[i];\n    while (total + coin <= amount) {\n      // {2}\n      change.push(coin); // {3}\n      total += coin; // {4}\n    }\n  }\n  return change;\n}\n```\n\n![technology-5](technology-5.png)\n\n_比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。_\n\n**分数背包问题**\n\n```javascript\nfunction knapSack(capacity, weights, values) {\n  const n = values.length;\n  let load = 0;\n  let val = 0;\n  for (let i = 0; i < n && load < capacity; i++) {\n    // {1}\n    if (weights[i] <= capacity - load) {\n      // {2}\n      val += values[i];\n      load += weights[i];\n    } else {\n      const r = (capacity - load) / weights[i]; // {3}\n      val += r * values[i];\n      load += weights[i];\n    }\n  }\n  return val;\n}\n```\n\n###### 回溯算法\n\n回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。\n\n**迷宫老鼠问题**\n\n```javascript\nexport function ratInAMaze(maze) {\n  const solution = [];\n  // 每个位置初始化为零\n  for (let i = 0; i < maze.length; i++) {\n    // {1}\n    solution[i] = [];\n    for (let j = 0; j < maze[i].length; j++) {\n      solution[i][j] = 0;\n    }\n  }\n  if (findPath(maze, 0, 0, solution) === true) {\n    // {2}\n    return solution;\n  }\n  return 'NO PATH FOUND'; // {3}\n}\n\nfunction findPath(maze, x, y, solution) {\n  const n = maze.length;\n  if (x === n - 1 && y === n - 1) {\n    // {4}\n    solution[x][y] = 1;\n    return true;\n  }\n  if (isSafe(maze, x, y) === true) {\n    // {5}\n    solution[x][y] = 1; // {6}\n    if (findPath(maze, x + 1, y, solution)) {\n      // {7}\n      return true;\n    }\n    if (findPath(maze, x, y + 1, solution)) {\n      // {8}\n      return true;\n    }\n    solution[x][y] = 0; // {9}\n    return false;\n  }\n  return false; // {10}\n}\n\nfunction isSafe(maze, x, y) {\n  const n = maze.length;\n  if (x >= 0 && y >= 0 && x < n && y < n && maze[x][y] !== 0) {\n    return true; // {11}\n  }\n  return false;\n}\n\nconst maze = [\n  [1, 0, 0, 0],\n  [1, 1, 1, 1],\n  [0, 0, 1, 0],\n  [0, 1, 1, 1],\n];\nconsole.log(ratInAMaze(maze));\n[\n  [1, 0, 0, 0],\n  [1, 1, 1, 0],\n  [0, 0, 1, 0],\n  [0, 0, 1, 1],\n];\n```\n\n**数独解题器**\n\n```javascript\nfunction sudokuSolver(matrix) {\n  if (solveSudoku(matrix) === true) {\n    return matrix;\n  }\n  return '问题无解！';\n}\n\nconst UNASSIGNED = 0;\nfunction solveSudoku(matrix) {\n  let row = 0;\n  let col = 0;\n  let checkBlankSpaces = false;\n  for (row = 0; row < matrix.length; row++) {\n    // {1}\n    for (col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] === UNASSIGNED) {\n        checkBlankSpaces = true; // {2}\n        break;\n      }\n    }\n    if (checkBlankSpaces === true) {\n      // {3}\n      break;\n    }\n  }\n  if (checkBlankSpaces === false) {\n    return true; // {4}\n  }\n  for (let num = 1; num <= 9; num++) {\n    // {5}\n    if (isSafe(matrix, row, col, num)) {\n      // {6}\n      matrix[row][col] = num; // {7}\n      if (solveSudoku(matrix)) {\n        // {8}\n        return true;\n      }\n      matrix[row][col] = UNASSIGNED; // {9}\n    }\n  }\n  return false; // {10}\n}\nfunction isSafe(matrix, row, col, num) {\n  return (\n    !usedInRow(matrix, row, num) &&\n    !usedInCol(matrix, col, num) &&\n    !usedInBox(matrix, row - (row % 3), col - (col % 3), num)\n  );\n}\n\nfunction usedInRow(matrix, row, num) {\n  for (let col = 0; col < matrix.length; col++) {\n    // {11}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInCol(matrix, col, num) {\n  for (let row = 0; row < matrix.length; row++) {\n    // {12}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInBox(matrix, boxStartRow, boxStartCol, num) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (matrix[row + boxStartRow][col + boxStartCol] === num) {\n        // {13}\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst sudokuGrid = [\n  [5, 3, 0, 0, 7, 0, 0, 0, 0],\n  [6, 0, 0, 1, 9, 5, 0, 0, 0],\n  [0, 9, 8, 0, 0, 0, 0, 6, 0],\n  [8, 0, 0, 0, 6, 0, 0, 0, 3],\n  [4, 0, 0, 8, 0, 3, 0, 0, 1],\n  [7, 0, 0, 0, 2, 0, 0, 0, 6],\n  [0, 6, 0, 0, 0, 0, 2, 8, 0],\n  [0, 0, 0, 4, 1, 9, 0, 0, 5],\n  [0, 0, 0, 0, 8, 0, 0, 7, 9],\n];\nconsole.log(sudokuSolver(sudokuGrid));\n[\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9],\n];\n```\n\n###### 函数式编程(FP)简介\n\n**函数式编程与命令式编程**\n\n```javascript\n// 命令式编程\nconst printArray = function (array) {\n  for (var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n  }\n};\nprintArray([1, 2, 3, 4, 5]);\n\n// 函数式编程\nconst forEach = function (array, action) {\n  for (var i = 0; i < array.length; i++) {\n    action(array[i]);\n  }\n};\nconst logItem = function (item) {\n  console.log(item);\n};\nforEach([1, 2, 3, 4, 5], logItem);\n```\n\n_注意：_\n(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。\n(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。\n(3)函数和数据集合是函数式编程的核心。\n(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。\n(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。\n\n**JavaScript 函数式类库和数据结构**\nUnderscode.js：http://underscorejs.org/\nBilby.js：http://bilby.brianmckenna.org/\nLazy.js：http://danieltao.com/lazy.js/\nBacon.js：https://baconjs.github.io/\nFn.js：http://eliperelman.com/fn.js/\nFunctional.js：http://functionaljs.com/\nRamda.js：http://ramdajs.com/0.20.1/index.html\nMori：http://swannodette.github.io/mori/\n\nJavaScript 函数式编程：https://www.packtpub.com/web-development/functional-programming-javascript\n\n#### 算法复杂度\n\n###### 大 O 表示法\n\n用于描述算法的性能和复杂程度。\n大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。\n\n| 符 号        | 名 称        |\n| ------------ | ------------ |\n| O(1)         | 常数的       |\n| O(log(n))    | 对数的       |\n| O((log(n))c) | 对数多项式的 |\n| O(n)         | 线性的       |\n| O(n^2)       | 二次的       |\n| O(n^c)       | 多项式的     |\n| O(c^n)       | 指数的       |\n\n**理解大 O 表示法**\n\n衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。\n\n1. O(1)\n\n```javascript\nfunction increment(num) {\n  return ++num;\n}\n```\n\n假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）\n\n2. O(n)\n\n函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。\n\n以顺序搜索算法为例\n\n```javascript\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    if (equalsFn(value, array[i])) {\n      // {1}\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  let cost = 0;\n  for (let i = 0; i < array.length; i++) {\n    cost++;\n    if (equalsFn(value, array[i])) {\n      return i;\n    }\n  }\n  console.log(\n    `cost for sequentialSearch with input size ${array.length} is ${cost}`\n  );\n  return -1;\n}\n```\n\n3. O(n^2)\n\n以冒泡排序为例\n\n```javascript\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n\n// 假设行{1}和行{2}的开销分别是 1。修改算法的实现使之计算开销。\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  let cost = 0;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    cost++;\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      cost++;\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  console.log(`cost for bubbleSort with input size ${length} is ${cost}`);\n  return array;\n}\n```\n\n如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久\n\n*时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)*\n\n**时间复杂度比较**\n\n| 输入大小（n） | O(1) | O(log(n)) | O(n)   | O(nlog(n)) | O(n^2)      | O(2^n)    |\n| ------------- | ---- | --------- | ------ | ---------- | ----------- | --------- |\n| 10            | 1    | 1         | 10     | 10         | 100         | 1024      |\n| 20            | 1    | 1.30      | 20     | 26.02      | 400         | 1 048 576 |\n| 50            | 1    | 1.69      | 50     | 84.94      | 2500        | 非常大    |\n| 100           | 1    | 2         | 100    | 200        | 10 000      | 非常大    |\n| 500           | 1    | 2.69      | 500    | 1349.48    | 250 000     | 非常大    |\n| 1000          | 1    | 3         | 1000   | 3000       | 1 000 000   | 非常大    |\n| 10 000        | 1    | 4         | 10 000 | 40 000     | 100 000 000 | 非常大    |\n\n不同的大 O 表示法的消耗\n\n![big-o-1](big-o-1.png)\n\n*常用数据结构的时间复杂度*\n![big-o-2](big-o-2.png)\n\n*图的时间复杂度*\n![big-o-3](big-o-3.png)\n\n*排序算法的时间复杂度*\n![big-o-4](big-o-4.png)\n\n*搜索算法的时间复杂度*\n![big-o-5](big-o-5.png)\n\n**NP 完全理论概述**\n一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.\n\n对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）\n\nNP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP\n\n如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。\n\nNP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：\n(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；\n(2) 所有的 NP 问题都能在多项式时间内归约为 L。\n\n为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。\n\n还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。\n\n下面是满足 P<>NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。\n![big-o-6](big-o-6.png)\n\n非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。\n\nNP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。\n\n以上问题，具体可查看：https://en.wikipedia.org/wiki/NP-completeness\n\n*不可解问题与启发式算法*\n有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。\n启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。\n启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。\n详情请查阅 https://en.wikipedia.org/wiki/Heuristic_(computer_science)\n\nUVa Online Judge（http://uva.onlinejudge.org/）\nSphere Online Judge（http://www.spoj.com/）\nCoderbyte（http://coderbyte.com/）\nProject Euler（https://projecteuler.net/）\nHackerRank（https://www.hackerrank.com）\nCodeChef（http://www.codechef.com/）\nTop Coder（http://www.topcoder.com/）\n\n\n#### 疑问点\n尾调用优化\n- 调用栈长\n- 使用后性能有较大的提升\nFloyd-Warshall 算法\nKruskal 算法\n背包问题\n最长公共子序列\n矩阵链相乘\nNP 完全理论\n- 多项式时间\n\n算法的使用，什么情况下用合适？需要将数据转换处理\n合适\n\n自己写的算法怎么验证正确性？\nLeetCode或其他刷题网站\n\nantd升级后的visible修改任务\n评估修改时间\ntesting-library/react测试react组件的库，安装了却没用？\numc-ui的项目框架使用的是别的项目的，原来就有，没删","source":"_posts/39-data-structure7.md","raw":"---\ntitle: 数据结构与算法阅读笔记(7)\ndate: 2022-10-13 16:13:40\ntags:\n---\n\n#### 算法设计与技巧\n\n###### 分而治之\n\n将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题\n\n分而治之算法可以分成三个部分。\n(1) 分解原问题为多个子问题（原问题的多个小实例）。\n(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。\n(3) 组合这些子问题的解决方式，得到原问题的解。\n\n**二分搜索**\n分解：计算 mid 并搜索数组较小或较大的一半。\n解决：在较小或较大的一半中搜索值。\n合并：这步不需要，因为我们直接返回了索引值。\n\n```javascript\nfunction binarySearchRecursive(\n  array,\n  value,\n  low,\n  high,\n  compareFn = defaultCompare\n) {\n  if (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const element = array[mid];\n    if (compareFn(element, value) === Compare.LESS_THAN) {\n      // {1}\n      return binarySearchRecursive(array, value, mid + 1, high, compareFn);\n    } else if (compareFn(element, value) === Compare.BIGGER_THAN) {\n      // {2}\n      return binarySearchRecursive(array, value, low, mid - 1, compareFn);\n    } else {\n      return mid; // {3}\n    }\n  }\n  return DOES_NOT_EXIST; // {4}\n}\nexport function binarySearch(array, value, compareFn = defaultCompare) {\n  const sortedArray = quickSort(array);\n  const low = 0;\n  const high = sortedArray.length - 1;\n  return binarySearchRecursive(array, value, low, high, compareFn);\n}\n```\n\n![technology-1](technology-1.png)\n\n**动态规划**\n动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。\n\n_注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。_\n\n步骤：\n(1) 定义子问题；\n(2) 实现要反复执行来解决子问题的部分；\n(3) 识别并求解出基线条件。\n\n_能用动态规划解决的一些著名问题如下。_\n(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。\n(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。\n(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。\n(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。\n(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)\n\n_最少硬币找零问题_\n最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。\n\n```javascript\n// coins 硬币面额的数组\nfunction minCoinChange(coins, amount) {\n  const cache = []; // {1}\n  const makeChange = (value) => {\n    // {2}\n    if (!value) {\n      // {3}\n      return [];\n    }\n    if (cache[value]) {\n      // {4}\n      return cache[value];\n    }\n    let min = [];\n    let newMin;\n    let newAmount;\n    for (let i = 0; i < coins.length; i++) {\n      // {5}\n      const coin = coins[i];\n      newAmount = value - coin; // {6}\n      if (newAmount >= 0) {\n        newMin = makeChange(newAmount); // {7}\n      }\n      if (\n        newAmount >= 0 && // {8}\n        (newMin.length < min.length - 1 || !min.length) && // {9}\n        (newMin.length || !newAmount) // {10}\n      ) {\n        min = [coin].concat(newMin); // {11}\n        console.log('new Min ' + min + ' for ' + amount);\n      }\n    }\n    return (cache[value] = min); // {12}\n  };\n  return makeChange(amount); // {13}\n}\n```\n\n_背包问题_\n背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。\n\n```javascript\nfunction knapSack(capacity, weights, values, n) {\n  const kS = [];\n  // 初始化将用于寻找解决方案的矩阵\n  for (let i = 0; i <= n; i++) {\n    kS[i] = [];\n  }\n  for (let i = 0; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (i === 0 || w === 0) {\n        // {2}\n        kS[i][w] = 0;\n      } else if (weights[i - 1] <= w) {\n        // 。物品 i 的重量必须小于约束\n        const a = values[i - 1] + kS[i - 1][w - weights[i - 1]];\n        const b = kS[i - 1][w];\n        // 当找到可以构成解决方案的物品时，选择价值最大的那个\n        kS[i][w] = a > b ? a : b; // {4} max(a,b)\n      } else {\n        kS[i][w] = kS[i - 1][w]; // {5}\n      }\n    }\n  }\n  findValues(n, capacity, kS, weights, values); // {6} 增加的代码\n  return kS[n][capacity]; // {7}\n}\n\nfunction findValues(n, capacity, kS, weights, values) {\n  let i = n;\n  let k = capacity;\n  console.log('构成解的物品：');\n  while (i > 0 && k > 0) {\n    if (kS[i][k] !== kS[i - 1][k]) {\n      console.log(\n        `物品 ${i} 可以是解的一部分 w,v: ${weights[i - 1]}, ${values[i - 1]}`\n      );\n      i--;\n      k -= kS[i][k];\n    } else {\n      i--;\n    }\n  }\n}\n```\n\n![technology-2](technology-2.png)\n\n_最长公共子序列(LCS)_\n找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。\n![technology-3](technology-3.png)\n\n```javascript\nfunction lcs(wordX, wordY) {\n  const m = wordX.length;\n  const n = wordY.length;\n  const l = [];\n  for (let i = 0; i <= m; i++) {\n    l[i] = []; // {1}\n    // solution[i] = [];\n    for (let j = 0; j <= n; j++) {\n      l[i][j] = 0; // {2}\n      // solution[i][j] = '0';\n    }\n  }\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      if (i === 0 || j === 0) {\n        l[i][j] = 0;\n      } else if (wordX[i - 1] === wordY[j - 1]) {\n        l[i][j] = l[i - 1][j - 1] + 1; // {3}\n        // solution[i][j] = 'diagonal';\n      } else {\n        const a = l[i - 1][j];\n        const b = l[i][j - 1];\n        l[i][j] = a > b ? a : b; // {4} max(a,b)\n        // solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';\n      }\n    }\n  }\n  return l[m][n]; // {5}\n  // printSolution(solution, wordX, m, n);\n}\n\nfunction printSolution(solution, wordX, m, n) {\n  let a = m;\n  let b = n;\n  let x = solution[a][b];\n  let answer = '';\n  while (x !== '0') {\n    if (solution[a][b] === 'diagonal') {\n      answer = wordX[a - 1] + answer;\n      a--;\n      b--;\n    } else if (solution[a][b] === 'left') {\n      b--;\n    } else if (solution[a][b] === 'top') {\n      a--;\n    }\n    x = solution[a][b];\n  }\n  console.log('lcs: ' + answer);\n}\n```\n\n![technology-4](technology-4.png)\n\n_矩阵链相乘_\n要找出一组矩阵相乘的最佳方式（顺序）\n\nA*B*C\\*D 的乘法\n\nA 是一个 10 行 100 列的矩阵；\nB 是一个 100 行 5 列的矩阵；\nC 是一个 5 行 50 列的矩阵；\nD 是一个 50 行 1 列的矩阵；\nA*B*C\\*D 的结果是一个 10 行 1 列的矩阵\n\n(1) (A(B(CD)))：乘法运算的次数是 1750 次。\n(2) ((AB)(CD))：乘法运算的次数是 5300 次。\n(3) (((AB)C)D)：乘法运算的次数是 8000 次。\n(4) ((A(BC))D)：乘法运算的次数是 75 500 次。\n(5) (A((BC)D))：乘法运算的次数是 31 000 次。\n\n```javascript\nfunction matrixChainOrder(p) {\n  const n = p.length;\n  const m = [];\n  const s = [];\n  for (let i = 1; i <= n; i++) {\n    m[i] = [];\n    m[i][i] = 0;\n  }\n\n  //   const s = [];\n  // for (let i = 0; i <= n; i++){\n  //  s[i] = [];\n  //  for (let j=0; j <= n; j++){\n  //  s[i][j] = 0;\n  //  }\n  // }\n\n  for (let l = 2; l < n; l++) {\n    for (let i = 1; i <= n - l + 1; i++) {\n      const j = i + l - 1;\n      m[i][j] = Number.MAX_SAFE_INTEGER;\n      for (let k = i; k <= j - 1; k++) {\n        const q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // {1}\n        if (q < m[i][j]) {\n          m[i][j] = q; // {2}\n          // s[i][j] = k;\n        }\n      }\n    }\n  }\n  return m[1][n - 1]; // {3}\n  // printOptimalParenthesis(s, 1, n-1);\n}\n\nfunction printOptimalParenthesis(s, i, j) {\n  if (i === j) {\n    console.log('A[' + i + ']');\n  } else {\n    console.log('(');\n    printOptimalParenthesis(s, i, s[i][j]);\n    printOptimalParenthesis(s, s[i][j] + 1, j);\n    console.log(')');\n  }\n}\n// (A[1](A[2](A[3]A[4]))) => (A(B(CD)))\n```\n\n###### 贪心算法\n\n贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。\n\n**最少硬币找零问题**\n\n```javascript\nfunction minCoinChange(coins, amount) {\n  const change = [];\n  let total = 0;\n  for (let i = coins.length; i >= 0; i--) {\n    // {1}\n    const coin = coins[i];\n    while (total + coin <= amount) {\n      // {2}\n      change.push(coin); // {3}\n      total += coin; // {4}\n    }\n  }\n  return change;\n}\n```\n\n![technology-5](technology-5.png)\n\n_比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。_\n\n**分数背包问题**\n\n```javascript\nfunction knapSack(capacity, weights, values) {\n  const n = values.length;\n  let load = 0;\n  let val = 0;\n  for (let i = 0; i < n && load < capacity; i++) {\n    // {1}\n    if (weights[i] <= capacity - load) {\n      // {2}\n      val += values[i];\n      load += weights[i];\n    } else {\n      const r = (capacity - load) / weights[i]; // {3}\n      val += r * values[i];\n      load += weights[i];\n    }\n  }\n  return val;\n}\n```\n\n###### 回溯算法\n\n回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。\n\n**迷宫老鼠问题**\n\n```javascript\nexport function ratInAMaze(maze) {\n  const solution = [];\n  // 每个位置初始化为零\n  for (let i = 0; i < maze.length; i++) {\n    // {1}\n    solution[i] = [];\n    for (let j = 0; j < maze[i].length; j++) {\n      solution[i][j] = 0;\n    }\n  }\n  if (findPath(maze, 0, 0, solution) === true) {\n    // {2}\n    return solution;\n  }\n  return 'NO PATH FOUND'; // {3}\n}\n\nfunction findPath(maze, x, y, solution) {\n  const n = maze.length;\n  if (x === n - 1 && y === n - 1) {\n    // {4}\n    solution[x][y] = 1;\n    return true;\n  }\n  if (isSafe(maze, x, y) === true) {\n    // {5}\n    solution[x][y] = 1; // {6}\n    if (findPath(maze, x + 1, y, solution)) {\n      // {7}\n      return true;\n    }\n    if (findPath(maze, x, y + 1, solution)) {\n      // {8}\n      return true;\n    }\n    solution[x][y] = 0; // {9}\n    return false;\n  }\n  return false; // {10}\n}\n\nfunction isSafe(maze, x, y) {\n  const n = maze.length;\n  if (x >= 0 && y >= 0 && x < n && y < n && maze[x][y] !== 0) {\n    return true; // {11}\n  }\n  return false;\n}\n\nconst maze = [\n  [1, 0, 0, 0],\n  [1, 1, 1, 1],\n  [0, 0, 1, 0],\n  [0, 1, 1, 1],\n];\nconsole.log(ratInAMaze(maze));\n[\n  [1, 0, 0, 0],\n  [1, 1, 1, 0],\n  [0, 0, 1, 0],\n  [0, 0, 1, 1],\n];\n```\n\n**数独解题器**\n\n```javascript\nfunction sudokuSolver(matrix) {\n  if (solveSudoku(matrix) === true) {\n    return matrix;\n  }\n  return '问题无解！';\n}\n\nconst UNASSIGNED = 0;\nfunction solveSudoku(matrix) {\n  let row = 0;\n  let col = 0;\n  let checkBlankSpaces = false;\n  for (row = 0; row < matrix.length; row++) {\n    // {1}\n    for (col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] === UNASSIGNED) {\n        checkBlankSpaces = true; // {2}\n        break;\n      }\n    }\n    if (checkBlankSpaces === true) {\n      // {3}\n      break;\n    }\n  }\n  if (checkBlankSpaces === false) {\n    return true; // {4}\n  }\n  for (let num = 1; num <= 9; num++) {\n    // {5}\n    if (isSafe(matrix, row, col, num)) {\n      // {6}\n      matrix[row][col] = num; // {7}\n      if (solveSudoku(matrix)) {\n        // {8}\n        return true;\n      }\n      matrix[row][col] = UNASSIGNED; // {9}\n    }\n  }\n  return false; // {10}\n}\nfunction isSafe(matrix, row, col, num) {\n  return (\n    !usedInRow(matrix, row, num) &&\n    !usedInCol(matrix, col, num) &&\n    !usedInBox(matrix, row - (row % 3), col - (col % 3), num)\n  );\n}\n\nfunction usedInRow(matrix, row, num) {\n  for (let col = 0; col < matrix.length; col++) {\n    // {11}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInCol(matrix, col, num) {\n  for (let row = 0; row < matrix.length; row++) {\n    // {12}\n    if (matrix[row][col] === num) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction usedInBox(matrix, boxStartRow, boxStartCol, num) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (matrix[row + boxStartRow][col + boxStartCol] === num) {\n        // {13}\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst sudokuGrid = [\n  [5, 3, 0, 0, 7, 0, 0, 0, 0],\n  [6, 0, 0, 1, 9, 5, 0, 0, 0],\n  [0, 9, 8, 0, 0, 0, 0, 6, 0],\n  [8, 0, 0, 0, 6, 0, 0, 0, 3],\n  [4, 0, 0, 8, 0, 3, 0, 0, 1],\n  [7, 0, 0, 0, 2, 0, 0, 0, 6],\n  [0, 6, 0, 0, 0, 0, 2, 8, 0],\n  [0, 0, 0, 4, 1, 9, 0, 0, 5],\n  [0, 0, 0, 0, 8, 0, 0, 7, 9],\n];\nconsole.log(sudokuSolver(sudokuGrid));\n[\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9],\n];\n```\n\n###### 函数式编程(FP)简介\n\n**函数式编程与命令式编程**\n\n```javascript\n// 命令式编程\nconst printArray = function (array) {\n  for (var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n  }\n};\nprintArray([1, 2, 3, 4, 5]);\n\n// 函数式编程\nconst forEach = function (array, action) {\n  for (var i = 0; i < array.length; i++) {\n    action(array[i]);\n  }\n};\nconst logItem = function (item) {\n  console.log(item);\n};\nforEach([1, 2, 3, 4, 5], logItem);\n```\n\n_注意：_\n(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。\n(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。\n(3)函数和数据集合是函数式编程的核心。\n(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。\n(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。\n\n**JavaScript 函数式类库和数据结构**\nUnderscode.js：http://underscorejs.org/\nBilby.js：http://bilby.brianmckenna.org/\nLazy.js：http://danieltao.com/lazy.js/\nBacon.js：https://baconjs.github.io/\nFn.js：http://eliperelman.com/fn.js/\nFunctional.js：http://functionaljs.com/\nRamda.js：http://ramdajs.com/0.20.1/index.html\nMori：http://swannodette.github.io/mori/\n\nJavaScript 函数式编程：https://www.packtpub.com/web-development/functional-programming-javascript\n\n#### 算法复杂度\n\n###### 大 O 表示法\n\n用于描述算法的性能和复杂程度。\n大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。\n\n| 符 号        | 名 称        |\n| ------------ | ------------ |\n| O(1)         | 常数的       |\n| O(log(n))    | 对数的       |\n| O((log(n))c) | 对数多项式的 |\n| O(n)         | 线性的       |\n| O(n^2)       | 二次的       |\n| O(n^c)       | 多项式的     |\n| O(c^n)       | 指数的       |\n\n**理解大 O 表示法**\n\n衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。\n\n1. O(1)\n\n```javascript\nfunction increment(num) {\n  return ++num;\n}\n```\n\n假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）\n\n2. O(n)\n\n函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。\n\n以顺序搜索算法为例\n\n```javascript\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  for (let i = 0; i < array.length; i++) {\n    if (equalsFn(value, array[i])) {\n      // {1}\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction sequentialSearch(array, value, equalsFn = defaultEquals) {\n  let cost = 0;\n  for (let i = 0; i < array.length; i++) {\n    cost++;\n    if (equalsFn(value, array[i])) {\n      return i;\n    }\n  }\n  console.log(\n    `cost for sequentialSearch with input size ${array.length} is ${cost}`\n  );\n  return -1;\n}\n```\n\n3. O(n^2)\n\n以冒泡排序为例\n\n```javascript\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  return array;\n}\n\n// 假设行{1}和行{2}的开销分别是 1。修改算法的实现使之计算开销。\nfunction bubbleSort(array, compareFn = defaultCompare) {\n  const { length } = array;\n  let cost = 0;\n  for (let i = 0; i < length; i++) {\n    // {1}\n    cost++;\n    for (let j = 0; j < length - 1; j++) {\n      // {2}\n      cost++;\n      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {\n        swap(array, j, j + 1);\n      }\n    }\n  }\n  console.log(`cost for bubbleSort with input size ${length} is ${cost}`);\n  return array;\n}\n```\n\n如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久\n\n*时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)*\n\n**时间复杂度比较**\n\n| 输入大小（n） | O(1) | O(log(n)) | O(n)   | O(nlog(n)) | O(n^2)      | O(2^n)    |\n| ------------- | ---- | --------- | ------ | ---------- | ----------- | --------- |\n| 10            | 1    | 1         | 10     | 10         | 100         | 1024      |\n| 20            | 1    | 1.30      | 20     | 26.02      | 400         | 1 048 576 |\n| 50            | 1    | 1.69      | 50     | 84.94      | 2500        | 非常大    |\n| 100           | 1    | 2         | 100    | 200        | 10 000      | 非常大    |\n| 500           | 1    | 2.69      | 500    | 1349.48    | 250 000     | 非常大    |\n| 1000          | 1    | 3         | 1000   | 3000       | 1 000 000   | 非常大    |\n| 10 000        | 1    | 4         | 10 000 | 40 000     | 100 000 000 | 非常大    |\n\n不同的大 O 表示法的消耗\n\n![big-o-1](big-o-1.png)\n\n*常用数据结构的时间复杂度*\n![big-o-2](big-o-2.png)\n\n*图的时间复杂度*\n![big-o-3](big-o-3.png)\n\n*排序算法的时间复杂度*\n![big-o-4](big-o-4.png)\n\n*搜索算法的时间复杂度*\n![big-o-5](big-o-5.png)\n\n**NP 完全理论概述**\n一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.\n\n对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）\n\nNP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP\n\n如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。\n\nNP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：\n(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；\n(2) 所有的 NP 问题都能在多项式时间内归约为 L。\n\n为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。\n\n还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。\n\n下面是满足 P<>NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。\n![big-o-6](big-o-6.png)\n\n非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。\n\nNP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。\n\n以上问题，具体可查看：https://en.wikipedia.org/wiki/NP-completeness\n\n*不可解问题与启发式算法*\n有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。\n启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。\n启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。\n详情请查阅 https://en.wikipedia.org/wiki/Heuristic_(computer_science)\n\nUVa Online Judge（http://uva.onlinejudge.org/）\nSphere Online Judge（http://www.spoj.com/）\nCoderbyte（http://coderbyte.com/）\nProject Euler（https://projecteuler.net/）\nHackerRank（https://www.hackerrank.com）\nCodeChef（http://www.codechef.com/）\nTop Coder（http://www.topcoder.com/）\n\n\n#### 疑问点\n尾调用优化\n- 调用栈长\n- 使用后性能有较大的提升\nFloyd-Warshall 算法\nKruskal 算法\n背包问题\n最长公共子序列\n矩阵链相乘\nNP 完全理论\n- 多项式时间\n\n算法的使用，什么情况下用合适？需要将数据转换处理\n合适\n\n自己写的算法怎么验证正确性？\nLeetCode或其他刷题网站\n\nantd升级后的visible修改任务\n评估修改时间\ntesting-library/react测试react组件的库，安装了却没用？\numc-ui的项目框架使用的是别的项目的，原来就有，没删","slug":"39-data-structure7","published":1,"updated":"2022-10-25T02:34:13.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx5001lckttflx468i6","content":"<h4 id=\"算法设计与技巧\"><a href=\"#算法设计与技巧\" class=\"headerlink\" title=\"算法设计与技巧\"></a>算法设计与技巧</h4><h6 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h6><p>将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p>\n<p>分而治之算法可以分成三个部分。<br>(1) 分解原问题为多个子问题（原问题的多个小实例）。<br>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。<br>(3) 组合这些子问题的解决方式，得到原问题的解。</p>\n<p><strong>二分搜索</strong><br>分解：计算 mid 并搜索数组较小或较大的一半。<br>解决：在较小或较大的一半中搜索值。<br>合并：这步不需要，因为我们直接返回了索引值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearchRecursive</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  low,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  high,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (low &lt;= high) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = array[mid];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, mid + <span class=\"number\">1</span>, high, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, mid - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> high = sortedArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, high, compareFn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-1.png\" alt=\"technology-1\"></p>\n<p><strong>动态规划</strong><br>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>\n<p><em>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</em></p>\n<p>步骤：<br>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分；<br>(3) 识别并求解出基线条件。</p>\n<p><em>能用动态规划解决的一些著名问题如下。</em><br>(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)</p>\n<p><em>最少硬币找零问题</em><br>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// coins 硬币面额的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> makeChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache[value]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache[value];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> min = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newMin;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newAmount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">      newAmount = value - coin; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newAmount &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        newMin = makeChange(newAmount); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        newAmount &gt;= <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        (newMin.length &lt; min.length - <span class=\"number\">1</span> || !min.length) &amp;&amp; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        (newMin.length || !newAmount) <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        min = [coin].concat(newMin); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;new Min &#x27;</span> + min + <span class=\"string\">&#x27; for &#x27;</span> + amount);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cache[value] = min); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> makeChange(amount); <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>背包问题</em><br>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> kS = [];</span><br><span class=\"line\">  <span class=\"comment\">// 初始化将用于寻找解决方案的矩阵</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    kS[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> w = <span class=\"number\">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || w === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        kS[i][w] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (weights[i - <span class=\"number\">1</span>] &lt;= w) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 。物品 i 的重量必须小于约束</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = values[i - <span class=\"number\">1</span>] + kS[i - <span class=\"number\">1</span>][w - weights[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = kS[i - <span class=\"number\">1</span>][w];</span><br><span class=\"line\">        <span class=\"comment\">// 当找到可以构成解决方案的物品时，选择价值最大的那个</span></span><br><span class=\"line\">        kS[i][w] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        kS[i][w] = kS[i - <span class=\"number\">1</span>][w]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  findValues(n, capacity, kS, weights, values); <span class=\"comment\">// &#123;6&#125; 增加的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> kS[n][capacity]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findValues</span>(<span class=\"params\">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> k = capacity;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;构成解的物品：&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kS[i][k] !== kS[i - <span class=\"number\">1</span>][k]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">        <span class=\"string\">`物品 <span class=\"subst\">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class=\"subst\">$&#123;weights[i - <span class=\"number\">1</span>]&#125;</span>, <span class=\"subst\">$&#123;values[i - <span class=\"number\">1</span>]&#125;</span>`</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">      k -= kS[i][k];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-2.png\" alt=\"technology-2\"></p>\n<p><em>最长公共子序列(LCS)</em><br>找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。<br><img src=\"/2022/10/13/39-data-structure7/technology-3.png\" alt=\"technology-3\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">wordX, wordY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = wordX.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = wordY.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    l[i] = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// solution[i] = [];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      l[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// solution[i][j] = &#x27;0&#x27;;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        l[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wordX[i - <span class=\"number\">1</span>] === wordY[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        l[i][j] = l[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j] = &#x27;diagonal&#x27;;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = l[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = l[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        l[i][j] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j]=(l[i][j] == l[i-1][j]) ? &#x27;top&#x27; : &#x27;left&#x27;;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l[m][n]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printSolution(solution, wordX, m, n);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printSolution</span>(<span class=\"params\">solution, wordX, m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = m;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = solution[a][b];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> answer = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (x !== <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;diagonal&#x27;</span>) &#123;</span><br><span class=\"line\">      answer = wordX[a - <span class=\"number\">1</span>] + answer;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;left&#x27;</span>) &#123;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;top&#x27;</span>) &#123;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x = solution[a][b];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;lcs: &#x27;</span> + answer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-4.png\" alt=\"technology-4\"></p>\n<p><em>矩阵链相乘</em><br>要找出一组矩阵相乘的最佳方式（顺序）</p>\n<p>A<em>B</em>C*D 的乘法</p>\n<p>A 是一个 10 行 100 列的矩阵；<br>B 是一个 100 行 5 列的矩阵；<br>C 是一个 5 行 50 列的矩阵；<br>D 是一个 50 行 1 列的矩阵；<br>A<em>B</em>C*D 的结果是一个 10 行 1 列的矩阵</p>\n<p>(1) (A(B(CD)))：乘法运算的次数是 1750 次。<br>(2) ((AB)(CD))：乘法运算的次数是 5300 次。<br>(3) (((AB)C)D)：乘法运算的次数是 8000 次。<br>(4) ((A(BC))D)：乘法运算的次数是 75 500 次。<br>(5) (A((BC)D))：乘法运算的次数是 31 000 次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matrixChainOrder</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = p.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> s = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    m[i] = [];</span><br><span class=\"line\">    m[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//   const s = [];</span></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 0; i &lt;= n; i++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i] = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for (let j=0; j &lt;= n; j++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i][j] = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">2</span>; l &lt; n; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n - l + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> j = i + l - <span class=\"number\">1</span>;</span><br><span class=\"line\">      m[i][j] = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = i; k &lt;= j - <span class=\"number\">1</span>; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> q = m[i][k] + m[k + <span class=\"number\">1</span>][j] + p[i - <span class=\"number\">1</span>] * p[k] * p[j]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &lt; m[i][j]) &#123;</span><br><span class=\"line\">          m[i][j] = q; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"comment\">// s[i][j] = k;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m[<span class=\"number\">1</span>][n - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printOptimalParenthesis(s, 1, n-1);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printOptimalParenthesis</span>(<span class=\"params\">s, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;A[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;(&#x27;</span>);</span><br><span class=\"line\">    printOptimalParenthesis(s, i, s[i][j]);</span><br><span class=\"line\">    printOptimalParenthesis(s, s[i][j] + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// (A[1](A[2](A[3]A[4]))) =&gt; (A(B(CD)))</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h6><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p>\n<p><strong>最少硬币找零问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> change = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = coins.length; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (total + coin &lt;= amount) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      change.push(coin); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      total += coin; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> change;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-5.png\" alt=\"technology-5\"></p>\n<p><em>比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</em></p>\n<p><strong>分数背包问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = values.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> load = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weights[i] &lt;= capacity - load) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      val += values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> r = (capacity - load) / weights[i]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      val += r * values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h6><p>回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。</p>\n<p><strong>迷宫老鼠问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ratInAMaze</span>(<span class=\"params\">maze</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> solution = [];</span><br><span class=\"line\">  <span class=\"comment\">// 每个位置初始化为零</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; maze.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    solution[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; maze[i].length; j++) &#123;</span><br><span class=\"line\">      solution[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (findPath(maze, <span class=\"number\">0</span>, <span class=\"number\">0</span>, solution) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> solution;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NO PATH FOUND&#x27;</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findPath</span>(<span class=\"params\">maze, x, y, solution</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === n - <span class=\"number\">1</span> &amp;&amp; y === n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSafe(maze, x, y) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x + <span class=\"number\">1</span>, y, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x, y + <span class=\"number\">1</span>, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">maze, x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> maze = [</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ratInAMaze(maze));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><strong>数独解题器</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sudokuSolver</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (solveSudoku(matrix) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;问题无解！&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UNASSIGNED = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">solveSudoku</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> col = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> checkBlankSpaces = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (col = <span class=\"number\">0</span>; col &lt; matrix[row].length; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row][col] === UNASSIGNED) &#123;</span><br><span class=\"line\">        checkBlankSpaces = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num = <span class=\"number\">1</span>; num &lt;= <span class=\"number\">9</span>; num++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSafe(matrix, row, col, num)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      matrix[row][col] = num; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (solveSudoku(matrix)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      matrix[row][col] = UNASSIGNED; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">matrix, row, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !usedInRow(matrix, row, num) &amp;&amp;</span><br><span class=\"line\">    !usedInCol(matrix, col, num) &amp;&amp;</span><br><span class=\"line\">    !usedInBox(matrix, row - (row % <span class=\"number\">3</span>), col - (col % <span class=\"number\">3</span>), num)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInRow</span>(<span class=\"params\">matrix, row, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; matrix.length; col++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInCol</span>(<span class=\"params\">matrix, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInBox</span>(<span class=\"params\">matrix, boxStartRow, boxStartCol, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; <span class=\"number\">3</span>; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; <span class=\"number\">3</span>; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row + boxStartRow][col + boxStartCol] === num) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sudokuGrid = [</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sudokuSolver(sudokuGrid));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"函数式编程-FP-简介\"><a href=\"#函数式编程-FP-简介\" class=\"headerlink\" title=\"函数式编程(FP)简介\"></a>函数式编程(FP)简介</h6><p><strong>函数式编程与命令式编程</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> printArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printArray([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    action(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> logItem = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">forEach([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], logItem);</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：</em><br>(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。<br>(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。<br>(3)函数和数据集合是函数式编程的核心。<br>(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。<br>(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。</p>\n<p><strong>JavaScript 函数式类库和数据结构</strong><br>Underscode.js：<a href=\"http://underscorejs.org/\">http://underscorejs.org/</a><br>Bilby.js：<a href=\"http://bilby.brianmckenna.org/\">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a href=\"http://danieltao.com/lazy.js/\">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a href=\"https://baconjs.github.io/\">https://baconjs.github.io/</a><br>Fn.js：<a href=\"http://eliperelman.com/fn.js/\">http://eliperelman.com/fn.js/</a><br>Functional.js：<a href=\"http://functionaljs.com/\">http://functionaljs.com/</a><br>Ramda.js：<a href=\"http://ramdajs.com/0.20.1/index.html\">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a href=\"http://swannodette.github.io/mori/\">http://swannodette.github.io/mori/</a></p>\n<p>JavaScript 函数式编程：<a href=\"https://www.packtpub.com/web-development/functional-programming-javascript\">https://www.packtpub.com/web-development/functional-programming-javascript</a></p>\n<h4 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h4><h6 id=\"大-O-表示法\"><a href=\"#大-O-表示法\" class=\"headerlink\" title=\"大 O 表示法\"></a>大 O 表示法</h6><p>用于描述算法的性能和复杂程度。<br>大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。</p>\n<table>\n<thead>\n<tr>\n<th>符 号</th>\n<th>名 称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td>常数的</td>\n</tr>\n<tr>\n<td>O(log(n))</td>\n<td>对数的</td>\n</tr>\n<tr>\n<td>O((log(n))c)</td>\n<td>对数多项式的</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>线性的</td>\n</tr>\n<tr>\n<td>O(n^2)</td>\n<td>二次的</td>\n</tr>\n<tr>\n<td>O(n^c)</td>\n<td>多项式的</td>\n</tr>\n<tr>\n<td>O(c^n)</td>\n<td>指数的</td>\n</tr>\n</tbody></table>\n<p><strong>理解大 O 表示法</strong></p>\n<p>衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。</p>\n<ol>\n<li>O(1)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ++num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）</p>\n<ol start=\"2\">\n<li>O(n)</li>\n</ol>\n<p>函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。</p>\n<p>以顺序搜索算法为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">    <span class=\"string\">`cost for sequentialSearch with input size <span class=\"subst\">$&#123;array.length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>O(n^2)</li>\n</ol>\n<p>以冒泡排序为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设行&#123;1&#125;和行&#123;2&#125;的开销分别是 1。修改算法的实现使之计算开销。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      cost++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`cost for bubbleSort with input size <span class=\"subst\">$&#123;length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久</p>\n<p><em>时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)</em></p>\n<p><strong>时间复杂度比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>输入大小（n）</th>\n<th>O(1)</th>\n<th>O(log(n))</th>\n<th>O(n)</th>\n<th>O(nlog(n))</th>\n<th>O(n^2)</th>\n<th>O(2^n)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>10</td>\n<td>10</td>\n<td>100</td>\n<td>1024</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1</td>\n<td>1.30</td>\n<td>20</td>\n<td>26.02</td>\n<td>400</td>\n<td>1 048 576</td>\n</tr>\n<tr>\n<td>50</td>\n<td>1</td>\n<td>1.69</td>\n<td>50</td>\n<td>84.94</td>\n<td>2500</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1</td>\n<td>2</td>\n<td>100</td>\n<td>200</td>\n<td>10 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>500</td>\n<td>1</td>\n<td>2.69</td>\n<td>500</td>\n<td>1349.48</td>\n<td>250 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>1</td>\n<td>3</td>\n<td>1000</td>\n<td>3000</td>\n<td>1 000 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>10 000</td>\n<td>1</td>\n<td>4</td>\n<td>10 000</td>\n<td>40 000</td>\n<td>100 000 000</td>\n<td>非常大</td>\n</tr>\n</tbody></table>\n<p>不同的大 O 表示法的消耗</p>\n<p><img src=\"/2022/10/13/39-data-structure7/big-o-1.png\" alt=\"big-o-1\"></p>\n<p><em>常用数据结构的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-2.png\" alt=\"big-o-2\"></p>\n<p><em>图的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-3.png\" alt=\"big-o-3\"></p>\n<p><em>排序算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-4.png\" alt=\"big-o-4\"></p>\n<p><em>搜索算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-5.png\" alt=\"big-o-5\"></p>\n<p><strong>NP 完全理论概述</strong><br>一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.</p>\n<p>对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）</p>\n<p>NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP</p>\n<p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。</p>\n<p>NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：<br>(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；<br>(2) 所有的 NP 问题都能在多项式时间内归约为 L。</p>\n<p>为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。</p>\n<p>还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。</p>\n<p>下面是满足 P&lt;&gt;NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。<br><img src=\"/2022/10/13/39-data-structure7/big-o-6.png\" alt=\"big-o-6\"></p>\n<p>非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。</p>\n<p>NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p>\n<p>以上问题，具体可查看：<a href=\"https://en.wikipedia.org/wiki/NP-completeness\">https://en.wikipedia.org/wiki/NP-completeness</a></p>\n<p><em>不可解问题与启发式算法</em><br>有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。<br>启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。<br>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。<br>详情请查阅 <a href=\"https://en.wikipedia.org/wiki/Heuristic_(computer_science)\">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a></p>\n<p>UVa Online Judge（<a href=\"http://uva.onlinejudge.org/%EF%BC%89\">http://uva.onlinejudge.org/）</a><br>Sphere Online Judge（<a href=\"http://www.spoj.com/%EF%BC%89\">http://www.spoj.com/）</a><br>Coderbyte（<a href=\"http://coderbyte.com/%EF%BC%89\">http://coderbyte.com/）</a><br>Project Euler（<a href=\"https://projecteuler.net/%EF%BC%89\">https://projecteuler.net/）</a><br>HackerRank（<a href=\"https://www.hackerrank.com)/\">https://www.hackerrank.com）</a><br>CodeChef（<a href=\"http://www.codechef.com/%EF%BC%89\">http://www.codechef.com/）</a><br>Top Coder（<a href=\"http://www.topcoder.com/%EF%BC%89\">http://www.topcoder.com/）</a></p>\n<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>尾调用优化</p>\n<ul>\n<li>调用栈长</li>\n<li>使用后性能有较大的提升<br>Floyd-Warshall 算法<br>Kruskal 算法<br>背包问题<br>最长公共子序列<br>矩阵链相乘<br>NP 完全理论</li>\n<li>多项式时间</li>\n</ul>\n<p>算法的使用，什么情况下用合适？需要将数据转换处理<br>合适</p>\n<p>自己写的算法怎么验证正确性？<br>LeetCode或其他刷题网站</p>\n<p>antd升级后的visible修改任务<br>评估修改时间<br>testing-library/react测试react组件的库，安装了却没用？<br>umc-ui的项目框架使用的是别的项目的，原来就有，没删</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"算法设计与技巧\"><a href=\"#算法设计与技巧\" class=\"headerlink\" title=\"算法设计与技巧\"></a>算法设计与技巧</h4><h6 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h6><p>将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p>\n<p>分而治之算法可以分成三个部分。<br>(1) 分解原问题为多个子问题（原问题的多个小实例）。<br>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。<br>(3) 组合这些子问题的解决方式，得到原问题的解。</p>\n<p><strong>二分搜索</strong><br>分解：计算 mid 并搜索数组较小或较大的一半。<br>解决：在较小或较大的一半中搜索值。<br>合并：这步不需要，因为我们直接返回了索引值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearchRecursive</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  array,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  low,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  high,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  compareFn = defaultCompare</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (low &lt;= high) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = array[mid];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.LESS_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, mid + <span class=\"number\">1</span>, high, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareFn(element, value) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, mid - <span class=\"number\">1</span>, compareFn);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> DOES_NOT_EXIST; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binarySearch</span>(<span class=\"params\">array, value, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sortedArray = quickSort(array);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> high = sortedArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> binarySearchRecursive(array, value, low, high, compareFn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-1.png\" alt=\"technology-1\"></p>\n<p><strong>动态规划</strong><br>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>\n<p><em>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</em></p>\n<p>步骤：<br>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分；<br>(3) 识别并求解出基线条件。</p>\n<p><em>能用动态规划解决的一些著名问题如下。</em><br>(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法)</p>\n<p><em>最少硬币找零问题</em><br>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// coins 硬币面额的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> makeChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache[value]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache[value];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> min = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newMin;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newAmount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">      newAmount = value - coin; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newAmount &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        newMin = makeChange(newAmount); <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        newAmount &gt;= <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        (newMin.length &lt; min.length - <span class=\"number\">1</span> || !min.length) &amp;&amp; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">        (newMin.length || !newAmount) <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        min = [coin].concat(newMin); <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;new Min &#x27;</span> + min + <span class=\"string\">&#x27; for &#x27;</span> + amount);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cache[value] = min); <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> makeChange(amount); <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>背包问题</em><br>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> kS = [];</span><br><span class=\"line\">  <span class=\"comment\">// 初始化将用于寻找解决方案的矩阵</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    kS[i] = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> w = <span class=\"number\">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || w === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        kS[i][w] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (weights[i - <span class=\"number\">1</span>] &lt;= w) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 。物品 i 的重量必须小于约束</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = values[i - <span class=\"number\">1</span>] + kS[i - <span class=\"number\">1</span>][w - weights[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = kS[i - <span class=\"number\">1</span>][w];</span><br><span class=\"line\">        <span class=\"comment\">// 当找到可以构成解决方案的物品时，选择价值最大的那个</span></span><br><span class=\"line\">        kS[i][w] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        kS[i][w] = kS[i - <span class=\"number\">1</span>][w]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  findValues(n, capacity, kS, weights, values); <span class=\"comment\">// &#123;6&#125; 增加的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> kS[n][capacity]; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findValues</span>(<span class=\"params\">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> k = capacity;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;构成解的物品：&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kS[i][k] !== kS[i - <span class=\"number\">1</span>][k]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">        <span class=\"string\">`物品 <span class=\"subst\">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class=\"subst\">$&#123;weights[i - <span class=\"number\">1</span>]&#125;</span>, <span class=\"subst\">$&#123;values[i - <span class=\"number\">1</span>]&#125;</span>`</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">      k -= kS[i][k];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-2.png\" alt=\"technology-2\"></p>\n<p><em>最长公共子序列(LCS)</em><br>找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。<br><img src=\"/2022/10/13/39-data-structure7/technology-3.png\" alt=\"technology-3\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">wordX, wordY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = wordX.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = wordY.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    l[i] = []; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// solution[i] = [];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      l[i][j] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// solution[i][j] = &#x27;0&#x27;;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        l[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wordX[i - <span class=\"number\">1</span>] === wordY[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        l[i][j] = l[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j] = &#x27;diagonal&#x27;;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> a = l[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = l[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        l[i][j] = a &gt; b ? a : b; <span class=\"comment\">// &#123;4&#125; max(a,b)</span></span><br><span class=\"line\">        <span class=\"comment\">// solution[i][j]=(l[i][j] == l[i-1][j]) ? &#x27;top&#x27; : &#x27;left&#x27;;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l[m][n]; <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printSolution(solution, wordX, m, n);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printSolution</span>(<span class=\"params\">solution, wordX, m, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = m;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = n;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = solution[a][b];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> answer = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (x !== <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;diagonal&#x27;</span>) &#123;</span><br><span class=\"line\">      answer = wordX[a - <span class=\"number\">1</span>] + answer;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;left&#x27;</span>) &#123;</span><br><span class=\"line\">      b--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (solution[a][b] === <span class=\"string\">&#x27;top&#x27;</span>) &#123;</span><br><span class=\"line\">      a--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    x = solution[a][b];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;lcs: &#x27;</span> + answer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-4.png\" alt=\"technology-4\"></p>\n<p><em>矩阵链相乘</em><br>要找出一组矩阵相乘的最佳方式（顺序）</p>\n<p>A<em>B</em>C*D 的乘法</p>\n<p>A 是一个 10 行 100 列的矩阵；<br>B 是一个 100 行 5 列的矩阵；<br>C 是一个 5 行 50 列的矩阵；<br>D 是一个 50 行 1 列的矩阵；<br>A<em>B</em>C*D 的结果是一个 10 行 1 列的矩阵</p>\n<p>(1) (A(B(CD)))：乘法运算的次数是 1750 次。<br>(2) ((AB)(CD))：乘法运算的次数是 5300 次。<br>(3) (((AB)C)D)：乘法运算的次数是 8000 次。<br>(4) ((A(BC))D)：乘法运算的次数是 75 500 次。<br>(5) (A((BC)D))：乘法运算的次数是 31 000 次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matrixChainOrder</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = p.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> s = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    m[i] = [];</span><br><span class=\"line\">    m[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//   const s = [];</span></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 0; i &lt;= n; i++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i] = [];</span></span><br><span class=\"line\">  <span class=\"comment\">//  for (let j=0; j &lt;= n; j++)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//  s[i][j] = 0;</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> l = <span class=\"number\">2</span>; l &lt; n; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n - l + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> j = i + l - <span class=\"number\">1</span>;</span><br><span class=\"line\">      m[i][j] = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = i; k &lt;= j - <span class=\"number\">1</span>; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> q = m[i][k] + m[k + <span class=\"number\">1</span>][j] + p[i - <span class=\"number\">1</span>] * p[k] * p[j]; <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &lt; m[i][j]) &#123;</span><br><span class=\"line\">          m[i][j] = q; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">          <span class=\"comment\">// s[i][j] = k;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m[<span class=\"number\">1</span>][n - <span class=\"number\">1</span>]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// printOptimalParenthesis(s, 1, n-1);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printOptimalParenthesis</span>(<span class=\"params\">s, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === j) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;A[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;(&#x27;</span>);</span><br><span class=\"line\">    printOptimalParenthesis(s, i, s[i][j]);</span><br><span class=\"line\">    printOptimalParenthesis(s, s[i][j] + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// (A[1](A[2](A[3]A[4]))) =&gt; (A(B(CD)))</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h6><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p>\n<p><strong>最少硬币找零问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minCoinChange</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> change = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = coins.length; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> coin = coins[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (total + coin &lt;= amount) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      change.push(coin); <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      total += coin; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> change;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/10/13/39-data-structure7/technology-5.png\" alt=\"technology-5\"></p>\n<p><em>比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</em></p>\n<p><strong>分数背包问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapSack</span>(<span class=\"params\">capacity, weights, values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = values.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> load = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weights[i] &lt;= capacity - load) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      val += values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> r = (capacity - load) / weights[i]; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      val += r * values[i];</span><br><span class=\"line\">      load += weights[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h6><p>回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。</p>\n<p><strong>迷宫老鼠问题</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ratInAMaze</span>(<span class=\"params\">maze</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> solution = [];</span><br><span class=\"line\">  <span class=\"comment\">// 每个位置初始化为零</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; maze.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    solution[i] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; maze[i].length; j++) &#123;</span><br><span class=\"line\">      solution[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (findPath(maze, <span class=\"number\">0</span>, <span class=\"number\">0</span>, solution) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> solution;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;NO PATH FOUND&#x27;</span>; <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findPath</span>(<span class=\"params\">maze, x, y, solution</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === n - <span class=\"number\">1</span> &amp;&amp; y === n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSafe(maze, x, y) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">1</span>; <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x + <span class=\"number\">1</span>, y, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPath(maze, x, y + <span class=\"number\">1</span>, solution)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    solution[x][y] = <span class=\"number\">0</span>; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">maze, x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = maze.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span> &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> maze = [</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ratInAMaze(maze));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><strong>数独解题器</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sudokuSolver</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (solveSudoku(matrix) === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;问题无解！&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UNASSIGNED = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">solveSudoku</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> col = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> checkBlankSpaces = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (col = <span class=\"number\">0</span>; col &lt; matrix[row].length; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row][col] === UNASSIGNED) &#123;</span><br><span class=\"line\">        checkBlankSpaces = <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;3&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (checkBlankSpaces === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// &#123;4&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num = <span class=\"number\">1</span>; num &lt;= <span class=\"number\">9</span>; num++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSafe(matrix, row, col, num)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;6&#125;</span></span><br><span class=\"line\">      matrix[row][col] = num; <span class=\"comment\">// &#123;7&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (solveSudoku(matrix)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;8&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      matrix[row][col] = UNASSIGNED; <span class=\"comment\">// &#123;9&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// &#123;10&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSafe</span>(<span class=\"params\">matrix, row, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !usedInRow(matrix, row, num) &amp;&amp;</span><br><span class=\"line\">    !usedInCol(matrix, col, num) &amp;&amp;</span><br><span class=\"line\">    !usedInBox(matrix, row - (row % <span class=\"number\">3</span>), col - (col % <span class=\"number\">3</span>), num)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInRow</span>(<span class=\"params\">matrix, row, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; matrix.length; col++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;11&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInCol</span>(<span class=\"params\">matrix, col, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;12&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[row][col] === num) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usedInBox</span>(<span class=\"params\">matrix, boxStartRow, boxStartCol, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">0</span>; row &lt; <span class=\"number\">3</span>; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; <span class=\"number\">3</span>; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[row + boxStartRow][col + boxStartCol] === num) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;13&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sudokuGrid = [</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sudokuSolver(sudokuGrid));</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"函数式编程-FP-简介\"><a href=\"#函数式编程-FP-简介\" class=\"headerlink\" title=\"函数式编程(FP)简介\"></a>函数式编程(FP)简介</h6><p><strong>函数式编程与命令式编程</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> printArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printArray([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forEach = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    action(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> logItem = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">forEach([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], logItem);</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：</em><br>(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。<br>(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。<br>(3)函数和数据集合是函数式编程的核心。<br>(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。<br>(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。</p>\n<p><strong>JavaScript 函数式类库和数据结构</strong><br>Underscode.js：<a href=\"http://underscorejs.org/\">http://underscorejs.org/</a><br>Bilby.js：<a href=\"http://bilby.brianmckenna.org/\">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a href=\"http://danieltao.com/lazy.js/\">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a href=\"https://baconjs.github.io/\">https://baconjs.github.io/</a><br>Fn.js：<a href=\"http://eliperelman.com/fn.js/\">http://eliperelman.com/fn.js/</a><br>Functional.js：<a href=\"http://functionaljs.com/\">http://functionaljs.com/</a><br>Ramda.js：<a href=\"http://ramdajs.com/0.20.1/index.html\">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a href=\"http://swannodette.github.io/mori/\">http://swannodette.github.io/mori/</a></p>\n<p>JavaScript 函数式编程：<a href=\"https://www.packtpub.com/web-development/functional-programming-javascript\">https://www.packtpub.com/web-development/functional-programming-javascript</a></p>\n<h4 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h4><h6 id=\"大-O-表示法\"><a href=\"#大-O-表示法\" class=\"headerlink\" title=\"大 O 表示法\"></a>大 O 表示法</h6><p>用于描述算法的性能和复杂程度。<br>大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。</p>\n<table>\n<thead>\n<tr>\n<th>符 号</th>\n<th>名 称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td>常数的</td>\n</tr>\n<tr>\n<td>O(log(n))</td>\n<td>对数的</td>\n</tr>\n<tr>\n<td>O((log(n))c)</td>\n<td>对数多项式的</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>线性的</td>\n</tr>\n<tr>\n<td>O(n^2)</td>\n<td>二次的</td>\n</tr>\n<tr>\n<td>O(n^c)</td>\n<td>多项式的</td>\n</tr>\n<tr>\n<td>O(c^n)</td>\n<td>指数的</td>\n</tr>\n</tbody></table>\n<p><strong>理解大 O 表示法</strong></p>\n<p>衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。</p>\n<ol>\n<li>O(1)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ++num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数）</p>\n<ol start=\"2\">\n<li>O(n)</li>\n</ol>\n<p>函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。</p>\n<p>以顺序搜索算法为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialSearch</span>(<span class=\"params\">array, value, equalsFn = defaultEquals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equalsFn(value, array[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">    <span class=\"string\">`cost for sequentialSearch with input size <span class=\"subst\">$&#123;array.length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>O(n^2)</li>\n</ol>\n<p>以冒泡排序为例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设行&#123;1&#125;和行&#123;2&#125;的开销分别是 1。修改算法的实现使之计算开销。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">    cost++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// &#123;2&#125;</span></span><br><span class=\"line\">      cost++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareFn(array[j], array[j + <span class=\"number\">1</span>]) === Compare.BIGGER_THAN) &#123;</span><br><span class=\"line\">        swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`cost for bubbleSort with input size <span class=\"subst\">$&#123;length&#125;</span> is <span class=\"subst\">$&#123;cost&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久</p>\n<p><em>时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3)</em></p>\n<p><strong>时间复杂度比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>输入大小（n）</th>\n<th>O(1)</th>\n<th>O(log(n))</th>\n<th>O(n)</th>\n<th>O(nlog(n))</th>\n<th>O(n^2)</th>\n<th>O(2^n)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>10</td>\n<td>10</td>\n<td>100</td>\n<td>1024</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1</td>\n<td>1.30</td>\n<td>20</td>\n<td>26.02</td>\n<td>400</td>\n<td>1 048 576</td>\n</tr>\n<tr>\n<td>50</td>\n<td>1</td>\n<td>1.69</td>\n<td>50</td>\n<td>84.94</td>\n<td>2500</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1</td>\n<td>2</td>\n<td>100</td>\n<td>200</td>\n<td>10 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>500</td>\n<td>1</td>\n<td>2.69</td>\n<td>500</td>\n<td>1349.48</td>\n<td>250 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>1</td>\n<td>3</td>\n<td>1000</td>\n<td>3000</td>\n<td>1 000 000</td>\n<td>非常大</td>\n</tr>\n<tr>\n<td>10 000</td>\n<td>1</td>\n<td>4</td>\n<td>10 000</td>\n<td>40 000</td>\n<td>100 000 000</td>\n<td>非常大</td>\n</tr>\n</tbody></table>\n<p>不同的大 O 表示法的消耗</p>\n<p><img src=\"/2022/10/13/39-data-structure7/big-o-1.png\" alt=\"big-o-1\"></p>\n<p><em>常用数据结构的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-2.png\" alt=\"big-o-2\"></p>\n<p><em>图的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-3.png\" alt=\"big-o-3\"></p>\n<p><em>排序算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-4.png\" alt=\"big-o-4\"></p>\n<p><em>搜索算法的时间复杂度</em><br><img src=\"/2022/10/13/39-data-structure7/big-o-5.png\" alt=\"big-o-5\"></p>\n<p><strong>NP 完全理论概述</strong><br>一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法.</p>\n<p>对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式）</p>\n<p>NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP</p>\n<p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。</p>\n<p>NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：<br>(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；<br>(2) 所有的 NP 问题都能在多项式时间内归约为 L。</p>\n<p>为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。</p>\n<p>还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。</p>\n<p>下面是满足 P&lt;&gt;NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。<br><img src=\"/2022/10/13/39-data-structure7/big-o-6.png\" alt=\"big-o-6\"></p>\n<p>非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。</p>\n<p>NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p>\n<p>以上问题，具体可查看：<a href=\"https://en.wikipedia.org/wiki/NP-completeness\">https://en.wikipedia.org/wiki/NP-completeness</a></p>\n<p><em>不可解问题与启发式算法</em><br>有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。<br>启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。<br>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。<br>详情请查阅 <a href=\"https://en.wikipedia.org/wiki/Heuristic_(computer_science)\">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a></p>\n<p>UVa Online Judge（<a href=\"http://uva.onlinejudge.org/%EF%BC%89\">http://uva.onlinejudge.org/）</a><br>Sphere Online Judge（<a href=\"http://www.spoj.com/%EF%BC%89\">http://www.spoj.com/）</a><br>Coderbyte（<a href=\"http://coderbyte.com/%EF%BC%89\">http://coderbyte.com/）</a><br>Project Euler（<a href=\"https://projecteuler.net/%EF%BC%89\">https://projecteuler.net/）</a><br>HackerRank（<a href=\"https://www.hackerrank.com)/\">https://www.hackerrank.com）</a><br>CodeChef（<a href=\"http://www.codechef.com/%EF%BC%89\">http://www.codechef.com/）</a><br>Top Coder（<a href=\"http://www.topcoder.com/%EF%BC%89\">http://www.topcoder.com/）</a></p>\n<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>尾调用优化</p>\n<ul>\n<li>调用栈长</li>\n<li>使用后性能有较大的提升<br>Floyd-Warshall 算法<br>Kruskal 算法<br>背包问题<br>最长公共子序列<br>矩阵链相乘<br>NP 完全理论</li>\n<li>多项式时间</li>\n</ul>\n<p>算法的使用，什么情况下用合适？需要将数据转换处理<br>合适</p>\n<p>自己写的算法怎么验证正确性？<br>LeetCode或其他刷题网站</p>\n<p>antd升级后的visible修改任务<br>评估修改时间<br>testing-library/react测试react组件的库，安装了却没用？<br>umc-ui的项目框架使用的是别的项目的，原来就有，没删</p>\n"},{"title":"尾调用与尾递归","date":"2022-10-17T02:26:13.000Z","_content":"\n###### 什么是尾调用？\n**某个函数的最后一步调用另一个函数**\n\n```javascript\nfunction call1(a) {\n return call2(a);\n}\n\n// 以下三种情况不属于尾调用！！！\n// 函数调用后还有其他操作\nfunction call1(a) {\n const x = call2(a);\n return x;\n}\n\nfunction call1(a) {\n return call2(a) + 1;\n}\n\nfunction call1(a) {\n call2(a);\n}\n\n// 以下属于尾调用\nfunction call1(a) {\n if (!!a) {\n  return call2(a);\n }\n return call3(a);\n}\n```\n\n###### 尾调用优化\n\n*注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度*\n\n函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。\n\n![call-stack](40-tail-call/call-stack.png)\n\n但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。\n\n*注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’*\n\n###### 尾递归\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。\n\n```javascript\n// 阶乘计算\n// 复杂度 O(n)\nfunction factorial(n) {\n if (n === 1) return 1;\n return n * factorial(n - 1);\n}\n\n// 复杂度O(1)\nfunction factorial(n, total) {\n if (n === 1) return total;\n return factorial(n -1, n* total);\n}\nfactorial(5, 1);\n\n// factorial(5, 1);\n// factorial(4, 5);\n// factorial(3, 20);\n// factorial(2, 60);\n// factorial(1, 120);\n// 120\n```\n\n###### 递归函数的改写优化\n尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：\n\n(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数\n\n```javascript\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nfunction call(n) {\n return tailCall(n, 1);\n}\n\ncall(5);\n```\n\n(2) 使用柯理化，将多参数的函数转化为单参数形式\n\n```javascript\nfunction currying(fn, n) {\n return function (m) {\n  return fn.call(this, m, n);\n }\n}\n\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nconst factorial = currying(tailCall, 1);\nfactorial(5);\n\n// 或者使用ES6函数默认值\nfunction factorial(n, total = 1) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\nfactorial(5);\n```\n\n*ES6的尾调用优化只在严格模式下开启，正常模式无效*\n正常模式下，函数内部有两个变量，可以跟踪函数的调用栈\n- arguments 返回调用时函数的参数\n- func.caller 返回调用当前函数的那个函数\n尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。\n\n[尾调用-维基百科](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)","source":"_posts/40-tail-call.md","raw":"---\ntitle: 尾调用与尾递归\ndate: 2022-10-17 10:26:13\ntags:\n---\n\n###### 什么是尾调用？\n**某个函数的最后一步调用另一个函数**\n\n```javascript\nfunction call1(a) {\n return call2(a);\n}\n\n// 以下三种情况不属于尾调用！！！\n// 函数调用后还有其他操作\nfunction call1(a) {\n const x = call2(a);\n return x;\n}\n\nfunction call1(a) {\n return call2(a) + 1;\n}\n\nfunction call1(a) {\n call2(a);\n}\n\n// 以下属于尾调用\nfunction call1(a) {\n if (!!a) {\n  return call2(a);\n }\n return call3(a);\n}\n```\n\n###### 尾调用优化\n\n*注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度*\n\n函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。\n\n![call-stack](40-tail-call/call-stack.png)\n\n但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。\n\n*注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’*\n\n###### 尾递归\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。\n\n```javascript\n// 阶乘计算\n// 复杂度 O(n)\nfunction factorial(n) {\n if (n === 1) return 1;\n return n * factorial(n - 1);\n}\n\n// 复杂度O(1)\nfunction factorial(n, total) {\n if (n === 1) return total;\n return factorial(n -1, n* total);\n}\nfactorial(5, 1);\n\n// factorial(5, 1);\n// factorial(4, 5);\n// factorial(3, 20);\n// factorial(2, 60);\n// factorial(1, 120);\n// 120\n```\n\n###### 递归函数的改写优化\n尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：\n\n(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数\n\n```javascript\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nfunction call(n) {\n return tailCall(n, 1);\n}\n\ncall(5);\n```\n\n(2) 使用柯理化，将多参数的函数转化为单参数形式\n\n```javascript\nfunction currying(fn, n) {\n return function (m) {\n  return fn.call(this, m, n);\n }\n}\n\nfunction tailCall(n, total) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\n\nconst factorial = currying(tailCall, 1);\nfactorial(5);\n\n// 或者使用ES6函数默认值\nfunction factorial(n, total = 1) {\n if (n === 1) return total;\n return tailCall(n -1, n*total);\n}\nfactorial(5);\n```\n\n*ES6的尾调用优化只在严格模式下开启，正常模式无效*\n正常模式下，函数内部有两个变量，可以跟踪函数的调用栈\n- arguments 返回调用时函数的参数\n- func.caller 返回调用当前函数的那个函数\n尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。\n\n[尾调用-维基百科](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)","slug":"40-tail-call","published":1,"updated":"2022-12-16T06:56:22.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx6001mcktt1axz3zz6","content":"<h6 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h6><p><strong>某个函数的最后一步调用另一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下三种情况不属于尾调用！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 函数调用后还有其他操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> x = call2(a);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下属于尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!!a) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call3(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h6><p><em>注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度</em></p>\n<p>函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。</p>\n<p><img src=\"/2022/10/17/40-tail-call/call-stack.png\" alt=\"call-stack\"></p>\n<p>但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。</p>\n<p><em>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’</em></p>\n<h6 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h6><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阶乘计算</span></span><br><span class=\"line\"><span class=\"comment\">// 复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复杂度O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> factorial(n -<span class=\"number\">1</span>, n* total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// factorial(5, 1);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(4, 5);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(3, 20);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(2, 60);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(1, 120);</span></span><br><span class=\"line\"><span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"递归函数的改写优化\"><a href=\"#递归函数的改写优化\" class=\"headerlink\" title=\"递归函数的改写优化\"></a>递归函数的改写优化</h6><p>尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：</p>\n<p>(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>(2) 使用柯理化，将多参数的函数转化为单参数形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.call(<span class=\"built_in\">this</span>, m, n);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> factorial = currying(tailCall, <span class=\"number\">1</span>);</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用ES6函数默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6的尾调用优化只在严格模式下开启，正常模式无效</em><br>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈</p>\n<ul>\n<li>arguments 返回调用时函数的参数</li>\n<li>func.caller 返回调用当前函数的那个函数<br>尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。</li>\n</ul>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\">尾调用-维基百科</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h6><p><strong>某个函数的最后一步调用另一个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下三种情况不属于尾调用！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 函数调用后还有其他操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> x = call2(a);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call2(a) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> call2(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下属于尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!!a) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call2(a);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> call3(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h6><p><em>注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度</em></p>\n<p>函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。</p>\n<p><img src=\"/2022/10/17/40-tail-call/call-stack.png\" alt=\"call-stack\"></p>\n<p>但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。</p>\n<p><em>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’</em></p>\n<h6 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h6><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阶乘计算</span></span><br><span class=\"line\"><span class=\"comment\">// 复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复杂度O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> factorial(n -<span class=\"number\">1</span>, n* total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// factorial(5, 1);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(4, 5);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(3, 20);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(2, 60);</span></span><br><span class=\"line\"><span class=\"comment\">// factorial(1, 120);</span></span><br><span class=\"line\"><span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"递归函数的改写优化\"><a href=\"#递归函数的改写优化\" class=\"headerlink\" title=\"递归函数的改写优化\"></a>递归函数的改写优化</h6><p>尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决：</p>\n<p>(1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">call</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>(2) 使用柯理化，将多参数的函数转化为单参数形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.call(<span class=\"built_in\">this</span>, m, n);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailCall</span>(<span class=\"params\">n, total</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> factorial = currying(tailCall, <span class=\"number\">1</span>);</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用ES6函数默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> tailCall(n -<span class=\"number\">1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6的尾调用优化只在严格模式下开启，正常模式无效</em><br>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈</p>\n<ul>\n<li>arguments 返回调用时函数的参数</li>\n<li>func.caller 返回调用当前函数的那个函数<br>尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。</li>\n</ul>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\">尾调用-维基百科</a></p>\n"},{"title":"scrollIntoView参数项说明","date":"2022-11-10T02:39:52.000Z","_content":"\n###### scrollIntoView作用\n*element.scrollIntoView*\n滚动元素的父容器，使被调用scrollIntoView的元素对用户可见2，即滚动到可视区域\n\n###### scrollIntoView用法\n*element.scrollIntoView()*\n等同于element.scrollIntoView(true)\n\n*element.scrollIntoView(boolean)*\n- boolean为true\n  - 元素的顶端将和其所在滚动区域的可视区域的顶端对齐\n  - 与element.scrollIntoView({ block: \"start\", inline: 'nearest'})等价\n- boolean为false\n  - 元素的底端将和其所在滚定区域的可视区域的底端对齐\n  - 与element.scrollIntoView({ block: \"end\", inline: 'nearest'})等价\n\n*element.scrollIntoView(options)*\noptions为一个对象，属性如下：\n- behavior\n  - 定义动画过渡效果\n  - 值为：\n    - auto(默认值)，无平滑滚动效果\n    - smooth，有平滑的滚动效果\n- block\n  - 定义垂直方向的对齐\n  - 值为：\n    - start: 默认值，顶端对齐\n    - center：中间对齐\n    - end：底端对齐\n    - nearest：如果元素完全在可视区域内，则垂直方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，垂直方向滚动父级容器，使元素完全在可视区域内。\n- inline\n  - 定义水平方向的对齐\n  - 值为：\n    - start：左端对齐\n    - center：中间对齐\n    - end：右端对齐\n    - nearest: 默认值，如果元素完全在可视区域内，则水平方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，水平方向滚动父级容器，使元素完全在可视区域内。\n\n**注意：取决于其他元素的布局情况，此元素可能不会完全滚动到顶端或底端**","source":"_posts/42-scrollInToView-params.md","raw":"---\ntitle: scrollIntoView参数项说明\ndate: 2022-11-10 10:39:52\ntags:\n---\n\n###### scrollIntoView作用\n*element.scrollIntoView*\n滚动元素的父容器，使被调用scrollIntoView的元素对用户可见2，即滚动到可视区域\n\n###### scrollIntoView用法\n*element.scrollIntoView()*\n等同于element.scrollIntoView(true)\n\n*element.scrollIntoView(boolean)*\n- boolean为true\n  - 元素的顶端将和其所在滚动区域的可视区域的顶端对齐\n  - 与element.scrollIntoView({ block: \"start\", inline: 'nearest'})等价\n- boolean为false\n  - 元素的底端将和其所在滚定区域的可视区域的底端对齐\n  - 与element.scrollIntoView({ block: \"end\", inline: 'nearest'})等价\n\n*element.scrollIntoView(options)*\noptions为一个对象，属性如下：\n- behavior\n  - 定义动画过渡效果\n  - 值为：\n    - auto(默认值)，无平滑滚动效果\n    - smooth，有平滑的滚动效果\n- block\n  - 定义垂直方向的对齐\n  - 值为：\n    - start: 默认值，顶端对齐\n    - center：中间对齐\n    - end：底端对齐\n    - nearest：如果元素完全在可视区域内，则垂直方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，垂直方向滚动父级容器，使元素完全在可视区域内。\n- inline\n  - 定义水平方向的对齐\n  - 值为：\n    - start：左端对齐\n    - center：中间对齐\n    - end：右端对齐\n    - nearest: 默认值，如果元素完全在可视区域内，则水平方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，水平方向滚动父级容器，使元素完全在可视区域内。\n\n**注意：取决于其他元素的布局情况，此元素可能不会完全滚动到顶端或底端**","slug":"42-scrollInToView-params","published":1,"updated":"2022-11-10T03:09:05.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx6001ncktthx0kd8sm","content":"<h6 id=\"scrollIntoView作用\"><a href=\"#scrollIntoView作用\" class=\"headerlink\" title=\"scrollIntoView作用\"></a>scrollIntoView作用</h6><p><em>element.scrollIntoView</em><br>滚动元素的父容器，使被调用scrollIntoView的元素对用户可见2，即滚动到可视区域</p>\n<h6 id=\"scrollIntoView用法\"><a href=\"#scrollIntoView用法\" class=\"headerlink\" title=\"scrollIntoView用法\"></a>scrollIntoView用法</h6><p><em>element.scrollIntoView()</em><br>等同于element.scrollIntoView(true)</p>\n<p><em>element.scrollIntoView(boolean)</em></p>\n<ul>\n<li>boolean为true<ul>\n<li>元素的顶端将和其所在滚动区域的可视区域的顶端对齐</li>\n<li>与element.scrollIntoView({ block: “start”, inline: ‘nearest’})等价</li>\n</ul>\n</li>\n<li>boolean为false<ul>\n<li>元素的底端将和其所在滚定区域的可视区域的底端对齐</li>\n<li>与element.scrollIntoView({ block: “end”, inline: ‘nearest’})等价</li>\n</ul>\n</li>\n</ul>\n<p><em>element.scrollIntoView(options)</em><br>options为一个对象，属性如下：</p>\n<ul>\n<li>behavior<ul>\n<li>定义动画过渡效果</li>\n<li>值为：<ul>\n<li>auto(默认值)，无平滑滚动效果</li>\n<li>smooth，有平滑的滚动效果</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>block<ul>\n<li>定义垂直方向的对齐</li>\n<li>值为：<ul>\n<li>start: 默认值，顶端对齐</li>\n<li>center：中间对齐</li>\n<li>end：底端对齐</li>\n<li>nearest：如果元素完全在可视区域内，则垂直方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，垂直方向滚动父级容器，使元素完全在可视区域内。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>inline<ul>\n<li>定义水平方向的对齐</li>\n<li>值为：<ul>\n<li>start：左端对齐</li>\n<li>center：中间对齐</li>\n<li>end：右端对齐</li>\n<li>nearest: 默认值，如果元素完全在可视区域内，则水平方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，水平方向滚动父级容器，使元素完全在可视区域内。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：取决于其他元素的布局情况，此元素可能不会完全滚动到顶端或底端</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"scrollIntoView作用\"><a href=\"#scrollIntoView作用\" class=\"headerlink\" title=\"scrollIntoView作用\"></a>scrollIntoView作用</h6><p><em>element.scrollIntoView</em><br>滚动元素的父容器，使被调用scrollIntoView的元素对用户可见2，即滚动到可视区域</p>\n<h6 id=\"scrollIntoView用法\"><a href=\"#scrollIntoView用法\" class=\"headerlink\" title=\"scrollIntoView用法\"></a>scrollIntoView用法</h6><p><em>element.scrollIntoView()</em><br>等同于element.scrollIntoView(true)</p>\n<p><em>element.scrollIntoView(boolean)</em></p>\n<ul>\n<li>boolean为true<ul>\n<li>元素的顶端将和其所在滚动区域的可视区域的顶端对齐</li>\n<li>与element.scrollIntoView({ block: “start”, inline: ‘nearest’})等价</li>\n</ul>\n</li>\n<li>boolean为false<ul>\n<li>元素的底端将和其所在滚定区域的可视区域的底端对齐</li>\n<li>与element.scrollIntoView({ block: “end”, inline: ‘nearest’})等价</li>\n</ul>\n</li>\n</ul>\n<p><em>element.scrollIntoView(options)</em><br>options为一个对象，属性如下：</p>\n<ul>\n<li>behavior<ul>\n<li>定义动画过渡效果</li>\n<li>值为：<ul>\n<li>auto(默认值)，无平滑滚动效果</li>\n<li>smooth，有平滑的滚动效果</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>block<ul>\n<li>定义垂直方向的对齐</li>\n<li>值为：<ul>\n<li>start: 默认值，顶端对齐</li>\n<li>center：中间对齐</li>\n<li>end：底端对齐</li>\n<li>nearest：如果元素完全在可视区域内，则垂直方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，垂直方向滚动父级容器，使元素完全在可视区域内。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>inline<ul>\n<li>定义水平方向的对齐</li>\n<li>值为：<ul>\n<li>start：左端对齐</li>\n<li>center：中间对齐</li>\n<li>end：右端对齐</li>\n<li>nearest: 默认值，如果元素完全在可视区域内，则水平方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，水平方向滚动父级容器，使元素完全在可视区域内。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：取决于其他元素的布局情况，此元素可能不会完全滚动到顶端或底端</strong></p>\n"},{"title":"react渲染","date":"2022-06-22T14:12:37.000Z","_content":"\n## 主要步骤\n#### React.createElement语法糖\n(1)React.createElement(type, [props], [...children]);\n(2)type：元素类型\n(3)props：属性值\n(4)children：子元素\n#### 虚拟DOM\n(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系\n(2)$$typeof：标识符，使用Symbol数据结构确保唯一性\n\n#### 协调算法\n#### filter图示\n![filter_tree](fiber_tree.png)\n\n## Element转化为Dom\n(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化\n(2)ReactDOM.render(element, container[, callback])\n(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function\n\n## 源码相关\n1、setState触发更新、父组件重新渲染时触发更新\n![update_class](update_class.png)\n(1)static getDerivedStateFromProps()\n(2)shouldComponentUpdate(nextProps,nextState)\n(3)render()\n(4)getSnapshotBeforeUpdate(prevProps,prevState)\n(5)componentDidUpdate(prevProps,prevState,snapshot)\n其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参\n2、forceUpdate触发更新\n![force_update](force_update.png)\n(1)static getDerivedStateFromProps()\n(2)render()\n(3)getSnapshotBeforeUpdate()\n(4)componentDidUpdate()","source":"_posts/5-react-render.md","raw":"---\ntitle: react渲染\ndate: 2022-06-22 22:12:37\ntags:\n---\n\n## 主要步骤\n#### React.createElement语法糖\n(1)React.createElement(type, [props], [...children]);\n(2)type：元素类型\n(3)props：属性值\n(4)children：子元素\n#### 虚拟DOM\n(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系\n(2)$$typeof：标识符，使用Symbol数据结构确保唯一性\n\n#### 协调算法\n#### filter图示\n![filter_tree](fiber_tree.png)\n\n## Element转化为Dom\n(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化\n(2)ReactDOM.render(element, container[, callback])\n(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function\n\n## 源码相关\n1、setState触发更新、父组件重新渲染时触发更新\n![update_class](update_class.png)\n(1)static getDerivedStateFromProps()\n(2)shouldComponentUpdate(nextProps,nextState)\n(3)render()\n(4)getSnapshotBeforeUpdate(prevProps,prevState)\n(5)componentDidUpdate(prevProps,prevState,snapshot)\n其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参\n2、forceUpdate触发更新\n![force_update](force_update.png)\n(1)static getDerivedStateFromProps()\n(2)render()\n(3)getSnapshotBeforeUpdate()\n(4)componentDidUpdate()","slug":"5-react-render","published":1,"updated":"2022-08-10T03:15:06.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx6001ocktt5q7ha88g","content":"<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><h4 id=\"React-createElement语法糖\"><a href=\"#React-createElement语法糖\" class=\"headerlink\" title=\"React.createElement语法糖\"></a>React.createElement语法糖</h4><p>(1)React.createElement(type, [props], […children]);<br>(2)type：元素类型<br>(3)props：属性值<br>(4)children：子元素</p>\n<h4 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h4><p>(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系<br>(2)$$typeof：标识符，使用Symbol数据结构确保唯一性</p>\n<h4 id=\"协调算法\"><a href=\"#协调算法\" class=\"headerlink\" title=\"协调算法\"></a>协调算法</h4><h4 id=\"filter图示\"><a href=\"#filter图示\" class=\"headerlink\" title=\"filter图示\"></a>filter图示</h4><p><img src=\"/2022/06/22/5-react-render/fiber_tree.png\" alt=\"filter_tree\"></p>\n<h2 id=\"Element转化为Dom\"><a href=\"#Element转化为Dom\" class=\"headerlink\" title=\"Element转化为Dom\"></a>Element转化为Dom</h2><p>(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化<br>(2)ReactDOM.render(element, container[, callback])<br>(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function</p>\n<h2 id=\"源码相关\"><a href=\"#源码相关\" class=\"headerlink\" title=\"源码相关\"></a>源码相关</h2><p>1、setState触发更新、父组件重新渲染时触发更新<br><img src=\"/2022/06/22/5-react-render/update_class.png\" alt=\"update_class\"><br>(1)static getDerivedStateFromProps()<br>(2)shouldComponentUpdate(nextProps,nextState)<br>(3)render()<br>(4)getSnapshotBeforeUpdate(prevProps,prevState)<br>(5)componentDidUpdate(prevProps,prevState,snapshot)<br>其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参<br>2、forceUpdate触发更新<br><img src=\"/2022/06/22/5-react-render/force_update.png\" alt=\"force_update\"><br>(1)static getDerivedStateFromProps()<br>(2)render()<br>(3)getSnapshotBeforeUpdate()<br>(4)componentDidUpdate()</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><h4 id=\"React-createElement语法糖\"><a href=\"#React-createElement语法糖\" class=\"headerlink\" title=\"React.createElement语法糖\"></a>React.createElement语法糖</h4><p>(1)React.createElement(type, [props], […children]);<br>(2)type：元素类型<br>(3)props：属性值<br>(4)children：子元素</p>\n<h4 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h4><p>(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系<br>(2)$$typeof：标识符，使用Symbol数据结构确保唯一性</p>\n<h4 id=\"协调算法\"><a href=\"#协调算法\" class=\"headerlink\" title=\"协调算法\"></a>协调算法</h4><h4 id=\"filter图示\"><a href=\"#filter图示\" class=\"headerlink\" title=\"filter图示\"></a>filter图示</h4><p><img src=\"/2022/06/22/5-react-render/fiber_tree.png\" alt=\"filter_tree\"></p>\n<h2 id=\"Element转化为Dom\"><a href=\"#Element转化为Dom\" class=\"headerlink\" title=\"Element转化为Dom\"></a>Element转化为Dom</h2><p>(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化<br>(2)ReactDOM.render(element, container[, callback])<br>(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function</p>\n<h2 id=\"源码相关\"><a href=\"#源码相关\" class=\"headerlink\" title=\"源码相关\"></a>源码相关</h2><p>1、setState触发更新、父组件重新渲染时触发更新<br><img src=\"/2022/06/22/5-react-render/update_class.png\" alt=\"update_class\"><br>(1)static getDerivedStateFromProps()<br>(2)shouldComponentUpdate(nextProps,nextState)<br>(3)render()<br>(4)getSnapshotBeforeUpdate(prevProps,prevState)<br>(5)componentDidUpdate(prevProps,prevState,snapshot)<br>其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参<br>2、forceUpdate触发更新<br><img src=\"/2022/06/22/5-react-render/force_update.png\" alt=\"force_update\"><br>(1)static getDerivedStateFromProps()<br>(2)render()<br>(3)getSnapshotBeforeUpdate()<br>(4)componentDidUpdate()</p>\n"},{"title":"前端压缩图片方法-canvas.toDataURL & canvas.toBlob","date":"2022-12-08T08:48:13.000Z","_content":"\n###### 为什么压缩图片？\n浏览器在加载页面的时候，图片也是影响请求前端用户体验的一环：如果图片较大，请求耗时越长，那页面会长时间处于加载中或者白屏状态，导致用户体验较差。所以压缩图片就成了一种比较常用的优化前端性能的手段。\n\n###### 压缩图片方法\n* 第一种：将图片传给后端，后端进行压缩\n* 第二种：使用canvas压缩图片\n思路：\n- 通过<input type=\"file\"/>获取二进制图片\n- 使用 FileReader 把二进制图片转换成base64格式，用于生成 Image 对象\n- 把图片绘制成 Canvas（这一步可以对图片尺寸进行压缩，这一步压缩效率最高，图片尺寸是最影响图片大小的）\n- 将Canvas 再转成 base64 图片（这一步可以对图片质量进行压缩）\n\n###### toDataURL\n* canvas对象的一种方法，用于将canvas对象转换为base64位编码.\n* 转化实现：将图片绘制到canvas中，然后将canvas对象转换为base64编码，从而实现图片转为base64编码；\n* 转换为base64位编码的好处：\n  - 将图片转换为base64位编码后，图片会跟随代码（html、css、js）一起请求加载，不会再单独进行请求加载；\n  - 可以防止由于图片路径错误导致图片加载失败的问题；\n* 注意事项：\n  - 如果画布的高度或宽度是 0，那么会返回字符串“data:,”\n* 参数：toDataURL(type, encoderOptions)\n  - type指定转换为base64编码后图片的格式，如：image/png、image/jpeg、image/webp等等，默认为image/png格式；\n  - encoderOptions用于设置转换为base64编码后图片的质量，在指定图片格式为 image/jpeg 或 image/webp 的情况下，取值范围为0-1，超出取值范围用默认值0.92代替；\n[MDN HTMLCanvasElement.toDataURL()](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL)\n\n###### toBlob\n* 创造 Blob 对象，用以展示 canvas 上的图片\n* 参数：toBlob(callback, type, quality)\n  - callback：回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值\n  - type(可选): DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png\n  - quality(可选): Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略\n[MDN HTMLCanvasElement.toBlob()](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob)\n\n###### toDataURL和toBlob的差异与共同点\n* 差异\n  - 绘制处理图片的过程不同：\n    - toBlob是直接将canvas中绘制的图形转换成Blob实例对象，再将Blob实例对象转成File实例对象即可\n    - toDataURL则是将canvas中绘制的图形转成base64编码的字符串，然后再将base64编码的字符串转成File的实例对象\n  - 结果不同：\n    - toBlob无返回值，通过传参中的回调函数，可获得一个单独的 Blob 对象参数\n    - toDataURL返回一个包含 data URI 的DOMString\n  - 执行不同：\n    - toDataURL是同步执行的，执行操作的时候会阻止UI\n    - toBlob通过回调函数获取返回值，非阻塞方式进行图像格式转换\n  - toDataURL结果比toBlob占用更多的内存，toDataURL包含在base64中压缩的完整二进制数据，base64编码本身意味着二进制数据比现在大37％\n\n* 共同点\n  - canvas方法，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92\n\n```javascript\n// toBlob\ncanvas.toBlob(\n  function (b) {\n    let compressUrl = URL.createObjectURL(b); //压缩后的文件url\n    let fileName =\n      imgFile.name.substring(0, imgFile.name.lastIndexOf('.')) +\n      '.' +\n      imgType.split('/')[1]; //重构文件名\n    let file = blobToFile(b, fileName, imgType); //Blob实例转成File实例\n    resolve({\n      url: compressUrl,\n      file: file,\n    });\n    imgCanvas = null; //释放内存\n  },\n  imgType,\n  quality\n);\n// toDataURL\ncanvas.toDataURL(imgType, quality);\n```","source":"_posts/43-compress-picture.md","raw":"---\ntitle: 前端压缩图片方法-canvas.toDataURL & canvas.toBlob\ndate: 2022-12-08 16:48:13\ntags:\n---\n\n###### 为什么压缩图片？\n浏览器在加载页面的时候，图片也是影响请求前端用户体验的一环：如果图片较大，请求耗时越长，那页面会长时间处于加载中或者白屏状态，导致用户体验较差。所以压缩图片就成了一种比较常用的优化前端性能的手段。\n\n###### 压缩图片方法\n* 第一种：将图片传给后端，后端进行压缩\n* 第二种：使用canvas压缩图片\n思路：\n- 通过<input type=\"file\"/>获取二进制图片\n- 使用 FileReader 把二进制图片转换成base64格式，用于生成 Image 对象\n- 把图片绘制成 Canvas（这一步可以对图片尺寸进行压缩，这一步压缩效率最高，图片尺寸是最影响图片大小的）\n- 将Canvas 再转成 base64 图片（这一步可以对图片质量进行压缩）\n\n###### toDataURL\n* canvas对象的一种方法，用于将canvas对象转换为base64位编码.\n* 转化实现：将图片绘制到canvas中，然后将canvas对象转换为base64编码，从而实现图片转为base64编码；\n* 转换为base64位编码的好处：\n  - 将图片转换为base64位编码后，图片会跟随代码（html、css、js）一起请求加载，不会再单独进行请求加载；\n  - 可以防止由于图片路径错误导致图片加载失败的问题；\n* 注意事项：\n  - 如果画布的高度或宽度是 0，那么会返回字符串“data:,”\n* 参数：toDataURL(type, encoderOptions)\n  - type指定转换为base64编码后图片的格式，如：image/png、image/jpeg、image/webp等等，默认为image/png格式；\n  - encoderOptions用于设置转换为base64编码后图片的质量，在指定图片格式为 image/jpeg 或 image/webp 的情况下，取值范围为0-1，超出取值范围用默认值0.92代替；\n[MDN HTMLCanvasElement.toDataURL()](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL)\n\n###### toBlob\n* 创造 Blob 对象，用以展示 canvas 上的图片\n* 参数：toBlob(callback, type, quality)\n  - callback：回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值\n  - type(可选): DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png\n  - quality(可选): Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略\n[MDN HTMLCanvasElement.toBlob()](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob)\n\n###### toDataURL和toBlob的差异与共同点\n* 差异\n  - 绘制处理图片的过程不同：\n    - toBlob是直接将canvas中绘制的图形转换成Blob实例对象，再将Blob实例对象转成File实例对象即可\n    - toDataURL则是将canvas中绘制的图形转成base64编码的字符串，然后再将base64编码的字符串转成File的实例对象\n  - 结果不同：\n    - toBlob无返回值，通过传参中的回调函数，可获得一个单独的 Blob 对象参数\n    - toDataURL返回一个包含 data URI 的DOMString\n  - 执行不同：\n    - toDataURL是同步执行的，执行操作的时候会阻止UI\n    - toBlob通过回调函数获取返回值，非阻塞方式进行图像格式转换\n  - toDataURL结果比toBlob占用更多的内存，toDataURL包含在base64中压缩的完整二进制数据，base64编码本身意味着二进制数据比现在大37％\n\n* 共同点\n  - canvas方法，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92\n\n```javascript\n// toBlob\ncanvas.toBlob(\n  function (b) {\n    let compressUrl = URL.createObjectURL(b); //压缩后的文件url\n    let fileName =\n      imgFile.name.substring(0, imgFile.name.lastIndexOf('.')) +\n      '.' +\n      imgType.split('/')[1]; //重构文件名\n    let file = blobToFile(b, fileName, imgType); //Blob实例转成File实例\n    resolve({\n      url: compressUrl,\n      file: file,\n    });\n    imgCanvas = null; //释放内存\n  },\n  imgType,\n  quality\n);\n// toDataURL\ncanvas.toDataURL(imgType, quality);\n```","slug":"43-compress-picture","published":1,"updated":"2022-12-09T01:43:39.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx7001pcktt13bq8zys","content":"<h6 id=\"为什么压缩图片？\"><a href=\"#为什么压缩图片？\" class=\"headerlink\" title=\"为什么压缩图片？\"></a>为什么压缩图片？</h6><p>浏览器在加载页面的时候，图片也是影响请求前端用户体验的一环：如果图片较大，请求耗时越长，那页面会长时间处于加载中或者白屏状态，导致用户体验较差。所以压缩图片就成了一种比较常用的优化前端性能的手段。</p>\n<h6 id=\"压缩图片方法\"><a href=\"#压缩图片方法\" class=\"headerlink\" title=\"压缩图片方法\"></a>压缩图片方法</h6><ul>\n<li>第一种：将图片传给后端，后端进行压缩</li>\n<li>第二种：使用canvas压缩图片<br>思路：</li>\n</ul>\n<ul>\n<li>通过<input type=\"file\">获取二进制图片</li>\n<li>使用 FileReader 把二进制图片转换成base64格式，用于生成 Image 对象</li>\n<li>把图片绘制成 Canvas（这一步可以对图片尺寸进行压缩，这一步压缩效率最高，图片尺寸是最影响图片大小的）</li>\n<li>将Canvas 再转成 base64 图片（这一步可以对图片质量进行压缩）</li>\n</ul>\n<h6 id=\"toDataURL\"><a href=\"#toDataURL\" class=\"headerlink\" title=\"toDataURL\"></a>toDataURL</h6><ul>\n<li>canvas对象的一种方法，用于将canvas对象转换为base64位编码.</li>\n<li>转化实现：将图片绘制到canvas中，然后将canvas对象转换为base64编码，从而实现图片转为base64编码；</li>\n<li>转换为base64位编码的好处：<ul>\n<li>将图片转换为base64位编码后，图片会跟随代码（html、css、js）一起请求加载，不会再单独进行请求加载；</li>\n<li>可以防止由于图片路径错误导致图片加载失败的问题；</li>\n</ul>\n</li>\n<li>注意事项：<ul>\n<li>如果画布的高度或宽度是 0，那么会返回字符串“data:,”</li>\n</ul>\n</li>\n<li>参数：toDataURL(type, encoderOptions)<ul>\n<li>type指定转换为base64编码后图片的格式，如：image/png、image/jpeg、image/webp等等，默认为image/png格式；</li>\n<li>encoderOptions用于设置转换为base64编码后图片的质量，在指定图片格式为 image/jpeg 或 image/webp 的情况下，取值范围为0-1，超出取值范围用默认值0.92代替；<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL\">MDN HTMLCanvasElement.toDataURL()</a></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"toBlob\"><a href=\"#toBlob\" class=\"headerlink\" title=\"toBlob\"></a>toBlob</h6><ul>\n<li>创造 Blob 对象，用以展示 canvas 上的图片</li>\n<li>参数：toBlob(callback, type, quality)<ul>\n<li>callback：回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值</li>\n<li>type(可选): DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png</li>\n<li>quality(可选): Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob\">MDN HTMLCanvasElement.toBlob()</a></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"toDataURL和toBlob的差异与共同点\"><a href=\"#toDataURL和toBlob的差异与共同点\" class=\"headerlink\" title=\"toDataURL和toBlob的差异与共同点\"></a>toDataURL和toBlob的差异与共同点</h6><ul>\n<li><p>差异</p>\n<ul>\n<li>绘制处理图片的过程不同：<ul>\n<li>toBlob是直接将canvas中绘制的图形转换成Blob实例对象，再将Blob实例对象转成File实例对象即可</li>\n<li>toDataURL则是将canvas中绘制的图形转成base64编码的字符串，然后再将base64编码的字符串转成File的实例对象</li>\n</ul>\n</li>\n<li>结果不同：<ul>\n<li>toBlob无返回值，通过传参中的回调函数，可获得一个单独的 Blob 对象参数</li>\n<li>toDataURL返回一个包含 data URI 的DOMString</li>\n</ul>\n</li>\n<li>执行不同：<ul>\n<li>toDataURL是同步执行的，执行操作的时候会阻止UI</li>\n<li>toBlob通过回调函数获取返回值，非阻塞方式进行图像格式转换</li>\n</ul>\n</li>\n<li>toDataURL结果比toBlob占用更多的内存，toDataURL包含在base64中压缩的完整二进制数据，base64编码本身意味着二进制数据比现在大37％</li>\n</ul>\n</li>\n<li><p>共同点</p>\n<ul>\n<li>canvas方法，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// toBlob</span></span><br><span class=\"line\">canvas.toBlob(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> compressUrl = URL.createObjectURL(b); <span class=\"comment\">//压缩后的文件url</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileName =</span><br><span class=\"line\">      imgFile.name.substring(<span class=\"number\">0</span>, imgFile.name.lastIndexOf(<span class=\"string\">&#x27;.&#x27;</span>)) +</span><br><span class=\"line\">      <span class=\"string\">&#x27;.&#x27;</span> +</span><br><span class=\"line\">      imgType.split(<span class=\"string\">&#x27;/&#x27;</span>)[<span class=\"number\">1</span>]; <span class=\"comment\">//重构文件名</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = blobToFile(b, fileName, imgType); <span class=\"comment\">//Blob实例转成File实例</span></span><br><span class=\"line\">    resolve(&#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: compressUrl,</span><br><span class=\"line\">      <span class=\"attr\">file</span>: file,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    imgCanvas = <span class=\"literal\">null</span>; <span class=\"comment\">//释放内存</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  imgType,</span><br><span class=\"line\">  quality</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// toDataURL</span></span><br><span class=\"line\">canvas.toDataURL(imgType, quality);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"为什么压缩图片？\"><a href=\"#为什么压缩图片？\" class=\"headerlink\" title=\"为什么压缩图片？\"></a>为什么压缩图片？</h6><p>浏览器在加载页面的时候，图片也是影响请求前端用户体验的一环：如果图片较大，请求耗时越长，那页面会长时间处于加载中或者白屏状态，导致用户体验较差。所以压缩图片就成了一种比较常用的优化前端性能的手段。</p>\n<h6 id=\"压缩图片方法\"><a href=\"#压缩图片方法\" class=\"headerlink\" title=\"压缩图片方法\"></a>压缩图片方法</h6><ul>\n<li>第一种：将图片传给后端，后端进行压缩</li>\n<li>第二种：使用canvas压缩图片<br>思路：</li>\n</ul>\n<ul>\n<li>通过<input type=\"file\">获取二进制图片</li>\n<li>使用 FileReader 把二进制图片转换成base64格式，用于生成 Image 对象</li>\n<li>把图片绘制成 Canvas（这一步可以对图片尺寸进行压缩，这一步压缩效率最高，图片尺寸是最影响图片大小的）</li>\n<li>将Canvas 再转成 base64 图片（这一步可以对图片质量进行压缩）</li>\n</ul>\n<h6 id=\"toDataURL\"><a href=\"#toDataURL\" class=\"headerlink\" title=\"toDataURL\"></a>toDataURL</h6><ul>\n<li>canvas对象的一种方法，用于将canvas对象转换为base64位编码.</li>\n<li>转化实现：将图片绘制到canvas中，然后将canvas对象转换为base64编码，从而实现图片转为base64编码；</li>\n<li>转换为base64位编码的好处：<ul>\n<li>将图片转换为base64位编码后，图片会跟随代码（html、css、js）一起请求加载，不会再单独进行请求加载；</li>\n<li>可以防止由于图片路径错误导致图片加载失败的问题；</li>\n</ul>\n</li>\n<li>注意事项：<ul>\n<li>如果画布的高度或宽度是 0，那么会返回字符串“data:,”</li>\n</ul>\n</li>\n<li>参数：toDataURL(type, encoderOptions)<ul>\n<li>type指定转换为base64编码后图片的格式，如：image/png、image/jpeg、image/webp等等，默认为image/png格式；</li>\n<li>encoderOptions用于设置转换为base64编码后图片的质量，在指定图片格式为 image/jpeg 或 image/webp 的情况下，取值范围为0-1，超出取值范围用默认值0.92代替；<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL\">MDN HTMLCanvasElement.toDataURL()</a></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"toBlob\"><a href=\"#toBlob\" class=\"headerlink\" title=\"toBlob\"></a>toBlob</h6><ul>\n<li>创造 Blob 对象，用以展示 canvas 上的图片</li>\n<li>参数：toBlob(callback, type, quality)<ul>\n<li>callback：回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值</li>\n<li>type(可选): DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png</li>\n<li>quality(可选): Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob\">MDN HTMLCanvasElement.toBlob()</a></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"toDataURL和toBlob的差异与共同点\"><a href=\"#toDataURL和toBlob的差异与共同点\" class=\"headerlink\" title=\"toDataURL和toBlob的差异与共同点\"></a>toDataURL和toBlob的差异与共同点</h6><ul>\n<li><p>差异</p>\n<ul>\n<li>绘制处理图片的过程不同：<ul>\n<li>toBlob是直接将canvas中绘制的图形转换成Blob实例对象，再将Blob实例对象转成File实例对象即可</li>\n<li>toDataURL则是将canvas中绘制的图形转成base64编码的字符串，然后再将base64编码的字符串转成File的实例对象</li>\n</ul>\n</li>\n<li>结果不同：<ul>\n<li>toBlob无返回值，通过传参中的回调函数，可获得一个单独的 Blob 对象参数</li>\n<li>toDataURL返回一个包含 data URI 的DOMString</li>\n</ul>\n</li>\n<li>执行不同：<ul>\n<li>toDataURL是同步执行的，执行操作的时候会阻止UI</li>\n<li>toBlob通过回调函数获取返回值，非阻塞方式进行图像格式转换</li>\n</ul>\n</li>\n<li>toDataURL结果比toBlob占用更多的内存，toDataURL包含在base64中压缩的完整二进制数据，base64编码本身意味着二进制数据比现在大37％</li>\n</ul>\n</li>\n<li><p>共同点</p>\n<ul>\n<li>canvas方法，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// toBlob</span></span><br><span class=\"line\">canvas.toBlob(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> compressUrl = URL.createObjectURL(b); <span class=\"comment\">//压缩后的文件url</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileName =</span><br><span class=\"line\">      imgFile.name.substring(<span class=\"number\">0</span>, imgFile.name.lastIndexOf(<span class=\"string\">&#x27;.&#x27;</span>)) +</span><br><span class=\"line\">      <span class=\"string\">&#x27;.&#x27;</span> +</span><br><span class=\"line\">      imgType.split(<span class=\"string\">&#x27;/&#x27;</span>)[<span class=\"number\">1</span>]; <span class=\"comment\">//重构文件名</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = blobToFile(b, fileName, imgType); <span class=\"comment\">//Blob实例转成File实例</span></span><br><span class=\"line\">    resolve(&#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: compressUrl,</span><br><span class=\"line\">      <span class=\"attr\">file</span>: file,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    imgCanvas = <span class=\"literal\">null</span>; <span class=\"comment\">//释放内存</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  imgType,</span><br><span class=\"line\">  quality</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// toDataURL</span></span><br><span class=\"line\">canvas.toDataURL(imgType, quality);</span><br></pre></td></tr></table></figure>"},{"title":"关于grid布局的相关内容","date":"2023-01-03T07:28:21.000Z","_content":"\n###### 什么是grid布局？\n###### 怎么实现grid布局？\n###### grid布局的好处\n###### grid布局中一些常用设置说明\n- grid-row: grid-row-start / grid-row-end;\n  - grid-row-start\t指定在哪一行开始显示网格元素。\n  - grid-row-end\t指定停止显示网格元素的行，或要跨越多少行。\n```css\n/* 设置 \"item1\" 在第 1 行开始，在第 4 行前结束 */\n.item1 {\n  grid-row: 1 / 4;\n}\n/* 可以参考行号来设置网格元素，也可以使用关键字 \"span\" 来定义元素将跨越的行数。 */\n/* 设置 \"item1\" 跨越两行 */\n.item1 {\n  grid-row: 1 / span 2;\n}\n```\n- grid-template-columns\n  - 规定网格布局中的列数（和宽度）\n```css\n/* 设置三列，每列10px */\n.grid-container {\n  grid-template-columns: 10px 10px 10px;\n}\n/* 设置四列，每列宽度自适应 */\n.grid-container {\n  grid-template-columns: auto auto auto auto;\n}\n```\n- repeat()\n  - 函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。\n  - 该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows。\n```css\n/* repeat(4, 1fr) */\n/* 设置四列，每列均分 */\n.grid-container {\n  grid-template-columns: repeat(4, 1fr);\n}\n```\n- fr\n  - 一种新的长度单位 fr(fraction)。它表示 Grid 布局中中剩余空间(leftover space)的一部分(fraction)。\n  - 一般来说 1fr 的意思是“100%的剩余空间”, .25fr 意味着“25%的剩余空间”。当时当 fr 大于 1 的时候，则会重新计算比例来分配\n  - 一般都建议使用 fr>=1 的情况, 比如说 1fr 2fr 就比 .33fr .67fr 可读性更强。","source":"_posts/44-about-grid.md","raw":"---\ntitle: 关于grid布局的相关内容\ndate: 2023-01-03 15:28:21\ntags:\n---\n\n###### 什么是grid布局？\n###### 怎么实现grid布局？\n###### grid布局的好处\n###### grid布局中一些常用设置说明\n- grid-row: grid-row-start / grid-row-end;\n  - grid-row-start\t指定在哪一行开始显示网格元素。\n  - grid-row-end\t指定停止显示网格元素的行，或要跨越多少行。\n```css\n/* 设置 \"item1\" 在第 1 行开始，在第 4 行前结束 */\n.item1 {\n  grid-row: 1 / 4;\n}\n/* 可以参考行号来设置网格元素，也可以使用关键字 \"span\" 来定义元素将跨越的行数。 */\n/* 设置 \"item1\" 跨越两行 */\n.item1 {\n  grid-row: 1 / span 2;\n}\n```\n- grid-template-columns\n  - 规定网格布局中的列数（和宽度）\n```css\n/* 设置三列，每列10px */\n.grid-container {\n  grid-template-columns: 10px 10px 10px;\n}\n/* 设置四列，每列宽度自适应 */\n.grid-container {\n  grid-template-columns: auto auto auto auto;\n}\n```\n- repeat()\n  - 函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。\n  - 该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows。\n```css\n/* repeat(4, 1fr) */\n/* 设置四列，每列均分 */\n.grid-container {\n  grid-template-columns: repeat(4, 1fr);\n}\n```\n- fr\n  - 一种新的长度单位 fr(fraction)。它表示 Grid 布局中中剩余空间(leftover space)的一部分(fraction)。\n  - 一般来说 1fr 的意思是“100%的剩余空间”, .25fr 意味着“25%的剩余空间”。当时当 fr 大于 1 的时候，则会重新计算比例来分配\n  - 一般都建议使用 fr>=1 的情况, 比如说 1fr 2fr 就比 .33fr .67fr 可读性更强。","slug":"44-about-grid","published":1,"updated":"2023-01-03T08:17:58.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx7001qcktt5y4ac7aj","content":"<h6 id=\"什么是grid布局？\"><a href=\"#什么是grid布局？\" class=\"headerlink\" title=\"什么是grid布局？\"></a>什么是grid布局？</h6><h6 id=\"怎么实现grid布局？\"><a href=\"#怎么实现grid布局？\" class=\"headerlink\" title=\"怎么实现grid布局？\"></a>怎么实现grid布局？</h6><h6 id=\"grid布局的好处\"><a href=\"#grid布局的好处\" class=\"headerlink\" title=\"grid布局的好处\"></a>grid布局的好处</h6><h6 id=\"grid布局中一些常用设置说明\"><a href=\"#grid布局中一些常用设置说明\" class=\"headerlink\" title=\"grid布局中一些常用设置说明\"></a>grid布局中一些常用设置说明</h6><ul>\n<li>grid-row: grid-row-start / grid-row-end;<ul>\n<li>grid-row-start    指定在哪一行开始显示网格元素。</li>\n<li>grid-row-end    指定停止显示网格元素的行，或要跨越多少行。<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置 &quot;item1&quot; 在第 1 行开始，在第 4 行前结束 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.item1</span> &#123;</span><br><span class=\"line\">  grid-row: <span class=\"number\">1</span> / <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 可以参考行号来设置网格元素，也可以使用关键字 &quot;span&quot; 来定义元素将跨越的行数。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 设置 &quot;item1&quot; 跨越两行 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.item1</span> &#123;</span><br><span class=\"line\">  grid-row: <span class=\"number\">1</span> / span <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>grid-template-columns<ul>\n<li>规定网格布局中的列数（和宽度）<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置三列，每列10px */</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  grid-template-<span class=\"attribute\">columns</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 设置四列，每列宽度自适应 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  grid-template-<span class=\"attribute\">columns</span>: auto auto auto auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>repeat()<ul>\n<li>函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。</li>\n<li>该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows。<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* repeat(4, 1fr) */</span></span><br><span class=\"line\"><span class=\"comment\">/* 设置四列，每列均分 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  grid-template-<span class=\"attribute\">columns</span>: <span class=\"built_in\">repeat</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>fr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>fr<ul>\n<li>一种新的长度单位 fr(fraction)。它表示 Grid 布局中中剩余空间(leftover space)的一部分(fraction)。</li>\n<li>一般来说 1fr 的意思是“100%的剩余空间”, .25fr 意味着“25%的剩余空间”。当时当 fr 大于 1 的时候，则会重新计算比例来分配</li>\n<li>一般都建议使用 fr&gt;=1 的情况, 比如说 1fr 2fr 就比 .33fr .67fr 可读性更强。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"什么是grid布局？\"><a href=\"#什么是grid布局？\" class=\"headerlink\" title=\"什么是grid布局？\"></a>什么是grid布局？</h6><h6 id=\"怎么实现grid布局？\"><a href=\"#怎么实现grid布局？\" class=\"headerlink\" title=\"怎么实现grid布局？\"></a>怎么实现grid布局？</h6><h6 id=\"grid布局的好处\"><a href=\"#grid布局的好处\" class=\"headerlink\" title=\"grid布局的好处\"></a>grid布局的好处</h6><h6 id=\"grid布局中一些常用设置说明\"><a href=\"#grid布局中一些常用设置说明\" class=\"headerlink\" title=\"grid布局中一些常用设置说明\"></a>grid布局中一些常用设置说明</h6><ul>\n<li>grid-row: grid-row-start / grid-row-end;<ul>\n<li>grid-row-start    指定在哪一行开始显示网格元素。</li>\n<li>grid-row-end    指定停止显示网格元素的行，或要跨越多少行。<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置 &quot;item1&quot; 在第 1 行开始，在第 4 行前结束 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.item1</span> &#123;</span><br><span class=\"line\">  grid-row: <span class=\"number\">1</span> / <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 可以参考行号来设置网格元素，也可以使用关键字 &quot;span&quot; 来定义元素将跨越的行数。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 设置 &quot;item1&quot; 跨越两行 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.item1</span> &#123;</span><br><span class=\"line\">  grid-row: <span class=\"number\">1</span> / span <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>grid-template-columns<ul>\n<li>规定网格布局中的列数（和宽度）<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置三列，每列10px */</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  grid-template-<span class=\"attribute\">columns</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 设置四列，每列宽度自适应 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  grid-template-<span class=\"attribute\">columns</span>: auto auto auto auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>repeat()<ul>\n<li>函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。</li>\n<li>该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows。<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* repeat(4, 1fr) */</span></span><br><span class=\"line\"><span class=\"comment\">/* 设置四列，每列均分 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  grid-template-<span class=\"attribute\">columns</span>: <span class=\"built_in\">repeat</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>fr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>fr<ul>\n<li>一种新的长度单位 fr(fraction)。它表示 Grid 布局中中剩余空间(leftover space)的一部分(fraction)。</li>\n<li>一般来说 1fr 的意思是“100%的剩余空间”, .25fr 意味着“25%的剩余空间”。当时当 fr 大于 1 的时候，则会重新计算比例来分配</li>\n<li>一般都建议使用 fr&gt;=1 的情况, 比如说 1fr 2fr 就比 .33fr .67fr 可读性更强。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"vue3渲染","date":"2022-06-22T14:12:51.000Z","_content":"\n## 渲染流程\n![vue3_render](vue3_render.png)\n(1)创建一个vue实例 -> 初始化实例（包括需要相关事件与生命周期函数等）\n(2)调用beforeCreate\n(3)初始化注入，包括data、method等添加到实例对象\n(4)实例创建完成，调用created\n(5)有el挂载，使用template替换；无挂载，使用mount自动挂载\n(6)有template，进行编译，使其成为render函数\n(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板\n(8)调用beforeMount（vue实例挂载在虚拟DOM上）\n(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）\n(10)调用mounted\n-- （1）数据变更，即将重新渲染\n-- （2）调用beforeUpdate\n-- （3）进行虚拟DOM和真实DOM对比，进行patch\n-- （4）渲染完成，调用updated\n(11)实例销毁之前调用beforeUnmount\n(12)实例销毁，vm.$destroy\n(13)销毁后调用unmounted\n\n## render函数\n![render](render.png)\n(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载\n(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）\n(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池\n(4)最后更新容器上的Vnode\n注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）\n\n## patch函数\n![render_node1](render_node1.png)\n![render_node2](render_node2.png)\n![render_function](render_function.png)\n注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等\n(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点\n(2)container 是新节点的容器\n(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物\n(4)optimized 参数是是否开启优化模式的标识\n\n## 卸载组件\n如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：\n(1)如果存在ref，会首先重置ref\n(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载\n(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载\n","source":"_posts/6-vue3-render.md","raw":"---\ntitle: vue3渲染\ndate: 2022-06-22 22:12:51\ntags:\n---\n\n## 渲染流程\n![vue3_render](vue3_render.png)\n(1)创建一个vue实例 -> 初始化实例（包括需要相关事件与生命周期函数等）\n(2)调用beforeCreate\n(3)初始化注入，包括data、method等添加到实例对象\n(4)实例创建完成，调用created\n(5)有el挂载，使用template替换；无挂载，使用mount自动挂载\n(6)有template，进行编译，使其成为render函数\n(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板\n(8)调用beforeMount（vue实例挂载在虚拟DOM上）\n(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）\n(10)调用mounted\n-- （1）数据变更，即将重新渲染\n-- （2）调用beforeUpdate\n-- （3）进行虚拟DOM和真实DOM对比，进行patch\n-- （4）渲染完成，调用updated\n(11)实例销毁之前调用beforeUnmount\n(12)实例销毁，vm.$destroy\n(13)销毁后调用unmounted\n\n## render函数\n![render](render.png)\n(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载\n(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）\n(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池\n(4)最后更新容器上的Vnode\n注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）\n\n## patch函数\n![render_node1](render_node1.png)\n![render_node2](render_node2.png)\n![render_function](render_function.png)\n注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等\n(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点\n(2)container 是新节点的容器\n(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物\n(4)optimized 参数是是否开启优化模式的标识\n\n## 卸载组件\n如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：\n(1)如果存在ref，会首先重置ref\n(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载\n(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载\n","slug":"6-vue3-render","published":1,"updated":"2022-08-10T03:16:20.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx7001rckttcenka803","content":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p><img src=\"/2022/06/22/6-vue3-render/vue3_render.png\" alt=\"vue3_render\"><br>(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）<br>(2)调用beforeCreate<br>(3)初始化注入，包括data、method等添加到实例对象<br>(4)实例创建完成，调用created<br>(5)有el挂载，使用template替换；无挂载，使用mount自动挂载<br>(6)有template，进行编译，使其成为render函数<br>(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板<br>(8)调用beforeMount（vue实例挂载在虚拟DOM上）<br>(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）<br>(10)调用mounted<br>– （1）数据变更，即将重新渲染<br>– （2）调用beforeUpdate<br>– （3）进行虚拟DOM和真实DOM对比，进行patch<br>– （4）渲染完成，调用updated<br>(11)实例销毁之前调用beforeUnmount<br>(12)实例销毁，vm.$destroy<br>(13)销毁后调用unmounted</p>\n<h2 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render.png\" alt=\"render\"><br>(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载<br>(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）<br>(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池<br>(4)最后更新容器上的Vnode<br>注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）</p>\n<h2 id=\"patch函数\"><a href=\"#patch函数\" class=\"headerlink\" title=\"patch函数\"></a>patch函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render_node1.png\" alt=\"render_node1\"><br><img src=\"/2022/06/22/6-vue3-render/render_node2.png\" alt=\"render_node2\"><br><img src=\"/2022/06/22/6-vue3-render/render_function.png\" alt=\"render_function\"><br>注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等<br>(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点<br>(2)container 是新节点的容器<br>(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物<br>(4)optimized 参数是是否开启优化模式的标识</p>\n<h2 id=\"卸载组件\"><a href=\"#卸载组件\" class=\"headerlink\" title=\"卸载组件\"></a>卸载组件</h2><p>如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：<br>(1)如果存在ref，会首先重置ref<br>(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载<br>(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h2><p><img src=\"/2022/06/22/6-vue3-render/vue3_render.png\" alt=\"vue3_render\"><br>(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）<br>(2)调用beforeCreate<br>(3)初始化注入，包括data、method等添加到实例对象<br>(4)实例创建完成，调用created<br>(5)有el挂载，使用template替换；无挂载，使用mount自动挂载<br>(6)有template，进行编译，使其成为render函数<br>(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板<br>(8)调用beforeMount（vue实例挂载在虚拟DOM上）<br>(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）<br>(10)调用mounted<br>– （1）数据变更，即将重新渲染<br>– （2）调用beforeUpdate<br>– （3）进行虚拟DOM和真实DOM对比，进行patch<br>– （4）渲染完成，调用updated<br>(11)实例销毁之前调用beforeUnmount<br>(12)实例销毁，vm.$destroy<br>(13)销毁后调用unmounted</p>\n<h2 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render.png\" alt=\"render\"><br>(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载<br>(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）<br>(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池<br>(4)最后更新容器上的Vnode<br>注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染）</p>\n<h2 id=\"patch函数\"><a href=\"#patch函数\" class=\"headerlink\" title=\"patch函数\"></a>patch函数</h2><p><img src=\"/2022/06/22/6-vue3-render/render_node1.png\" alt=\"render_node1\"><br><img src=\"/2022/06/22/6-vue3-render/render_node2.png\" alt=\"render_node2\"><br><img src=\"/2022/06/22/6-vue3-render/render_function.png\" alt=\"render_function\"><br>注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等<br>(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点<br>(2)container 是新节点的容器<br>(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物<br>(4)optimized 参数是是否开启优化模式的标识</p>\n<h2 id=\"卸载组件\"><a href=\"#卸载组件\" class=\"headerlink\" title=\"卸载组件\"></a>卸载组件</h2><p>如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：<br>(1)如果存在ref，会首先重置ref<br>(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载<br>(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载</p>\n"},{"title":"react & vue渲染问题","date":"2022-06-23T05:21:12.000Z","_content":"\n#### 疑问点\n(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？\n类似渲染的子节点？？？\n(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？\n没什么特别意义，团队规范规定\n(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？\n性能、更新\n(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js\nreact-dom =》 渲染浏览器\nvue可以搭配react-dom\n(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？\n可以，使用createElement\n(6)hooks和函数的区别是什么？没区别\n(7)vue3中element-plus组件函数的类型从哪里获取？\n(8)如何将看到的东西和实际应用联系起来？\n(9)怎么抓住重点？\n","source":"_posts/7-question-about-render.md","raw":"---\ntitle: react & vue渲染问题\ndate: 2022-06-23 13:21:12\ntags:\n---\n\n#### 疑问点\n(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？\n类似渲染的子节点？？？\n(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？\n没什么特别意义，团队规范规定\n(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？\n性能、更新\n(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js\nreact-dom =》 渲染浏览器\nvue可以搭配react-dom\n(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？\n可以，使用createElement\n(6)hooks和函数的区别是什么？没区别\n(7)vue3中element-plus组件函数的类型从哪里获取？\n(8)如何将看到的东西和实际应用联系起来？\n(9)怎么抓住重点？\n","slug":"7-question-about-render","published":1,"updated":"2022-08-10T03:14:53.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx8001scktt8kyh3pzz","content":"<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？<br>类似渲染的子节点？？？<br>(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？<br>没什么特别意义，团队规范规定<br>(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？<br>性能、更新<br>(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js<br>react-dom =》 渲染浏览器<br>vue可以搭配react-dom<br>(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？<br>可以，使用createElement<br>(6)hooks和函数的区别是什么？没区别<br>(7)vue3中element-plus组件函数的类型从哪里获取？<br>(8)如何将看到的东西和实际应用联系起来？<br>(9)怎么抓住重点？</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h4><p>(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？<br>类似渲染的子节点？？？<br>(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？<br>没什么特别意义，团队规范规定<br>(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？<br>性能、更新<br>(4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.js<br>react-dom =》 渲染浏览器<br>vue可以搭配react-dom<br>(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？<br>可以，使用createElement<br>(6)hooks和函数的区别是什么？没区别<br>(7)vue3中element-plus组件函数的类型从哪里获取？<br>(8)如何将看到的东西和实际应用联系起来？<br>(9)怎么抓住重点？</p>\n"},{"title":"js-新建固定长度数据","date":"2022-06-27T02:20:46.000Z","_content":"\n#### 新建固定长度数组\n\n###### 使用primitives填充数组\n```javascript\nconst newArray = Array(3).fill(3);\nconsole.log(newArray);  // [3, 3, 3]\n```\nArray(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法\n\n###### 使用对象填充数组\n(1)使用Array().fill()创建数组\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\nArray(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。\n这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 2}, {value: 2}, {value: 2}]\n```\n(2)使用Array.from()创建数组\nArray.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n(3)使用Array.map()结合Array.fill()创建数组\n注意：不要直接使用map新建数组，**array.map()跳过 empty 元素**\n```javascript\nconst newArray = Array(3).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [empty x 3]\n```\n解决方法很简单，将 empty 数组 fill null 即可：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n注意：使用这种方法创建的数组，修改某一项时不影响其他项：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n","source":"_posts/8-create-fixed-length-array.md","raw":"---\ntitle: js-新建固定长度数据\ndate: 2022-06-27 10:20:46\ntags:\n---\n\n#### 新建固定长度数组\n\n###### 使用primitives填充数组\n```javascript\nconst newArray = Array(3).fill(3);\nconsole.log(newArray);  // [3, 3, 3]\n```\nArray(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法\n\n###### 使用对象填充数组\n(1)使用Array().fill()创建数组\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\nArray(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。\n这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:\n```javascript\nconst newArray = Array(3).fill({ value: 0 });\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 2}, {value: 2}, {value: 2}]\n```\n(2)使用Array.from()创建数组\nArray.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：\n```javascript\nconst newArray = Array.from(Array(3), () => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n(3)使用Array.map()结合Array.fill()创建数组\n注意：不要直接使用map新建数组，**array.map()跳过 empty 元素**\n```javascript\nconst newArray = Array(3).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [empty x 3]\n```\n解决方法很简单，将 empty 数组 fill null 即可：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\n```\n注意：使用这种方法创建的数组，修改某一项时不影响其他项：\n```javascript\nconst newArray = Array(3).fill(null).map(() => {\n  return { value: 0 };\n});\nconsole.log(newArray);  // [{value: 0}, {value: 0}, {value: 0}]\nnewArray[1].value = 2;\nconsole.log(newArray);  // [{value: 0}, {value: 2}, {value: 0}]\n```\n","slug":"8-create-fixed-length-array","published":1,"updated":"2022-08-10T03:12:26.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx8001tcktt1pzc3gt0","content":"<h4 id=\"新建固定长度数组\"><a href=\"#新建固定长度数组\" class=\"headerlink\" title=\"新建固定长度数组\"></a>新建固定长度数组</h4><h6 id=\"使用primitives填充数组\"><a href=\"#使用primitives填充数组\" class=\"headerlink\" title=\"使用primitives填充数组\"></a>使用primitives填充数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [3, 3, 3]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法</p>\n<h6 id=\"使用对象填充数组\"><a href=\"#使用对象填充数组\" class=\"headerlink\" title=\"使用对象填充数组\"></a>使用对象填充数组</h6><p>(1)使用Array().fill()创建数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。<br>这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 2&#125;, &#123;value: 2&#125;, &#123;value: 2&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(2)使用Array.from()创建数组<br>Array.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。<br>因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(3)使用Array.map()结合Array.fill()创建数组<br>注意：不要直接使用map新建数组，<strong>array.map()跳过 empty 元素</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [empty x 3]</span></span><br></pre></td></tr></table></figure>\n<p>解决方法很简单，将 empty 数组 fill null 即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>注意：使用这种方法创建的数组，修改某一项时不影响其他项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"新建固定长度数组\"><a href=\"#新建固定长度数组\" class=\"headerlink\" title=\"新建固定长度数组\"></a>新建固定长度数组</h4><h6 id=\"使用primitives填充数组\"><a href=\"#使用primitives填充数组\" class=\"headerlink\" title=\"使用primitives填充数组\"></a>使用primitives填充数组</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [3, 3, 3]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法</p>\n<h6 id=\"使用对象填充数组\"><a href=\"#使用对象填充数组\" class=\"headerlink\" title=\"使用对象填充数组\"></a>使用对象填充数组</h6><p>(1)使用Array().fill()创建数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>Array(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。<br>这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 2&#125;, &#123;value: 2&#125;, &#123;value: 2&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(2)使用Array.from()创建数组<br>Array.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。<br>因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">Array</span>(<span class=\"number\">3</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>(3)使用Array.map()结合Array.fill()创建数组<br>注意：不要直接使用map新建数组，<strong>array.map()跳过 empty 元素</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [empty x 3]</span></span><br></pre></td></tr></table></figure>\n<p>解决方法很简单，将 empty 数组 fill null 即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>注意：使用这种方法创建的数组，修改某一项时不影响其他项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newArray = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]</span></span><br><span class=\"line\">newArray[<span class=\"number\">1</span>].value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray);  <span class=\"comment\">// [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"MarkDown语法及示例","date":"2022-06-27T02:43:07.000Z","_content":"\n#### MarkDown语法及示例\n\n###### 代码块\n\\```javascript\nconst name = 'eric';\n....\n\\``` \n###### 加粗字体\n\\*\\*文字\\*\\*\n\\_\\_文字\\_\\_\n\n###### 倾斜字体\n\\*文字\\*\n\\_文字\\_\n\n###### 斜体加粗\n\\*\\*\\*文字\\*\\*\\*\n\\_\\_\\_文字\\_\\_\\_\n\n###### 删除线\n\\~\\~文字\\~\\~\n\n###### 表格\n| 表头1 | 表头2 |\n| ----- | ----- |\n| 文字1 | 文字2 |\n\n###### 文字颜色\n<font color=\"red\">文字</font>\n```javascript\n<font color=\"red\">文字</font>\n<font color=\"blue\">文字</font>\n```\n\n###### 文字大小\n<font size=\"10\">文字</font>\n```javascript\n<font size=\"10\">文字</font>\n<font size=\"14\">文字</font>\n```\n\n###### 文字字体\n<font face=\"黑体\">文字</font>\n```javascript\n<font face=\"黑体\">文字</font>\n<font face=\"微软雅黑\">文字</font>\n```\n\n###### 背景色\n<mark style=\"bgcolor:red\">文字</mark>\n```javascript\n<mark style=\"bgcolor:red\">文字</mark>\n```\n\n###### 无序列表\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```javascript\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```\n\n###### 有序列表\n1. 第一行\n2. 第二行\n3. 第三行\n\n```javascript\n1. 第一行\n2. 第二行\n3. 第三行\n```\n\n###### 嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n\n```javascript\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n```\n\n###### 区块：区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号\n\\> 区块\n> 区块1\n> 区块2\n\n区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推\n> 1\n> > 2\n> > > 3\n\n###### 链接\n\\[链接名称\\]\\(链接地址\\) 或 <链接地址>\n```\n[百度](www.baidu.com)\n<www.baidu.com>\n```\n\n###### 图片\n!\\[alt 属性文本\\]\\(图片地址\\)\n\n\n###### 插入公式\n$ 数学公式 $​​​​​​​\n$$ 数学公式 $$​\n\n###### 指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\na^1\na_1\n$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$\n\n\n","source":"_posts/9-text-type-about-markdown.md","raw":"---\ntitle: MarkDown语法及示例\ndate: 2022-06-27 10:43:07\ntags:\n---\n\n#### MarkDown语法及示例\n\n###### 代码块\n\\```javascript\nconst name = 'eric';\n....\n\\``` \n###### 加粗字体\n\\*\\*文字\\*\\*\n\\_\\_文字\\_\\_\n\n###### 倾斜字体\n\\*文字\\*\n\\_文字\\_\n\n###### 斜体加粗\n\\*\\*\\*文字\\*\\*\\*\n\\_\\_\\_文字\\_\\_\\_\n\n###### 删除线\n\\~\\~文字\\~\\~\n\n###### 表格\n| 表头1 | 表头2 |\n| ----- | ----- |\n| 文字1 | 文字2 |\n\n###### 文字颜色\n<font color=\"red\">文字</font>\n```javascript\n<font color=\"red\">文字</font>\n<font color=\"blue\">文字</font>\n```\n\n###### 文字大小\n<font size=\"10\">文字</font>\n```javascript\n<font size=\"10\">文字</font>\n<font size=\"14\">文字</font>\n```\n\n###### 文字字体\n<font face=\"黑体\">文字</font>\n```javascript\n<font face=\"黑体\">文字</font>\n<font face=\"微软雅黑\">文字</font>\n```\n\n###### 背景色\n<mark style=\"bgcolor:red\">文字</mark>\n```javascript\n<mark style=\"bgcolor:red\">文字</mark>\n```\n\n###### 无序列表\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```javascript\n* 第一行\n* 第二行\n* 第三行\n\n+ 第一行\n+ 第二行\n+ 第三行\n\n- 第一行\n- 第二行\n- 第三行\n```\n\n###### 有序列表\n1. 第一行\n2. 第二行\n3. 第三行\n\n```javascript\n1. 第一行\n2. 第二行\n3. 第三行\n```\n\n###### 嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n\n```javascript\n* 第一行\n  - 1-1\n* 第二行\n  - 2-1\n* 第三行\n  - 3-1\n\n* 第一行\n  1. 1-1\n* 第二行\n  1. 2-1\n* 第三行\n  1. 3-1\n```\n\n###### 区块：区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号\n\\> 区块\n> 区块1\n> 区块2\n\n区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推\n> 1\n> > 2\n> > > 3\n\n###### 链接\n\\[链接名称\\]\\(链接地址\\) 或 <链接地址>\n```\n[百度](www.baidu.com)\n<www.baidu.com>\n```\n\n###### 图片\n!\\[alt 属性文本\\]\\(图片地址\\)\n\n\n###### 插入公式\n$ 数学公式 $​​​​​​​\n$$ 数学公式 $$​\n\n###### 指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\na^1\na_1\n$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$\n\n\n","slug":"9-text-type-about-markdown","published":1,"updated":"2022-10-14T03:01:44.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx9001ucktt5whgcf7s","content":"<h4 id=\"MarkDown语法及示例\"><a href=\"#MarkDown语法及示例\" class=\"headerlink\" title=\"MarkDown语法及示例\"></a>MarkDown语法及示例</h4><h6 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h6><p>```javascript<br>const name = ‘eric’;<br>….<br>``` </p>\n<h6 id=\"加粗字体\"><a href=\"#加粗字体\" class=\"headerlink\" title=\"加粗字体\"></a>加粗字体</h6><p>**文字**<br>__文字__</p>\n<h6 id=\"倾斜字体\"><a href=\"#倾斜字体\" class=\"headerlink\" title=\"倾斜字体\"></a>倾斜字体</h6><p>*文字*<br>_文字_</p>\n<h6 id=\"斜体加粗\"><a href=\"#斜体加粗\" class=\"headerlink\" title=\"斜体加粗\"></a>斜体加粗</h6><p>***文字***<br>___文字___</p>\n<h6 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h6><p>~~文字~~</p>\n<h6 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h6><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文字1</td>\n<td>文字2</td>\n</tr>\n</tbody></table>\n<h6 id=\"文字颜色\"><a href=\"#文字颜色\" class=\"headerlink\" title=\"文字颜色\"></a>文字颜色</h6><p><font color=\"red\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font color=<span class=\"string\">&quot;red&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;blue&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字大小\"><a href=\"#文字大小\" class=\"headerlink\" title=\"文字大小\"></a>文字大小</h6><p><font size=\"10\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font size=<span class=\"string\">&quot;10&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;14&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字字体\"><a href=\"#文字字体\" class=\"headerlink\" title=\"文字字体\"></a>文字字体</h6><p><font face=\"黑体\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font face=<span class=\"string\">&quot;黑体&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">face</span>=<span class=\"string\">&quot;微软雅黑&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"背景色\"><a href=\"#背景色\" class=\"headerlink\" title=\"背景色\"></a>背景色</h6><p><mark style=\"bgcolor:red\">文字</mark></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mark style=<span class=\"string\">&quot;bgcolor:red&quot;</span>&gt;文字&lt;/mark&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h6><ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">* 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一行</span><br><span class=\"line\">+ 第二行</span><br><span class=\"line\">+ 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一行</span><br><span class=\"line\">- 第二行</span><br><span class=\"line\">- 第三行</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h6><ol>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 第一行</span><br><span class=\"line\"><span class=\"number\">2.</span> 第二行</span><br><span class=\"line\"><span class=\"number\">3.</span> 第三行</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"><a href=\"#嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\" class=\"headerlink\" title=\"嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"></a>嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</h6><ul>\n<li>第一行<ul>\n<li>1-1</li>\n</ul>\n</li>\n<li>第二行<ul>\n<li>2-1</li>\n</ul>\n</li>\n<li>第三行<ul>\n<li>3-1</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>第一行<ol>\n<li>1-1</li>\n</ol>\n</li>\n<li>第二行<ol>\n<li>2-1</li>\n</ol>\n</li>\n<li>第三行<ol>\n<li>3-1</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">  - <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  - <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  - <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">* 第一行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\"><a href=\"#区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\" class=\"headerlink\" title=\"区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号\"></a>区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</h6><p>&gt; 区块</p>\n<blockquote>\n<p>区块1<br>区块2</p>\n</blockquote>\n<p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p>\n<blockquote>\n<p>1</p>\n<blockquote>\n<p>2</p>\n<blockquote>\n<p>3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>[链接名称](链接地址) 或 &lt;链接地址&gt;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[百度](www.baidu.com)</span><br><span class=\"line\">&lt;www.baidu.com&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>![alt 属性文本](图片地址)</p>\n<h6 id=\"插入公式\"><a href=\"#插入公式\" class=\"headerlink\" title=\"插入公式\"></a>插入公式</h6><p>$ 数学公式 $​​​​​​​<br>$$ 数学公式 $$​</p>\n<h6 id=\"指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"><a href=\"#指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\" class=\"headerlink\" title=\"指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"></a>指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</h6><p>a^1<br>a_1<br>$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"MarkDown语法及示例\"><a href=\"#MarkDown语法及示例\" class=\"headerlink\" title=\"MarkDown语法及示例\"></a>MarkDown语法及示例</h4><h6 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h6><p>```javascript<br>const name = ‘eric’;<br>….<br>``` </p>\n<h6 id=\"加粗字体\"><a href=\"#加粗字体\" class=\"headerlink\" title=\"加粗字体\"></a>加粗字体</h6><p>**文字**<br>__文字__</p>\n<h6 id=\"倾斜字体\"><a href=\"#倾斜字体\" class=\"headerlink\" title=\"倾斜字体\"></a>倾斜字体</h6><p>*文字*<br>_文字_</p>\n<h6 id=\"斜体加粗\"><a href=\"#斜体加粗\" class=\"headerlink\" title=\"斜体加粗\"></a>斜体加粗</h6><p>***文字***<br>___文字___</p>\n<h6 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h6><p>~~文字~~</p>\n<h6 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h6><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文字1</td>\n<td>文字2</td>\n</tr>\n</tbody></table>\n<h6 id=\"文字颜色\"><a href=\"#文字颜色\" class=\"headerlink\" title=\"文字颜色\"></a>文字颜色</h6><p><font color=\"red\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font color=<span class=\"string\">&quot;red&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;blue&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字大小\"><a href=\"#文字大小\" class=\"headerlink\" title=\"文字大小\"></a>文字大小</h6><p><font size=\"10\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font size=<span class=\"string\">&quot;10&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;14&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"文字字体\"><a href=\"#文字字体\" class=\"headerlink\" title=\"文字字体\"></a>文字字体</h6><p><font face=\"黑体\">文字</font></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font face=<span class=\"string\">&quot;黑体&quot;</span>&gt;文字&lt;/font&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">face</span>=<span class=\"string\">&quot;微软雅黑&quot;</span>&gt;</span>文字<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"背景色\"><a href=\"#背景色\" class=\"headerlink\" title=\"背景色\"></a>背景色</h6><p><mark style=\"bgcolor:red\">文字</mark></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mark style=<span class=\"string\">&quot;bgcolor:red&quot;</span>&gt;文字&lt;/mark&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h6><ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ul>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">* 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一行</span><br><span class=\"line\">+ 第二行</span><br><span class=\"line\">+ 第三行</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一行</span><br><span class=\"line\">- 第二行</span><br><span class=\"line\">- 第三行</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h6 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h6><ol>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 第一行</span><br><span class=\"line\"><span class=\"number\">2.</span> 第二行</span><br><span class=\"line\"><span class=\"number\">3.</span> 第三行</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"><a href=\"#嵌套列表-列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\" class=\"headerlink\" title=\"嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\"></a>嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</h6><ul>\n<li>第一行<ul>\n<li>1-1</li>\n</ul>\n</li>\n<li>第二行<ul>\n<li>2-1</li>\n</ul>\n</li>\n<li>第三行<ul>\n<li>3-1</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>第一行<ol>\n<li>1-1</li>\n</ol>\n</li>\n<li>第二行<ol>\n<li>2-1</li>\n</ol>\n</li>\n<li>第三行<ol>\n<li>3-1</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一行</span><br><span class=\"line\">  - <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  - <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  - <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">* 第一行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">1</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第二行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">2</span>-<span class=\"number\">1</span></span><br><span class=\"line\">* 第三行</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"number\">3</span>-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\"><a href=\"#区块：区块引用是在段落开头使用-gt-符号-，然后后面紧跟一个空格符号\" class=\"headerlink\" title=\"区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号\"></a>区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</h6><p>&gt; 区块</p>\n<blockquote>\n<p>区块1<br>区块2</p>\n</blockquote>\n<p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p>\n<blockquote>\n<p>1</p>\n<blockquote>\n<p>2</p>\n<blockquote>\n<p>3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>[链接名称](链接地址) 或 &lt;链接地址&gt;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[百度](www.baidu.com)</span><br><span class=\"line\">&lt;www.baidu.com&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>![alt 属性文本](图片地址)</p>\n<h6 id=\"插入公式\"><a href=\"#插入公式\" class=\"headerlink\" title=\"插入公式\"></a>插入公式</h6><p>$ 数学公式 $​​​​​​​<br>$$ 数学公式 $$​</p>\n<h6 id=\"指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"><a href=\"#指数和下标可以用-和-后加相应字符来实现-如果上下标的内容多于一个字符，需要用-将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\" class=\"headerlink\" title=\"指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。\"></a>指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</h6><p>a^1<br>a_1<br>$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$</p>\n"},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n","source":"_posts/15-js-transform/js-transform.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n","slug":"15-js-transform/js-transform","published":1,"date":"2022-08-11T05:19:34.637Z","updated":"2022-08-11T09:29:33.722Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clchh4gx9001vcktt0lbnbc1n","content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n  </head>\n  <body>\n    <script>\n      console.log(`1 - true: ${1 - true}`);\n      console.log(`1 - false: ${1 - false}`);\n      console.log(`1 - null: ${1 - null}`);\n      console.log(`1 - undefined: ${1 - undefined}`);\n      console.log(`2 * ['5']: ${2 * ['5']}`);\n\n      console.log(`123 + '123': ${123 + '123'}`);\n      console.log(`123 + null: ${123 + null}`);\n      console.log(`123 + true: ${123 + true}`);\n      console.log(`123 + {}: ${123 + {}}`);\n\n      console.log(`NaN == NaN: ${NaN == NaN}`);\n\n      console.log(`true == 1: ${true == 1}`);\n      console.log(`true == '2': ${true == '2'}`);\n      console.log(`true == ['1']: ${true == ['1']}`);\n      console.log(`true == ['2']: ${true == ['2']}`);\n      console.log(`undefined == false: ${undefined == false}`);\n      console.log(`null == false: ${null == false}`);\n\n      console.log(`123 == '123': ${123 == '123'}`);\n      console.log(`'' == 0: ${'' == 0}`);\n\n      console.log(`null == undefined: ${null == undefined}`); // true\n      console.log(`null == '': ${null == ''}`); // false\n      console.log(`null == 0: ${null == 0}`); // false\n      console.log(`null == false: ${null == false}`); // false\n      console.log(`undefined == '': ${undefined == ''}`); // false\n      console.log(`undefined == 0: ${undefined == 0}`); // false\n      console.log(`undefined == false: ${undefined == false}`); // false\n\n      console.log(`'[object Object]' == {}: ${'[object Object]' == {}}`); // true\n      console.log(`'1,2,3' == [1, 2, 3]: ${'1,2,3' == [1, 2, 3]}`); // true\n\n      console.log(`'10' > '2': ${'10' > '2'}`); // false\n    </script>\n  </body>\n</html>\n"}],"PostAsset":[{"_id":"source/_posts/15-js-transform/convert-table.png","post":"clchh4gwn000fckttde89euf3","slug":"convert-table.png","modified":1,"renderable":1},{"_id":"source/_posts/15-js-transform/js-transform.html","post":"clchh4gwn000fckttde89euf3","slug":"js-transform.html","modified":1,"renderable":1},{"_id":"source/_posts/18-fake-array/array_from.png","post":"clchh4gwp000jcktt3n3i9ak4","slug":"array_from.png","modified":1,"renderable":1},{"_id":"source/_posts/18-fake-array/document.png","post":"clchh4gwp000jcktt3n3i9ak4","slug":"document.png","modified":1,"renderable":1},{"_id":"source/_posts/18-fake-array/prototype_call.png","post":"clchh4gwp000jcktt3n3i9ak4","slug":"prototype_call.png","modified":1,"renderable":1},{"_id":"source/_posts/18-fake-array/slice_call.png","post":"clchh4gwp000jcktt3n3i9ak4","slug":"slice_call.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/abstract-car.png","post":"clchh4gwt000tcktt1jfgchng","slug":"abstract-car.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/abstract-factory1.png","post":"clchh4gwt000tcktt1jfgchng","slug":"abstract-factory1.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/abstract-factory2.png","post":"clchh4gwt000tcktt1jfgchng","slug":"abstract-factory2.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/abstract-factory3.png","post":"clchh4gwt000tcktt1jfgchng","slug":"abstract-factory3.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/human.png","post":"clchh4gwt000tcktt1jfgchng","slug":"human.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/lazy-single-instance.png","post":"clchh4gwt000tcktt1jfgchng","slug":"lazy-single-instance.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/name.png","post":"clchh4gwt000tcktt1jfgchng","slug":"name.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/person.png","post":"clchh4gwt000tcktt1jfgchng","slug":"person.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/prototype-inherit1.png","post":"clchh4gwt000tcktt1jfgchng","slug":"prototype-inherit1.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/prototype-inherit2.png","post":"clchh4gwt000tcktt1jfgchng","slug":"prototype-inherit2.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/prototype-model.png","post":"clchh4gwt000tcktt1jfgchng","slug":"prototype-model.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/safe-factory-model.png","post":"clchh4gwt000tcktt1jfgchng","slug":"safe-factory-model.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/safe-model-class.png","post":"clchh4gwt000tcktt1jfgchng","slug":"safe-model-class.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/static-param.png","post":"clchh4gwt000tcktt1jfgchng","slug":"static-param.png","modified":1,"renderable":1},{"_id":"source/_posts/24-about-design-model1/work.png","post":"clchh4gwt000tcktt1jfgchng","slug":"work.png","modified":1,"renderable":1},{"_id":"source/_posts/25-about-design-model2/bridge1.png","post":"clchh4gwv000zcktthfkx2hwg","slug":"bridge1.png","modified":1,"renderable":1},{"_id":"source/_posts/25-about-design-model2/bridge2.png","post":"clchh4gwv000zcktthfkx2hwg","slug":"bridge2.png","modified":1,"renderable":1},{"_id":"source/_posts/25-about-design-model2/bridge3.png","post":"clchh4gwv000zcktthfkx2hwg","slug":"bridge3.png","modified":1,"renderable":1},{"_id":"source/_posts/25-about-design-model2/decorator.png","post":"clchh4gwv000zcktthfkx2hwg","slug":"decorator.png","modified":1,"renderable":1},{"_id":"source/_posts/25-about-design-model2/out-look.png","post":"clchh4gwv000zcktthfkx2hwg","slug":"out-look.png","modified":1,"renderable":1},{"_id":"source/_posts/25-about-design-model2/station-culculate.png","post":"clchh4gwv000zcktthfkx2hwg","slug":"station-culculate.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/class-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"class-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/combination-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"combination-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/constructor-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"constructor-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/create-pop.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"create-pop.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/how-to-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"how-to-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/multiple-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"multiple-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/multiple-status.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"multiple-status.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/parasitic-combination-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"parasitic-combination-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/parasitic-inherit-change.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"parasitic-inherit-change.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/parasitic-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"parasitic-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/prototype-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"prototype-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/prototype.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"prototype.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/public-and-private.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"public-and-private.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/safe-model.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"safe-model.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/simple-factory1.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"simple-factory1.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/simple-factory2.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"simple-factory2.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/static-and-public.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"static-and-public.png","modified":1,"renderable":1},{"_id":"source/_posts/23-about-design-model/test-prototype-inherit.png","post":"clchh4gwv000xcktt5uwdh7ah","slug":"test-prototype-inherit.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/add-message.png","post":"clchh4gww0011cktt12x8feua","slug":"add-message.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/basic-model.png","post":"clchh4gww0011cktt12x8feua","slug":"basic-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/cache-model.png","post":"clchh4gww0011cktt12x8feua","slug":"cache-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/command-model-1.png","post":"clchh4gww0011cktt12x8feua","slug":"command-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/command-model-2.png","post":"clchh4gww0011cktt12x8feua","slug":"command-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/command-model-3.png","post":"clchh4gww0011cktt12x8feua","slug":"command-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/create-component.png","post":"clchh4gww0011cktt12x8feua","slug":"create-component.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/deal-data.png","post":"clchh4gww0011cktt12x8feua","slug":"deal-data.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/explain-model-1.png","post":"clchh4gww0011cktt12x8feua","slug":"explain-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/explain-model-2.png","post":"clchh4gww0011cktt12x8feua","slug":"explain-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/explain-model-3.png","post":"clchh4gww0011cktt12x8feua","slug":"explain-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/inherit-as-basic-model.png","post":"clchh4gww0011cktt12x8feua","slug":"inherit-as-basic-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/inherit-model.png","post":"clchh4gww0011cktt12x8feua","slug":"inherit-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/iterator-model.png","post":"clchh4gww0011cktt12x8feua","slug":"iterator-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/marry-state.png","post":"clchh4gww0011cktt12x8feua","slug":"marry-state.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/marry-state1.png","post":"clchh4gww0011cktt12x8feua","slug":"marry-state1.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/mediator-model.png","post":"clchh4gww0011cktt12x8feua","slug":"mediator-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/observer-fire.png","post":"clchh4gww0011cktt12x8feua","slug":"observer-fire.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/observer-regist.png","post":"clchh4gww0011cktt12x8feua","slug":"observer-regist.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/observer-remove.png","post":"clchh4gww0011cktt12x8feua","slug":"observer-remove.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/observer.png","post":"clchh4gww0011cktt12x8feua","slug":"observer.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/price-strategy.png","post":"clchh4gww0011cktt12x8feua","slug":"price-strategy.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/regist-change-num.png","post":"clchh4gww0011cktt12x8feua","slug":"regist-change-num.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/regist-message.png","post":"clchh4gww0011cktt12x8feua","slug":"regist-message.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/send-data.png","post":"clchh4gww0011cktt12x8feua","slug":"send-data.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/visitor-model.png","post":"clchh4gww0011cktt12x8feua","slug":"visitor-model.png","modified":1,"renderable":1},{"_id":"source/_posts/26-about-design-model3/vote-status.png","post":"clchh4gww0011cktt12x8feua","slug":"vote-status.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/chain-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"chain-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/chain-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"chain-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/chain-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"chain-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/chain-model-4.png","post":"clchh4gwx0013cktt7ij295mx","slug":"chain-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/chain-model-5.png","post":"clchh4gwx0013cktt7ij295mx","slug":"chain-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/chain-model-6.png","post":"clchh4gwx0013cktt7ij295mx","slug":"chain-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/entrust-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"entrust-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/entrust-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"entrust-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/lazy-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"lazy-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/lazy-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"lazy-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/lazy-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"lazy-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/lazy-model-4.png","post":"clchh4gwx0013cktt7ij295mx","slug":"lazy-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/lazy-model-5.png","post":"clchh4gwx0013cktt7ij295mx","slug":"lazy-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/lazy-model-6.png","post":"clchh4gwx0013cktt7ij295mx","slug":"lazy-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/localstorage-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"localstorage-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/localstorage-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"localstorage-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/localstorage-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"localstorage-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/localstorage-model-4.png","post":"clchh4gwx0013cktt7ij295mx","slug":"localstorage-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/localstorage-model-5.png","post":"clchh4gwx0013cktt7ij295mx","slug":"localstorage-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/localstorage-model-6.png","post":"clchh4gwx0013cktt7ij295mx","slug":"localstorage-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/participate-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"participate-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/participate-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"participate-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/participate-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"participate-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/participate-model-4.png","post":"clchh4gwx0013cktt7ij295mx","slug":"participate-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/participate-model-5.png","post":"clchh4gwx0013cktt7ij295mx","slug":"participate-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/participate-model-6.png","post":"clchh4gwx0013cktt7ij295mx","slug":"participate-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/template-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"template-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/template-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"template-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/template-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"template-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/template-model-4.png","post":"clchh4gwx0013cktt7ij295mx","slug":"template-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/template-model-5.png","post":"clchh4gwx0013cktt7ij295mx","slug":"template-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/template-model-6.png","post":"clchh4gwx0013cktt7ij295mx","slug":"template-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/throttle-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"throttle-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/throttle-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"throttle-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/throttle-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"throttle-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-1.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-2.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-3.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-4.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-5.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-6.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-7.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-7.png","modified":1,"renderable":1},{"_id":"source/_posts/27-about-design-model4/waiter-model-8.png","post":"clchh4gwx0013cktt7ij295mx","slug":"waiter-model-8.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-10.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-10.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-5.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-5.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-6.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-6.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-7.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-7.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-8.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-8.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/appendix-9.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"appendix-9.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-5.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-6.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-7.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-7.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-8.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-8.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/async-module-model-9.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"async-module-model-9.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/module-model-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"module-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/module-model-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"module-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/module-model-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"module-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/module-model-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"module-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/module-model-5.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"module-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvc-model-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvc-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvc-model-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvc-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvc-model-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvc-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvc-model-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvc-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-5.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-6.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvp-model-7.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvp-model-7.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-5.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-6.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-7.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-7.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/mvvm-model-8.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"mvvm-model-8.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/widget-model-1.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"widget-model-1.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/widget-model-2.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"widget-model-2.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/widget-model-3.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"widget-model-3.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/widget-model-4.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"widget-model-4.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/widget-model-5.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"widget-model-5.png","modified":1,"renderable":1},{"_id":"source/_posts/28-about-design-model5/widget-model-6.png","post":"clchh4gwy0015cktt0yuydb6h","slug":"widget-model-6.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/binary-search-tree.png","post":"clchh4gx1001dckttcuiw12rz","slug":"binary-search-tree.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/factorial.png","post":"clchh4gx1001dckttcuiw12rz","slug":"factorial.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/in-order-traverse.png","post":"clchh4gx1001dckttcuiw12rz","slug":"in-order-traverse.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/left-left-1.png","post":"clchh4gx1001dckttcuiw12rz","slug":"left-left-1.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/left-left-2.png","post":"clchh4gx1001dckttcuiw12rz","slug":"left-left-2.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/left-right-1.png","post":"clchh4gx1001dckttcuiw12rz","slug":"left-right-1.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/left-right-2.png","post":"clchh4gx1001dckttcuiw12rz","slug":"left-right-2.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/post-order-traverse.png","post":"clchh4gx1001dckttcuiw12rz","slug":"post-order-traverse.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/pre-order-traverse.png","post":"clchh4gx1001dckttcuiw12rz","slug":"pre-order-traverse.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/red-black-2a.png","post":"clchh4gx1001dckttcuiw12rz","slug":"red-black-2a.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/red-black-2b.png","post":"clchh4gx1001dckttcuiw12rz","slug":"red-black-2b.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/red-black-3a.png","post":"clchh4gx1001dckttcuiw12rz","slug":"red-black-3a.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/red-black-3b.png","post":"clchh4gx1001dckttcuiw12rz","slug":"red-black-3b.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/remove-left-right.png","post":"clchh4gx1001dckttcuiw12rz","slug":"remove-left-right.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/right-left-1.png","post":"clchh4gx1001dckttcuiw12rz","slug":"right-left-1.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/right-left-2.png","post":"clchh4gx1001dckttcuiw12rz","slug":"right-left-2.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/right-right-1.png","post":"clchh4gx1001dckttcuiw12rz","slug":"right-right-1.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/right-right-2.png","post":"clchh4gx1001dckttcuiw12rz","slug":"right-right-2.png","modified":1,"renderable":1},{"_id":"source/_posts/36-data-structure4/tree.png","post":"clchh4gx1001dckttcuiw12rz","slug":"tree.png","modified":1,"renderable":1},{"_id":"source/_posts/34-data-structure2/chain-table-1.png","post":"clchh4gx2001ecktthr53h1pe","slug":"chain-table-1.png","modified":1,"renderable":1},{"_id":"source/_posts/34-data-structure2/chain-table-2.png","post":"clchh4gx2001ecktthr53h1pe","slug":"chain-table-2.png","modified":1,"renderable":1},{"_id":"source/_posts/34-data-structure2/chain-table-3.png","post":"clchh4gx2001ecktthr53h1pe","slug":"chain-table-3.png","modified":1,"renderable":1},{"_id":"source/_posts/34-data-structure2/chain-table-4.png","post":"clchh4gx2001ecktthr53h1pe","slug":"chain-table-4.png","modified":1,"renderable":1},{"_id":"source/_posts/35-data-structure3/linear-probing.png","post":"clchh4gx3001gckttebru30l9","slug":"linear-probing.png","modified":1,"renderable":1},{"_id":"source/_posts/35-data-structure3/lose-lose.png","post":"clchh4gx3001gckttebru30l9","slug":"lose-lose.png","modified":1,"renderable":1},{"_id":"source/_posts/35-data-structure3/move-key.png","post":"clchh4gx3001gckttebru30l9","slug":"move-key.png","modified":1,"renderable":1},{"_id":"source/_posts/35-data-structure3/soft-delete.png","post":"clchh4gx3001gckttebru30l9","slug":"soft-delete.png","modified":1,"renderable":1},{"_id":"source/_posts/35-data-structure3/sperate-chain.png","post":"clchh4gx3001gckttebru30l9","slug":"sperate-chain.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/search-1.png","post":"clchh4gx4001icktt1le40upq","slug":"search-1.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/search-2.png","post":"clchh4gx4001icktt1le40upq","slug":"search-2.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/search-3.png","post":"clchh4gx4001icktt1le40upq","slug":"search-3.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/search-4.png","post":"clchh4gx4001icktt1le40upq","slug":"search-4.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-1.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-1.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-10.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-10.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-11.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-11.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-12.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-12.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-2.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-2.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-3.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-3.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-4.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-4.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-5.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-5.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-6.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-6.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-7.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-7.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-8.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-8.png","modified":1,"renderable":1},{"_id":"source/_posts/38-data-structure6/sort-9.png","post":"clchh4gx4001icktt1le40upq","slug":"sort-9.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-1.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-1.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-10.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-10.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-11.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-11.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-12.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-12.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-13.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-13.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-2.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-2.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-3.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-3.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-4.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-4.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-5.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-5.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-6.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-6.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-7.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-7.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-8.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-8.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/graph-9.png","post":"clchh4gx4001jcktta6jo57f0","slug":"graph-9.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/heap-sort.png","post":"clchh4gx4001jcktta6jo57f0","slug":"heap-sort.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/heat.png","post":"clchh4gx4001jcktta6jo57f0","slug":"heat.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/min-heat-pic.png","post":"clchh4gx4001jcktta6jo57f0","slug":"min-heat-pic.png","modified":1,"renderable":1},{"_id":"source/_posts/37-data-structure5/min-heat.png","post":"clchh4gx4001jcktta6jo57f0","slug":"min-heat.png","modified":1,"renderable":1},{"_id":"source/_posts/40-tail-call/call-stack.png","post":"clchh4gx6001mcktt1axz3zz6","slug":"call-stack.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/big-o-1.png","post":"clchh4gx5001lckttflx468i6","slug":"big-o-1.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/big-o-2.png","post":"clchh4gx5001lckttflx468i6","slug":"big-o-2.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/big-o-3.png","post":"clchh4gx5001lckttflx468i6","slug":"big-o-3.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/big-o-4.png","post":"clchh4gx5001lckttflx468i6","slug":"big-o-4.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/big-o-5.png","post":"clchh4gx5001lckttflx468i6","slug":"big-o-5.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/big-o-6.png","post":"clchh4gx5001lckttflx468i6","slug":"big-o-6.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/technology-1.png","post":"clchh4gx5001lckttflx468i6","slug":"technology-1.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/technology-2.png","post":"clchh4gx5001lckttflx468i6","slug":"technology-2.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/technology-3.png","post":"clchh4gx5001lckttflx468i6","slug":"technology-3.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/technology-4.png","post":"clchh4gx5001lckttflx468i6","slug":"technology-4.png","modified":1,"renderable":1},{"_id":"source/_posts/39-data-structure7/technology-5.png","post":"clchh4gx5001lckttflx468i6","slug":"technology-5.png","modified":1,"renderable":1},{"_id":"source/_posts/5-react-render/fiber_tree.png","post":"clchh4gx6001ocktt5q7ha88g","slug":"fiber_tree.png","modified":1,"renderable":1},{"_id":"source/_posts/5-react-render/force_update.png","post":"clchh4gx6001ocktt5q7ha88g","slug":"force_update.png","modified":1,"renderable":1},{"_id":"source/_posts/5-react-render/update_class.png","post":"clchh4gx6001ocktt5q7ha88g","slug":"update_class.png","modified":1,"renderable":1},{"_id":"source/_posts/6-vue3-render/render.png","post":"clchh4gx7001rckttcenka803","slug":"render.png","modified":1,"renderable":1},{"_id":"source/_posts/6-vue3-render/render_function.png","post":"clchh4gx7001rckttcenka803","slug":"render_function.png","modified":1,"renderable":1},{"_id":"source/_posts/6-vue3-render/render_node1.png","post":"clchh4gx7001rckttcenka803","slug":"render_node1.png","modified":1,"renderable":1},{"_id":"source/_posts/6-vue3-render/render_node2.png","post":"clchh4gx7001rckttcenka803","slug":"render_node2.png","modified":1,"renderable":1},{"_id":"source/_posts/6-vue3-render/vue3_render.png","post":"clchh4gx7001rckttcenka803","slug":"vue3_render.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}